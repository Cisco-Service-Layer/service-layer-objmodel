// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_common_types.proto

#ifndef PROTOBUF_sl_5fcommon_5ftypes_2eproto__INCLUDED
#define PROTOBUF_sl_5fcommon_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_sl_5fcommon_5ftypes_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSLErrorStatusImpl();
void InitDefaultsSLErrorStatus();
void InitDefaultsSLInterfaceImpl();
void InitDefaultsSLInterface();
void InitDefaultsSLIpAddressImpl();
void InitDefaultsSLIpAddress();
inline void InitDefaults() {
  InitDefaultsSLErrorStatus();
  InitDefaultsSLInterface();
  InitDefaultsSLIpAddress();
}
}  // namespace protobuf_sl_5fcommon_5ftypes_2eproto
namespace service_layer {
class SLErrorStatus;
class SLErrorStatusDefaultTypeInternal;
extern SLErrorStatusDefaultTypeInternal _SLErrorStatus_default_instance_;
class SLInterface;
class SLInterfaceDefaultTypeInternal;
extern SLInterfaceDefaultTypeInternal _SLInterface_default_instance_;
class SLIpAddress;
class SLIpAddressDefaultTypeInternal;
extern SLIpAddressDefaultTypeInternal _SLIpAddress_default_instance_;
}  // namespace service_layer
namespace service_layer {

enum SLErrorStatus_SLErrno {
  SLErrorStatus_SLErrno_SL_SUCCESS = 0,
  SLErrorStatus_SLErrno_SL_NOT_CONNECTED = 1,
  SLErrorStatus_SLErrno_SL_EAGAIN = 2,
  SLErrorStatus_SLErrno_SL_ENOMEM = 3,
  SLErrorStatus_SLErrno_SL_EBUSY = 4,
  SLErrorStatus_SLErrno_SL_EINVAL = 5,
  SLErrorStatus_SLErrno_SL_UNSUPPORTED_VER = 6,
  SLErrorStatus_SLErrno_SL_NOT_AVAILABLE = 7,
  SLErrorStatus_SLErrno_SL_STREAM_NOT_SUPPORTED = 8,
  SLErrorStatus_SLErrno_SL_ENOTSUP = 9,
  SLErrorStatus_SLErrno_SL_SOME_ERR = 10,
  SLErrorStatus_SLErrno_SL_TIMEOUT = 11,
  SLErrorStatus_SLErrno_SL_NOTIF_TERM = 12,
  SLErrorStatus_SLErrno_SL_INIT_START_OFFSET = 1280,
  SLErrorStatus_SLErrno_SL_INIT_STATE_CLEAR = 1281,
  SLErrorStatus_SLErrno_SL_INIT_STATE_READY = 1282,
  SLErrorStatus_SLErrno_SL_INIT_UNSUPPORTED_VER = 1283,
  SLErrorStatus_SLErrno_SL_INIT_SERVER_NOT_INITIALIZED = 1284,
  SLErrorStatus_SLErrno_SL_INIT_SERVER_MODE_CHANGE_FAILED = 1285,
  SLErrorStatus_SLErrno_SL_RPC_VRF_START_OFFSET = 4096,
  SLErrorStatus_SLErrno_SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS = 4097,
  SLErrorStatus_SLErrno_SL_RPC_VRF_SERVER_NOT_INITIALIZED = 4098,
  SLErrorStatus_SLErrno_SL_VRF_START_OFFSET = 8192,
  SLErrorStatus_SLErrno_SL_VRF_NAME_TOOLONG = 8193,
  SLErrorStatus_SLErrno_SL_VRF_NOT_FOUND = 8194,
  SLErrorStatus_SLErrno_SL_VRF_NO_TABLE_ID = 8195,
  SLErrorStatus_SLErrno_SL_VRF_REG_INVALID_ADMIN_DISTANCE = 8196,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_ADD_ERR = 8197,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_REGISTRATION_ERR = 8198,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_UNREGISTRATION_ERR = 8199,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_EOF_ERR = 8200,
  SLErrorStatus_SLErrno_SL_VRF_REG_VRF_NAME_MISSING = 8201,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_START_OFFSET = 12288,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_TOO_MANY_ROUTES = 12289,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_TOOLONG = 12290,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NOT_FOUND = 12291,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NO_TABLE = 12292,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED = 12293,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_MISSING = 12294,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE = 12295,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_SERVER_NOT_INITIALIZED = 12296,
  SLErrorStatus_SLErrno_SL_ROUTE_START_OFFSET = 16384,
  SLErrorStatus_SLErrno_SL_ROUTE_ADD_NO_PATHS = 16385,
  SLErrorStatus_SLErrno_SL_ROUTE_UPDATE_NO_PATHS = 16386,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_LEN = 16387,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_ADMIN_DISTANCE = 16388,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_NUM_PATHS = 16389,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_SZ = 16390,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX = 16391,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED = 16392,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_INVALID_ARGS = 16393,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT = 16394,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TOOMANYPATHS = 16395,
  SLErrorStatus_SLErrno_SL_ROUTE_EEXIST = 16396,
  SLErrorStatus_SLErrno_SL_ROUTE_HOST_BITS_SET = 16397,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_MCAST = 16398,
  SLErrorStatus_SLErrno_SL_ROUTE_PATH_AFI_MISMATCH = 16399,
  SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_PRIMARY_PATHS = 16400,
  SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_BACKUP_PATHS = 16401,
  SLErrorStatus_SLErrno_SL_ROUTE_DB_NOMEM = 16402,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_LOCAL_LABEL = 16403,
  SLErrorStatus_SLErrno_SL_PATH_START_OFFSET = 20480,
  SLErrorStatus_SLErrno_SL_PATH_NH_NO_TABLE = 20481,
  SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NOT_FOUND = 20482,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL_COUNT = 20483,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_ID = 20484,
  SLErrorStatus_SLErrno_SL_PATH_VRF_NAME_TOOLONG = 20485,
  SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NAME_TOOLONG = 20486,
  SLErrorStatus_SLErrno_SL_PATH_NH_INVALID_ADDR_SZ = 20487,
  SLErrorStatus_SLErrno_SL_PATH_NH_INF_NAME_MISSING = 20488,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_NEXT_HOP_ADDR = 20489,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_REMOTE_ADDR_COUNT = 20490,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID_SZ = 20491,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_AFI_MISMATCH = 20492,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_PROTECTED_BITMAP = 20493,
  SLErrorStatus_SLErrno_SL_PATH_BACKUP_MISSING_PRIMARY_PATH = 20494,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_ID_REPEATED = 20495,
  SLErrorStatus_SLErrno_SL_PATH_BACKUP_ID_REPEATED = 20496,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS = 20497,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_LABELS = 20498,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR = 20499,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID = 20500,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL = 20501,
  SLErrorStatus_SLErrno_SL_RPC_BFD_START_OFFSET = 24576,
  SLErrorStatus_SLErrno_SL_RPC_BFD_TOO_MANY_BFD_SESSIONS = 24577,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_BAD_PARAMETER = 24578,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_CLIENT_NOT_REGISTERED = 24579,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_INTERNAL_ERROR = 24580,
  SLErrorStatus_SLErrno_SL_RPC_BFD_SERVER_NOT_INITIALIZED = 24581,
  SLErrorStatus_SLErrno_SL_RPC_BFD_V4_NOT_REGISTERED = 24582,
  SLErrorStatus_SLErrno_SL_RPC_BFD_V6_NOT_REGISTERED = 24583,
  SLErrorStatus_SLErrno_SL_BFD_START_OFFSET = 28672,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_TOOLONG = 28673,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NOT_FOUND = 28674,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_ATTRIBUTE = 28675,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_MISSING = 28676,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR_MCAST = 28677,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR = 28678,
  SLErrorStatus_SLErrno_SL_BFD_VRF_NAME_TOOLONG = 28679,
  SLErrorStatus_SLErrno_SL_BFD_BAD_PARAMETER = 28680,
  SLErrorStatus_SLErrno_SL_BFD_API_INTERNAL_ERROR = 28681,
  SLErrorStatus_SLErrno_SL_BFD_VRF_NOT_FOUND = 28682,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_PREFIX_SIZE = 28683,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_SESSION_TYPE = 28684,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_VRF = 28685,
  SLErrorStatus_SLErrno_SL_BFD_SESSION_NOT_FOUND = 28686,
  SLErrorStatus_SLErrno_SL_BFD_SESSION_EXISTS = 28687,
  SLErrorStatus_SLErrno_SL_BFD_INTERNAL_DB_ERROR = 28688,
  SLErrorStatus_SLErrno_SL_BFD_RECOVERY_ERROR = 28689,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_START_OFFSET = 32768,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_ILM_TOO_MANY_ILMS = 32769,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_SERVER_NOT_INITIALIZED = 32770,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE = 32771,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS = 32772,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_NOT_REGISTERED = 32773,
  SLErrorStatus_SLErrno_SL_ILM_ERR_OFFSET = 36864,
  SLErrorStatus_SLErrno_SL_ILM_ADD_FAILED = 36865,
  SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_FAILED = 36866,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_NUM_NHLFE = 36867,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_LABEL = 36868,
  SLErrorStatus_SLErrno_SL_ILM_DELETE_FAILED = 36869,
  SLErrorStatus_SLErrno_SL_ILM_LSD_DELETE_FAILED = 36870,
  SLErrorStatus_SLErrno_SL_ILM_TOOMANY_PRIMARY_NHLFES = 36871,
  SLErrorStatus_SLErrno_SL_ILM_TOOMANY_BACKUP_NHLFES = 36872,
  SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED = 36873,
  SLErrorStatus_SLErrno_SL_ILM_LSD_NHLFE_INVALID_ATTRIB = 36874,
  SLErrorStatus_SLErrno_SL_ILM_EEXIST = 36875,
  SLErrorStatus_SLErrno_SL_ILM_DB_NOMEM = 36876,
  SLErrorStatus_SLErrno_SL_NHLFE_ERR_OFFSET = 40960,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_NO_TABLE = 40961,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INVALID_ADDR_SZ = 40962,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_NEXT_HOP_ADDR = 40963,
  SLErrorStatus_SLErrno_SL_NHLFE_VRF_NAME_TOOLONG = 40964,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INF_NAME_MISSING = 40965,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NAME_TOOLONG = 40966,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL_COUNT = 40967,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_ID = 40968,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL = 40969,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PROTECTED_BITMAP = 40970,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_REMOTE_ADDR_COUNT = 40971,
  SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID_SZ = 40972,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_LABELS = 40973,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR = 40974,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_ID_REPEATED = 40975,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_ID_REPEATED = 40976,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY = 40977,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS = 40978,
  SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID = 40979,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH = 40980,
  SLErrorStatus_SLErrno_SL_NHLFE_NEXT_HOP_MISSING = 40981,
  SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_INVALID = 40982,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NOT_FOUND = 40983,
  SLErrorStatus_SLErrno_SL_NHLFE_OPER_FAILED = 40984,
  SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_MISSING = 40985,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_ERR_OFFSET = 45056,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_ADD_FAILED = 45057,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_DELETE_FAILED = 45058,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND = 45059,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE = 45060,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_INVALID_ATTRIB = 45061,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_BLOCK_SIZE = 45062,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_START_LABEL = 45063,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_EEXIST = 45064,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_DB_NOMEM = 45065,
  SLErrorStatus_SLErrno_SL_MPLS_REG_ERR_OFFSET = 49152,
  SLErrorStatus_SLErrno_SL_MPLS_REG_ERR = 49153,
  SLErrorStatus_SLErrno_SL_MPLS_UNREG_ERR = 49154,
  SLErrorStatus_SLErrno_SL_MPLS_EOF_ERR = 49155,
  SLErrorStatus_SLErrno_SL_RPC_INTF_START_OFFSET = 53248,
  SLErrorStatus_SLErrno_SL_RPC_INTF_TOO_MANY_INTERFACES = 53249,
  SLErrorStatus_SLErrno_SL_RPC_INTF_SERVER_NOT_INITIALIZED = 53250,
  SLErrorStatus_SLErrno_SL_RPC_INTF_API_CLIENT_NOT_REGISTERED = 53251,
  SLErrorStatus_SLErrno_SL_INTF_START_OFFSET = 57344,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_MISSING = 57345,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_TOOLONG = 57346,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_REG_ERR = 57347,
  SLErrorStatus_SLErrno_SL_INTF_INTERNAL_DB_ERROR = 57348,
  SLErrorStatus_SLErrno_SL_INTF_RECOVERY_ERROR = 57349,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_EXISTS = 57350,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NOT_FOUND = 57351,
  SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET = 1048576,
  SLErrorStatus_SLErrno_SLErrorStatus_SLErrno_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLErrorStatus_SLErrno_SLErrorStatus_SLErrno_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLErrorStatus_SLErrno_IsValid(int value);
const SLErrorStatus_SLErrno SLErrorStatus_SLErrno_SLErrno_MIN = SLErrorStatus_SLErrno_SL_SUCCESS;
const SLErrorStatus_SLErrno SLErrorStatus_SLErrno_SLErrno_MAX = SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET;
const int SLErrorStatus_SLErrno_SLErrno_ARRAYSIZE = SLErrorStatus_SLErrno_SLErrno_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLErrorStatus_SLErrno_descriptor();
inline const ::std::string& SLErrorStatus_SLErrno_Name(SLErrorStatus_SLErrno value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLErrorStatus_SLErrno_descriptor(), value);
}
inline bool SLErrorStatus_SLErrno_Parse(
    const ::std::string& name, SLErrorStatus_SLErrno* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLErrorStatus_SLErrno>(
    SLErrorStatus_SLErrno_descriptor(), name, value);
}
enum SLRegOp {
  SL_REGOP_RESERVED = 0,
  SL_REGOP_REGISTER = 1,
  SL_REGOP_UNREGISTER = 2,
  SL_REGOP_EOF = 3,
  SLRegOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLRegOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLRegOp_IsValid(int value);
const SLRegOp SLRegOp_MIN = SL_REGOP_RESERVED;
const SLRegOp SLRegOp_MAX = SL_REGOP_EOF;
const int SLRegOp_ARRAYSIZE = SLRegOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLRegOp_descriptor();
inline const ::std::string& SLRegOp_Name(SLRegOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLRegOp_descriptor(), value);
}
inline bool SLRegOp_Parse(
    const ::std::string& name, SLRegOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLRegOp>(
    SLRegOp_descriptor(), name, value);
}
enum SLObjectOp {
  SL_OBJOP_RESERVED = 0,
  SL_OBJOP_ADD = 1,
  SL_OBJOP_UPDATE = 2,
  SL_OBJOP_DELETE = 3,
  SLObjectOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLObjectOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLObjectOp_IsValid(int value);
const SLObjectOp SLObjectOp_MIN = SL_OBJOP_RESERVED;
const SLObjectOp SLObjectOp_MAX = SL_OBJOP_DELETE;
const int SLObjectOp_ARRAYSIZE = SLObjectOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLObjectOp_descriptor();
inline const ::std::string& SLObjectOp_Name(SLObjectOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLObjectOp_descriptor(), value);
}
inline bool SLObjectOp_Parse(
    const ::std::string& name, SLObjectOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLObjectOp>(
    SLObjectOp_descriptor(), name, value);
}
enum SLNotifOp {
  SL_NOTIFOP_RESERVED = 0,
  SL_NOTIFOP_ENABLE = 1,
  SL_NOTIFOP_DISABLE = 2,
  SLNotifOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLNotifOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLNotifOp_IsValid(int value);
const SLNotifOp SLNotifOp_MIN = SL_NOTIFOP_RESERVED;
const SLNotifOp SLNotifOp_MAX = SL_NOTIFOP_DISABLE;
const int SLNotifOp_ARRAYSIZE = SLNotifOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLNotifOp_descriptor();
inline const ::std::string& SLNotifOp_Name(SLNotifOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLNotifOp_descriptor(), value);
}
inline bool SLNotifOp_Parse(
    const ::std::string& name, SLNotifOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLNotifOp>(
    SLNotifOp_descriptor(), name, value);
}
// ===================================================================

class SLErrorStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLErrorStatus) */ {
 public:
  SLErrorStatus();
  virtual ~SLErrorStatus();

  SLErrorStatus(const SLErrorStatus& from);

  inline SLErrorStatus& operator=(const SLErrorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLErrorStatus(SLErrorStatus&& from) noexcept
    : SLErrorStatus() {
    *this = ::std::move(from);
  }

  inline SLErrorStatus& operator=(SLErrorStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLErrorStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLErrorStatus* internal_default_instance() {
    return reinterpret_cast<const SLErrorStatus*>(
               &_SLErrorStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SLErrorStatus* other);
  friend void swap(SLErrorStatus& a, SLErrorStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLErrorStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  SLErrorStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLErrorStatus& from);
  void MergeFrom(const SLErrorStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLErrorStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SLErrorStatus_SLErrno SLErrno;
  static const SLErrno SL_SUCCESS =
    SLErrorStatus_SLErrno_SL_SUCCESS;
  static const SLErrno SL_NOT_CONNECTED =
    SLErrorStatus_SLErrno_SL_NOT_CONNECTED;
  static const SLErrno SL_EAGAIN =
    SLErrorStatus_SLErrno_SL_EAGAIN;
  static const SLErrno SL_ENOMEM =
    SLErrorStatus_SLErrno_SL_ENOMEM;
  static const SLErrno SL_EBUSY =
    SLErrorStatus_SLErrno_SL_EBUSY;
  static const SLErrno SL_EINVAL =
    SLErrorStatus_SLErrno_SL_EINVAL;
  static const SLErrno SL_UNSUPPORTED_VER =
    SLErrorStatus_SLErrno_SL_UNSUPPORTED_VER;
  static const SLErrno SL_NOT_AVAILABLE =
    SLErrorStatus_SLErrno_SL_NOT_AVAILABLE;
  static const SLErrno SL_STREAM_NOT_SUPPORTED =
    SLErrorStatus_SLErrno_SL_STREAM_NOT_SUPPORTED;
  static const SLErrno SL_ENOTSUP =
    SLErrorStatus_SLErrno_SL_ENOTSUP;
  static const SLErrno SL_SOME_ERR =
    SLErrorStatus_SLErrno_SL_SOME_ERR;
  static const SLErrno SL_TIMEOUT =
    SLErrorStatus_SLErrno_SL_TIMEOUT;
  static const SLErrno SL_NOTIF_TERM =
    SLErrorStatus_SLErrno_SL_NOTIF_TERM;
  static const SLErrno SL_INIT_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INIT_START_OFFSET;
  static const SLErrno SL_INIT_STATE_CLEAR =
    SLErrorStatus_SLErrno_SL_INIT_STATE_CLEAR;
  static const SLErrno SL_INIT_STATE_READY =
    SLErrorStatus_SLErrno_SL_INIT_STATE_READY;
  static const SLErrno SL_INIT_UNSUPPORTED_VER =
    SLErrorStatus_SLErrno_SL_INIT_UNSUPPORTED_VER;
  static const SLErrno SL_INIT_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_INIT_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_INIT_SERVER_MODE_CHANGE_FAILED =
    SLErrorStatus_SLErrno_SL_INIT_SERVER_MODE_CHANGE_FAILED;
  static const SLErrno SL_RPC_VRF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_VRF_START_OFFSET;
  static const SLErrno SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS =
    SLErrorStatus_SLErrno_SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS;
  static const SLErrno SL_RPC_VRF_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_VRF_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_VRF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_VRF_START_OFFSET;
  static const SLErrno SL_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_VRF_NAME_TOOLONG;
  static const SLErrno SL_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_VRF_NOT_FOUND;
  static const SLErrno SL_VRF_NO_TABLE_ID =
    SLErrorStatus_SLErrno_SL_VRF_NO_TABLE_ID;
  static const SLErrno SL_VRF_REG_INVALID_ADMIN_DISTANCE =
    SLErrorStatus_SLErrno_SL_VRF_REG_INVALID_ADMIN_DISTANCE;
  static const SLErrno SL_VRF_TABLE_ADD_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_ADD_ERR;
  static const SLErrno SL_VRF_TABLE_REGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_REGISTRATION_ERR;
  static const SLErrno SL_VRF_TABLE_UNREGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_UNREGISTRATION_ERR;
  static const SLErrno SL_VRF_TABLE_EOF_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_EOF_ERR;
  static const SLErrno SL_VRF_REG_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_VRF_REG_VRF_NAME_MISSING;
  static const SLErrno SL_RPC_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_START_OFFSET;
  static const SLErrno SL_RPC_ROUTE_TOO_MANY_ROUTES =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_TOO_MANY_ROUTES;
  static const SLErrno SL_RPC_ROUTE_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_TOOLONG;
  static const SLErrno SL_RPC_ROUTE_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NOT_FOUND;
  static const SLErrno SL_RPC_ROUTE_VRF_NO_TABLE =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NO_TABLE;
  static const SLErrno SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED;
  static const SLErrno SL_RPC_ROUTE_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_MISSING;
  static const SLErrno SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE;
  static const SLErrno SL_RPC_ROUTE_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_ROUTE_START_OFFSET;
  static const SLErrno SL_ROUTE_ADD_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_ADD_NO_PATHS;
  static const SLErrno SL_ROUTE_UPDATE_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_UPDATE_NO_PATHS;
  static const SLErrno SL_ROUTE_INVALID_PREFIX_LEN =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_LEN;
  static const SLErrno SL_ROUTE_INVALID_ADMIN_DISTANCE =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_ADMIN_DISTANCE;
  static const SLErrno SL_ROUTE_INVALID_NUM_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_NUM_PATHS;
  static const SLErrno SL_ROUTE_INVALID_PREFIX_SZ =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_SZ;
  static const SLErrno SL_ROUTE_INVALID_PREFIX =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX;
  static const SLErrno SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED;
  static const SLErrno SL_ROUTE_ERR_RIB_INVALID_ARGS =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_INVALID_ARGS;
  static const SLErrno SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT;
  static const SLErrno SL_ROUTE_ERR_RIB_TOOMANYPATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TOOMANYPATHS;
  static const SLErrno SL_ROUTE_EEXIST =
    SLErrorStatus_SLErrno_SL_ROUTE_EEXIST;
  static const SLErrno SL_ROUTE_HOST_BITS_SET =
    SLErrorStatus_SLErrno_SL_ROUTE_HOST_BITS_SET;
  static const SLErrno SL_ROUTE_INVALID_PREFIX_MCAST =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_MCAST;
  static const SLErrno SL_ROUTE_PATH_AFI_MISMATCH =
    SLErrorStatus_SLErrno_SL_ROUTE_PATH_AFI_MISMATCH;
  static const SLErrno SL_ROUTE_TOOMANY_PRIMARY_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_PRIMARY_PATHS;
  static const SLErrno SL_ROUTE_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_BACKUP_PATHS;
  static const SLErrno SL_ROUTE_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_ROUTE_DB_NOMEM;
  static const SLErrno SL_ROUTE_INVALID_LOCAL_LABEL =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_LOCAL_LABEL;
  static const SLErrno SL_PATH_START_OFFSET =
    SLErrorStatus_SLErrno_SL_PATH_START_OFFSET;
  static const SLErrno SL_PATH_NH_NO_TABLE =
    SLErrorStatus_SLErrno_SL_PATH_NH_NO_TABLE;
  static const SLErrno SL_PATH_NH_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NOT_FOUND;
  static const SLErrno SL_PATH_INVALID_LABEL_COUNT =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL_COUNT;
  static const SLErrno SL_PATH_INVALID_ID =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_ID;
  static const SLErrno SL_PATH_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_PATH_VRF_NAME_TOOLONG;
  static const SLErrno SL_PATH_NH_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NAME_TOOLONG;
  static const SLErrno SL_PATH_NH_INVALID_ADDR_SZ =
    SLErrorStatus_SLErrno_SL_PATH_NH_INVALID_ADDR_SZ;
  static const SLErrno SL_PATH_NH_INF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_PATH_NH_INF_NAME_MISSING;
  static const SLErrno SL_PATH_INVALID_NEXT_HOP_ADDR =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_NEXT_HOP_ADDR;
  static const SLErrno SL_PATH_INVALID_REMOTE_ADDR_COUNT =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_REMOTE_ADDR_COUNT;
  static const SLErrno SL_PATH_REMOTE_ADDR_INVALID_SZ =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID_SZ;
  static const SLErrno SL_PATH_REMOTE_ADDR_AFI_MISMATCH =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_AFI_MISMATCH;
  static const SLErrno SL_PATH_INVALID_PROTECTED_BITMAP =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_PROTECTED_BITMAP;
  static const SLErrno SL_PATH_BACKUP_MISSING_PRIMARY_PATH =
    SLErrorStatus_SLErrno_SL_PATH_BACKUP_MISSING_PRIMARY_PATH;
  static const SLErrno SL_PATH_PRIMARY_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_ID_REPEATED;
  static const SLErrno SL_PATH_BACKUP_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_PATH_BACKUP_ID_REPEATED;
  static const SLErrno SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS;
  static const SLErrno SL_PATH_PRIMARY_TOOMANY_LABELS =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_LABELS;
  static const SLErrno SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR;
  static const SLErrno SL_PATH_REMOTE_ADDR_INVALID =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID;
  static const SLErrno SL_PATH_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL;
  static const SLErrno SL_RPC_BFD_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_BFD_START_OFFSET;
  static const SLErrno SL_RPC_BFD_TOO_MANY_BFD_SESSIONS =
    SLErrorStatus_SLErrno_SL_RPC_BFD_TOO_MANY_BFD_SESSIONS;
  static const SLErrno SL_RPC_BFD_API_BAD_PARAMETER =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_BAD_PARAMETER;
  static const SLErrno SL_RPC_BFD_API_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_CLIENT_NOT_REGISTERED;
  static const SLErrno SL_RPC_BFD_API_INTERNAL_ERROR =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_INTERNAL_ERROR;
  static const SLErrno SL_RPC_BFD_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_RPC_BFD_V4_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_V4_NOT_REGISTERED;
  static const SLErrno SL_RPC_BFD_V6_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_V6_NOT_REGISTERED;
  static const SLErrno SL_BFD_START_OFFSET =
    SLErrorStatus_SLErrno_SL_BFD_START_OFFSET;
  static const SLErrno SL_BFD_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_TOOLONG;
  static const SLErrno SL_BFD_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NOT_FOUND;
  static const SLErrno SL_BFD_INVALID_ATTRIBUTE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_ATTRIBUTE;
  static const SLErrno SL_BFD_INTF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_MISSING;
  static const SLErrno SL_BFD_INVALID_NBR_MCAST =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR_MCAST;
  static const SLErrno SL_BFD_INVALID_NBR =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR;
  static const SLErrno SL_BFD_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_BFD_VRF_NAME_TOOLONG;
  static const SLErrno SL_BFD_BAD_PARAMETER =
    SLErrorStatus_SLErrno_SL_BFD_BAD_PARAMETER;
  static const SLErrno SL_BFD_API_INTERNAL_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_API_INTERNAL_ERROR;
  static const SLErrno SL_BFD_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_VRF_NOT_FOUND;
  static const SLErrno SL_BFD_INVALID_PREFIX_SIZE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_PREFIX_SIZE;
  static const SLErrno SL_BFD_INVALID_SESSION_TYPE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_SESSION_TYPE;
  static const SLErrno SL_BFD_INVALID_VRF =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_VRF;
  static const SLErrno SL_BFD_SESSION_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_SESSION_NOT_FOUND;
  static const SLErrno SL_BFD_SESSION_EXISTS =
    SLErrorStatus_SLErrno_SL_BFD_SESSION_EXISTS;
  static const SLErrno SL_BFD_INTERNAL_DB_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_INTERNAL_DB_ERROR;
  static const SLErrno SL_BFD_RECOVERY_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_RECOVERY_ERROR;
  static const SLErrno SL_RPC_MPLS_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_START_OFFSET;
  static const SLErrno SL_RPC_MPLS_ILM_TOO_MANY_ILMS =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_ILM_TOO_MANY_ILMS;
  static const SLErrno SL_RPC_MPLS_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE;
  static const SLErrno SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS;
  static const SLErrno SL_RPC_MPLS_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_NOT_REGISTERED;
  static const SLErrno SL_ILM_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_ILM_ERR_OFFSET;
  static const SLErrno SL_ILM_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_ADD_FAILED;
  static const SLErrno SL_ILM_LSD_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_FAILED;
  static const SLErrno SL_ILM_INVALID_NUM_NHLFE =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_NUM_NHLFE;
  static const SLErrno SL_ILM_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_LABEL;
  static const SLErrno SL_ILM_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_DELETE_FAILED;
  static const SLErrno SL_ILM_LSD_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_DELETE_FAILED;
  static const SLErrno SL_ILM_TOOMANY_PRIMARY_NHLFES =
    SLErrorStatus_SLErrno_SL_ILM_TOOMANY_PRIMARY_NHLFES;
  static const SLErrno SL_ILM_TOOMANY_BACKUP_NHLFES =
    SLErrorStatus_SLErrno_SL_ILM_TOOMANY_BACKUP_NHLFES;
  static const SLErrno SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED;
  static const SLErrno SL_ILM_LSD_NHLFE_INVALID_ATTRIB =
    SLErrorStatus_SLErrno_SL_ILM_LSD_NHLFE_INVALID_ATTRIB;
  static const SLErrno SL_ILM_EEXIST =
    SLErrorStatus_SLErrno_SL_ILM_EEXIST;
  static const SLErrno SL_ILM_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_ILM_DB_NOMEM;
  static const SLErrno SL_NHLFE_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_NHLFE_ERR_OFFSET;
  static const SLErrno SL_NHLFE_NH_NO_TABLE =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_NO_TABLE;
  static const SLErrno SL_NHLFE_NH_INVALID_ADDR_SZ =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INVALID_ADDR_SZ;
  static const SLErrno SL_NHLFE_INVALID_NEXT_HOP_ADDR =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_NEXT_HOP_ADDR;
  static const SLErrno SL_NHLFE_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_NHLFE_VRF_NAME_TOOLONG;
  static const SLErrno SL_NHLFE_NH_INF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INF_NAME_MISSING;
  static const SLErrno SL_NHLFE_NH_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NAME_TOOLONG;
  static const SLErrno SL_NHLFE_INVALID_LABEL_COUNT =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL_COUNT;
  static const SLErrno SL_NHLFE_INVALID_PATH_ID =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_ID;
  static const SLErrno SL_NHLFE_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL;
  static const SLErrno SL_NHLFE_INVALID_PROTECTED_BITMAP =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PROTECTED_BITMAP;
  static const SLErrno SL_NHLFE_INVALID_REMOTE_ADDR_COUNT =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_REMOTE_ADDR_COUNT;
  static const SLErrno SL_NHLFE_REMOTE_ADDR_INVALID_SZ =
    SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID_SZ;
  static const SLErrno SL_NHLFE_PRIMARY_TOOMANY_LABELS =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_LABELS;
  static const SLErrno SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR;
  static const SLErrno SL_NHLFE_BACKUP_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_ID_REPEATED;
  static const SLErrno SL_NHLFE_PRIMARY_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_ID_REPEATED;
  static const SLErrno SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY;
  static const SLErrno SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS;
  static const SLErrno SL_NHLFE_REMOTE_ADDR_INVALID =
    SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID;
  static const SLErrno SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH;
  static const SLErrno SL_NHLFE_NEXT_HOP_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_NEXT_HOP_MISSING;
  static const SLErrno SL_NHLFE_LABEL_ACTION_INVALID =
    SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_INVALID;
  static const SLErrno SL_NHLFE_NH_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NOT_FOUND;
  static const SLErrno SL_NHLFE_OPER_FAILED =
    SLErrorStatus_SLErrno_SL_NHLFE_OPER_FAILED;
  static const SLErrno SL_NHLFE_LABEL_ACTION_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_MISSING;
  static const SLErrno SL_LABEL_BLK_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_ERR_OFFSET;
  static const SLErrno SL_LABEL_BLK_LSD_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_ADD_FAILED;
  static const SLErrno SL_LABEL_BLK_LSD_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_DELETE_FAILED;
  static const SLErrno SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND;
  static const SLErrno SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE;
  static const SLErrno SL_LABEL_BLK_LSD_INVALID_ATTRIB =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_INVALID_ATTRIB;
  static const SLErrno SL_LABEL_BLK_INVALID_BLOCK_SIZE =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_BLOCK_SIZE;
  static const SLErrno SL_LABEL_BLK_INVALID_START_LABEL =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_START_LABEL;
  static const SLErrno SL_LABEL_BLK_EEXIST =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_EEXIST;
  static const SLErrno SL_LABEL_BLK_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_DB_NOMEM;
  static const SLErrno SL_MPLS_REG_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_MPLS_REG_ERR_OFFSET;
  static const SLErrno SL_MPLS_REG_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_REG_ERR;
  static const SLErrno SL_MPLS_UNREG_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_UNREG_ERR;
  static const SLErrno SL_MPLS_EOF_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_EOF_ERR;
  static const SLErrno SL_RPC_INTF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_INTF_START_OFFSET;
  static const SLErrno SL_RPC_INTF_TOO_MANY_INTERFACES =
    SLErrorStatus_SLErrno_SL_RPC_INTF_TOO_MANY_INTERFACES;
  static const SLErrno SL_RPC_INTF_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_INTF_SERVER_NOT_INITIALIZED;
  static const SLErrno SL_RPC_INTF_API_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_INTF_API_CLIENT_NOT_REGISTERED;
  static const SLErrno SL_INTF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INTF_START_OFFSET;
  static const SLErrno SL_INTF_INTERFACE_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_MISSING;
  static const SLErrno SL_INTF_INTERFACE_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_TOOLONG;
  static const SLErrno SL_INTF_INTERFACE_REG_ERR =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_REG_ERR;
  static const SLErrno SL_INTF_INTERNAL_DB_ERROR =
    SLErrorStatus_SLErrno_SL_INTF_INTERNAL_DB_ERROR;
  static const SLErrno SL_INTF_RECOVERY_ERROR =
    SLErrorStatus_SLErrno_SL_INTF_RECOVERY_ERROR;
  static const SLErrno SL_INTF_INTERFACE_EXISTS =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_EXISTS;
  static const SLErrno SL_INTF_INTERFACE_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NOT_FOUND;
  static const SLErrno SL_INTERNAL_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET;
  static inline bool SLErrno_IsValid(int value) {
    return SLErrorStatus_SLErrno_IsValid(value);
  }
  static const SLErrno SLErrno_MIN =
    SLErrorStatus_SLErrno_SLErrno_MIN;
  static const SLErrno SLErrno_MAX =
    SLErrorStatus_SLErrno_SLErrno_MAX;
  static const int SLErrno_ARRAYSIZE =
    SLErrorStatus_SLErrno_SLErrno_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SLErrno_descriptor() {
    return SLErrorStatus_SLErrno_descriptor();
  }
  static inline const ::std::string& SLErrno_Name(SLErrno value) {
    return SLErrorStatus_SLErrno_Name(value);
  }
  static inline bool SLErrno_Parse(const ::std::string& name,
      SLErrno* value) {
    return SLErrorStatus_SLErrno_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .service_layer.SLErrorStatus.SLErrno Status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::service_layer::SLErrorStatus_SLErrno status() const;
  void set_status(::service_layer::SLErrorStatus_SLErrno value);

  // @@protoc_insertion_point(class_scope:service_layer.SLErrorStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fcommon_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_sl_5fcommon_5ftypes_2eproto::InitDefaultsSLErrorStatusImpl();
};
// -------------------------------------------------------------------

class SLInterface : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterface) */ {
 public:
  SLInterface();
  virtual ~SLInterface();

  SLInterface(const SLInterface& from);

  inline SLInterface& operator=(const SLInterface& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLInterface(SLInterface&& from) noexcept
    : SLInterface() {
    *this = ::std::move(from);
  }

  inline SLInterface& operator=(SLInterface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLInterface& default_instance();

  enum InterfaceCase {
    kName = 1,
    kHandle = 2,
    INTERFACE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLInterface* internal_default_instance() {
    return reinterpret_cast<const SLInterface*>(
               &_SLInterface_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SLInterface* other);
  friend void swap(SLInterface& a, SLInterface& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLInterface* New() const PROTOBUF_FINAL { return New(NULL); }

  SLInterface* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLInterface& from);
  void MergeFrom(const SLInterface& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLInterface* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 Handle = 2;
  private:
  bool has_handle() const;
  public:
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  InterfaceCase Interface_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLInterface)
 private:
  void set_has_name();
  void set_has_handle();

  inline bool has_Interface() const;
  void clear_Interface();
  inline void clear_has_Interface();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InterfaceUnion {
    InterfaceUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::uint32 handle_;
  } Interface_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fcommon_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_sl_5fcommon_5ftypes_2eproto::InitDefaultsSLInterfaceImpl();
};
// -------------------------------------------------------------------

class SLIpAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLIpAddress) */ {
 public:
  SLIpAddress();
  virtual ~SLIpAddress();

  SLIpAddress(const SLIpAddress& from);

  inline SLIpAddress& operator=(const SLIpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLIpAddress(SLIpAddress&& from) noexcept
    : SLIpAddress() {
    *this = ::std::move(from);
  }

  inline SLIpAddress& operator=(SLIpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLIpAddress& default_instance();

  enum AddressCase {
    kV4Address = 1,
    kV6Address = 2,
    ADDRESS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLIpAddress* internal_default_instance() {
    return reinterpret_cast<const SLIpAddress*>(
               &_SLIpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SLIpAddress* other);
  friend void swap(SLIpAddress& a, SLIpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLIpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  SLIpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLIpAddress& from);
  void MergeFrom(const SLIpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLIpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 V4Address = 1;
  private:
  bool has_v4address() const;
  public:
  void clear_v4address();
  static const int kV4AddressFieldNumber = 1;
  ::google::protobuf::uint32 v4address() const;
  void set_v4address(::google::protobuf::uint32 value);

  // bytes V6Address = 2;
  private:
  bool has_v6address() const;
  public:
  void clear_v6address();
  static const int kV6AddressFieldNumber = 2;
  const ::std::string& v6address() const;
  void set_v6address(const ::std::string& value);
  #if LANG_CXX11
  void set_v6address(::std::string&& value);
  #endif
  void set_v6address(const char* value);
  void set_v6address(const void* value, size_t size);
  ::std::string* mutable_v6address();
  ::std::string* release_v6address();
  void set_allocated_v6address(::std::string* v6address);

  AddressCase Address_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLIpAddress)
 private:
  void set_has_v4address();
  void set_has_v6address();

  inline bool has_Address() const;
  void clear_Address();
  inline void clear_has_Address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AddressUnion {
    AddressUnion() {}
    ::google::protobuf::uint32 v4address_;
    ::google::protobuf::internal::ArenaStringPtr v6address_;
  } Address_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fcommon_5ftypes_2eproto::TableStruct;
  friend void ::protobuf_sl_5fcommon_5ftypes_2eproto::InitDefaultsSLIpAddressImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLErrorStatus

// .service_layer.SLErrorStatus.SLErrno Status = 1;
inline void SLErrorStatus::clear_status() {
  status_ = 0;
}
inline ::service_layer::SLErrorStatus_SLErrno SLErrorStatus::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLErrorStatus.Status)
  return static_cast< ::service_layer::SLErrorStatus_SLErrno >(status_);
}
inline void SLErrorStatus::set_status(::service_layer::SLErrorStatus_SLErrno value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLErrorStatus.Status)
}

// -------------------------------------------------------------------

// SLInterface

// string Name = 1;
inline bool SLInterface::has_name() const {
  return Interface_case() == kName;
}
inline void SLInterface::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void SLInterface::clear_name() {
  if (has_name()) {
    Interface_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Interface();
  }
}
inline const ::std::string& SLInterface::name() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterface.Name)
  if (has_name()) {
    return Interface_.name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SLInterface::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Name)
  if (!has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Name)
}
#if LANG_CXX11
inline void SLInterface::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Name)
  if (!has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLInterface.Name)
}
#endif
inline void SLInterface::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLInterface.Name)
}
inline void SLInterface::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLInterface.Name)
}
inline ::std::string* SLInterface::mutable_name() {
  if (!has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterface.Name)
  return Interface_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLInterface::release_name() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterface.Name)
  if (has_name()) {
    clear_has_Interface();
    return Interface_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void SLInterface::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    Interface_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Interface();
  if (name != NULL) {
    set_has_name();
    Interface_.name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        name);
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterface.Name)
}

// uint32 Handle = 2;
inline bool SLInterface::has_handle() const {
  return Interface_case() == kHandle;
}
inline void SLInterface::set_has_handle() {
  _oneof_case_[0] = kHandle;
}
inline void SLInterface::clear_handle() {
  if (has_handle()) {
    Interface_.handle_ = 0u;
    clear_has_Interface();
  }
}
inline ::google::protobuf::uint32 SLInterface::handle() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterface.Handle)
  if (has_handle()) {
    return Interface_.handle_;
  }
  return 0u;
}
inline void SLInterface::set_handle(::google::protobuf::uint32 value) {
  if (!has_handle()) {
    clear_Interface();
    set_has_handle();
  }
  Interface_.handle_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Handle)
}

inline bool SLInterface::has_Interface() const {
  return Interface_case() != INTERFACE_NOT_SET;
}
inline void SLInterface::clear_has_Interface() {
  _oneof_case_[0] = INTERFACE_NOT_SET;
}
inline SLInterface::InterfaceCase SLInterface::Interface_case() const {
  return SLInterface::InterfaceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLIpAddress

// uint32 V4Address = 1;
inline bool SLIpAddress::has_v4address() const {
  return Address_case() == kV4Address;
}
inline void SLIpAddress::set_has_v4address() {
  _oneof_case_[0] = kV4Address;
}
inline void SLIpAddress::clear_v4address() {
  if (has_v4address()) {
    Address_.v4address_ = 0u;
    clear_has_Address();
  }
}
inline ::google::protobuf::uint32 SLIpAddress::v4address() const {
  // @@protoc_insertion_point(field_get:service_layer.SLIpAddress.V4Address)
  if (has_v4address()) {
    return Address_.v4address_;
  }
  return 0u;
}
inline void SLIpAddress::set_v4address(::google::protobuf::uint32 value) {
  if (!has_v4address()) {
    clear_Address();
    set_has_v4address();
  }
  Address_.v4address_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V4Address)
}

// bytes V6Address = 2;
inline bool SLIpAddress::has_v6address() const {
  return Address_case() == kV6Address;
}
inline void SLIpAddress::set_has_v6address() {
  _oneof_case_[0] = kV6Address;
}
inline void SLIpAddress::clear_v6address() {
  if (has_v6address()) {
    Address_.v6address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Address();
  }
}
inline const ::std::string& SLIpAddress::v6address() const {
  // @@protoc_insertion_point(field_get:service_layer.SLIpAddress.V6Address)
  if (has_v6address()) {
    return Address_.v6address_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SLIpAddress::set_v6address(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V6Address)
  if (!has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V6Address)
}
#if LANG_CXX11
inline void SLIpAddress::set_v6address(::std::string&& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V6Address)
  if (!has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLIpAddress.V6Address)
}
#endif
inline void SLIpAddress::set_v6address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLIpAddress.V6Address)
}
inline void SLIpAddress::set_v6address(const void* value, size_t size) {
  if (!has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLIpAddress.V6Address)
}
inline ::std::string* SLIpAddress::mutable_v6address() {
  if (!has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLIpAddress.V6Address)
  return Address_.v6address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLIpAddress::release_v6address() {
  // @@protoc_insertion_point(field_release:service_layer.SLIpAddress.V6Address)
  if (has_v6address()) {
    clear_has_Address();
    return Address_.v6address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void SLIpAddress::set_allocated_v6address(::std::string* v6address) {
  if (!has_v6address()) {
    Address_.v6address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Address();
  if (v6address != NULL) {
    set_has_v6address();
    Address_.v6address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        v6address);
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLIpAddress.V6Address)
}

inline bool SLIpAddress::has_Address() const {
  return Address_case() != ADDRESS_NOT_SET;
}
inline void SLIpAddress::clear_has_Address() {
  _oneof_case_[0] = ADDRESS_NOT_SET;
}
inline SLIpAddress::AddressCase SLIpAddress::Address_case() const {
  return SLIpAddress::AddressCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::service_layer::SLErrorStatus_SLErrno> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLErrorStatus_SLErrno>() {
  return ::service_layer::SLErrorStatus_SLErrno_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRegOp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRegOp>() {
  return ::service_layer::SLRegOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLObjectOp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLObjectOp>() {
  return ::service_layer::SLObjectOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLNotifOp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLNotifOp>() {
  return ::service_layer::SLNotifOp_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sl_5fcommon_5ftypes_2eproto__INCLUDED
