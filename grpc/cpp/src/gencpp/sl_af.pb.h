// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_af.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
#include "sl_route_common.pb.h"
#include "sl_route_ipv4.pb.h"
#include "sl_route_ipv6.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5faf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5faf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5faf_2eproto;
namespace service_layer {
class SLAFFibStatus;
struct SLAFFibStatusDefaultTypeInternal;
extern SLAFFibStatusDefaultTypeInternal _SLAFFibStatus_default_instance_;
class SLAFGetMsg;
struct SLAFGetMsgDefaultTypeInternal;
extern SLAFGetMsgDefaultTypeInternal _SLAFGetMsg_default_instance_;
class SLAFGetMsgRsp;
struct SLAFGetMsgRspDefaultTypeInternal;
extern SLAFGetMsgRspDefaultTypeInternal _SLAFGetMsgRsp_default_instance_;
class SLAFGetMsgRspEntry;
struct SLAFGetMsgRspEntryDefaultTypeInternal;
extern SLAFGetMsgRspEntryDefaultTypeInternal _SLAFGetMsgRspEntry_default_instance_;
class SLAFMsg;
struct SLAFMsgDefaultTypeInternal;
extern SLAFMsgDefaultTypeInternal _SLAFMsg_default_instance_;
class SLAFMsgRsp;
struct SLAFMsgRspDefaultTypeInternal;
extern SLAFMsgRspDefaultTypeInternal _SLAFMsgRsp_default_instance_;
class SLAFNextHopRegKey;
struct SLAFNextHopRegKeyDefaultTypeInternal;
extern SLAFNextHopRegKeyDefaultTypeInternal _SLAFNextHopRegKey_default_instance_;
class SLAFNextHopRegKey_SLNextHopKey;
struct SLAFNextHopRegKey_SLNextHopKeyDefaultTypeInternal;
extern SLAFNextHopRegKey_SLNextHopKeyDefaultTypeInternal _SLAFNextHopRegKey_SLNextHopKey_default_instance_;
class SLAFNextHopRegMsg;
struct SLAFNextHopRegMsgDefaultTypeInternal;
extern SLAFNextHopRegMsgDefaultTypeInternal _SLAFNextHopRegMsg_default_instance_;
class SLAFNotif;
struct SLAFNotifDefaultTypeInternal;
extern SLAFNotifDefaultTypeInternal _SLAFNotif_default_instance_;
class SLAFNotifMsg;
struct SLAFNotifMsgDefaultTypeInternal;
extern SLAFNotifMsgDefaultTypeInternal _SLAFNotifMsg_default_instance_;
class SLAFNotifRegReq;
struct SLAFNotifRegReqDefaultTypeInternal;
extern SLAFNotifRegReqDefaultTypeInternal _SLAFNotifRegReq_default_instance_;
class SLAFNotifReq;
struct SLAFNotifReqDefaultTypeInternal;
extern SLAFNotifReqDefaultTypeInternal _SLAFNotifReq_default_instance_;
class SLAFNotifRsp;
struct SLAFNotifRspDefaultTypeInternal;
extern SLAFNotifRspDefaultTypeInternal _SLAFNotifRsp_default_instance_;
class SLAFObject;
struct SLAFObjectDefaultTypeInternal;
extern SLAFObjectDefaultTypeInternal _SLAFObject_default_instance_;
class SLAFOp;
struct SLAFOpDefaultTypeInternal;
extern SLAFOpDefaultTypeInternal _SLAFOp_default_instance_;
class SLAFRedistRegMsg;
struct SLAFRedistRegMsgDefaultTypeInternal;
extern SLAFRedistRegMsgDefaultTypeInternal _SLAFRedistRegMsg_default_instance_;
class SLAFRes;
struct SLAFResDefaultTypeInternal;
extern SLAFResDefaultTypeInternal _SLAFRes_default_instance_;
class SLAFVrfReg;
struct SLAFVrfRegDefaultTypeInternal;
extern SLAFVrfRegDefaultTypeInternal _SLAFVrfReg_default_instance_;
class SLAFVrfRegGetMsg;
struct SLAFVrfRegGetMsgDefaultTypeInternal;
extern SLAFVrfRegGetMsgDefaultTypeInternal _SLAFVrfRegGetMsg_default_instance_;
class SLAFVrfRegGetMsgRsp;
struct SLAFVrfRegGetMsgRspDefaultTypeInternal;
extern SLAFVrfRegGetMsgRspDefaultTypeInternal _SLAFVrfRegGetMsgRsp_default_instance_;
class SLAFVrfRegMsg;
struct SLAFVrfRegMsgDefaultTypeInternal;
extern SLAFVrfRegMsgDefaultTypeInternal _SLAFVrfRegMsg_default_instance_;
class SLAFVrfRegMsgRes;
struct SLAFVrfRegMsgResDefaultTypeInternal;
extern SLAFVrfRegMsgResDefaultTypeInternal _SLAFVrfRegMsgRes_default_instance_;
class SLAFVrfRegMsgRsp;
struct SLAFVrfRegMsgRspDefaultTypeInternal;
extern SLAFVrfRegMsgRspDefaultTypeInternal _SLAFVrfRegMsgRsp_default_instance_;
class SLMplsEntry;
struct SLMplsEntryDefaultTypeInternal;
extern SLMplsEntryDefaultTypeInternal _SLMplsEntry_default_instance_;
class SLNextHop;
struct SLNextHopDefaultTypeInternal;
extern SLNextHopDefaultTypeInternal _SLNextHop_default_instance_;
class SLPathGroup;
struct SLPathGroupDefaultTypeInternal;
extern SLPathGroupDefaultTypeInternal _SLPathGroup_default_instance_;
class SLPathGroup_SLPath;
struct SLPathGroup_SLPathDefaultTypeInternal;
extern SLPathGroup_SLPathDefaultTypeInternal _SLPathGroup_SLPath_default_instance_;
class SLPathGroup_SLPathList;
struct SLPathGroup_SLPathListDefaultTypeInternal;
extern SLPathGroup_SLPathListDefaultTypeInternal _SLPathGroup_SLPathList_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLAFFibStatus* Arena::CreateMaybeMessage<::service_layer::SLAFFibStatus>(Arena*);
template<> ::service_layer::SLAFGetMsg* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsg>(Arena*);
template<> ::service_layer::SLAFGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsgRsp>(Arena*);
template<> ::service_layer::SLAFGetMsgRspEntry* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsgRspEntry>(Arena*);
template<> ::service_layer::SLAFMsg* Arena::CreateMaybeMessage<::service_layer::SLAFMsg>(Arena*);
template<> ::service_layer::SLAFMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFMsgRsp>(Arena*);
template<> ::service_layer::SLAFNextHopRegKey* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(Arena*);
template<> ::service_layer::SLAFNextHopRegKey_SLNextHopKey* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegKey_SLNextHopKey>(Arena*);
template<> ::service_layer::SLAFNextHopRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegMsg>(Arena*);
template<> ::service_layer::SLAFNotif* Arena::CreateMaybeMessage<::service_layer::SLAFNotif>(Arena*);
template<> ::service_layer::SLAFNotifMsg* Arena::CreateMaybeMessage<::service_layer::SLAFNotifMsg>(Arena*);
template<> ::service_layer::SLAFNotifRegReq* Arena::CreateMaybeMessage<::service_layer::SLAFNotifRegReq>(Arena*);
template<> ::service_layer::SLAFNotifReq* Arena::CreateMaybeMessage<::service_layer::SLAFNotifReq>(Arena*);
template<> ::service_layer::SLAFNotifRsp* Arena::CreateMaybeMessage<::service_layer::SLAFNotifRsp>(Arena*);
template<> ::service_layer::SLAFObject* Arena::CreateMaybeMessage<::service_layer::SLAFObject>(Arena*);
template<> ::service_layer::SLAFOp* Arena::CreateMaybeMessage<::service_layer::SLAFOp>(Arena*);
template<> ::service_layer::SLAFRedistRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFRedistRegMsg>(Arena*);
template<> ::service_layer::SLAFRes* Arena::CreateMaybeMessage<::service_layer::SLAFRes>(Arena*);
template<> ::service_layer::SLAFVrfReg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfReg>(Arena*);
template<> ::service_layer::SLAFVrfRegGetMsg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegGetMsg>(Arena*);
template<> ::service_layer::SLAFVrfRegGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegGetMsgRsp>(Arena*);
template<> ::service_layer::SLAFVrfRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsg>(Arena*);
template<> ::service_layer::SLAFVrfRegMsgRes* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsgRes>(Arena*);
template<> ::service_layer::SLAFVrfRegMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsgRsp>(Arena*);
template<> ::service_layer::SLMplsEntry* Arena::CreateMaybeMessage<::service_layer::SLMplsEntry>(Arena*);
template<> ::service_layer::SLNextHop* Arena::CreateMaybeMessage<::service_layer::SLNextHop>(Arena*);
template<> ::service_layer::SLPathGroup* Arena::CreateMaybeMessage<::service_layer::SLPathGroup>(Arena*);
template<> ::service_layer::SLPathGroup_SLPath* Arena::CreateMaybeMessage<::service_layer::SLPathGroup_SLPath>(Arena*);
template<> ::service_layer::SLPathGroup_SLPathList* Arena::CreateMaybeMessage<::service_layer::SLPathGroup_SLPathList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

// ===================================================================

class SLAFVrfReg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfReg) */ {
 public:
  inline SLAFVrfReg() : SLAFVrfReg(nullptr) {}
  ~SLAFVrfReg() override;
  explicit constexpr SLAFVrfReg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfReg(const SLAFVrfReg& from);
  SLAFVrfReg(SLAFVrfReg&& from) noexcept
    : SLAFVrfReg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfReg& operator=(const SLAFVrfReg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfReg& operator=(SLAFVrfReg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfReg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfReg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfReg*>(
               &_SLAFVrfReg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLAFVrfReg& a, SLAFVrfReg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfReg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfReg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfReg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfReg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfReg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfReg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfReg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfReg";
  }
  protected:
  explicit SLAFVrfReg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfRegFieldNumber = 2,
    kTableFieldNumber = 1,
  };
  // .service_layer.SLVrfReg VrfReg = 2;
  bool has_vrfreg() const;
  private:
  bool _internal_has_vrfreg() const;
  public:
  void clear_vrfreg();
  const ::service_layer::SLVrfReg& vrfreg() const;
  PROTOBUF_NODISCARD ::service_layer::SLVrfReg* release_vrfreg();
  ::service_layer::SLVrfReg* mutable_vrfreg();
  void set_allocated_vrfreg(::service_layer::SLVrfReg* vrfreg);
  private:
  const ::service_layer::SLVrfReg& _internal_vrfreg() const;
  ::service_layer::SLVrfReg* _internal_mutable_vrfreg();
  public:
  void unsafe_arena_set_allocated_vrfreg(
      ::service_layer::SLVrfReg* vrfreg);
  ::service_layer::SLVrfReg* unsafe_arena_release_vrfreg();

  // .service_layer.SLTableType Table = 1;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfReg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLVrfReg* vrfreg_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsg) */ {
 public:
  inline SLAFVrfRegMsg() : SLAFVrfRegMsg(nullptr) {}
  ~SLAFVrfRegMsg() override;
  explicit constexpr SLAFVrfRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsg(const SLAFVrfRegMsg& from);
  SLAFVrfRegMsg(SLAFVrfRegMsg&& from) noexcept
    : SLAFVrfRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsg& operator=(const SLAFVrfRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsg& operator=(SLAFVrfRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsg*>(
               &_SLAFVrfRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLAFVrfRegMsg& a, SLAFVrfRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsg";
  }
  protected:
  explicit SLAFVrfRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfRegMsgsFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFVrfReg VrfRegMsgs = 2;
  int vrfregmsgs_size() const;
  private:
  int _internal_vrfregmsgs_size() const;
  public:
  void clear_vrfregmsgs();
  ::service_layer::SLAFVrfReg* mutable_vrfregmsgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >*
      mutable_vrfregmsgs();
  private:
  const ::service_layer::SLAFVrfReg& _internal_vrfregmsgs(int index) const;
  ::service_layer::SLAFVrfReg* _internal_add_vrfregmsgs();
  public:
  const ::service_layer::SLAFVrfReg& vrfregmsgs(int index) const;
  ::service_layer::SLAFVrfReg* add_vrfregmsgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >&
      vrfregmsgs() const;

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);
  private:
  ::service_layer::SLRegOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLRegOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg > vrfregmsgs_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsgRes) */ {
 public:
  inline SLAFVrfRegMsgRes() : SLAFVrfRegMsgRes(nullptr) {}
  ~SLAFVrfRegMsgRes() override;
  explicit constexpr SLAFVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsgRes(const SLAFVrfRegMsgRes& from);
  SLAFVrfRegMsgRes(SLAFVrfRegMsgRes&& from) noexcept
    : SLAFVrfRegMsgRes() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsgRes& operator=(const SLAFVrfRegMsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsgRes& operator=(SLAFVrfRegMsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsgRes* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsgRes*>(
               &_SLAFVrfRegMsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLAFVrfRegMsgRes& a, SLAFVrfRegMsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsgRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsgRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsgRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsgRes";
  }
  protected:
  explicit SLAFVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
    kTableFieldNumber = 3,
  };
  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* errstatus_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsgRsp) */ {
 public:
  inline SLAFVrfRegMsgRsp() : SLAFVrfRegMsgRsp(nullptr) {}
  ~SLAFVrfRegMsgRsp() override;
  explicit constexpr SLAFVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsgRsp(const SLAFVrfRegMsgRsp& from);
  SLAFVrfRegMsgRsp(SLAFVrfRegMsgRsp&& from) noexcept
    : SLAFVrfRegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsgRsp& operator=(const SLAFVrfRegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsgRsp& operator=(SLAFVrfRegMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsgRsp*>(
               &_SLAFVrfRegMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLAFVrfRegMsgRsp& a, SLAFVrfRegMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsgRsp";
  }
  protected:
  explicit SLAFVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kStatusSummaryFieldNumber = 1,
  };
  // repeated .service_layer.SLAFVrfRegMsgRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLAFVrfRegMsgRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >*
      mutable_results();
  private:
  const ::service_layer::SLAFVrfRegMsgRes& _internal_results(int index) const;
  ::service_layer::SLAFVrfRegMsgRes* _internal_add_results();
  public:
  const ::service_layer::SLAFVrfRegMsgRes& results(int index) const;
  ::service_layer::SLAFVrfRegMsgRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 1;
  bool has_statussummary() const;
  private:
  bool _internal_has_statussummary() const;
  public:
  void clear_statussummary();
  const ::service_layer::SLErrorStatus& statussummary() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);
  private:
  const ::service_layer::SLErrorStatus& _internal_statussummary() const;
  ::service_layer::SLErrorStatus* _internal_mutable_statussummary();
  public:
  void unsafe_arena_set_allocated_statussummary(
      ::service_layer::SLErrorStatus* statussummary);
  ::service_layer::SLErrorStatus* unsafe_arena_release_statussummary();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegGetMsg) */ {
 public:
  inline SLAFVrfRegGetMsg() : SLAFVrfRegGetMsg(nullptr) {}
  ~SLAFVrfRegGetMsg() override;
  explicit constexpr SLAFVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegGetMsg(const SLAFVrfRegGetMsg& from);
  SLAFVrfRegGetMsg(SLAFVrfRegGetMsg&& from) noexcept
    : SLAFVrfRegGetMsg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegGetMsg& operator=(const SLAFVrfRegGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegGetMsg& operator=(SLAFVrfRegGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegGetMsg*>(
               &_SLAFVrfRegGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLAFVrfRegGetMsg& a, SLAFVrfRegGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegGetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegGetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegGetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegGetMsg";
  }
  protected:
  explicit SLAFVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetAllFieldNumber = 1,
  };
  // bool GetAll = 1;
  void clear_getall();
  bool getall() const;
  void set_getall(bool value);
  private:
  bool _internal_getall() const;
  void _internal_set_getall(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool getall_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegGetMsgRsp) */ {
 public:
  inline SLAFVrfRegGetMsgRsp() : SLAFVrfRegGetMsgRsp(nullptr) {}
  ~SLAFVrfRegGetMsgRsp() override;
  explicit constexpr SLAFVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegGetMsgRsp(const SLAFVrfRegGetMsgRsp& from);
  SLAFVrfRegGetMsgRsp(SLAFVrfRegGetMsgRsp&& from) noexcept
    : SLAFVrfRegGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegGetMsgRsp& operator=(const SLAFVrfRegGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegGetMsgRsp& operator=(SLAFVrfRegGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegGetMsgRsp*>(
               &_SLAFVrfRegGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLAFVrfRegGetMsgRsp& a, SLAFVrfRegGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegGetMsgRsp";
  }
  protected:
  explicit SLAFVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 4,
    kErrStatusFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // repeated .service_layer.SLVrfReg Entries = 4;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::service_layer::SLVrfReg* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
      mutable_entries();
  private:
  const ::service_layer::SLVrfReg& _internal_entries(int index) const;
  ::service_layer::SLVrfReg* _internal_add_entries();
  public:
  const ::service_layer::SLVrfReg& entries(int index) const;
  ::service_layer::SLVrfReg* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
      entries() const;

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint64 ClientID = 2;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg > entries_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint64_t clientid_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup_SLPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup.SLPath) */ {
 public:
  inline SLPathGroup_SLPath() : SLPathGroup_SLPath(nullptr) {}
  ~SLPathGroup_SLPath() override;
  explicit constexpr SLPathGroup_SLPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup_SLPath(const SLPathGroup_SLPath& from);
  SLPathGroup_SLPath(SLPathGroup_SLPath&& from) noexcept
    : SLPathGroup_SLPath() {
    *this = ::std::move(from);
  }

  inline SLPathGroup_SLPath& operator=(const SLPathGroup_SLPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup_SLPath& operator=(SLPathGroup_SLPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup_SLPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPathGroup_SLPath* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup_SLPath*>(
               &_SLPathGroup_SLPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLPathGroup_SLPath& a, SLPathGroup_SLPath& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup_SLPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup_SLPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup_SLPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup_SLPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup_SLPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup_SLPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup_SLPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup.SLPath";
  }
  protected:
  explicit SLPathGroup_SLPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // .service_layer.SLRoutePath Path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::service_layer::SLRoutePath& path() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePath* release_path();
  ::service_layer::SLRoutePath* mutable_path();
  void set_allocated_path(::service_layer::SLRoutePath* path);
  private:
  const ::service_layer::SLRoutePath& _internal_path() const;
  ::service_layer::SLRoutePath* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::service_layer::SLRoutePath* path);
  ::service_layer::SLRoutePath* unsafe_arena_release_path();

  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup.SLPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLRoutePath* path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup_SLPathList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup.SLPathList) */ {
 public:
  inline SLPathGroup_SLPathList() : SLPathGroup_SLPathList(nullptr) {}
  ~SLPathGroup_SLPathList() override;
  explicit constexpr SLPathGroup_SLPathList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup_SLPathList(const SLPathGroup_SLPathList& from);
  SLPathGroup_SLPathList(SLPathGroup_SLPathList&& from) noexcept
    : SLPathGroup_SLPathList() {
    *this = ::std::move(from);
  }

  inline SLPathGroup_SLPathList& operator=(const SLPathGroup_SLPathList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup_SLPathList& operator=(SLPathGroup_SLPathList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup_SLPathList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPathGroup_SLPathList* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup_SLPathList*>(
               &_SLPathGroup_SLPathList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLPathGroup_SLPathList& a, SLPathGroup_SLPathList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup_SLPathList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup_SLPathList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup_SLPathList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup_SLPathList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup_SLPathList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup_SLPathList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup_SLPathList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup.SLPathList";
  }
  protected:
  explicit SLPathGroup_SLPathList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 1,
  };
  // repeated .service_layer.SLPathGroup.SLPath Paths = 1;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::service_layer::SLPathGroup_SLPath* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >*
      mutable_paths();
  private:
  const ::service_layer::SLPathGroup_SLPath& _internal_paths(int index) const;
  ::service_layer::SLPathGroup_SLPath* _internal_add_paths();
  public:
  const ::service_layer::SLPathGroup_SLPath& paths(int index) const;
  ::service_layer::SLPathGroup_SLPath* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >&
      paths() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup.SLPathList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath > paths_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup) */ {
 public:
  inline SLPathGroup() : SLPathGroup(nullptr) {}
  ~SLPathGroup() override;
  explicit constexpr SLPathGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup(const SLPathGroup& from);
  SLPathGroup(SLPathGroup&& from) noexcept
    : SLPathGroup() {
    *this = ::std::move(from);
  }

  inline SLPathGroup& operator=(const SLPathGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup& operator=(SLPathGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kPathList = 3,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLPathGroup* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup*>(
               &_SLPathGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLPathGroup& a, SLPathGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup";
  }
  protected:
  explicit SLPathGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLPathGroup_SLPath SLPath;
  typedef SLPathGroup_SLPathList SLPathList;

  // accessors -------------------------------------------------------

  enum : int {
    kPathGroupIdFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kFlagsFieldNumber = 4,
    kPathListFieldNumber = 3,
  };
  // .service_layer.SLObjectId PathGroupId = 1;
  bool has_pathgroupid() const;
  private:
  bool _internal_has_pathgroupid() const;
  public:
  void clear_pathgroupid();
  const ::service_layer::SLObjectId& pathgroupid() const;
  PROTOBUF_NODISCARD ::service_layer::SLObjectId* release_pathgroupid();
  ::service_layer::SLObjectId* mutable_pathgroupid();
  void set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid);
  private:
  const ::service_layer::SLObjectId& _internal_pathgroupid() const;
  ::service_layer::SLObjectId* _internal_mutable_pathgroupid();
  public:
  void unsafe_arena_set_allocated_pathgroupid(
      ::service_layer::SLObjectId* pathgroupid);
  ::service_layer::SLObjectId* unsafe_arena_release_pathgroupid();

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 Flags = 4;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // .service_layer.SLPathGroup.SLPathList PathList = 3;
  bool has_pathlist() const;
  private:
  bool _internal_has_pathlist() const;
  public:
  void clear_pathlist();
  const ::service_layer::SLPathGroup_SLPathList& pathlist() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroup_SLPathList* release_pathlist();
  ::service_layer::SLPathGroup_SLPathList* mutable_pathlist();
  void set_allocated_pathlist(::service_layer::SLPathGroup_SLPathList* pathlist);
  private:
  const ::service_layer::SLPathGroup_SLPathList& _internal_pathlist() const;
  ::service_layer::SLPathGroup_SLPathList* _internal_mutable_pathlist();
  public:
  void unsafe_arena_set_allocated_pathlist(
      ::service_layer::SLPathGroup_SLPathList* pathlist);
  ::service_layer::SLPathGroup_SLPathList* unsafe_arena_release_pathlist();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup)
 private:
  class _Internal;
  void set_has_pathlist();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLObjectId* pathgroupid_;
  uint32_t admindistance_;
  uint32_t flags_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLPathGroup_SLPathList* pathlist_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLMplsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLMplsEntry) */ {
 public:
  inline SLMplsEntry() : SLMplsEntry(nullptr) {}
  ~SLMplsEntry() override;
  explicit constexpr SLMplsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLMplsEntry(const SLMplsEntry& from);
  SLMplsEntry(SLMplsEntry&& from) noexcept
    : SLMplsEntry() {
    *this = ::std::move(from);
  }

  inline SLMplsEntry& operator=(const SLMplsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLMplsEntry& operator=(SLMplsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLMplsEntry& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kPathGroupKey = 4,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLMplsEntry* internal_default_instance() {
    return reinterpret_cast<const SLMplsEntry*>(
               &_SLMplsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLMplsEntry& a, SLMplsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLMplsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLMplsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLMplsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLMplsEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLMplsEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLMplsEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLMplsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLMplsEntry";
  }
  protected:
  explicit SLMplsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathListFieldNumber = 3,
    kLocalLabelFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kFlagsFieldNumber = 5,
    kPathGroupKeyFieldNumber = 4,
  };
  // repeated .service_layer.SLRoutePath PathList = 3;
  int pathlist_size() const;
  private:
  int _internal_pathlist_size() const;
  public:
  void clear_pathlist();
  ::service_layer::SLRoutePath* mutable_pathlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
      mutable_pathlist();
  private:
  const ::service_layer::SLRoutePath& _internal_pathlist(int index) const;
  ::service_layer::SLRoutePath* _internal_add_pathlist();
  public:
  const ::service_layer::SLRoutePath& pathlist(int index) const;
  ::service_layer::SLRoutePath* add_pathlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
      pathlist() const;

  // uint32 LocalLabel = 1;
  void clear_locallabel();
  uint32_t locallabel() const;
  void set_locallabel(uint32_t value);
  private:
  uint32_t _internal_locallabel() const;
  void _internal_set_locallabel(uint32_t value);
  public:

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 Flags = 5;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // .service_layer.SLPathGroupRefKey PathGroupKey = 4;
  bool has_pathgroupkey() const;
  private:
  bool _internal_has_pathgroupkey() const;
  public:
  void clear_pathgroupkey();
  const ::service_layer::SLPathGroupRefKey& pathgroupkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroupRefKey* release_pathgroupkey();
  ::service_layer::SLPathGroupRefKey* mutable_pathgroupkey();
  void set_allocated_pathgroupkey(::service_layer::SLPathGroupRefKey* pathgroupkey);
  private:
  const ::service_layer::SLPathGroupRefKey& _internal_pathgroupkey() const;
  ::service_layer::SLPathGroupRefKey* _internal_mutable_pathgroupkey();
  public:
  void unsafe_arena_set_allocated_pathgroupkey(
      ::service_layer::SLPathGroupRefKey* pathgroupkey);
  ::service_layer::SLPathGroupRefKey* unsafe_arena_release_pathgroupkey();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLMplsEntry)
 private:
  class _Internal;
  void set_has_pathgroupkey();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath > pathlist_;
  uint32_t locallabel_;
  uint32_t admindistance_;
  uint32_t flags_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLPathGroupRefKey* pathgroupkey_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFObject) */ {
 public:
  inline SLAFObject() : SLAFObject(nullptr) {}
  ~SLAFObject() override;
  explicit constexpr SLAFObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFObject(const SLAFObject& from);
  SLAFObject(SLAFObject&& from) noexcept
    : SLAFObject() {
    *this = ::std::move(from);
  }

  inline SLAFObject& operator=(const SLAFObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFObject& operator=(SLAFObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFObject& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kIPv4Route = 1,
    kIPv6Route = 2,
    kMplsLabel = 3,
    kPathGroup = 4,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLAFObject* internal_default_instance() {
    return reinterpret_cast<const SLAFObject*>(
               &_SLAFObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLAFObject& a, SLAFObject& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFObject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFObject";
  }
  protected:
  explicit SLAFObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPv4RouteFieldNumber = 1,
    kIPv6RouteFieldNumber = 2,
    kMplsLabelFieldNumber = 3,
    kPathGroupFieldNumber = 4,
  };
  // .service_layer.SLRoutev4 IPv4Route = 1;
  bool has_ipv4route() const;
  private:
  bool _internal_has_ipv4route() const;
  public:
  void clear_ipv4route();
  const ::service_layer::SLRoutev4& ipv4route() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutev4* release_ipv4route();
  ::service_layer::SLRoutev4* mutable_ipv4route();
  void set_allocated_ipv4route(::service_layer::SLRoutev4* ipv4route);
  private:
  const ::service_layer::SLRoutev4& _internal_ipv4route() const;
  ::service_layer::SLRoutev4* _internal_mutable_ipv4route();
  public:
  void unsafe_arena_set_allocated_ipv4route(
      ::service_layer::SLRoutev4* ipv4route);
  ::service_layer::SLRoutev4* unsafe_arena_release_ipv4route();

  // .service_layer.SLRoutev6 IPv6Route = 2;
  bool has_ipv6route() const;
  private:
  bool _internal_has_ipv6route() const;
  public:
  void clear_ipv6route();
  const ::service_layer::SLRoutev6& ipv6route() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutev6* release_ipv6route();
  ::service_layer::SLRoutev6* mutable_ipv6route();
  void set_allocated_ipv6route(::service_layer::SLRoutev6* ipv6route);
  private:
  const ::service_layer::SLRoutev6& _internal_ipv6route() const;
  ::service_layer::SLRoutev6* _internal_mutable_ipv6route();
  public:
  void unsafe_arena_set_allocated_ipv6route(
      ::service_layer::SLRoutev6* ipv6route);
  ::service_layer::SLRoutev6* unsafe_arena_release_ipv6route();

  // .service_layer.SLMplsEntry MplsLabel = 3;
  bool has_mplslabel() const;
  private:
  bool _internal_has_mplslabel() const;
  public:
  void clear_mplslabel();
  const ::service_layer::SLMplsEntry& mplslabel() const;
  PROTOBUF_NODISCARD ::service_layer::SLMplsEntry* release_mplslabel();
  ::service_layer::SLMplsEntry* mutable_mplslabel();
  void set_allocated_mplslabel(::service_layer::SLMplsEntry* mplslabel);
  private:
  const ::service_layer::SLMplsEntry& _internal_mplslabel() const;
  ::service_layer::SLMplsEntry* _internal_mutable_mplslabel();
  public:
  void unsafe_arena_set_allocated_mplslabel(
      ::service_layer::SLMplsEntry* mplslabel);
  ::service_layer::SLMplsEntry* unsafe_arena_release_mplslabel();

  // .service_layer.SLPathGroup PathGroup = 4;
  bool has_pathgroup() const;
  private:
  bool _internal_has_pathgroup() const;
  public:
  void clear_pathgroup();
  const ::service_layer::SLPathGroup& pathgroup() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroup* release_pathgroup();
  ::service_layer::SLPathGroup* mutable_pathgroup();
  void set_allocated_pathgroup(::service_layer::SLPathGroup* pathgroup);
  private:
  const ::service_layer::SLPathGroup& _internal_pathgroup() const;
  ::service_layer::SLPathGroup* _internal_mutable_pathgroup();
  public:
  void unsafe_arena_set_allocated_pathgroup(
      ::service_layer::SLPathGroup* pathgroup);
  ::service_layer::SLPathGroup* unsafe_arena_release_pathgroup();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFObject)
 private:
  class _Internal;
  void set_has_ipv4route();
  void set_has_ipv6route();
  void set_has_mplslabel();
  void set_has_pathgroup();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLRoutev4* ipv4route_;
    ::service_layer::SLRoutev6* ipv6route_;
    ::service_layer::SLMplsEntry* mplslabel_;
    ::service_layer::SLPathGroup* pathgroup_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFOp) */ {
 public:
  inline SLAFOp() : SLAFOp(nullptr) {}
  ~SLAFOp() override;
  explicit constexpr SLAFOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFOp(const SLAFOp& from);
  SLAFOp(SLAFOp&& from) noexcept
    : SLAFOp() {
    *this = ::std::move(from);
  }

  inline SLAFOp& operator=(const SLAFOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFOp& operator=(SLAFOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFOp* internal_default_instance() {
    return reinterpret_cast<const SLAFOp*>(
               &_SLAFOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLAFOp& a, SLAFOp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFOp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFOp";
  }
  protected:
  explicit SLAFOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFObjectFieldNumber = 1,
    kOperationIDFieldNumber = 2,
    kAckTypeFieldNumber = 3,
  };
  // .service_layer.SLAFObject AFObject = 1;
  bool has_afobject() const;
  private:
  bool _internal_has_afobject() const;
  public:
  void clear_afobject();
  const ::service_layer::SLAFObject& afobject() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObject* release_afobject();
  ::service_layer::SLAFObject* mutable_afobject();
  void set_allocated_afobject(::service_layer::SLAFObject* afobject);
  private:
  const ::service_layer::SLAFObject& _internal_afobject() const;
  ::service_layer::SLAFObject* _internal_mutable_afobject();
  public:
  void unsafe_arena_set_allocated_afobject(
      ::service_layer::SLAFObject* afobject);
  ::service_layer::SLAFObject* unsafe_arena_release_afobject();

  // uint64 OperationID = 2;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLRspACKType AckType = 3;
  void clear_acktype();
  ::service_layer::SLRspACKType acktype() const;
  void set_acktype(::service_layer::SLRspACKType value);
  private:
  ::service_layer::SLRspACKType _internal_acktype() const;
  void _internal_set_acktype(::service_layer::SLRspACKType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFObject* afobject_;
  uint64_t operationid_;
  int acktype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsg) */ {
 public:
  inline SLAFGetMsg() : SLAFGetMsg(nullptr) {}
  ~SLAFGetMsg() override;
  explicit constexpr SLAFGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsg(const SLAFGetMsg& from);
  SLAFGetMsg(SLAFGetMsg&& from) noexcept
    : SLAFGetMsg() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsg& operator=(const SLAFGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsg& operator=(SLAFGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsg*>(
               &_SLAFGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLAFGetMsg& a, SLAFGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsg";
  }
  protected:
  explicit SLAFGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteMatchFieldNumber = 4,
    kVrfNameFieldNumber = 1,
    kTableFieldNumber = 2,
    kGetAllClientsFieldNumber = 3,
  };
  // repeated .service_layer.SLRouteGetMatch RouteMatch = 4;
  int routematch_size() const;
  private:
  int _internal_routematch_size() const;
  public:
  void clear_routematch();
  ::service_layer::SLRouteGetMatch* mutable_routematch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRouteGetMatch >*
      mutable_routematch();
  private:
  const ::service_layer::SLRouteGetMatch& _internal_routematch(int index) const;
  ::service_layer::SLRouteGetMatch* _internal_add_routematch();
  public:
  const ::service_layer::SLRouteGetMatch& routematch(int index) const;
  ::service_layer::SLRouteGetMatch* add_routematch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRouteGetMatch >&
      routematch() const;

  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLTableType Table = 2;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // bool GetAllClients = 3;
  void clear_getallclients();
  bool getallclients() const;
  void set_getallclients(bool value);
  private:
  bool _internal_getallclients() const;
  void _internal_set_getallclients(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRouteGetMatch > routematch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int table_;
  bool getallclients_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFFibStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFFibStatus) */ {
 public:
  inline SLAFFibStatus() : SLAFFibStatus(nullptr) {}
  ~SLAFFibStatus() override;
  explicit constexpr SLAFFibStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFFibStatus(const SLAFFibStatus& from);
  SLAFFibStatus(SLAFFibStatus&& from) noexcept
    : SLAFFibStatus() {
    *this = ::std::move(from);
  }

  inline SLAFFibStatus& operator=(const SLAFFibStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFFibStatus& operator=(SLAFFibStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFFibStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFFibStatus* internal_default_instance() {
    return reinterpret_cast<const SLAFFibStatus*>(
               &_SLAFFibStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLAFFibStatus& a, SLAFFibStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFFibStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFFibStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFFibStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFFibStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFFibStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFFibStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFFibStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFFibStatus";
  }
  protected:
  explicit SLAFFibStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepResultFieldNumber = 5,
    kErrorStringFieldNumber = 4,
    kErrorCodeFieldNumber = 1,
    kOperationIDFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // repeated .service_layer.SLAFFibStatus DepResult = 5;
  int depresult_size() const;
  private:
  int _internal_depresult_size() const;
  public:
  void clear_depresult();
  ::service_layer::SLAFFibStatus* mutable_depresult(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFFibStatus >*
      mutable_depresult();
  private:
  const ::service_layer::SLAFFibStatus& _internal_depresult(int index) const;
  ::service_layer::SLAFFibStatus* _internal_add_depresult();
  public:
  const ::service_layer::SLAFFibStatus& depresult(int index) const;
  ::service_layer::SLAFFibStatus* add_depresult();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFFibStatus >&
      depresult() const;

  // string ErrorString = 4;
  void clear_errorstring();
  const std::string& errorstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errorstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errorstring();
  PROTOBUF_NODISCARD std::string* release_errorstring();
  void set_allocated_errorstring(std::string* errorstring);
  private:
  const std::string& _internal_errorstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errorstring(const std::string& value);
  std::string* _internal_mutable_errorstring();
  public:

  // .service_layer.SLErrorStatus ErrorCode = 1;
  bool has_errorcode() const;
  private:
  bool _internal_has_errorcode() const;
  public:
  void clear_errorcode();
  const ::service_layer::SLErrorStatus& errorcode() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errorcode();
  ::service_layer::SLErrorStatus* mutable_errorcode();
  void set_allocated_errorcode(::service_layer::SLErrorStatus* errorcode);
  private:
  const ::service_layer::SLErrorStatus& _internal_errorcode() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errorcode();
  public:
  void unsafe_arena_set_allocated_errorcode(
      ::service_layer::SLErrorStatus* errorcode);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errorcode();

  // uint64 OperationID = 2;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // uint64 Version = 3;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFFibStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFFibStatus > depresult_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errorstring_;
  ::service_layer::SLErrorStatus* errorcode_;
  uint64_t operationid_;
  uint64_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsgRspEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsgRspEntry) */ {
 public:
  inline SLAFGetMsgRspEntry() : SLAFGetMsgRspEntry(nullptr) {}
  ~SLAFGetMsgRspEntry() override;
  explicit constexpr SLAFGetMsgRspEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsgRspEntry(const SLAFGetMsgRspEntry& from);
  SLAFGetMsgRspEntry(SLAFGetMsgRspEntry&& from) noexcept
    : SLAFGetMsgRspEntry() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsgRspEntry& operator=(const SLAFGetMsgRspEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsgRspEntry& operator=(SLAFGetMsgRspEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsgRspEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMsgRspEntry* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsgRspEntry*>(
               &_SLAFGetMsgRspEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLAFGetMsgRspEntry& a, SLAFGetMsgRspEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsgRspEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsgRspEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsgRspEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsgRspEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsgRspEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsgRspEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsgRspEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsgRspEntry";
  }
  protected:
  explicit SLAFGetMsgRspEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFOpFieldNumber = 1,
    kFIBStatusFieldNumber = 2,
  };
  // .service_layer.SLAFOp AFOp = 1;
  bool has_afop() const;
  private:
  bool _internal_has_afop() const;
  public:
  void clear_afop();
  const ::service_layer::SLAFOp& afop() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFOp* release_afop();
  ::service_layer::SLAFOp* mutable_afop();
  void set_allocated_afop(::service_layer::SLAFOp* afop);
  private:
  const ::service_layer::SLAFOp& _internal_afop() const;
  ::service_layer::SLAFOp* _internal_mutable_afop();
  public:
  void unsafe_arena_set_allocated_afop(
      ::service_layer::SLAFOp* afop);
  ::service_layer::SLAFOp* unsafe_arena_release_afop();

  // .service_layer.SLAFFibStatus FIBStatus = 2;
  bool has_fibstatus() const;
  private:
  bool _internal_has_fibstatus() const;
  public:
  void clear_fibstatus();
  const ::service_layer::SLAFFibStatus& fibstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFFibStatus* release_fibstatus();
  ::service_layer::SLAFFibStatus* mutable_fibstatus();
  void set_allocated_fibstatus(::service_layer::SLAFFibStatus* fibstatus);
  private:
  const ::service_layer::SLAFFibStatus& _internal_fibstatus() const;
  ::service_layer::SLAFFibStatus* _internal_mutable_fibstatus();
  public:
  void unsafe_arena_set_allocated_fibstatus(
      ::service_layer::SLAFFibStatus* fibstatus);
  ::service_layer::SLAFFibStatus* unsafe_arena_release_fibstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsgRspEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFOp* afop_;
  ::service_layer::SLAFFibStatus* fibstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsgRsp) */ {
 public:
  inline SLAFGetMsgRsp() : SLAFGetMsgRsp(nullptr) {}
  ~SLAFGetMsgRsp() override;
  explicit constexpr SLAFGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsgRsp(const SLAFGetMsgRsp& from);
  SLAFGetMsgRsp(SLAFGetMsgRsp&& from) noexcept
    : SLAFGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsgRsp& operator=(const SLAFGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsgRsp& operator=(SLAFGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsgRsp*>(
               &_SLAFGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLAFGetMsgRsp& a, SLAFGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsgRsp";
  }
  protected:
  explicit SLAFGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFListFieldNumber = 4,
    kVrfNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
    kClientIDFieldNumber = 3,
  };
  // repeated .service_layer.SLAFGetMsgRspEntry AFList = 4;
  int aflist_size() const;
  private:
  int _internal_aflist_size() const;
  public:
  void clear_aflist();
  ::service_layer::SLAFGetMsgRspEntry* mutable_aflist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >*
      mutable_aflist();
  private:
  const ::service_layer::SLAFGetMsgRspEntry& _internal_aflist(int index) const;
  ::service_layer::SLAFGetMsgRspEntry* _internal_add_aflist();
  public:
  const ::service_layer::SLAFGetMsgRspEntry& aflist(int index) const;
  ::service_layer::SLAFGetMsgRspEntry* add_aflist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >&
      aflist() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint64 ClientID = 3;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry > aflist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint64_t clientid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFMsg) */ {
 public:
  inline SLAFMsg() : SLAFMsg(nullptr) {}
  ~SLAFMsg() override;
  explicit constexpr SLAFMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFMsg(const SLAFMsg& from);
  SLAFMsg(SLAFMsg&& from) noexcept
    : SLAFMsg() {
    *this = ::std::move(from);
  }

  inline SLAFMsg& operator=(const SLAFMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFMsg& operator=(SLAFMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFMsg*>(
               &_SLAFMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLAFMsg& a, SLAFMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFMsg";
  }
  protected:
  explicit SLAFMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpListFieldNumber = 3,
    kVrfNameFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFOp OpList = 3;
  int oplist_size() const;
  private:
  int _internal_oplist_size() const;
  public:
  void clear_oplist();
  ::service_layer::SLAFOp* mutable_oplist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOp >*
      mutable_oplist();
  private:
  const ::service_layer::SLAFOp& _internal_oplist(int index) const;
  ::service_layer::SLAFOp* _internal_add_oplist();
  public:
  const ::service_layer::SLAFOp& oplist(int index) const;
  ::service_layer::SLAFOp* add_oplist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOp >&
      oplist() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLObjectOp Oper = 1;
  void clear_oper();
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);
  private:
  ::service_layer::SLObjectOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOp > oplist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFRes) */ {
 public:
  inline SLAFRes() : SLAFRes(nullptr) {}
  ~SLAFRes() override;
  explicit constexpr SLAFRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFRes(const SLAFRes& from);
  SLAFRes(SLAFRes&& from) noexcept
    : SLAFRes() {
    *this = ::std::move(from);
  }

  inline SLAFRes& operator=(const SLAFRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFRes& operator=(SLAFRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFRes* internal_default_instance() {
    return reinterpret_cast<const SLAFRes*>(
               &_SLAFRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SLAFRes& a, SLAFRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFRes";
  }
  protected:
  explicit SLAFRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kOperationFieldNumber = 2,
    kFIBStatusFieldNumber = 3,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLAFOp Operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const ::service_layer::SLAFOp& operation() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFOp* release_operation();
  ::service_layer::SLAFOp* mutable_operation();
  void set_allocated_operation(::service_layer::SLAFOp* operation);
  private:
  const ::service_layer::SLAFOp& _internal_operation() const;
  ::service_layer::SLAFOp* _internal_mutable_operation();
  public:
  void unsafe_arena_set_allocated_operation(
      ::service_layer::SLAFOp* operation);
  ::service_layer::SLAFOp* unsafe_arena_release_operation();

  // .service_layer.SLAFFibStatus FIBStatus = 3;
  bool has_fibstatus() const;
  private:
  bool _internal_has_fibstatus() const;
  public:
  void clear_fibstatus();
  const ::service_layer::SLAFFibStatus& fibstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFFibStatus* release_fibstatus();
  ::service_layer::SLAFFibStatus* mutable_fibstatus();
  void set_allocated_fibstatus(::service_layer::SLAFFibStatus* fibstatus);
  private:
  const ::service_layer::SLAFFibStatus& _internal_fibstatus() const;
  ::service_layer::SLAFFibStatus* _internal_mutable_fibstatus();
  public:
  void unsafe_arena_set_allocated_fibstatus(
      ::service_layer::SLAFFibStatus* fibstatus);
  ::service_layer::SLAFFibStatus* unsafe_arena_release_fibstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  ::service_layer::SLAFOp* operation_;
  ::service_layer::SLAFFibStatus* fibstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFMsgRsp) */ {
 public:
  inline SLAFMsgRsp() : SLAFMsgRsp(nullptr) {}
  ~SLAFMsgRsp() override;
  explicit constexpr SLAFMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFMsgRsp(const SLAFMsgRsp& from);
  SLAFMsgRsp(SLAFMsgRsp&& from) noexcept
    : SLAFMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFMsgRsp& operator=(const SLAFMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFMsgRsp& operator=(SLAFMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFMsgRsp*>(
               &_SLAFMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SLAFMsgRsp& a, SLAFMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFMsgRsp";
  }
  protected:
  explicit SLAFMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kVrfNameFieldNumber = 1,
  };
  // repeated .service_layer.SLAFRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLAFRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >*
      mutable_results();
  private:
  const ::service_layer::SLAFRes& _internal_results(int index) const;
  ::service_layer::SLAFRes* _internal_add_results();
  public:
  const ::service_layer::SLAFRes& results(int index) const;
  ::service_layer::SLAFRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >&
      results() const;

  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes > results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFRedistRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFRedistRegMsg) */ {
 public:
  inline SLAFRedistRegMsg() : SLAFRedistRegMsg(nullptr) {}
  ~SLAFRedistRegMsg() override;
  explicit constexpr SLAFRedistRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFRedistRegMsg(const SLAFRedistRegMsg& from);
  SLAFRedistRegMsg(SLAFRedistRegMsg&& from) noexcept
    : SLAFRedistRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFRedistRegMsg& operator=(const SLAFRedistRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFRedistRegMsg& operator=(SLAFRedistRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFRedistRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFRedistRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFRedistRegMsg*>(
               &_SLAFRedistRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SLAFRedistRegMsg& a, SLAFRedistRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFRedistRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFRedistRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFRedistRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFRedistRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFRedistRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFRedistRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFRedistRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFRedistRegMsg";
  }
  protected:
  explicit SLAFRedistRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcProtoFieldNumber = 1,
    kSrcProtoTagFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // string SrcProto = 1;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 2;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFRedistRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegKey_SLNextHopKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegKey.SLNextHopKey) */ {
 public:
  inline SLAFNextHopRegKey_SLNextHopKey() : SLAFNextHopRegKey_SLNextHopKey(nullptr) {}
  ~SLAFNextHopRegKey_SLNextHopKey() override;
  explicit constexpr SLAFNextHopRegKey_SLNextHopKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegKey_SLNextHopKey(const SLAFNextHopRegKey_SLNextHopKey& from);
  SLAFNextHopRegKey_SLNextHopKey(SLAFNextHopRegKey_SLNextHopKey&& from) noexcept
    : SLAFNextHopRegKey_SLNextHopKey() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegKey_SLNextHopKey& operator=(const SLAFNextHopRegKey_SLNextHopKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegKey_SLNextHopKey& operator=(SLAFNextHopRegKey_SLNextHopKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegKey_SLNextHopKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNextHopRegKey_SLNextHopKey* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegKey_SLNextHopKey*>(
               &_SLAFNextHopRegKey_SLNextHopKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SLAFNextHopRegKey_SLNextHopKey& a, SLAFNextHopRegKey_SLNextHopKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegKey_SLNextHopKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegKey_SLNextHopKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegKey_SLNextHopKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegKey_SLNextHopKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegKey_SLNextHopKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegKey_SLNextHopKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegKey_SLNextHopKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegKey.SLNextHopKey";
  }
  protected:
  explicit SLAFNextHopRegKey_SLNextHopKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopFieldNumber = 1,
    kNextHopLenFieldNumber = 2,
    kExactMatchFieldNumber = 3,
    kAllowDefaultFieldNumber = 4,
    kRecurseFieldNumber = 5,
  };
  // .service_layer.SLIpAddress NextHop = 1;
  bool has_nexthop() const;
  private:
  bool _internal_has_nexthop() const;
  public:
  void clear_nexthop();
  const ::service_layer::SLIpAddress& nexthop() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_nexthop();
  ::service_layer::SLIpAddress* mutable_nexthop();
  void set_allocated_nexthop(::service_layer::SLIpAddress* nexthop);
  private:
  const ::service_layer::SLIpAddress& _internal_nexthop() const;
  ::service_layer::SLIpAddress* _internal_mutable_nexthop();
  public:
  void unsafe_arena_set_allocated_nexthop(
      ::service_layer::SLIpAddress* nexthop);
  ::service_layer::SLIpAddress* unsafe_arena_release_nexthop();

  // uint32 NextHopLen = 2;
  void clear_nexthoplen();
  uint32_t nexthoplen() const;
  void set_nexthoplen(uint32_t value);
  private:
  uint32_t _internal_nexthoplen() const;
  void _internal_set_nexthoplen(uint32_t value);
  public:

  // bool ExactMatch = 3;
  void clear_exactmatch();
  bool exactmatch() const;
  void set_exactmatch(bool value);
  private:
  bool _internal_exactmatch() const;
  void _internal_set_exactmatch(bool value);
  public:

  // bool AllowDefault = 4;
  void clear_allowdefault();
  bool allowdefault() const;
  void set_allowdefault(bool value);
  private:
  bool _internal_allowdefault() const;
  void _internal_set_allowdefault(bool value);
  public:

  // bool Recurse = 5;
  void clear_recurse();
  bool recurse() const;
  void set_recurse(bool value);
  private:
  bool _internal_recurse() const;
  void _internal_set_recurse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegKey.SLNextHopKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLIpAddress* nexthop_;
  uint32_t nexthoplen_;
  bool exactmatch_;
  bool allowdefault_;
  bool recurse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegKey) */ {
 public:
  inline SLAFNextHopRegKey() : SLAFNextHopRegKey(nullptr) {}
  ~SLAFNextHopRegKey() override;
  explicit constexpr SLAFNextHopRegKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegKey(const SLAFNextHopRegKey& from);
  SLAFNextHopRegKey(SLAFNextHopRegKey&& from) noexcept
    : SLAFNextHopRegKey() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegKey& operator=(const SLAFNextHopRegKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegKey& operator=(SLAFNextHopRegKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegKey& default_instance() {
    return *internal_default_instance();
  }
  enum NexthopkeyCase {
    kNextHop = 1,
    NEXTHOPKEY_NOT_SET = 0,
  };

  static inline const SLAFNextHopRegKey* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegKey*>(
               &_SLAFNextHopRegKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SLAFNextHopRegKey& a, SLAFNextHopRegKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegKey";
  }
  protected:
  explicit SLAFNextHopRegKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLAFNextHopRegKey_SLNextHopKey SLNextHopKey;

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopFieldNumber = 1,
  };
  // .service_layer.SLAFNextHopRegKey.SLNextHopKey NextHop = 1;
  bool has_nexthop() const;
  private:
  bool _internal_has_nexthop() const;
  public:
  void clear_nexthop();
  const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& nexthop() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey_SLNextHopKey* release_nexthop();
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* mutable_nexthop();
  void set_allocated_nexthop(::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop);
  private:
  const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& _internal_nexthop() const;
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* _internal_mutable_nexthop();
  public:
  void unsafe_arena_set_allocated_nexthop(
      ::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop);
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* unsafe_arena_release_nexthop();

  void clear_nexthopkey();
  NexthopkeyCase nexthopkey_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegKey)
 private:
  class _Internal;
  void set_has_nexthop();

  inline bool has_nexthopkey() const;
  inline void clear_has_nexthopkey();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union NexthopkeyUnion {
    constexpr NexthopkeyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop_;
  } nexthopkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegMsg) */ {
 public:
  inline SLAFNextHopRegMsg() : SLAFNextHopRegMsg(nullptr) {}
  ~SLAFNextHopRegMsg() override;
  explicit constexpr SLAFNextHopRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegMsg(const SLAFNextHopRegMsg& from);
  SLAFNextHopRegMsg(SLAFNextHopRegMsg&& from) noexcept
    : SLAFNextHopRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegMsg& operator=(const SLAFNextHopRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegMsg& operator=(SLAFNextHopRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNextHopRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegMsg*>(
               &_SLAFNextHopRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SLAFNextHopRegMsg& a, SLAFNextHopRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegMsg";
  }
  protected:
  explicit SLAFNextHopRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopKeyFieldNumber = 1,
  };
  // .service_layer.SLAFNextHopRegKey NextHopKey = 1;
  bool has_nexthopkey() const;
  private:
  bool _internal_has_nexthopkey() const;
  public:
  void clear_nexthopkey();
  const ::service_layer::SLAFNextHopRegKey& nexthopkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey* release_nexthopkey();
  ::service_layer::SLAFNextHopRegKey* mutable_nexthopkey();
  void set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey);
  private:
  const ::service_layer::SLAFNextHopRegKey& _internal_nexthopkey() const;
  ::service_layer::SLAFNextHopRegKey* _internal_mutable_nexthopkey();
  public:
  void unsafe_arena_set_allocated_nexthopkey(
      ::service_layer::SLAFNextHopRegKey* nexthopkey);
  ::service_layer::SLAFNextHopRegKey* unsafe_arena_release_nexthopkey();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFNextHopRegKey* nexthopkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifRegReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifRegReq) */ {
 public:
  inline SLAFNotifRegReq() : SLAFNotifRegReq(nullptr) {}
  ~SLAFNotifRegReq() override;
  explicit constexpr SLAFNotifRegReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifRegReq(const SLAFNotifRegReq& from);
  SLAFNotifRegReq(SLAFNotifRegReq&& from) noexcept
    : SLAFNotifRegReq() {
    *this = ::std::move(from);
  }

  inline SLAFNotifRegReq& operator=(const SLAFNotifRegReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifRegReq& operator=(SLAFNotifRegReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifRegReq& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kRedistReq = 1,
    kNextHopReq = 2,
    REQUEST_NOT_SET = 0,
  };

  static inline const SLAFNotifRegReq* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifRegReq*>(
               &_SLAFNotifRegReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SLAFNotifRegReq& a, SLAFNotifRegReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifRegReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifRegReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifRegReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifRegReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifRegReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifRegReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifRegReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifRegReq";
  }
  protected:
  explicit SLAFNotifRegReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationIDFieldNumber = 3,
    kRedistReqFieldNumber = 1,
    kNextHopReqFieldNumber = 2,
  };
  // uint64 OperationID = 3;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLAFRedistRegMsg RedistReq = 1;
  bool has_redistreq() const;
  private:
  bool _internal_has_redistreq() const;
  public:
  void clear_redistreq();
  const ::service_layer::SLAFRedistRegMsg& redistreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFRedistRegMsg* release_redistreq();
  ::service_layer::SLAFRedistRegMsg* mutable_redistreq();
  void set_allocated_redistreq(::service_layer::SLAFRedistRegMsg* redistreq);
  private:
  const ::service_layer::SLAFRedistRegMsg& _internal_redistreq() const;
  ::service_layer::SLAFRedistRegMsg* _internal_mutable_redistreq();
  public:
  void unsafe_arena_set_allocated_redistreq(
      ::service_layer::SLAFRedistRegMsg* redistreq);
  ::service_layer::SLAFRedistRegMsg* unsafe_arena_release_redistreq();

  // .service_layer.SLAFNextHopRegMsg NextHopReq = 2;
  bool has_nexthopreq() const;
  private:
  bool _internal_has_nexthopreq() const;
  public:
  void clear_nexthopreq();
  const ::service_layer::SLAFNextHopRegMsg& nexthopreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegMsg* release_nexthopreq();
  ::service_layer::SLAFNextHopRegMsg* mutable_nexthopreq();
  void set_allocated_nexthopreq(::service_layer::SLAFNextHopRegMsg* nexthopreq);
  private:
  const ::service_layer::SLAFNextHopRegMsg& _internal_nexthopreq() const;
  ::service_layer::SLAFNextHopRegMsg* _internal_mutable_nexthopreq();
  public:
  void unsafe_arena_set_allocated_nexthopreq(
      ::service_layer::SLAFNextHopRegMsg* nexthopreq);
  ::service_layer::SLAFNextHopRegMsg* unsafe_arena_release_nexthopreq();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifRegReq)
 private:
  class _Internal;
  void set_has_redistreq();
  void set_has_nexthopreq();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t operationid_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFRedistRegMsg* redistreq_;
    ::service_layer::SLAFNextHopRegMsg* nexthopreq_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifReq) */ {
 public:
  inline SLAFNotifReq() : SLAFNotifReq(nullptr) {}
  ~SLAFNotifReq() override;
  explicit constexpr SLAFNotifReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifReq(const SLAFNotifReq& from);
  SLAFNotifReq(SLAFNotifReq&& from) noexcept
    : SLAFNotifReq() {
    *this = ::std::move(from);
  }

  inline SLAFNotifReq& operator=(const SLAFNotifReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifReq& operator=(SLAFNotifReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifReq* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifReq*>(
               &_SLAFNotifReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SLAFNotifReq& a, SLAFNotifReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifReq";
  }
  protected:
  explicit SLAFNotifReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifReqFieldNumber = 3,
    kVrfNameFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFNotifRegReq NotifReq = 3;
  int notifreq_size() const;
  private:
  int _internal_notifreq_size() const;
  public:
  void clear_notifreq();
  ::service_layer::SLAFNotifRegReq* mutable_notifreq(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >*
      mutable_notifreq();
  private:
  const ::service_layer::SLAFNotifRegReq& _internal_notifreq(int index) const;
  ::service_layer::SLAFNotifRegReq* _internal_add_notifreq();
  public:
  const ::service_layer::SLAFNotifRegReq& notifreq(int index) const;
  ::service_layer::SLAFNotifRegReq* add_notifreq();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >&
      notifreq() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq > notifreq_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifRsp) */ {
 public:
  inline SLAFNotifRsp() : SLAFNotifRsp(nullptr) {}
  ~SLAFNotifRsp() override;
  explicit constexpr SLAFNotifRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifRsp(const SLAFNotifRsp& from);
  SLAFNotifRsp(SLAFNotifRsp&& from) noexcept
    : SLAFNotifRsp() {
    *this = ::std::move(from);
  }

  inline SLAFNotifRsp& operator=(const SLAFNotifRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifRsp& operator=(SLAFNotifRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifRsp*>(
               &_SLAFNotifRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SLAFNotifRsp& a, SLAFNotifRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifRsp";
  }
  protected:
  explicit SLAFNotifRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifReqFieldNumber = 1,
    kNotifStatusFieldNumber = 2,
  };
  // .service_layer.SLAFNotifRegReq NotifReq = 1;
  bool has_notifreq() const;
  private:
  bool _internal_has_notifreq() const;
  public:
  void clear_notifreq();
  const ::service_layer::SLAFNotifRegReq& notifreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotifRegReq* release_notifreq();
  ::service_layer::SLAFNotifRegReq* mutable_notifreq();
  void set_allocated_notifreq(::service_layer::SLAFNotifRegReq* notifreq);
  private:
  const ::service_layer::SLAFNotifRegReq& _internal_notifreq() const;
  ::service_layer::SLAFNotifRegReq* _internal_mutable_notifreq();
  public:
  void unsafe_arena_set_allocated_notifreq(
      ::service_layer::SLAFNotifRegReq* notifreq);
  ::service_layer::SLAFNotifRegReq* unsafe_arena_release_notifreq();

  // .service_layer.SLErrorStatus NotifStatus = 2;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLErrorStatus& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_notifstatus();
  ::service_layer::SLErrorStatus* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_notifstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLErrorStatus* notifstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_notifstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFNotifRegReq* notifreq_;
  ::service_layer::SLErrorStatus* notifstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLNextHop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLNextHop) */ {
 public:
  inline SLNextHop() : SLNextHop(nullptr) {}
  ~SLNextHop() override;
  explicit constexpr SLNextHop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLNextHop(const SLNextHop& from);
  SLNextHop(SLNextHop&& from) noexcept
    : SLNextHop() {
    *this = ::std::move(from);
  }

  inline SLNextHop& operator=(const SLNextHop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLNextHop& operator=(SLNextHop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLNextHop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLNextHop* internal_default_instance() {
    return reinterpret_cast<const SLNextHop*>(
               &_SLNextHop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SLNextHop& a, SLNextHop& b) {
    a.Swap(&b);
  }
  inline void Swap(SLNextHop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLNextHop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLNextHop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLNextHop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLNextHop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLNextHop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLNextHop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLNextHop";
  }
  protected:
  explicit SLNextHop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 8,
    kSrcProtoFieldNumber = 4,
    kSrcProtoTagFieldNumber = 5,
    kNextHopKeyFieldNumber = 1,
    kResolvingRouteFieldNumber = 2,
    kResolvingRouteLenFieldNumber = 3,
    kAdminDistanceFieldNumber = 6,
    kMetricFieldNumber = 7,
  };
  // repeated .service_layer.SLRoutePath Paths = 8;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::service_layer::SLRoutePath* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
      mutable_paths();
  private:
  const ::service_layer::SLRoutePath& _internal_paths(int index) const;
  ::service_layer::SLRoutePath* _internal_add_paths();
  public:
  const ::service_layer::SLRoutePath& paths(int index) const;
  ::service_layer::SLRoutePath* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
      paths() const;

  // string SrcProto = 4;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 5;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // .service_layer.SLAFNextHopRegKey NextHopKey = 1;
  bool has_nexthopkey() const;
  private:
  bool _internal_has_nexthopkey() const;
  public:
  void clear_nexthopkey();
  const ::service_layer::SLAFNextHopRegKey& nexthopkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey* release_nexthopkey();
  ::service_layer::SLAFNextHopRegKey* mutable_nexthopkey();
  void set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey);
  private:
  const ::service_layer::SLAFNextHopRegKey& _internal_nexthopkey() const;
  ::service_layer::SLAFNextHopRegKey* _internal_mutable_nexthopkey();
  public:
  void unsafe_arena_set_allocated_nexthopkey(
      ::service_layer::SLAFNextHopRegKey* nexthopkey);
  ::service_layer::SLAFNextHopRegKey* unsafe_arena_release_nexthopkey();

  // .service_layer.SLIpAddress ResolvingRoute = 2;
  bool has_resolvingroute() const;
  private:
  bool _internal_has_resolvingroute() const;
  public:
  void clear_resolvingroute();
  const ::service_layer::SLIpAddress& resolvingroute() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_resolvingroute();
  ::service_layer::SLIpAddress* mutable_resolvingroute();
  void set_allocated_resolvingroute(::service_layer::SLIpAddress* resolvingroute);
  private:
  const ::service_layer::SLIpAddress& _internal_resolvingroute() const;
  ::service_layer::SLIpAddress* _internal_mutable_resolvingroute();
  public:
  void unsafe_arena_set_allocated_resolvingroute(
      ::service_layer::SLIpAddress* resolvingroute);
  ::service_layer::SLIpAddress* unsafe_arena_release_resolvingroute();

  // uint32 ResolvingRouteLen = 3;
  void clear_resolvingroutelen();
  uint32_t resolvingroutelen() const;
  void set_resolvingroutelen(uint32_t value);
  private:
  uint32_t _internal_resolvingroutelen() const;
  void _internal_set_resolvingroutelen(uint32_t value);
  public:

  // uint32 AdminDistance = 6;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 Metric = 7;
  void clear_metric();
  uint32_t metric() const;
  void set_metric(uint32_t value);
  private:
  uint32_t _internal_metric() const;
  void _internal_set_metric(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLNextHop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath > paths_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  ::service_layer::SLAFNextHopRegKey* nexthopkey_;
  ::service_layer::SLIpAddress* resolvingroute_;
  uint32_t resolvingroutelen_;
  uint32_t admindistance_;
  uint32_t metric_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotif) */ {
 public:
  inline SLAFNotif() : SLAFNotif(nullptr) {}
  ~SLAFNotif() override;
  explicit constexpr SLAFNotif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotif(const SLAFNotif& from);
  SLAFNotif(SLAFNotif&& from) noexcept
    : SLAFNotif() {
    *this = ::std::move(from);
  }

  inline SLAFNotif& operator=(const SLAFNotif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotif& operator=(SLAFNotif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotif& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kNotifStatus = 1,
    kRedistObject = 4,
    kNextHop = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const SLAFNotif* internal_default_instance() {
    return reinterpret_cast<const SLAFNotif*>(
               &_SLAFNotif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SLAFNotif& a, SLAFNotif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotif";
  }
  protected:
  explicit SLAFNotif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifStatusFieldNumber = 1,
    kRedistObjectFieldNumber = 4,
    kNextHopFieldNumber = 5,
  };
  // .service_layer.SLAFNotifRsp NotifStatus = 1;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLAFNotifRsp& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotifRsp* release_notifstatus();
  ::service_layer::SLAFNotifRsp* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLAFNotifRsp* notifstatus);
  private:
  const ::service_layer::SLAFNotifRsp& _internal_notifstatus() const;
  ::service_layer::SLAFNotifRsp* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLAFNotifRsp* notifstatus);
  ::service_layer::SLAFNotifRsp* unsafe_arena_release_notifstatus();

  // .service_layer.SLAFObject RedistObject = 4;
  bool has_redistobject() const;
  private:
  bool _internal_has_redistobject() const;
  public:
  void clear_redistobject();
  const ::service_layer::SLAFObject& redistobject() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObject* release_redistobject();
  ::service_layer::SLAFObject* mutable_redistobject();
  void set_allocated_redistobject(::service_layer::SLAFObject* redistobject);
  private:
  const ::service_layer::SLAFObject& _internal_redistobject() const;
  ::service_layer::SLAFObject* _internal_mutable_redistobject();
  public:
  void unsafe_arena_set_allocated_redistobject(
      ::service_layer::SLAFObject* redistobject);
  ::service_layer::SLAFObject* unsafe_arena_release_redistobject();

  // .service_layer.SLNextHop NextHop = 5;
  bool has_nexthop() const;
  private:
  bool _internal_has_nexthop() const;
  public:
  void clear_nexthop();
  const ::service_layer::SLNextHop& nexthop() const;
  PROTOBUF_NODISCARD ::service_layer::SLNextHop* release_nexthop();
  ::service_layer::SLNextHop* mutable_nexthop();
  void set_allocated_nexthop(::service_layer::SLNextHop* nexthop);
  private:
  const ::service_layer::SLNextHop& _internal_nexthop() const;
  ::service_layer::SLNextHop* _internal_mutable_nexthop();
  public:
  void unsafe_arena_set_allocated_nexthop(
      ::service_layer::SLNextHop* nexthop);
  ::service_layer::SLNextHop* unsafe_arena_release_nexthop();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotif)
 private:
  class _Internal;
  void set_has_notifstatus();
  void set_has_redistobject();
  void set_has_nexthop();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFNotifRsp* notifstatus_;
    ::service_layer::SLAFObject* redistobject_;
    ::service_layer::SLNextHop* nexthop_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifMsg) */ {
 public:
  inline SLAFNotifMsg() : SLAFNotifMsg(nullptr) {}
  ~SLAFNotifMsg() override;
  explicit constexpr SLAFNotifMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifMsg(const SLAFNotifMsg& from);
  SLAFNotifMsg(SLAFNotifMsg&& from) noexcept
    : SLAFNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLAFNotifMsg& operator=(const SLAFNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifMsg& operator=(SLAFNotifMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifMsg*>(
               &_SLAFNotifMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SLAFNotifMsg& a, SLAFNotifMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifMsg";
  }
  protected:
  explicit SLAFNotifMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFNotifsFieldNumber = 3,
    kVrfNameFieldNumber = 1,
  };
  // repeated .service_layer.SLAFNotif AFNotifs = 3;
  int afnotifs_size() const;
  private:
  int _internal_afnotifs_size() const;
  public:
  void clear_afnotifs();
  ::service_layer::SLAFNotif* mutable_afnotifs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >*
      mutable_afnotifs();
  private:
  const ::service_layer::SLAFNotif& _internal_afnotifs(int index) const;
  ::service_layer::SLAFNotif* _internal_add_afnotifs();
  public:
  const ::service_layer::SLAFNotif& afnotifs(int index) const;
  ::service_layer::SLAFNotif* add_afnotifs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >&
      afnotifs() const;

  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif > afnotifs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLAFVrfReg

// .service_layer.SLTableType Table = 1;
inline void SLAFVrfReg::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfReg::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfReg::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfReg.Table)
  return _internal_table();
}
inline void SLAFVrfReg::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfReg::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfReg.Table)
}

// .service_layer.SLVrfReg VrfReg = 2;
inline bool SLAFVrfReg::_internal_has_vrfreg() const {
  return this != internal_default_instance() && vrfreg_ != nullptr;
}
inline bool SLAFVrfReg::has_vrfreg() const {
  return _internal_has_vrfreg();
}
inline const ::service_layer::SLVrfReg& SLAFVrfReg::_internal_vrfreg() const {
  const ::service_layer::SLVrfReg* p = vrfreg_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLVrfReg&>(
      ::service_layer::_SLVrfReg_default_instance_);
}
inline const ::service_layer::SLVrfReg& SLAFVrfReg::vrfreg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfReg.VrfReg)
  return _internal_vrfreg();
}
inline void SLAFVrfReg::unsafe_arena_set_allocated_vrfreg(
    ::service_layer::SLVrfReg* vrfreg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg_);
  }
  vrfreg_ = vrfreg;
  if (vrfreg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfReg.VrfReg)
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::release_vrfreg() {
  
  ::service_layer::SLVrfReg* temp = vrfreg_;
  vrfreg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::unsafe_arena_release_vrfreg() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfReg.VrfReg)
  
  ::service_layer::SLVrfReg* temp = vrfreg_;
  vrfreg_ = nullptr;
  return temp;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::_internal_mutable_vrfreg() {
  
  if (vrfreg_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLVrfReg>(GetArenaForAllocation());
    vrfreg_ = p;
  }
  return vrfreg_;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::mutable_vrfreg() {
  ::service_layer::SLVrfReg* _msg = _internal_mutable_vrfreg();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfReg.VrfReg)
  return _msg;
}
inline void SLAFVrfReg::set_allocated_vrfreg(::service_layer::SLVrfReg* vrfreg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg_);
  }
  if (vrfreg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg));
    if (message_arena != submessage_arena) {
      vrfreg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrfreg, submessage_arena);
    }
    
  } else {
    
  }
  vrfreg_ = vrfreg;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfReg.VrfReg)
}

// -------------------------------------------------------------------

// SLAFVrfRegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLAFVrfRegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLAFVrfRegMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline ::service_layer::SLRegOp SLAFVrfRegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsg.Oper)
  return _internal_oper();
}
inline void SLAFVrfRegMsg::_internal_set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
}
inline void SLAFVrfRegMsg::set_oper(::service_layer::SLRegOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsg.Oper)
}

// repeated .service_layer.SLAFVrfReg VrfRegMsgs = 2;
inline int SLAFVrfRegMsg::_internal_vrfregmsgs_size() const {
  return vrfregmsgs_.size();
}
inline int SLAFVrfRegMsg::vrfregmsgs_size() const {
  return _internal_vrfregmsgs_size();
}
inline void SLAFVrfRegMsg::clear_vrfregmsgs() {
  vrfregmsgs_.Clear();
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::mutable_vrfregmsgs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >*
SLAFVrfRegMsg::mutable_vrfregmsgs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return &vrfregmsgs_;
}
inline const ::service_layer::SLAFVrfReg& SLAFVrfRegMsg::_internal_vrfregmsgs(int index) const {
  return vrfregmsgs_.Get(index);
}
inline const ::service_layer::SLAFVrfReg& SLAFVrfRegMsg::vrfregmsgs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return _internal_vrfregmsgs(index);
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::_internal_add_vrfregmsgs() {
  return vrfregmsgs_.Add();
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::add_vrfregmsgs() {
  ::service_layer::SLAFVrfReg* _add = _internal_add_vrfregmsgs();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >&
SLAFVrfRegMsg::vrfregmsgs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_;
}

// -------------------------------------------------------------------

// SLAFVrfRegMsgRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFVrfRegMsgRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFVrfRegMsgRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFVrfRegMsgRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegMsgRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  return _msg;
}
inline void SLAFVrfRegMsgRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRes.ErrStatus)
}

// string VrfName = 2;
inline void SLAFVrfRegMsgRes::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFVrfRegMsgRes::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFVrfRegMsgRes::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsgRes.VrfName)
}
inline std::string* SLAFVrfRegMsgRes::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRes.VrfName)
  return _s;
}
inline const std::string& SLAFVrfRegMsgRes::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFVrfRegMsgRes::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFVrfRegMsgRes::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFVrfRegMsgRes::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRes.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFVrfRegMsgRes::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRes.VrfName)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFVrfRegMsgRes::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfRegMsgRes::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfRegMsgRes::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.Table)
  return _internal_table();
}
inline void SLAFVrfRegMsgRes::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfRegMsgRes::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsgRes.Table)
}

// -------------------------------------------------------------------

// SLAFVrfRegMsgRsp

// .service_layer.SLErrorStatus StatusSummary = 1;
inline bool SLAFVrfRegMsgRsp::_internal_has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != nullptr;
}
inline bool SLAFVrfRegMsgRsp::has_statussummary() const {
  return _internal_has_statussummary();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRsp::_internal_statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRsp::statussummary() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  return _internal_statussummary();
}
inline void SLAFVrfRegMsgRsp::unsafe_arena_set_allocated_statussummary(
    ::service_layer::SLErrorStatus* statussummary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  statussummary_ = statussummary;
  if (statussummary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::release_statussummary() {
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::unsafe_arena_release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::_internal_mutable_statussummary() {
  
  if (statussummary_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    statussummary_ = p;
  }
  return statussummary_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::mutable_statussummary() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_statussummary();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  return _msg;
}
inline void SLAFVrfRegMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary));
    if (message_arena != submessage_arena) {
      statussummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
}

// repeated .service_layer.SLAFVrfRegMsgRes Results = 2;
inline int SLAFVrfRegMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLAFVrfRegMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLAFVrfRegMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >*
SLAFVrfRegMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLAFVrfRegMsgRes& SLAFVrfRegMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLAFVrfRegMsgRes& SLAFVrfRegMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::add_results() {
  ::service_layer::SLAFVrfRegMsgRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >&
SLAFVrfRegMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLAFVrfRegGetMsg

// bool GetAll = 1;
inline void SLAFVrfRegGetMsg::clear_getall() {
  getall_ = false;
}
inline bool SLAFVrfRegGetMsg::_internal_getall() const {
  return getall_;
}
inline bool SLAFVrfRegGetMsg::getall() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsg.GetAll)
  return _internal_getall();
}
inline void SLAFVrfRegGetMsg::_internal_set_getall(bool value) {
  
  getall_ = value;
}
inline void SLAFVrfRegGetMsg::set_getall(bool value) {
  _internal_set_getall(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsg.GetAll)
}

// -------------------------------------------------------------------

// SLAFVrfRegGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFVrfRegGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFVrfRegGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFVrfRegGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLAFVrfRegGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
}

// uint64 ClientID = 2;
inline void SLAFVrfRegGetMsgRsp::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t SLAFVrfRegGetMsgRsp::_internal_clientid() const {
  return clientid_;
}
inline uint64_t SLAFVrfRegGetMsgRsp::clientid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.ClientID)
  return _internal_clientid();
}
inline void SLAFVrfRegGetMsgRsp::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void SLAFVrfRegGetMsgRsp::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsgRsp.ClientID)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFVrfRegGetMsgRsp::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfRegGetMsgRsp::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfRegGetMsgRsp::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.Table)
  return _internal_table();
}
inline void SLAFVrfRegGetMsgRsp::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfRegGetMsgRsp::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsgRsp.Table)
}

// repeated .service_layer.SLVrfReg Entries = 4;
inline int SLAFVrfRegGetMsgRsp::_internal_entries_size() const {
  return entries_.size();
}
inline int SLAFVrfRegGetMsgRsp::entries_size() const {
  return _internal_entries_size();
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
SLAFVrfRegGetMsgRsp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return &entries_;
}
inline const ::service_layer::SLVrfReg& SLAFVrfRegGetMsgRsp::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::service_layer::SLVrfReg& SLAFVrfRegGetMsgRsp::entries(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return _internal_entries(index);
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::_internal_add_entries() {
  return entries_.Add();
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::add_entries() {
  ::service_layer::SLVrfReg* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
SLAFVrfRegGetMsgRsp::entries() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SLPathGroup_SLPath

// .service_layer.SLRoutePath Path = 1;
inline bool SLPathGroup_SLPath::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool SLPathGroup_SLPath::has_path() const {
  return _internal_has_path();
}
inline const ::service_layer::SLRoutePath& SLPathGroup_SLPath::_internal_path() const {
  const ::service_layer::SLRoutePath* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRoutePath&>(
      ::service_layer::_SLRoutePath_default_instance_);
}
inline const ::service_layer::SLRoutePath& SLPathGroup_SLPath::path() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.SLPath.Path)
  return _internal_path();
}
inline void SLPathGroup_SLPath::unsafe_arena_set_allocated_path(
    ::service_layer::SLRoutePath* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.SLPath.Path)
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::release_path() {
  
  ::service_layer::SLRoutePath* temp = path_;
  path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.SLPath.Path)
  
  ::service_layer::SLRoutePath* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRoutePath>(GetArenaForAllocation());
    path_ = p;
  }
  return path_;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::mutable_path() {
  ::service_layer::SLRoutePath* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.SLPath.Path)
  return _msg;
}
inline void SLPathGroup_SLPath::set_allocated_path(::service_layer::SLRoutePath* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path));
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroup.SLPath.Path)
}

// -------------------------------------------------------------------

// SLPathGroup_SLPathList

// repeated .service_layer.SLPathGroup.SLPath Paths = 1;
inline int SLPathGroup_SLPathList::_internal_paths_size() const {
  return paths_.size();
}
inline int SLPathGroup_SLPathList::paths_size() const {
  return _internal_paths_size();
}
inline void SLPathGroup_SLPathList::clear_paths() {
  paths_.Clear();
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.SLPathList.Paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >*
SLPathGroup_SLPathList::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPathGroup.SLPathList.Paths)
  return &paths_;
}
inline const ::service_layer::SLPathGroup_SLPath& SLPathGroup_SLPathList::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::service_layer::SLPathGroup_SLPath& SLPathGroup_SLPathList::paths(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.SLPathList.Paths)
  return _internal_paths(index);
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::_internal_add_paths() {
  return paths_.Add();
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::add_paths() {
  ::service_layer::SLPathGroup_SLPath* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:service_layer.SLPathGroup.SLPathList.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >&
SLPathGroup_SLPathList::paths() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPathGroup.SLPathList.Paths)
  return paths_;
}

// -------------------------------------------------------------------

// SLPathGroup

// .service_layer.SLObjectId PathGroupId = 1;
inline bool SLPathGroup::_internal_has_pathgroupid() const {
  return this != internal_default_instance() && pathgroupid_ != nullptr;
}
inline bool SLPathGroup::has_pathgroupid() const {
  return _internal_has_pathgroupid();
}
inline const ::service_layer::SLObjectId& SLPathGroup::_internal_pathgroupid() const {
  const ::service_layer::SLObjectId* p = pathgroupid_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLObjectId&>(
      ::service_layer::_SLObjectId_default_instance_);
}
inline const ::service_layer::SLObjectId& SLPathGroup::pathgroupid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.PathGroupId)
  return _internal_pathgroupid();
}
inline void SLPathGroup::unsafe_arena_set_allocated_pathgroupid(
    ::service_layer::SLObjectId* pathgroupid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid_);
  }
  pathgroupid_ = pathgroupid;
  if (pathgroupid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.PathGroupId)
}
inline ::service_layer::SLObjectId* SLPathGroup::release_pathgroupid() {
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroup::unsafe_arena_release_pathgroupid() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.PathGroupId)
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroup::_internal_mutable_pathgroupid() {
  
  if (pathgroupid_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLObjectId>(GetArenaForAllocation());
    pathgroupid_ = p;
  }
  return pathgroupid_;
}
inline ::service_layer::SLObjectId* SLPathGroup::mutable_pathgroupid() {
  ::service_layer::SLObjectId* _msg = _internal_mutable_pathgroupid();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.PathGroupId)
  return _msg;
}
inline void SLPathGroup::set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid_);
  }
  if (pathgroupid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid));
    if (message_arena != submessage_arena) {
      pathgroupid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathgroupid, submessage_arena);
    }
    
  } else {
    
  }
  pathgroupid_ = pathgroupid;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroup.PathGroupId)
}

// uint32 AdminDistance = 2;
inline void SLPathGroup::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLPathGroup::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLPathGroup::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.AdminDistance)
  return _internal_admindistance();
}
inline void SLPathGroup::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLPathGroup::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPathGroup.AdminDistance)
}

// .service_layer.SLPathGroup.SLPathList PathList = 3;
inline bool SLPathGroup::_internal_has_pathlist() const {
  return entry_case() == kPathList;
}
inline bool SLPathGroup::has_pathlist() const {
  return _internal_has_pathlist();
}
inline void SLPathGroup::set_has_pathlist() {
  _oneof_case_[0] = kPathList;
}
inline void SLPathGroup::clear_pathlist() {
  if (_internal_has_pathlist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.pathlist_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::release_pathlist() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.PathList)
  if (_internal_has_pathlist()) {
    clear_has_entry();
      ::service_layer::SLPathGroup_SLPathList* temp = entry_.pathlist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroup_SLPathList& SLPathGroup::_internal_pathlist() const {
  return _internal_has_pathlist()
      ? *entry_.pathlist_
      : reinterpret_cast< ::service_layer::SLPathGroup_SLPathList&>(::service_layer::_SLPathGroup_SLPathList_default_instance_);
}
inline const ::service_layer::SLPathGroup_SLPathList& SLPathGroup::pathlist() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.PathList)
  return _internal_pathlist();
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::unsafe_arena_release_pathlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPathGroup.PathList)
  if (_internal_has_pathlist()) {
    clear_has_entry();
    ::service_layer::SLPathGroup_SLPathList* temp = entry_.pathlist_;
    entry_.pathlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPathGroup::unsafe_arena_set_allocated_pathlist(::service_layer::SLPathGroup_SLPathList* pathlist) {
  clear_entry();
  if (pathlist) {
    set_has_pathlist();
    entry_.pathlist_ = pathlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.PathList)
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::_internal_mutable_pathlist() {
  if (!_internal_has_pathlist()) {
    clear_entry();
    set_has_pathlist();
    entry_.pathlist_ = CreateMaybeMessage< ::service_layer::SLPathGroup_SLPathList >(GetArenaForAllocation());
  }
  return entry_.pathlist_;
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::mutable_pathlist() {
  ::service_layer::SLPathGroup_SLPathList* _msg = _internal_mutable_pathlist();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.PathList)
  return _msg;
}

// uint32 Flags = 4;
inline void SLPathGroup::clear_flags() {
  flags_ = 0u;
}
inline uint32_t SLPathGroup::_internal_flags() const {
  return flags_;
}
inline uint32_t SLPathGroup::flags() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.Flags)
  return _internal_flags();
}
inline void SLPathGroup::_internal_set_flags(uint32_t value) {
  
  flags_ = value;
}
inline void SLPathGroup::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPathGroup.Flags)
}

inline bool SLPathGroup::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLPathGroup::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLPathGroup::EntryCase SLPathGroup::entry_case() const {
  return SLPathGroup::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLMplsEntry

// uint32 LocalLabel = 1;
inline void SLMplsEntry::clear_locallabel() {
  locallabel_ = 0u;
}
inline uint32_t SLMplsEntry::_internal_locallabel() const {
  return locallabel_;
}
inline uint32_t SLMplsEntry::locallabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.LocalLabel)
  return _internal_locallabel();
}
inline void SLMplsEntry::_internal_set_locallabel(uint32_t value) {
  
  locallabel_ = value;
}
inline void SLMplsEntry::set_locallabel(uint32_t value) {
  _internal_set_locallabel(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.LocalLabel)
}

// uint32 AdminDistance = 2;
inline void SLMplsEntry::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLMplsEntry::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLMplsEntry::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.AdminDistance)
  return _internal_admindistance();
}
inline void SLMplsEntry::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLMplsEntry::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.AdminDistance)
}

// repeated .service_layer.SLRoutePath PathList = 3;
inline int SLMplsEntry::_internal_pathlist_size() const {
  return pathlist_.size();
}
inline int SLMplsEntry::pathlist_size() const {
  return _internal_pathlist_size();
}
inline ::service_layer::SLRoutePath* SLMplsEntry::mutable_pathlist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLMplsEntry.PathList)
  return pathlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
SLMplsEntry::mutable_pathlist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLMplsEntry.PathList)
  return &pathlist_;
}
inline const ::service_layer::SLRoutePath& SLMplsEntry::_internal_pathlist(int index) const {
  return pathlist_.Get(index);
}
inline const ::service_layer::SLRoutePath& SLMplsEntry::pathlist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.PathList)
  return _internal_pathlist(index);
}
inline ::service_layer::SLRoutePath* SLMplsEntry::_internal_add_pathlist() {
  return pathlist_.Add();
}
inline ::service_layer::SLRoutePath* SLMplsEntry::add_pathlist() {
  ::service_layer::SLRoutePath* _add = _internal_add_pathlist();
  // @@protoc_insertion_point(field_add:service_layer.SLMplsEntry.PathList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
SLMplsEntry::pathlist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLMplsEntry.PathList)
  return pathlist_;
}

// .service_layer.SLPathGroupRefKey PathGroupKey = 4;
inline bool SLMplsEntry::_internal_has_pathgroupkey() const {
  return entry_case() == kPathGroupKey;
}
inline bool SLMplsEntry::has_pathgroupkey() const {
  return _internal_has_pathgroupkey();
}
inline void SLMplsEntry::set_has_pathgroupkey() {
  _oneof_case_[0] = kPathGroupKey;
}
inline ::service_layer::SLPathGroupRefKey* SLMplsEntry::release_pathgroupkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLMplsEntry.PathGroupKey)
  if (_internal_has_pathgroupkey()) {
    clear_has_entry();
      ::service_layer::SLPathGroupRefKey* temp = entry_.pathgroupkey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathgroupkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroupRefKey& SLMplsEntry::_internal_pathgroupkey() const {
  return _internal_has_pathgroupkey()
      ? *entry_.pathgroupkey_
      : reinterpret_cast< ::service_layer::SLPathGroupRefKey&>(::service_layer::_SLPathGroupRefKey_default_instance_);
}
inline const ::service_layer::SLPathGroupRefKey& SLMplsEntry::pathgroupkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.PathGroupKey)
  return _internal_pathgroupkey();
}
inline ::service_layer::SLPathGroupRefKey* SLMplsEntry::unsafe_arena_release_pathgroupkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLMplsEntry.PathGroupKey)
  if (_internal_has_pathgroupkey()) {
    clear_has_entry();
    ::service_layer::SLPathGroupRefKey* temp = entry_.pathgroupkey_;
    entry_.pathgroupkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLMplsEntry::unsafe_arena_set_allocated_pathgroupkey(::service_layer::SLPathGroupRefKey* pathgroupkey) {
  clear_entry();
  if (pathgroupkey) {
    set_has_pathgroupkey();
    entry_.pathgroupkey_ = pathgroupkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLMplsEntry.PathGroupKey)
}
inline ::service_layer::SLPathGroupRefKey* SLMplsEntry::_internal_mutable_pathgroupkey() {
  if (!_internal_has_pathgroupkey()) {
    clear_entry();
    set_has_pathgroupkey();
    entry_.pathgroupkey_ = CreateMaybeMessage< ::service_layer::SLPathGroupRefKey >(GetArenaForAllocation());
  }
  return entry_.pathgroupkey_;
}
inline ::service_layer::SLPathGroupRefKey* SLMplsEntry::mutable_pathgroupkey() {
  ::service_layer::SLPathGroupRefKey* _msg = _internal_mutable_pathgroupkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLMplsEntry.PathGroupKey)
  return _msg;
}

// uint32 Flags = 5;
inline void SLMplsEntry::clear_flags() {
  flags_ = 0u;
}
inline uint32_t SLMplsEntry::_internal_flags() const {
  return flags_;
}
inline uint32_t SLMplsEntry::flags() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.Flags)
  return _internal_flags();
}
inline void SLMplsEntry::_internal_set_flags(uint32_t value) {
  
  flags_ = value;
}
inline void SLMplsEntry::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.Flags)
}

inline bool SLMplsEntry::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLMplsEntry::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLMplsEntry::EntryCase SLMplsEntry::entry_case() const {
  return SLMplsEntry::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFObject

// .service_layer.SLRoutev4 IPv4Route = 1;
inline bool SLAFObject::_internal_has_ipv4route() const {
  return entry_case() == kIPv4Route;
}
inline bool SLAFObject::has_ipv4route() const {
  return _internal_has_ipv4route();
}
inline void SLAFObject::set_has_ipv4route() {
  _oneof_case_[0] = kIPv4Route;
}
inline ::service_layer::SLRoutev4* SLAFObject::release_ipv4route() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.IPv4Route)
  if (_internal_has_ipv4route()) {
    clear_has_entry();
      ::service_layer::SLRoutev4* temp = entry_.ipv4route_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.ipv4route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLRoutev4& SLAFObject::_internal_ipv4route() const {
  return _internal_has_ipv4route()
      ? *entry_.ipv4route_
      : reinterpret_cast< ::service_layer::SLRoutev4&>(::service_layer::_SLRoutev4_default_instance_);
}
inline const ::service_layer::SLRoutev4& SLAFObject::ipv4route() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.IPv4Route)
  return _internal_ipv4route();
}
inline ::service_layer::SLRoutev4* SLAFObject::unsafe_arena_release_ipv4route() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.IPv4Route)
  if (_internal_has_ipv4route()) {
    clear_has_entry();
    ::service_layer::SLRoutev4* temp = entry_.ipv4route_;
    entry_.ipv4route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_ipv4route(::service_layer::SLRoutev4* ipv4route) {
  clear_entry();
  if (ipv4route) {
    set_has_ipv4route();
    entry_.ipv4route_ = ipv4route;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.IPv4Route)
}
inline ::service_layer::SLRoutev4* SLAFObject::_internal_mutable_ipv4route() {
  if (!_internal_has_ipv4route()) {
    clear_entry();
    set_has_ipv4route();
    entry_.ipv4route_ = CreateMaybeMessage< ::service_layer::SLRoutev4 >(GetArenaForAllocation());
  }
  return entry_.ipv4route_;
}
inline ::service_layer::SLRoutev4* SLAFObject::mutable_ipv4route() {
  ::service_layer::SLRoutev4* _msg = _internal_mutable_ipv4route();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.IPv4Route)
  return _msg;
}

// .service_layer.SLRoutev6 IPv6Route = 2;
inline bool SLAFObject::_internal_has_ipv6route() const {
  return entry_case() == kIPv6Route;
}
inline bool SLAFObject::has_ipv6route() const {
  return _internal_has_ipv6route();
}
inline void SLAFObject::set_has_ipv6route() {
  _oneof_case_[0] = kIPv6Route;
}
inline ::service_layer::SLRoutev6* SLAFObject::release_ipv6route() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.IPv6Route)
  if (_internal_has_ipv6route()) {
    clear_has_entry();
      ::service_layer::SLRoutev6* temp = entry_.ipv6route_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.ipv6route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLRoutev6& SLAFObject::_internal_ipv6route() const {
  return _internal_has_ipv6route()
      ? *entry_.ipv6route_
      : reinterpret_cast< ::service_layer::SLRoutev6&>(::service_layer::_SLRoutev6_default_instance_);
}
inline const ::service_layer::SLRoutev6& SLAFObject::ipv6route() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.IPv6Route)
  return _internal_ipv6route();
}
inline ::service_layer::SLRoutev6* SLAFObject::unsafe_arena_release_ipv6route() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.IPv6Route)
  if (_internal_has_ipv6route()) {
    clear_has_entry();
    ::service_layer::SLRoutev6* temp = entry_.ipv6route_;
    entry_.ipv6route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_ipv6route(::service_layer::SLRoutev6* ipv6route) {
  clear_entry();
  if (ipv6route) {
    set_has_ipv6route();
    entry_.ipv6route_ = ipv6route;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.IPv6Route)
}
inline ::service_layer::SLRoutev6* SLAFObject::_internal_mutable_ipv6route() {
  if (!_internal_has_ipv6route()) {
    clear_entry();
    set_has_ipv6route();
    entry_.ipv6route_ = CreateMaybeMessage< ::service_layer::SLRoutev6 >(GetArenaForAllocation());
  }
  return entry_.ipv6route_;
}
inline ::service_layer::SLRoutev6* SLAFObject::mutable_ipv6route() {
  ::service_layer::SLRoutev6* _msg = _internal_mutable_ipv6route();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.IPv6Route)
  return _msg;
}

// .service_layer.SLMplsEntry MplsLabel = 3;
inline bool SLAFObject::_internal_has_mplslabel() const {
  return entry_case() == kMplsLabel;
}
inline bool SLAFObject::has_mplslabel() const {
  return _internal_has_mplslabel();
}
inline void SLAFObject::set_has_mplslabel() {
  _oneof_case_[0] = kMplsLabel;
}
inline void SLAFObject::clear_mplslabel() {
  if (_internal_has_mplslabel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.mplslabel_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLMplsEntry* SLAFObject::release_mplslabel() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_entry();
      ::service_layer::SLMplsEntry* temp = entry_.mplslabel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLMplsEntry& SLAFObject::_internal_mplslabel() const {
  return _internal_has_mplslabel()
      ? *entry_.mplslabel_
      : reinterpret_cast< ::service_layer::SLMplsEntry&>(::service_layer::_SLMplsEntry_default_instance_);
}
inline const ::service_layer::SLMplsEntry& SLAFObject::mplslabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.MplsLabel)
  return _internal_mplslabel();
}
inline ::service_layer::SLMplsEntry* SLAFObject::unsafe_arena_release_mplslabel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_entry();
    ::service_layer::SLMplsEntry* temp = entry_.mplslabel_;
    entry_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_mplslabel(::service_layer::SLMplsEntry* mplslabel) {
  clear_entry();
  if (mplslabel) {
    set_has_mplslabel();
    entry_.mplslabel_ = mplslabel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.MplsLabel)
}
inline ::service_layer::SLMplsEntry* SLAFObject::_internal_mutable_mplslabel() {
  if (!_internal_has_mplslabel()) {
    clear_entry();
    set_has_mplslabel();
    entry_.mplslabel_ = CreateMaybeMessage< ::service_layer::SLMplsEntry >(GetArenaForAllocation());
  }
  return entry_.mplslabel_;
}
inline ::service_layer::SLMplsEntry* SLAFObject::mutable_mplslabel() {
  ::service_layer::SLMplsEntry* _msg = _internal_mutable_mplslabel();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.MplsLabel)
  return _msg;
}

// .service_layer.SLPathGroup PathGroup = 4;
inline bool SLAFObject::_internal_has_pathgroup() const {
  return entry_case() == kPathGroup;
}
inline bool SLAFObject::has_pathgroup() const {
  return _internal_has_pathgroup();
}
inline void SLAFObject::set_has_pathgroup() {
  _oneof_case_[0] = kPathGroup;
}
inline void SLAFObject::clear_pathgroup() {
  if (_internal_has_pathgroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.pathgroup_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLPathGroup* SLAFObject::release_pathgroup() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.PathGroup)
  if (_internal_has_pathgroup()) {
    clear_has_entry();
      ::service_layer::SLPathGroup* temp = entry_.pathgroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathgroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroup& SLAFObject::_internal_pathgroup() const {
  return _internal_has_pathgroup()
      ? *entry_.pathgroup_
      : reinterpret_cast< ::service_layer::SLPathGroup&>(::service_layer::_SLPathGroup_default_instance_);
}
inline const ::service_layer::SLPathGroup& SLAFObject::pathgroup() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.PathGroup)
  return _internal_pathgroup();
}
inline ::service_layer::SLPathGroup* SLAFObject::unsafe_arena_release_pathgroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.PathGroup)
  if (_internal_has_pathgroup()) {
    clear_has_entry();
    ::service_layer::SLPathGroup* temp = entry_.pathgroup_;
    entry_.pathgroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_pathgroup(::service_layer::SLPathGroup* pathgroup) {
  clear_entry();
  if (pathgroup) {
    set_has_pathgroup();
    entry_.pathgroup_ = pathgroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.PathGroup)
}
inline ::service_layer::SLPathGroup* SLAFObject::_internal_mutable_pathgroup() {
  if (!_internal_has_pathgroup()) {
    clear_entry();
    set_has_pathgroup();
    entry_.pathgroup_ = CreateMaybeMessage< ::service_layer::SLPathGroup >(GetArenaForAllocation());
  }
  return entry_.pathgroup_;
}
inline ::service_layer::SLPathGroup* SLAFObject::mutable_pathgroup() {
  ::service_layer::SLPathGroup* _msg = _internal_mutable_pathgroup();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.PathGroup)
  return _msg;
}

inline bool SLAFObject::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLAFObject::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLAFObject::EntryCase SLAFObject::entry_case() const {
  return SLAFObject::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFOp

// .service_layer.SLAFObject AFObject = 1;
inline bool SLAFOp::_internal_has_afobject() const {
  return this != internal_default_instance() && afobject_ != nullptr;
}
inline bool SLAFOp::has_afobject() const {
  return _internal_has_afobject();
}
inline void SLAFOp::clear_afobject() {
  if (GetArenaForAllocation() == nullptr && afobject_ != nullptr) {
    delete afobject_;
  }
  afobject_ = nullptr;
}
inline const ::service_layer::SLAFObject& SLAFOp::_internal_afobject() const {
  const ::service_layer::SLAFObject* p = afobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFObject&>(
      ::service_layer::_SLAFObject_default_instance_);
}
inline const ::service_layer::SLAFObject& SLAFOp::afobject() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOp.AFObject)
  return _internal_afobject();
}
inline void SLAFOp::unsafe_arena_set_allocated_afobject(
    ::service_layer::SLAFObject* afobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(afobject_);
  }
  afobject_ = afobject;
  if (afobject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFOp.AFObject)
}
inline ::service_layer::SLAFObject* SLAFOp::release_afobject() {
  
  ::service_layer::SLAFObject* temp = afobject_;
  afobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFObject* SLAFOp::unsafe_arena_release_afobject() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFOp.AFObject)
  
  ::service_layer::SLAFObject* temp = afobject_;
  afobject_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFObject* SLAFOp::_internal_mutable_afobject() {
  
  if (afobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFObject>(GetArenaForAllocation());
    afobject_ = p;
  }
  return afobject_;
}
inline ::service_layer::SLAFObject* SLAFOp::mutable_afobject() {
  ::service_layer::SLAFObject* _msg = _internal_mutable_afobject();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFOp.AFObject)
  return _msg;
}
inline void SLAFOp::set_allocated_afobject(::service_layer::SLAFObject* afobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete afobject_;
  }
  if (afobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFObject>::GetOwningArena(afobject);
    if (message_arena != submessage_arena) {
      afobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, afobject, submessage_arena);
    }
    
  } else {
    
  }
  afobject_ = afobject;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFOp.AFObject)
}

// uint64 OperationID = 2;
inline void SLAFOp::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFOp::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFOp::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOp.OperationID)
  return _internal_operationid();
}
inline void SLAFOp::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFOp::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOp.OperationID)
}

// .service_layer.SLRspACKType AckType = 3;
inline void SLAFOp::clear_acktype() {
  acktype_ = 0;
}
inline ::service_layer::SLRspACKType SLAFOp::_internal_acktype() const {
  return static_cast< ::service_layer::SLRspACKType >(acktype_);
}
inline ::service_layer::SLRspACKType SLAFOp::acktype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOp.AckType)
  return _internal_acktype();
}
inline void SLAFOp::_internal_set_acktype(::service_layer::SLRspACKType value) {
  
  acktype_ = value;
}
inline void SLAFOp::set_acktype(::service_layer::SLRspACKType value) {
  _internal_set_acktype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOp.AckType)
}

// -------------------------------------------------------------------

// SLAFGetMsg

// string VrfName = 1;
inline void SLAFGetMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFGetMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFGetMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsg.VrfName)
}
inline std::string* SLAFGetMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.VrfName)
  return _s;
}
inline const std::string& SLAFGetMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFGetMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFGetMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFGetMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFGetMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsg.VrfName)
}

// .service_layer.SLTableType Table = 2;
inline void SLAFGetMsg::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFGetMsg::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFGetMsg::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.Table)
  return _internal_table();
}
inline void SLAFGetMsg::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFGetMsg::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsg.Table)
}

// bool GetAllClients = 3;
inline void SLAFGetMsg::clear_getallclients() {
  getallclients_ = false;
}
inline bool SLAFGetMsg::_internal_getallclients() const {
  return getallclients_;
}
inline bool SLAFGetMsg::getallclients() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.GetAllClients)
  return _internal_getallclients();
}
inline void SLAFGetMsg::_internal_set_getallclients(bool value) {
  
  getallclients_ = value;
}
inline void SLAFGetMsg::set_getallclients(bool value) {
  _internal_set_getallclients(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsg.GetAllClients)
}

// repeated .service_layer.SLRouteGetMatch RouteMatch = 4;
inline int SLAFGetMsg::_internal_routematch_size() const {
  return routematch_.size();
}
inline int SLAFGetMsg::routematch_size() const {
  return _internal_routematch_size();
}
inline ::service_layer::SLRouteGetMatch* SLAFGetMsg::mutable_routematch(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.RouteMatch)
  return routematch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRouteGetMatch >*
SLAFGetMsg::mutable_routematch() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFGetMsg.RouteMatch)
  return &routematch_;
}
inline const ::service_layer::SLRouteGetMatch& SLAFGetMsg::_internal_routematch(int index) const {
  return routematch_.Get(index);
}
inline const ::service_layer::SLRouteGetMatch& SLAFGetMsg::routematch(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.RouteMatch)
  return _internal_routematch(index);
}
inline ::service_layer::SLRouteGetMatch* SLAFGetMsg::_internal_add_routematch() {
  return routematch_.Add();
}
inline ::service_layer::SLRouteGetMatch* SLAFGetMsg::add_routematch() {
  ::service_layer::SLRouteGetMatch* _add = _internal_add_routematch();
  // @@protoc_insertion_point(field_add:service_layer.SLAFGetMsg.RouteMatch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRouteGetMatch >&
SLAFGetMsg::routematch() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFGetMsg.RouteMatch)
  return routematch_;
}

// -------------------------------------------------------------------

// SLAFFibStatus

// .service_layer.SLErrorStatus ErrorCode = 1;
inline bool SLAFFibStatus::_internal_has_errorcode() const {
  return this != internal_default_instance() && errorcode_ != nullptr;
}
inline bool SLAFFibStatus::has_errorcode() const {
  return _internal_has_errorcode();
}
inline const ::service_layer::SLErrorStatus& SLAFFibStatus::_internal_errorcode() const {
  const ::service_layer::SLErrorStatus* p = errorcode_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFFibStatus::errorcode() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFFibStatus.ErrorCode)
  return _internal_errorcode();
}
inline void SLAFFibStatus::unsafe_arena_set_allocated_errorcode(
    ::service_layer::SLErrorStatus* errorcode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errorcode_);
  }
  errorcode_ = errorcode;
  if (errorcode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFFibStatus.ErrorCode)
}
inline ::service_layer::SLErrorStatus* SLAFFibStatus::release_errorcode() {
  
  ::service_layer::SLErrorStatus* temp = errorcode_;
  errorcode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFFibStatus::unsafe_arena_release_errorcode() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFFibStatus.ErrorCode)
  
  ::service_layer::SLErrorStatus* temp = errorcode_;
  errorcode_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFFibStatus::_internal_mutable_errorcode() {
  
  if (errorcode_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errorcode_ = p;
  }
  return errorcode_;
}
inline ::service_layer::SLErrorStatus* SLAFFibStatus::mutable_errorcode() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errorcode();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFFibStatus.ErrorCode)
  return _msg;
}
inline void SLAFFibStatus::set_allocated_errorcode(::service_layer::SLErrorStatus* errorcode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errorcode_);
  }
  if (errorcode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errorcode));
    if (message_arena != submessage_arena) {
      errorcode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errorcode, submessage_arena);
    }
    
  } else {
    
  }
  errorcode_ = errorcode;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFFibStatus.ErrorCode)
}

// uint64 OperationID = 2;
inline void SLAFFibStatus::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFFibStatus::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFFibStatus::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFFibStatus.OperationID)
  return _internal_operationid();
}
inline void SLAFFibStatus::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFFibStatus::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFFibStatus.OperationID)
}

// uint64 Version = 3;
inline void SLAFFibStatus::clear_version() {
  version_ = uint64_t{0u};
}
inline uint64_t SLAFFibStatus::_internal_version() const {
  return version_;
}
inline uint64_t SLAFFibStatus::version() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFFibStatus.Version)
  return _internal_version();
}
inline void SLAFFibStatus::_internal_set_version(uint64_t value) {
  
  version_ = value;
}
inline void SLAFFibStatus::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFFibStatus.Version)
}

// string ErrorString = 4;
inline void SLAFFibStatus::clear_errorstring() {
  errorstring_.ClearToEmpty();
}
inline const std::string& SLAFFibStatus::errorstring() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFFibStatus.ErrorString)
  return _internal_errorstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFFibStatus::set_errorstring(ArgT0&& arg0, ArgT... args) {
 
 errorstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFFibStatus.ErrorString)
}
inline std::string* SLAFFibStatus::mutable_errorstring() {
  std::string* _s = _internal_mutable_errorstring();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFFibStatus.ErrorString)
  return _s;
}
inline const std::string& SLAFFibStatus::_internal_errorstring() const {
  return errorstring_.Get();
}
inline void SLAFFibStatus::_internal_set_errorstring(const std::string& value) {
  
  errorstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFFibStatus::_internal_mutable_errorstring() {
  
  return errorstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFFibStatus::release_errorstring() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFFibStatus.ErrorString)
  return errorstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFFibStatus::set_allocated_errorstring(std::string* errorstring) {
  if (errorstring != nullptr) {
    
  } else {
    
  }
  errorstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errorstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errorstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errorstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFFibStatus.ErrorString)
}

// repeated .service_layer.SLAFFibStatus DepResult = 5;
inline int SLAFFibStatus::_internal_depresult_size() const {
  return depresult_.size();
}
inline int SLAFFibStatus::depresult_size() const {
  return _internal_depresult_size();
}
inline void SLAFFibStatus::clear_depresult() {
  depresult_.Clear();
}
inline ::service_layer::SLAFFibStatus* SLAFFibStatus::mutable_depresult(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFFibStatus.DepResult)
  return depresult_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFFibStatus >*
SLAFFibStatus::mutable_depresult() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFFibStatus.DepResult)
  return &depresult_;
}
inline const ::service_layer::SLAFFibStatus& SLAFFibStatus::_internal_depresult(int index) const {
  return depresult_.Get(index);
}
inline const ::service_layer::SLAFFibStatus& SLAFFibStatus::depresult(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFFibStatus.DepResult)
  return _internal_depresult(index);
}
inline ::service_layer::SLAFFibStatus* SLAFFibStatus::_internal_add_depresult() {
  return depresult_.Add();
}
inline ::service_layer::SLAFFibStatus* SLAFFibStatus::add_depresult() {
  ::service_layer::SLAFFibStatus* _add = _internal_add_depresult();
  // @@protoc_insertion_point(field_add:service_layer.SLAFFibStatus.DepResult)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFFibStatus >&
SLAFFibStatus::depresult() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFFibStatus.DepResult)
  return depresult_;
}

// -------------------------------------------------------------------

// SLAFGetMsgRspEntry

// .service_layer.SLAFOp AFOp = 1;
inline bool SLAFGetMsgRspEntry::_internal_has_afop() const {
  return this != internal_default_instance() && afop_ != nullptr;
}
inline bool SLAFGetMsgRspEntry::has_afop() const {
  return _internal_has_afop();
}
inline void SLAFGetMsgRspEntry::clear_afop() {
  if (GetArenaForAllocation() == nullptr && afop_ != nullptr) {
    delete afop_;
  }
  afop_ = nullptr;
}
inline const ::service_layer::SLAFOp& SLAFGetMsgRspEntry::_internal_afop() const {
  const ::service_layer::SLAFOp* p = afop_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFOp&>(
      ::service_layer::_SLAFOp_default_instance_);
}
inline const ::service_layer::SLAFOp& SLAFGetMsgRspEntry::afop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRspEntry.AFOp)
  return _internal_afop();
}
inline void SLAFGetMsgRspEntry::unsafe_arena_set_allocated_afop(
    ::service_layer::SLAFOp* afop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(afop_);
  }
  afop_ = afop;
  if (afop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsgRspEntry.AFOp)
}
inline ::service_layer::SLAFOp* SLAFGetMsgRspEntry::release_afop() {
  
  ::service_layer::SLAFOp* temp = afop_;
  afop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFOp* SLAFGetMsgRspEntry::unsafe_arena_release_afop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRspEntry.AFOp)
  
  ::service_layer::SLAFOp* temp = afop_;
  afop_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFOp* SLAFGetMsgRspEntry::_internal_mutable_afop() {
  
  if (afop_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFOp>(GetArenaForAllocation());
    afop_ = p;
  }
  return afop_;
}
inline ::service_layer::SLAFOp* SLAFGetMsgRspEntry::mutable_afop() {
  ::service_layer::SLAFOp* _msg = _internal_mutable_afop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRspEntry.AFOp)
  return _msg;
}
inline void SLAFGetMsgRspEntry::set_allocated_afop(::service_layer::SLAFOp* afop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete afop_;
  }
  if (afop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFOp>::GetOwningArena(afop);
    if (message_arena != submessage_arena) {
      afop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, afop, submessage_arena);
    }
    
  } else {
    
  }
  afop_ = afop;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRspEntry.AFOp)
}

// .service_layer.SLAFFibStatus FIBStatus = 2;
inline bool SLAFGetMsgRspEntry::_internal_has_fibstatus() const {
  return this != internal_default_instance() && fibstatus_ != nullptr;
}
inline bool SLAFGetMsgRspEntry::has_fibstatus() const {
  return _internal_has_fibstatus();
}
inline void SLAFGetMsgRspEntry::clear_fibstatus() {
  if (GetArenaForAllocation() == nullptr && fibstatus_ != nullptr) {
    delete fibstatus_;
  }
  fibstatus_ = nullptr;
}
inline const ::service_layer::SLAFFibStatus& SLAFGetMsgRspEntry::_internal_fibstatus() const {
  const ::service_layer::SLAFFibStatus* p = fibstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFFibStatus&>(
      ::service_layer::_SLAFFibStatus_default_instance_);
}
inline const ::service_layer::SLAFFibStatus& SLAFGetMsgRspEntry::fibstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRspEntry.FIBStatus)
  return _internal_fibstatus();
}
inline void SLAFGetMsgRspEntry::unsafe_arena_set_allocated_fibstatus(
    ::service_layer::SLAFFibStatus* fibstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fibstatus_);
  }
  fibstatus_ = fibstatus;
  if (fibstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsgRspEntry.FIBStatus)
}
inline ::service_layer::SLAFFibStatus* SLAFGetMsgRspEntry::release_fibstatus() {
  
  ::service_layer::SLAFFibStatus* temp = fibstatus_;
  fibstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFFibStatus* SLAFGetMsgRspEntry::unsafe_arena_release_fibstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRspEntry.FIBStatus)
  
  ::service_layer::SLAFFibStatus* temp = fibstatus_;
  fibstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFFibStatus* SLAFGetMsgRspEntry::_internal_mutable_fibstatus() {
  
  if (fibstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFFibStatus>(GetArenaForAllocation());
    fibstatus_ = p;
  }
  return fibstatus_;
}
inline ::service_layer::SLAFFibStatus* SLAFGetMsgRspEntry::mutable_fibstatus() {
  ::service_layer::SLAFFibStatus* _msg = _internal_mutable_fibstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRspEntry.FIBStatus)
  return _msg;
}
inline void SLAFGetMsgRspEntry::set_allocated_fibstatus(::service_layer::SLAFFibStatus* fibstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fibstatus_;
  }
  if (fibstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFFibStatus>::GetOwningArena(fibstatus);
    if (message_arena != submessage_arena) {
      fibstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fibstatus, submessage_arena);
    }
    
  } else {
    
  }
  fibstatus_ = fibstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRspEntry.FIBStatus)
}

// -------------------------------------------------------------------

// SLAFGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLAFGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRsp.ErrStatus)
}

// string VrfName = 2;
inline void SLAFGetMsgRsp::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFGetMsgRsp::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFGetMsgRsp::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsgRsp.VrfName)
}
inline std::string* SLAFGetMsgRsp::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.VrfName)
  return _s;
}
inline const std::string& SLAFGetMsgRsp::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFGetMsgRsp::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFGetMsgRsp::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFGetMsgRsp::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRsp.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFGetMsgRsp::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRsp.VrfName)
}

// uint64 ClientID = 3;
inline void SLAFGetMsgRsp::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t SLAFGetMsgRsp::_internal_clientid() const {
  return clientid_;
}
inline uint64_t SLAFGetMsgRsp::clientid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.ClientID)
  return _internal_clientid();
}
inline void SLAFGetMsgRsp::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void SLAFGetMsgRsp::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsgRsp.ClientID)
}

// repeated .service_layer.SLAFGetMsgRspEntry AFList = 4;
inline int SLAFGetMsgRsp::_internal_aflist_size() const {
  return aflist_.size();
}
inline int SLAFGetMsgRsp::aflist_size() const {
  return _internal_aflist_size();
}
inline void SLAFGetMsgRsp::clear_aflist() {
  aflist_.Clear();
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::mutable_aflist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.AFList)
  return aflist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >*
SLAFGetMsgRsp::mutable_aflist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFGetMsgRsp.AFList)
  return &aflist_;
}
inline const ::service_layer::SLAFGetMsgRspEntry& SLAFGetMsgRsp::_internal_aflist(int index) const {
  return aflist_.Get(index);
}
inline const ::service_layer::SLAFGetMsgRspEntry& SLAFGetMsgRsp::aflist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.AFList)
  return _internal_aflist(index);
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::_internal_add_aflist() {
  return aflist_.Add();
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::add_aflist() {
  ::service_layer::SLAFGetMsgRspEntry* _add = _internal_add_aflist();
  // @@protoc_insertion_point(field_add:service_layer.SLAFGetMsgRsp.AFList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >&
SLAFGetMsgRsp::aflist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFGetMsgRsp.AFList)
  return aflist_;
}

// -------------------------------------------------------------------

// SLAFMsg

// .service_layer.SLObjectOp Oper = 1;
inline void SLAFMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLAFMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline ::service_layer::SLObjectOp SLAFMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.Oper)
  return _internal_oper();
}
inline void SLAFMsg::_internal_set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
}
inline void SLAFMsg::set_oper(::service_layer::SLObjectOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsg.Oper)
}

// string VrfName = 2;
inline void SLAFMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsg.VrfName)
}
inline std::string* SLAFMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsg.VrfName)
  return _s;
}
inline const std::string& SLAFMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFMsg.VrfName)
}

// repeated .service_layer.SLAFOp OpList = 3;
inline int SLAFMsg::_internal_oplist_size() const {
  return oplist_.size();
}
inline int SLAFMsg::oplist_size() const {
  return _internal_oplist_size();
}
inline void SLAFMsg::clear_oplist() {
  oplist_.Clear();
}
inline ::service_layer::SLAFOp* SLAFMsg::mutable_oplist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsg.OpList)
  return oplist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOp >*
SLAFMsg::mutable_oplist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFMsg.OpList)
  return &oplist_;
}
inline const ::service_layer::SLAFOp& SLAFMsg::_internal_oplist(int index) const {
  return oplist_.Get(index);
}
inline const ::service_layer::SLAFOp& SLAFMsg::oplist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.OpList)
  return _internal_oplist(index);
}
inline ::service_layer::SLAFOp* SLAFMsg::_internal_add_oplist() {
  return oplist_.Add();
}
inline ::service_layer::SLAFOp* SLAFMsg::add_oplist() {
  ::service_layer::SLAFOp* _add = _internal_add_oplist();
  // @@protoc_insertion_point(field_add:service_layer.SLAFMsg.OpList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOp >&
SLAFMsg::oplist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFMsg.OpList)
  return oplist_;
}

// -------------------------------------------------------------------

// SLAFRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.ErrStatus)
  return _msg;
}
inline void SLAFRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.ErrStatus)
}

// .service_layer.SLAFOp Operation = 2;
inline bool SLAFRes::_internal_has_operation() const {
  return this != internal_default_instance() && operation_ != nullptr;
}
inline bool SLAFRes::has_operation() const {
  return _internal_has_operation();
}
inline void SLAFRes::clear_operation() {
  if (GetArenaForAllocation() == nullptr && operation_ != nullptr) {
    delete operation_;
  }
  operation_ = nullptr;
}
inline const ::service_layer::SLAFOp& SLAFRes::_internal_operation() const {
  const ::service_layer::SLAFOp* p = operation_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFOp&>(
      ::service_layer::_SLAFOp_default_instance_);
}
inline const ::service_layer::SLAFOp& SLAFRes::operation() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.Operation)
  return _internal_operation();
}
inline void SLAFRes::unsafe_arena_set_allocated_operation(
    ::service_layer::SLAFOp* operation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operation_);
  }
  operation_ = operation;
  if (operation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFRes.Operation)
}
inline ::service_layer::SLAFOp* SLAFRes::release_operation() {
  
  ::service_layer::SLAFOp* temp = operation_;
  operation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFOp* SLAFRes::unsafe_arena_release_operation() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.Operation)
  
  ::service_layer::SLAFOp* temp = operation_;
  operation_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFOp* SLAFRes::_internal_mutable_operation() {
  
  if (operation_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFOp>(GetArenaForAllocation());
    operation_ = p;
  }
  return operation_;
}
inline ::service_layer::SLAFOp* SLAFRes::mutable_operation() {
  ::service_layer::SLAFOp* _msg = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.Operation)
  return _msg;
}
inline void SLAFRes::set_allocated_operation(::service_layer::SLAFOp* operation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete operation_;
  }
  if (operation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFOp>::GetOwningArena(operation);
    if (message_arena != submessage_arena) {
      operation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operation, submessage_arena);
    }
    
  } else {
    
  }
  operation_ = operation;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.Operation)
}

// .service_layer.SLAFFibStatus FIBStatus = 3;
inline bool SLAFRes::_internal_has_fibstatus() const {
  return this != internal_default_instance() && fibstatus_ != nullptr;
}
inline bool SLAFRes::has_fibstatus() const {
  return _internal_has_fibstatus();
}
inline void SLAFRes::clear_fibstatus() {
  if (GetArenaForAllocation() == nullptr && fibstatus_ != nullptr) {
    delete fibstatus_;
  }
  fibstatus_ = nullptr;
}
inline const ::service_layer::SLAFFibStatus& SLAFRes::_internal_fibstatus() const {
  const ::service_layer::SLAFFibStatus* p = fibstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFFibStatus&>(
      ::service_layer::_SLAFFibStatus_default_instance_);
}
inline const ::service_layer::SLAFFibStatus& SLAFRes::fibstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.FIBStatus)
  return _internal_fibstatus();
}
inline void SLAFRes::unsafe_arena_set_allocated_fibstatus(
    ::service_layer::SLAFFibStatus* fibstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fibstatus_);
  }
  fibstatus_ = fibstatus;
  if (fibstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFRes.FIBStatus)
}
inline ::service_layer::SLAFFibStatus* SLAFRes::release_fibstatus() {
  
  ::service_layer::SLAFFibStatus* temp = fibstatus_;
  fibstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFFibStatus* SLAFRes::unsafe_arena_release_fibstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.FIBStatus)
  
  ::service_layer::SLAFFibStatus* temp = fibstatus_;
  fibstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFFibStatus* SLAFRes::_internal_mutable_fibstatus() {
  
  if (fibstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFFibStatus>(GetArenaForAllocation());
    fibstatus_ = p;
  }
  return fibstatus_;
}
inline ::service_layer::SLAFFibStatus* SLAFRes::mutable_fibstatus() {
  ::service_layer::SLAFFibStatus* _msg = _internal_mutable_fibstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.FIBStatus)
  return _msg;
}
inline void SLAFRes::set_allocated_fibstatus(::service_layer::SLAFFibStatus* fibstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fibstatus_;
  }
  if (fibstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFFibStatus>::GetOwningArena(fibstatus);
    if (message_arena != submessage_arena) {
      fibstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fibstatus, submessage_arena);
    }
    
  } else {
    
  }
  fibstatus_ = fibstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.FIBStatus)
}

// -------------------------------------------------------------------

// SLAFMsgRsp

// string VrfName = 1;
inline void SLAFMsgRsp::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFMsgRsp::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsgRsp.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFMsgRsp::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsgRsp.VrfName)
}
inline std::string* SLAFMsgRsp::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsgRsp.VrfName)
  return _s;
}
inline const std::string& SLAFMsgRsp::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFMsgRsp::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFMsgRsp::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFMsgRsp::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFMsgRsp.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFMsgRsp::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFMsgRsp.VrfName)
}

// repeated .service_layer.SLAFRes Results = 2;
inline int SLAFMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLAFMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLAFMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >*
SLAFMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLAFRes& SLAFMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLAFRes& SLAFMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::add_results() {
  ::service_layer::SLAFRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLAFMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >&
SLAFMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLAFRedistRegMsg

// string SrcProto = 1;
inline void SLAFRedistRegMsg::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLAFRedistRegMsg::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFRedistRegMsg::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.SrcProto)
}
inline std::string* SLAFRedistRegMsg::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRedistRegMsg.SrcProto)
  return _s;
}
inline const std::string& SLAFRedistRegMsg::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLAFRedistRegMsg::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRedistRegMsg.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFRedistRegMsg::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRedistRegMsg.SrcProto)
}

// string SrcProtoTag = 2;
inline void SLAFRedistRegMsg::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLAFRedistRegMsg::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFRedistRegMsg::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.SrcProtoTag)
}
inline std::string* SLAFRedistRegMsg::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return _s;
}
inline const std::string& SLAFRedistRegMsg::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLAFRedistRegMsg::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFRedistRegMsg::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRedistRegMsg.SrcProtoTag)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFRedistRegMsg::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFRedistRegMsg::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFRedistRegMsg::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.Table)
  return _internal_table();
}
inline void SLAFRedistRegMsg::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFRedistRegMsg::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.Table)
}

// -------------------------------------------------------------------

// SLAFNextHopRegKey_SLNextHopKey

// .service_layer.SLIpAddress NextHop = 1;
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_has_nexthop() const {
  return this != internal_default_instance() && nexthop_ != nullptr;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::has_nexthop() const {
  return _internal_has_nexthop();
}
inline const ::service_layer::SLIpAddress& SLAFNextHopRegKey_SLNextHopKey::_internal_nexthop() const {
  const ::service_layer::SLIpAddress* p = nexthop_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLAFNextHopRegKey_SLNextHopKey::nexthop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHop)
  return _internal_nexthop();
}
inline void SLAFNextHopRegKey_SLNextHopKey::unsafe_arena_set_allocated_nexthop(
    ::service_layer::SLIpAddress* nexthop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop_);
  }
  nexthop_ = nexthop;
  if (nexthop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHop)
}
inline ::service_layer::SLIpAddress* SLAFNextHopRegKey_SLNextHopKey::release_nexthop() {
  
  ::service_layer::SLIpAddress* temp = nexthop_;
  nexthop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLAFNextHopRegKey_SLNextHopKey::unsafe_arena_release_nexthop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHop)
  
  ::service_layer::SLIpAddress* temp = nexthop_;
  nexthop_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLAFNextHopRegKey_SLNextHopKey::_internal_mutable_nexthop() {
  
  if (nexthop_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    nexthop_ = p;
  }
  return nexthop_;
}
inline ::service_layer::SLIpAddress* SLAFNextHopRegKey_SLNextHopKey::mutable_nexthop() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_nexthop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHop)
  return _msg;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_allocated_nexthop(::service_layer::SLIpAddress* nexthop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop_);
  }
  if (nexthop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop));
    if (message_arena != submessage_arena) {
      nexthop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthop, submessage_arena);
    }
    
  } else {
    
  }
  nexthop_ = nexthop;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHop)
}

// uint32 NextHopLen = 2;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_nexthoplen() {
  nexthoplen_ = 0u;
}
inline uint32_t SLAFNextHopRegKey_SLNextHopKey::_internal_nexthoplen() const {
  return nexthoplen_;
}
inline uint32_t SLAFNextHopRegKey_SLNextHopKey::nexthoplen() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopLen)
  return _internal_nexthoplen();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_nexthoplen(uint32_t value) {
  
  nexthoplen_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_nexthoplen(uint32_t value) {
  _internal_set_nexthoplen(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopLen)
}

// bool ExactMatch = 3;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_exactmatch() {
  exactmatch_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_exactmatch() const {
  return exactmatch_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::exactmatch() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.ExactMatch)
  return _internal_exactmatch();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_exactmatch(bool value) {
  
  exactmatch_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_exactmatch(bool value) {
  _internal_set_exactmatch(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.ExactMatch)
}

// bool AllowDefault = 4;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_allowdefault() {
  allowdefault_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_allowdefault() const {
  return allowdefault_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::allowdefault() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.AllowDefault)
  return _internal_allowdefault();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_allowdefault(bool value) {
  
  allowdefault_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_allowdefault(bool value) {
  _internal_set_allowdefault(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.AllowDefault)
}

// bool Recurse = 5;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_recurse() {
  recurse_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_recurse() const {
  return recurse_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::recurse() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.Recurse)
  return _internal_recurse();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_recurse(bool value) {
  
  recurse_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_recurse(bool value) {
  _internal_set_recurse(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.Recurse)
}

// -------------------------------------------------------------------

// SLAFNextHopRegKey

// .service_layer.SLAFNextHopRegKey.SLNextHopKey NextHop = 1;
inline bool SLAFNextHopRegKey::_internal_has_nexthop() const {
  return nexthopkey_case() == kNextHop;
}
inline bool SLAFNextHopRegKey::has_nexthop() const {
  return _internal_has_nexthop();
}
inline void SLAFNextHopRegKey::set_has_nexthop() {
  _oneof_case_[0] = kNextHop;
}
inline void SLAFNextHopRegKey::clear_nexthop() {
  if (_internal_has_nexthop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nexthopkey_.nexthop_;
    }
    clear_has_nexthopkey();
  }
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::release_nexthop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegKey.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_nexthopkey();
      ::service_layer::SLAFNextHopRegKey_SLNextHopKey* temp = nexthopkey_.nexthop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nexthopkey_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& SLAFNextHopRegKey::_internal_nexthop() const {
  return _internal_has_nexthop()
      ? *nexthopkey_.nexthop_
      : reinterpret_cast< ::service_layer::SLAFNextHopRegKey_SLNextHopKey&>(::service_layer::_SLAFNextHopRegKey_SLNextHopKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& SLAFNextHopRegKey::nexthop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.NextHop)
  return _internal_nexthop();
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::unsafe_arena_release_nexthop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNextHopRegKey.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_nexthopkey();
    ::service_layer::SLAFNextHopRegKey_SLNextHopKey* temp = nexthopkey_.nexthop_;
    nexthopkey_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNextHopRegKey::unsafe_arena_set_allocated_nexthop(::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop) {
  clear_nexthopkey();
  if (nexthop) {
    set_has_nexthop();
    nexthopkey_.nexthop_ = nexthop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegKey.NextHop)
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::_internal_mutable_nexthop() {
  if (!_internal_has_nexthop()) {
    clear_nexthopkey();
    set_has_nexthop();
    nexthopkey_.nexthop_ = CreateMaybeMessage< ::service_layer::SLAFNextHopRegKey_SLNextHopKey >(GetArenaForAllocation());
  }
  return nexthopkey_.nexthop_;
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::mutable_nexthop() {
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* _msg = _internal_mutable_nexthop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegKey.NextHop)
  return _msg;
}

inline bool SLAFNextHopRegKey::has_nexthopkey() const {
  return nexthopkey_case() != NEXTHOPKEY_NOT_SET;
}
inline void SLAFNextHopRegKey::clear_has_nexthopkey() {
  _oneof_case_[0] = NEXTHOPKEY_NOT_SET;
}
inline SLAFNextHopRegKey::NexthopkeyCase SLAFNextHopRegKey::nexthopkey_case() const {
  return SLAFNextHopRegKey::NexthopkeyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNextHopRegMsg

// .service_layer.SLAFNextHopRegKey NextHopKey = 1;
inline bool SLAFNextHopRegMsg::_internal_has_nexthopkey() const {
  return this != internal_default_instance() && nexthopkey_ != nullptr;
}
inline bool SLAFNextHopRegMsg::has_nexthopkey() const {
  return _internal_has_nexthopkey();
}
inline void SLAFNextHopRegMsg::clear_nexthopkey() {
  if (GetArenaForAllocation() == nullptr && nexthopkey_ != nullptr) {
    delete nexthopkey_;
  }
  nexthopkey_ = nullptr;
}
inline const ::service_layer::SLAFNextHopRegKey& SLAFNextHopRegMsg::_internal_nexthopkey() const {
  const ::service_layer::SLAFNextHopRegKey* p = nexthopkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNextHopRegKey&>(
      ::service_layer::_SLAFNextHopRegKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey& SLAFNextHopRegMsg::nexthopkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegMsg.NextHopKey)
  return _internal_nexthopkey();
}
inline void SLAFNextHopRegMsg::unsafe_arena_set_allocated_nexthopkey(
    ::service_layer::SLAFNextHopRegKey* nexthopkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopkey_);
  }
  nexthopkey_ = nexthopkey;
  if (nexthopkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegMsg.NextHopKey)
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::release_nexthopkey() {
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::unsafe_arena_release_nexthopkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegMsg.NextHopKey)
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::_internal_mutable_nexthopkey() {
  
  if (nexthopkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(GetArenaForAllocation());
    nexthopkey_ = p;
  }
  return nexthopkey_;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::mutable_nexthopkey() {
  ::service_layer::SLAFNextHopRegKey* _msg = _internal_mutable_nexthopkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegMsg.NextHopKey)
  return _msg;
}
inline void SLAFNextHopRegMsg::set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nexthopkey_;
  }
  if (nexthopkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNextHopRegKey>::GetOwningArena(nexthopkey);
    if (message_arena != submessage_arena) {
      nexthopkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopkey, submessage_arena);
    }
    
  } else {
    
  }
  nexthopkey_ = nexthopkey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNextHopRegMsg.NextHopKey)
}

// -------------------------------------------------------------------

// SLAFNotifRegReq

// .service_layer.SLAFRedistRegMsg RedistReq = 1;
inline bool SLAFNotifRegReq::_internal_has_redistreq() const {
  return request_case() == kRedistReq;
}
inline bool SLAFNotifRegReq::has_redistreq() const {
  return _internal_has_redistreq();
}
inline void SLAFNotifRegReq::set_has_redistreq() {
  _oneof_case_[0] = kRedistReq;
}
inline void SLAFNotifRegReq::clear_redistreq() {
  if (_internal_has_redistreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.redistreq_;
    }
    clear_has_request();
  }
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::release_redistreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRegReq.RedistReq)
  if (_internal_has_redistreq()) {
    clear_has_request();
      ::service_layer::SLAFRedistRegMsg* temp = request_.redistreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.redistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFRedistRegMsg& SLAFNotifRegReq::_internal_redistreq() const {
  return _internal_has_redistreq()
      ? *request_.redistreq_
      : reinterpret_cast< ::service_layer::SLAFRedistRegMsg&>(::service_layer::_SLAFRedistRegMsg_default_instance_);
}
inline const ::service_layer::SLAFRedistRegMsg& SLAFNotifRegReq::redistreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.RedistReq)
  return _internal_redistreq();
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::unsafe_arena_release_redistreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotifRegReq.RedistReq)
  if (_internal_has_redistreq()) {
    clear_has_request();
    ::service_layer::SLAFRedistRegMsg* temp = request_.redistreq_;
    request_.redistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotifRegReq::unsafe_arena_set_allocated_redistreq(::service_layer::SLAFRedistRegMsg* redistreq) {
  clear_request();
  if (redistreq) {
    set_has_redistreq();
    request_.redistreq_ = redistreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRegReq.RedistReq)
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::_internal_mutable_redistreq() {
  if (!_internal_has_redistreq()) {
    clear_request();
    set_has_redistreq();
    request_.redistreq_ = CreateMaybeMessage< ::service_layer::SLAFRedistRegMsg >(GetArenaForAllocation());
  }
  return request_.redistreq_;
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::mutable_redistreq() {
  ::service_layer::SLAFRedistRegMsg* _msg = _internal_mutable_redistreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRegReq.RedistReq)
  return _msg;
}

// .service_layer.SLAFNextHopRegMsg NextHopReq = 2;
inline bool SLAFNotifRegReq::_internal_has_nexthopreq() const {
  return request_case() == kNextHopReq;
}
inline bool SLAFNotifRegReq::has_nexthopreq() const {
  return _internal_has_nexthopreq();
}
inline void SLAFNotifRegReq::set_has_nexthopreq() {
  _oneof_case_[0] = kNextHopReq;
}
inline void SLAFNotifRegReq::clear_nexthopreq() {
  if (_internal_has_nexthopreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.nexthopreq_;
    }
    clear_has_request();
  }
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::release_nexthopreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRegReq.NextHopReq)
  if (_internal_has_nexthopreq()) {
    clear_has_request();
      ::service_layer::SLAFNextHopRegMsg* temp = request_.nexthopreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.nexthopreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNextHopRegMsg& SLAFNotifRegReq::_internal_nexthopreq() const {
  return _internal_has_nexthopreq()
      ? *request_.nexthopreq_
      : reinterpret_cast< ::service_layer::SLAFNextHopRegMsg&>(::service_layer::_SLAFNextHopRegMsg_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegMsg& SLAFNotifRegReq::nexthopreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.NextHopReq)
  return _internal_nexthopreq();
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::unsafe_arena_release_nexthopreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotifRegReq.NextHopReq)
  if (_internal_has_nexthopreq()) {
    clear_has_request();
    ::service_layer::SLAFNextHopRegMsg* temp = request_.nexthopreq_;
    request_.nexthopreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotifRegReq::unsafe_arena_set_allocated_nexthopreq(::service_layer::SLAFNextHopRegMsg* nexthopreq) {
  clear_request();
  if (nexthopreq) {
    set_has_nexthopreq();
    request_.nexthopreq_ = nexthopreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRegReq.NextHopReq)
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::_internal_mutable_nexthopreq() {
  if (!_internal_has_nexthopreq()) {
    clear_request();
    set_has_nexthopreq();
    request_.nexthopreq_ = CreateMaybeMessage< ::service_layer::SLAFNextHopRegMsg >(GetArenaForAllocation());
  }
  return request_.nexthopreq_;
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::mutable_nexthopreq() {
  ::service_layer::SLAFNextHopRegMsg* _msg = _internal_mutable_nexthopreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRegReq.NextHopReq)
  return _msg;
}

// uint64 OperationID = 3;
inline void SLAFNotifRegReq::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFNotifRegReq::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFNotifRegReq::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.OperationID)
  return _internal_operationid();
}
inline void SLAFNotifRegReq::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFNotifRegReq::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifRegReq.OperationID)
}

inline bool SLAFNotifRegReq::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void SLAFNotifRegReq::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline SLAFNotifRegReq::RequestCase SLAFNotifRegReq::request_case() const {
  return SLAFNotifRegReq::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNotifReq

// .service_layer.SLNotifOp Oper = 1;
inline void SLAFNotifReq::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLAFNotifReq::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLAFNotifReq::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.Oper)
  return _internal_oper();
}
inline void SLAFNotifReq::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLAFNotifReq::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifReq.Oper)
}

// string VrfName = 2;
inline void SLAFNotifReq::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFNotifReq::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFNotifReq::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifReq.VrfName)
}
inline std::string* SLAFNotifReq::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifReq.VrfName)
  return _s;
}
inline const std::string& SLAFNotifReq::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFNotifReq::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFNotifReq::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFNotifReq::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifReq.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFNotifReq::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifReq.VrfName)
}

// repeated .service_layer.SLAFNotifRegReq NotifReq = 3;
inline int SLAFNotifReq::_internal_notifreq_size() const {
  return notifreq_.size();
}
inline int SLAFNotifReq::notifreq_size() const {
  return _internal_notifreq_size();
}
inline void SLAFNotifReq::clear_notifreq() {
  notifreq_.Clear();
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::mutable_notifreq(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifReq.NotifReq)
  return notifreq_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >*
SLAFNotifReq::mutable_notifreq() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFNotifReq.NotifReq)
  return &notifreq_;
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifReq::_internal_notifreq(int index) const {
  return notifreq_.Get(index);
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifReq::notifreq(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.NotifReq)
  return _internal_notifreq(index);
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::_internal_add_notifreq() {
  return notifreq_.Add();
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::add_notifreq() {
  ::service_layer::SLAFNotifRegReq* _add = _internal_add_notifreq();
  // @@protoc_insertion_point(field_add:service_layer.SLAFNotifReq.NotifReq)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >&
SLAFNotifReq::notifreq() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFNotifReq.NotifReq)
  return notifreq_;
}

// -------------------------------------------------------------------

// SLAFNotifRsp

// .service_layer.SLAFNotifRegReq NotifReq = 1;
inline bool SLAFNotifRsp::_internal_has_notifreq() const {
  return this != internal_default_instance() && notifreq_ != nullptr;
}
inline bool SLAFNotifRsp::has_notifreq() const {
  return _internal_has_notifreq();
}
inline void SLAFNotifRsp::clear_notifreq() {
  if (GetArenaForAllocation() == nullptr && notifreq_ != nullptr) {
    delete notifreq_;
  }
  notifreq_ = nullptr;
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifRsp::_internal_notifreq() const {
  const ::service_layer::SLAFNotifRegReq* p = notifreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNotifRegReq&>(
      ::service_layer::_SLAFNotifRegReq_default_instance_);
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifRsp::notifreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRsp.NotifReq)
  return _internal_notifreq();
}
inline void SLAFNotifRsp::unsafe_arena_set_allocated_notifreq(
    ::service_layer::SLAFNotifRegReq* notifreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifreq_);
  }
  notifreq_ = notifreq;
  if (notifreq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRsp.NotifReq)
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::release_notifreq() {
  
  ::service_layer::SLAFNotifRegReq* temp = notifreq_;
  notifreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::unsafe_arena_release_notifreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRsp.NotifReq)
  
  ::service_layer::SLAFNotifRegReq* temp = notifreq_;
  notifreq_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::_internal_mutable_notifreq() {
  
  if (notifreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNotifRegReq>(GetArenaForAllocation());
    notifreq_ = p;
  }
  return notifreq_;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::mutable_notifreq() {
  ::service_layer::SLAFNotifRegReq* _msg = _internal_mutable_notifreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRsp.NotifReq)
  return _msg;
}
inline void SLAFNotifRsp::set_allocated_notifreq(::service_layer::SLAFNotifRegReq* notifreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete notifreq_;
  }
  if (notifreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNotifRegReq>::GetOwningArena(notifreq);
    if (message_arena != submessage_arena) {
      notifreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifreq, submessage_arena);
    }
    
  } else {
    
  }
  notifreq_ = notifreq;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifRsp.NotifReq)
}

// .service_layer.SLErrorStatus NotifStatus = 2;
inline bool SLAFNotifRsp::_internal_has_notifstatus() const {
  return this != internal_default_instance() && notifstatus_ != nullptr;
}
inline bool SLAFNotifRsp::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFNotifRsp::_internal_notifstatus() const {
  const ::service_layer::SLErrorStatus* p = notifstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFNotifRsp::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRsp.NotifStatus)
  return _internal_notifstatus();
}
inline void SLAFNotifRsp::unsafe_arena_set_allocated_notifstatus(
    ::service_layer::SLErrorStatus* notifstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  notifstatus_ = notifstatus;
  if (notifstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRsp.NotifStatus)
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::release_notifstatus() {
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRsp.NotifStatus)
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::_internal_mutable_notifstatus() {
  
  if (notifstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    notifstatus_ = p;
  }
  return notifstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::mutable_notifstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRsp.NotifStatus)
  return _msg;
}
inline void SLAFNotifRsp::set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  if (notifstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus));
    if (message_arena != submessage_arena) {
      notifstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifstatus, submessage_arena);
    }
    
  } else {
    
  }
  notifstatus_ = notifstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifRsp.NotifStatus)
}

// -------------------------------------------------------------------

// SLNextHop

// .service_layer.SLAFNextHopRegKey NextHopKey = 1;
inline bool SLNextHop::_internal_has_nexthopkey() const {
  return this != internal_default_instance() && nexthopkey_ != nullptr;
}
inline bool SLNextHop::has_nexthopkey() const {
  return _internal_has_nexthopkey();
}
inline void SLNextHop::clear_nexthopkey() {
  if (GetArenaForAllocation() == nullptr && nexthopkey_ != nullptr) {
    delete nexthopkey_;
  }
  nexthopkey_ = nullptr;
}
inline const ::service_layer::SLAFNextHopRegKey& SLNextHop::_internal_nexthopkey() const {
  const ::service_layer::SLAFNextHopRegKey* p = nexthopkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNextHopRegKey&>(
      ::service_layer::_SLAFNextHopRegKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey& SLNextHop::nexthopkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.NextHopKey)
  return _internal_nexthopkey();
}
inline void SLNextHop::unsafe_arena_set_allocated_nexthopkey(
    ::service_layer::SLAFNextHopRegKey* nexthopkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopkey_);
  }
  nexthopkey_ = nexthopkey;
  if (nexthopkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLNextHop.NextHopKey)
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::release_nexthopkey() {
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::unsafe_arena_release_nexthopkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.NextHopKey)
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::_internal_mutable_nexthopkey() {
  
  if (nexthopkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(GetArenaForAllocation());
    nexthopkey_ = p;
  }
  return nexthopkey_;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::mutable_nexthopkey() {
  ::service_layer::SLAFNextHopRegKey* _msg = _internal_mutable_nexthopkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.NextHopKey)
  return _msg;
}
inline void SLNextHop::set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nexthopkey_;
  }
  if (nexthopkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNextHopRegKey>::GetOwningArena(nexthopkey);
    if (message_arena != submessage_arena) {
      nexthopkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopkey, submessage_arena);
    }
    
  } else {
    
  }
  nexthopkey_ = nexthopkey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.NextHopKey)
}

// .service_layer.SLIpAddress ResolvingRoute = 2;
inline bool SLNextHop::_internal_has_resolvingroute() const {
  return this != internal_default_instance() && resolvingroute_ != nullptr;
}
inline bool SLNextHop::has_resolvingroute() const {
  return _internal_has_resolvingroute();
}
inline const ::service_layer::SLIpAddress& SLNextHop::_internal_resolvingroute() const {
  const ::service_layer::SLIpAddress* p = resolvingroute_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLNextHop::resolvingroute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.ResolvingRoute)
  return _internal_resolvingroute();
}
inline void SLNextHop::unsafe_arena_set_allocated_resolvingroute(
    ::service_layer::SLIpAddress* resolvingroute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingroute_);
  }
  resolvingroute_ = resolvingroute;
  if (resolvingroute) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLNextHop.ResolvingRoute)
}
inline ::service_layer::SLIpAddress* SLNextHop::release_resolvingroute() {
  
  ::service_layer::SLIpAddress* temp = resolvingroute_;
  resolvingroute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLNextHop::unsafe_arena_release_resolvingroute() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.ResolvingRoute)
  
  ::service_layer::SLIpAddress* temp = resolvingroute_;
  resolvingroute_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLNextHop::_internal_mutable_resolvingroute() {
  
  if (resolvingroute_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    resolvingroute_ = p;
  }
  return resolvingroute_;
}
inline ::service_layer::SLIpAddress* SLNextHop::mutable_resolvingroute() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_resolvingroute();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.ResolvingRoute)
  return _msg;
}
inline void SLNextHop::set_allocated_resolvingroute(::service_layer::SLIpAddress* resolvingroute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingroute_);
  }
  if (resolvingroute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingroute));
    if (message_arena != submessage_arena) {
      resolvingroute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolvingroute, submessage_arena);
    }
    
  } else {
    
  }
  resolvingroute_ = resolvingroute;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.ResolvingRoute)
}

// uint32 ResolvingRouteLen = 3;
inline void SLNextHop::clear_resolvingroutelen() {
  resolvingroutelen_ = 0u;
}
inline uint32_t SLNextHop::_internal_resolvingroutelen() const {
  return resolvingroutelen_;
}
inline uint32_t SLNextHop::resolvingroutelen() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.ResolvingRouteLen)
  return _internal_resolvingroutelen();
}
inline void SLNextHop::_internal_set_resolvingroutelen(uint32_t value) {
  
  resolvingroutelen_ = value;
}
inline void SLNextHop::set_resolvingroutelen(uint32_t value) {
  _internal_set_resolvingroutelen(value);
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.ResolvingRouteLen)
}

// string SrcProto = 4;
inline void SLNextHop::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLNextHop::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLNextHop::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.SrcProto)
}
inline std::string* SLNextHop::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.SrcProto)
  return _s;
}
inline const std::string& SLNextHop::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLNextHop::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLNextHop::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLNextHop::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLNextHop::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.SrcProto)
}

// string SrcProtoTag = 5;
inline void SLNextHop::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLNextHop::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLNextHop::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.SrcProtoTag)
}
inline std::string* SLNextHop::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.SrcProtoTag)
  return _s;
}
inline const std::string& SLNextHop::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLNextHop::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLNextHop::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLNextHop::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLNextHop::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.SrcProtoTag)
}

// uint32 AdminDistance = 6;
inline void SLNextHop::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLNextHop::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLNextHop::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.AdminDistance)
  return _internal_admindistance();
}
inline void SLNextHop::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLNextHop::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.AdminDistance)
}

// uint32 Metric = 7;
inline void SLNextHop::clear_metric() {
  metric_ = 0u;
}
inline uint32_t SLNextHop::_internal_metric() const {
  return metric_;
}
inline uint32_t SLNextHop::metric() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.Metric)
  return _internal_metric();
}
inline void SLNextHop::_internal_set_metric(uint32_t value) {
  
  metric_ = value;
}
inline void SLNextHop::set_metric(uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.Metric)
}

// repeated .service_layer.SLRoutePath Paths = 8;
inline int SLNextHop::_internal_paths_size() const {
  return paths_.size();
}
inline int SLNextHop::paths_size() const {
  return _internal_paths_size();
}
inline ::service_layer::SLRoutePath* SLNextHop::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.Paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
SLNextHop::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLNextHop.Paths)
  return &paths_;
}
inline const ::service_layer::SLRoutePath& SLNextHop::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::service_layer::SLRoutePath& SLNextHop::paths(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.Paths)
  return _internal_paths(index);
}
inline ::service_layer::SLRoutePath* SLNextHop::_internal_add_paths() {
  return paths_.Add();
}
inline ::service_layer::SLRoutePath* SLNextHop::add_paths() {
  ::service_layer::SLRoutePath* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:service_layer.SLNextHop.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
SLNextHop::paths() const {
  // @@protoc_insertion_point(field_list:service_layer.SLNextHop.Paths)
  return paths_;
}

// -------------------------------------------------------------------

// SLAFNotif

// .service_layer.SLAFNotifRsp NotifStatus = 1;
inline bool SLAFNotif::_internal_has_notifstatus() const {
  return Event_case() == kNotifStatus;
}
inline bool SLAFNotif::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline void SLAFNotif::set_has_notifstatus() {
  _oneof_case_[0] = kNotifStatus;
}
inline void SLAFNotif::clear_notifstatus() {
  if (_internal_has_notifstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.notifstatus_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
      ::service_layer::SLAFNotifRsp* temp = Event_.notifstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNotifRsp& SLAFNotif::_internal_notifstatus() const {
  return _internal_has_notifstatus()
      ? *Event_.notifstatus_
      : reinterpret_cast< ::service_layer::SLAFNotifRsp&>(::service_layer::_SLAFNotifRsp_default_instance_);
}
inline const ::service_layer::SLAFNotifRsp& SLAFNotif::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.NotifStatus)
  return _internal_notifstatus();
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
    ::service_layer::SLAFNotifRsp* temp = Event_.notifstatus_;
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_notifstatus(::service_layer::SLAFNotifRsp* notifstatus) {
  clear_Event();
  if (notifstatus) {
    set_has_notifstatus();
    Event_.notifstatus_ = notifstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.NotifStatus)
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::_internal_mutable_notifstatus() {
  if (!_internal_has_notifstatus()) {
    clear_Event();
    set_has_notifstatus();
    Event_.notifstatus_ = CreateMaybeMessage< ::service_layer::SLAFNotifRsp >(GetArenaForAllocation());
  }
  return Event_.notifstatus_;
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::mutable_notifstatus() {
  ::service_layer::SLAFNotifRsp* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.NotifStatus)
  return _msg;
}

// .service_layer.SLAFObject RedistObject = 4;
inline bool SLAFNotif::_internal_has_redistobject() const {
  return Event_case() == kRedistObject;
}
inline bool SLAFNotif::has_redistobject() const {
  return _internal_has_redistobject();
}
inline void SLAFNotif::set_has_redistobject() {
  _oneof_case_[0] = kRedistObject;
}
inline void SLAFNotif::clear_redistobject() {
  if (_internal_has_redistobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.redistobject_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFObject* SLAFNotif::release_redistobject() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.RedistObject)
  if (_internal_has_redistobject()) {
    clear_has_Event();
      ::service_layer::SLAFObject* temp = Event_.redistobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.redistobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFObject& SLAFNotif::_internal_redistobject() const {
  return _internal_has_redistobject()
      ? *Event_.redistobject_
      : reinterpret_cast< ::service_layer::SLAFObject&>(::service_layer::_SLAFObject_default_instance_);
}
inline const ::service_layer::SLAFObject& SLAFNotif::redistobject() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.RedistObject)
  return _internal_redistobject();
}
inline ::service_layer::SLAFObject* SLAFNotif::unsafe_arena_release_redistobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.RedistObject)
  if (_internal_has_redistobject()) {
    clear_has_Event();
    ::service_layer::SLAFObject* temp = Event_.redistobject_;
    Event_.redistobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_redistobject(::service_layer::SLAFObject* redistobject) {
  clear_Event();
  if (redistobject) {
    set_has_redistobject();
    Event_.redistobject_ = redistobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.RedistObject)
}
inline ::service_layer::SLAFObject* SLAFNotif::_internal_mutable_redistobject() {
  if (!_internal_has_redistobject()) {
    clear_Event();
    set_has_redistobject();
    Event_.redistobject_ = CreateMaybeMessage< ::service_layer::SLAFObject >(GetArenaForAllocation());
  }
  return Event_.redistobject_;
}
inline ::service_layer::SLAFObject* SLAFNotif::mutable_redistobject() {
  ::service_layer::SLAFObject* _msg = _internal_mutable_redistobject();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.RedistObject)
  return _msg;
}

// .service_layer.SLNextHop NextHop = 5;
inline bool SLAFNotif::_internal_has_nexthop() const {
  return Event_case() == kNextHop;
}
inline bool SLAFNotif::has_nexthop() const {
  return _internal_has_nexthop();
}
inline void SLAFNotif::set_has_nexthop() {
  _oneof_case_[0] = kNextHop;
}
inline void SLAFNotif::clear_nexthop() {
  if (_internal_has_nexthop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.nexthop_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLNextHop* SLAFNotif::release_nexthop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_Event();
      ::service_layer::SLNextHop* temp = Event_.nexthop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLNextHop& SLAFNotif::_internal_nexthop() const {
  return _internal_has_nexthop()
      ? *Event_.nexthop_
      : reinterpret_cast< ::service_layer::SLNextHop&>(::service_layer::_SLNextHop_default_instance_);
}
inline const ::service_layer::SLNextHop& SLAFNotif::nexthop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.NextHop)
  return _internal_nexthop();
}
inline ::service_layer::SLNextHop* SLAFNotif::unsafe_arena_release_nexthop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_Event();
    ::service_layer::SLNextHop* temp = Event_.nexthop_;
    Event_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_nexthop(::service_layer::SLNextHop* nexthop) {
  clear_Event();
  if (nexthop) {
    set_has_nexthop();
    Event_.nexthop_ = nexthop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.NextHop)
}
inline ::service_layer::SLNextHop* SLAFNotif::_internal_mutable_nexthop() {
  if (!_internal_has_nexthop()) {
    clear_Event();
    set_has_nexthop();
    Event_.nexthop_ = CreateMaybeMessage< ::service_layer::SLNextHop >(GetArenaForAllocation());
  }
  return Event_.nexthop_;
}
inline ::service_layer::SLNextHop* SLAFNotif::mutable_nexthop() {
  ::service_layer::SLNextHop* _msg = _internal_mutable_nexthop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.NextHop)
  return _msg;
}

inline bool SLAFNotif::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLAFNotif::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLAFNotif::EventCase SLAFNotif::Event_case() const {
  return SLAFNotif::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNotifMsg

// string VrfName = 1;
inline void SLAFNotifMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFNotifMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFNotifMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifMsg.VrfName)
}
inline std::string* SLAFNotifMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifMsg.VrfName)
  return _s;
}
inline const std::string& SLAFNotifMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFNotifMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFNotifMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFNotifMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFNotifMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifMsg.VrfName)
}

// repeated .service_layer.SLAFNotif AFNotifs = 3;
inline int SLAFNotifMsg::_internal_afnotifs_size() const {
  return afnotifs_.size();
}
inline int SLAFNotifMsg::afnotifs_size() const {
  return _internal_afnotifs_size();
}
inline void SLAFNotifMsg::clear_afnotifs() {
  afnotifs_.Clear();
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::mutable_afnotifs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifMsg.AFNotifs)
  return afnotifs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >*
SLAFNotifMsg::mutable_afnotifs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFNotifMsg.AFNotifs)
  return &afnotifs_;
}
inline const ::service_layer::SLAFNotif& SLAFNotifMsg::_internal_afnotifs(int index) const {
  return afnotifs_.Get(index);
}
inline const ::service_layer::SLAFNotif& SLAFNotifMsg::afnotifs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifMsg.AFNotifs)
  return _internal_afnotifs(index);
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::_internal_add_afnotifs() {
  return afnotifs_.Add();
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::add_afnotifs() {
  ::service_layer::SLAFNotif* _add = _internal_add_afnotifs();
  // @@protoc_insertion_point(field_add:service_layer.SLAFNotifMsg.AFNotifs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >&
SLAFNotifMsg::afnotifs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFNotifMsg.AFNotifs)
  return afnotifs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto
