// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_af.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
#include "sl_route_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5faf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5faf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5faf_2eproto;
namespace service_layer {
class SLAFClientIDList;
struct SLAFClientIDListDefaultTypeInternal;
extern SLAFClientIDListDefaultTypeInternal _SLAFClientIDList_default_instance_;
class SLAFGetMatch;
struct SLAFGetMatchDefaultTypeInternal;
extern SLAFGetMatchDefaultTypeInternal _SLAFGetMatch_default_instance_;
class SLAFGetMatchList;
struct SLAFGetMatchListDefaultTypeInternal;
extern SLAFGetMatchListDefaultTypeInternal _SLAFGetMatchList_default_instance_;
class SLAFGetMsg;
struct SLAFGetMsgDefaultTypeInternal;
extern SLAFGetMsgDefaultTypeInternal _SLAFGetMsg_default_instance_;
class SLAFGetMsgRsp;
struct SLAFGetMsgRspDefaultTypeInternal;
extern SLAFGetMsgRspDefaultTypeInternal _SLAFGetMsgRsp_default_instance_;
class SLAFGetMsgRspEntry;
struct SLAFGetMsgRspEntryDefaultTypeInternal;
extern SLAFGetMsgRspEntryDefaultTypeInternal _SLAFGetMsgRspEntry_default_instance_;
class SLAFIPRoute;
struct SLAFIPRouteDefaultTypeInternal;
extern SLAFIPRouteDefaultTypeInternal _SLAFIPRoute_default_instance_;
class SLAFMsg;
struct SLAFMsgDefaultTypeInternal;
extern SLAFMsgDefaultTypeInternal _SLAFMsg_default_instance_;
class SLAFMsgRsp;
struct SLAFMsgRspDefaultTypeInternal;
extern SLAFMsgRspDefaultTypeInternal _SLAFMsgRsp_default_instance_;
class SLAFNextHopRegKey;
struct SLAFNextHopRegKeyDefaultTypeInternal;
extern SLAFNextHopRegKeyDefaultTypeInternal _SLAFNextHopRegKey_default_instance_;
class SLAFNextHopRegKey_SLNextHopKey;
struct SLAFNextHopRegKey_SLNextHopKeyDefaultTypeInternal;
extern SLAFNextHopRegKey_SLNextHopKeyDefaultTypeInternal _SLAFNextHopRegKey_SLNextHopKey_default_instance_;
class SLAFNextHopRegMsg;
struct SLAFNextHopRegMsgDefaultTypeInternal;
extern SLAFNextHopRegMsgDefaultTypeInternal _SLAFNextHopRegMsg_default_instance_;
class SLAFNotif;
struct SLAFNotifDefaultTypeInternal;
extern SLAFNotifDefaultTypeInternal _SLAFNotif_default_instance_;
class SLAFNotifMsg;
struct SLAFNotifMsgDefaultTypeInternal;
extern SLAFNotifMsgDefaultTypeInternal _SLAFNotifMsg_default_instance_;
class SLAFNotifRegReq;
struct SLAFNotifRegReqDefaultTypeInternal;
extern SLAFNotifRegReqDefaultTypeInternal _SLAFNotifRegReq_default_instance_;
class SLAFNotifReq;
struct SLAFNotifReqDefaultTypeInternal;
extern SLAFNotifReqDefaultTypeInternal _SLAFNotifReq_default_instance_;
class SLAFNotifRsp;
struct SLAFNotifRspDefaultTypeInternal;
extern SLAFNotifRspDefaultTypeInternal _SLAFNotifRsp_default_instance_;
class SLAFNotif_SLRedistMarker;
struct SLAFNotif_SLRedistMarkerDefaultTypeInternal;
extern SLAFNotif_SLRedistMarkerDefaultTypeInternal _SLAFNotif_SLRedistMarker_default_instance_;
class SLAFObject;
struct SLAFObjectDefaultTypeInternal;
extern SLAFObjectDefaultTypeInternal _SLAFObject_default_instance_;
class SLAFObjectKey;
struct SLAFObjectKeyDefaultTypeInternal;
extern SLAFObjectKeyDefaultTypeInternal _SLAFObjectKey_default_instance_;
class SLAFOpMsg;
struct SLAFOpMsgDefaultTypeInternal;
extern SLAFOpMsgDefaultTypeInternal _SLAFOpMsg_default_instance_;
class SLAFRedistRegMsg;
struct SLAFRedistRegMsgDefaultTypeInternal;
extern SLAFRedistRegMsgDefaultTypeInternal _SLAFRedistRegMsg_default_instance_;
class SLAFRes;
struct SLAFResDefaultTypeInternal;
extern SLAFResDefaultTypeInternal _SLAFRes_default_instance_;
class SLAFVrfReg;
struct SLAFVrfRegDefaultTypeInternal;
extern SLAFVrfRegDefaultTypeInternal _SLAFVrfReg_default_instance_;
class SLAFVrfRegGetMsg;
struct SLAFVrfRegGetMsgDefaultTypeInternal;
extern SLAFVrfRegGetMsgDefaultTypeInternal _SLAFVrfRegGetMsg_default_instance_;
class SLAFVrfRegGetMsgRsp;
struct SLAFVrfRegGetMsgRspDefaultTypeInternal;
extern SLAFVrfRegGetMsgRspDefaultTypeInternal _SLAFVrfRegGetMsgRsp_default_instance_;
class SLAFVrfRegMsg;
struct SLAFVrfRegMsgDefaultTypeInternal;
extern SLAFVrfRegMsgDefaultTypeInternal _SLAFVrfRegMsg_default_instance_;
class SLAFVrfRegMsgRes;
struct SLAFVrfRegMsgResDefaultTypeInternal;
extern SLAFVrfRegMsgResDefaultTypeInternal _SLAFVrfRegMsgRes_default_instance_;
class SLAFVrfRegMsgRsp;
struct SLAFVrfRegMsgRspDefaultTypeInternal;
extern SLAFVrfRegMsgRspDefaultTypeInternal _SLAFVrfRegMsgRsp_default_instance_;
class SLMplsEntry;
struct SLMplsEntryDefaultTypeInternal;
extern SLMplsEntryDefaultTypeInternal _SLMplsEntry_default_instance_;
class SLMplsEntryKey;
struct SLMplsEntryKeyDefaultTypeInternal;
extern SLMplsEntryKeyDefaultTypeInternal _SLMplsEntryKey_default_instance_;
class SLNextHop;
struct SLNextHopDefaultTypeInternal;
extern SLNextHopDefaultTypeInternal _SLNextHop_default_instance_;
class SLPathGroup;
struct SLPathGroupDefaultTypeInternal;
extern SLPathGroupDefaultTypeInternal _SLPathGroup_default_instance_;
class SLPathGroup_SLPath;
struct SLPathGroup_SLPathDefaultTypeInternal;
extern SLPathGroup_SLPathDefaultTypeInternal _SLPathGroup_SLPath_default_instance_;
class SLPathGroup_SLPathList;
struct SLPathGroup_SLPathListDefaultTypeInternal;
extern SLPathGroup_SLPathListDefaultTypeInternal _SLPathGroup_SLPathList_default_instance_;
class SLTableTypeList;
struct SLTableTypeListDefaultTypeInternal;
extern SLTableTypeListDefaultTypeInternal _SLTableTypeList_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLAFClientIDList* Arena::CreateMaybeMessage<::service_layer::SLAFClientIDList>(Arena*);
template<> ::service_layer::SLAFGetMatch* Arena::CreateMaybeMessage<::service_layer::SLAFGetMatch>(Arena*);
template<> ::service_layer::SLAFGetMatchList* Arena::CreateMaybeMessage<::service_layer::SLAFGetMatchList>(Arena*);
template<> ::service_layer::SLAFGetMsg* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsg>(Arena*);
template<> ::service_layer::SLAFGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsgRsp>(Arena*);
template<> ::service_layer::SLAFGetMsgRspEntry* Arena::CreateMaybeMessage<::service_layer::SLAFGetMsgRspEntry>(Arena*);
template<> ::service_layer::SLAFIPRoute* Arena::CreateMaybeMessage<::service_layer::SLAFIPRoute>(Arena*);
template<> ::service_layer::SLAFMsg* Arena::CreateMaybeMessage<::service_layer::SLAFMsg>(Arena*);
template<> ::service_layer::SLAFMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFMsgRsp>(Arena*);
template<> ::service_layer::SLAFNextHopRegKey* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(Arena*);
template<> ::service_layer::SLAFNextHopRegKey_SLNextHopKey* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegKey_SLNextHopKey>(Arena*);
template<> ::service_layer::SLAFNextHopRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFNextHopRegMsg>(Arena*);
template<> ::service_layer::SLAFNotif* Arena::CreateMaybeMessage<::service_layer::SLAFNotif>(Arena*);
template<> ::service_layer::SLAFNotifMsg* Arena::CreateMaybeMessage<::service_layer::SLAFNotifMsg>(Arena*);
template<> ::service_layer::SLAFNotifRegReq* Arena::CreateMaybeMessage<::service_layer::SLAFNotifRegReq>(Arena*);
template<> ::service_layer::SLAFNotifReq* Arena::CreateMaybeMessage<::service_layer::SLAFNotifReq>(Arena*);
template<> ::service_layer::SLAFNotifRsp* Arena::CreateMaybeMessage<::service_layer::SLAFNotifRsp>(Arena*);
template<> ::service_layer::SLAFNotif_SLRedistMarker* Arena::CreateMaybeMessage<::service_layer::SLAFNotif_SLRedistMarker>(Arena*);
template<> ::service_layer::SLAFObject* Arena::CreateMaybeMessage<::service_layer::SLAFObject>(Arena*);
template<> ::service_layer::SLAFObjectKey* Arena::CreateMaybeMessage<::service_layer::SLAFObjectKey>(Arena*);
template<> ::service_layer::SLAFOpMsg* Arena::CreateMaybeMessage<::service_layer::SLAFOpMsg>(Arena*);
template<> ::service_layer::SLAFRedistRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFRedistRegMsg>(Arena*);
template<> ::service_layer::SLAFRes* Arena::CreateMaybeMessage<::service_layer::SLAFRes>(Arena*);
template<> ::service_layer::SLAFVrfReg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfReg>(Arena*);
template<> ::service_layer::SLAFVrfRegGetMsg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegGetMsg>(Arena*);
template<> ::service_layer::SLAFVrfRegGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegGetMsgRsp>(Arena*);
template<> ::service_layer::SLAFVrfRegMsg* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsg>(Arena*);
template<> ::service_layer::SLAFVrfRegMsgRes* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsgRes>(Arena*);
template<> ::service_layer::SLAFVrfRegMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLAFVrfRegMsgRsp>(Arena*);
template<> ::service_layer::SLMplsEntry* Arena::CreateMaybeMessage<::service_layer::SLMplsEntry>(Arena*);
template<> ::service_layer::SLMplsEntryKey* Arena::CreateMaybeMessage<::service_layer::SLMplsEntryKey>(Arena*);
template<> ::service_layer::SLNextHop* Arena::CreateMaybeMessage<::service_layer::SLNextHop>(Arena*);
template<> ::service_layer::SLPathGroup* Arena::CreateMaybeMessage<::service_layer::SLPathGroup>(Arena*);
template<> ::service_layer::SLPathGroup_SLPath* Arena::CreateMaybeMessage<::service_layer::SLPathGroup_SLPath>(Arena*);
template<> ::service_layer::SLPathGroup_SLPathList* Arena::CreateMaybeMessage<::service_layer::SLPathGroup_SLPathList>(Arena*);
template<> ::service_layer::SLTableTypeList* Arena::CreateMaybeMessage<::service_layer::SLTableTypeList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

// ===================================================================

class SLAFVrfReg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfReg) */ {
 public:
  inline SLAFVrfReg() : SLAFVrfReg(nullptr) {}
  ~SLAFVrfReg() override;
  explicit constexpr SLAFVrfReg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfReg(const SLAFVrfReg& from);
  SLAFVrfReg(SLAFVrfReg&& from) noexcept
    : SLAFVrfReg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfReg& operator=(const SLAFVrfReg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfReg& operator=(SLAFVrfReg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfReg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfReg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfReg*>(
               &_SLAFVrfReg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLAFVrfReg& a, SLAFVrfReg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfReg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfReg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfReg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfReg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfReg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfReg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfReg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfReg";
  }
  protected:
  explicit SLAFVrfReg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfRegFieldNumber = 2,
    kTableFieldNumber = 1,
  };
  // .service_layer.SLVrfReg VrfReg = 2;
  bool has_vrfreg() const;
  private:
  bool _internal_has_vrfreg() const;
  public:
  void clear_vrfreg();
  const ::service_layer::SLVrfReg& vrfreg() const;
  PROTOBUF_NODISCARD ::service_layer::SLVrfReg* release_vrfreg();
  ::service_layer::SLVrfReg* mutable_vrfreg();
  void set_allocated_vrfreg(::service_layer::SLVrfReg* vrfreg);
  private:
  const ::service_layer::SLVrfReg& _internal_vrfreg() const;
  ::service_layer::SLVrfReg* _internal_mutable_vrfreg();
  public:
  void unsafe_arena_set_allocated_vrfreg(
      ::service_layer::SLVrfReg* vrfreg);
  ::service_layer::SLVrfReg* unsafe_arena_release_vrfreg();

  // .service_layer.SLTableType Table = 1;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfReg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLVrfReg* vrfreg_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsg) */ {
 public:
  inline SLAFVrfRegMsg() : SLAFVrfRegMsg(nullptr) {}
  ~SLAFVrfRegMsg() override;
  explicit constexpr SLAFVrfRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsg(const SLAFVrfRegMsg& from);
  SLAFVrfRegMsg(SLAFVrfRegMsg&& from) noexcept
    : SLAFVrfRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsg& operator=(const SLAFVrfRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsg& operator=(SLAFVrfRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsg*>(
               &_SLAFVrfRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLAFVrfRegMsg& a, SLAFVrfRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsg";
  }
  protected:
  explicit SLAFVrfRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfRegMsgsFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFVrfReg VrfRegMsgs = 2;
  int vrfregmsgs_size() const;
  private:
  int _internal_vrfregmsgs_size() const;
  public:
  void clear_vrfregmsgs();
  ::service_layer::SLAFVrfReg* mutable_vrfregmsgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >*
      mutable_vrfregmsgs();
  private:
  const ::service_layer::SLAFVrfReg& _internal_vrfregmsgs(int index) const;
  ::service_layer::SLAFVrfReg* _internal_add_vrfregmsgs();
  public:
  const ::service_layer::SLAFVrfReg& vrfregmsgs(int index) const;
  ::service_layer::SLAFVrfReg* add_vrfregmsgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >&
      vrfregmsgs() const;

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);
  private:
  ::service_layer::SLRegOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLRegOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg > vrfregmsgs_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsgRes) */ {
 public:
  inline SLAFVrfRegMsgRes() : SLAFVrfRegMsgRes(nullptr) {}
  ~SLAFVrfRegMsgRes() override;
  explicit constexpr SLAFVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsgRes(const SLAFVrfRegMsgRes& from);
  SLAFVrfRegMsgRes(SLAFVrfRegMsgRes&& from) noexcept
    : SLAFVrfRegMsgRes() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsgRes& operator=(const SLAFVrfRegMsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsgRes& operator=(SLAFVrfRegMsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsgRes* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsgRes*>(
               &_SLAFVrfRegMsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLAFVrfRegMsgRes& a, SLAFVrfRegMsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsgRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsgRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsgRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsgRes";
  }
  protected:
  explicit SLAFVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
    kTableFieldNumber = 3,
  };
  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* errstatus_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegMsgRsp) */ {
 public:
  inline SLAFVrfRegMsgRsp() : SLAFVrfRegMsgRsp(nullptr) {}
  ~SLAFVrfRegMsgRsp() override;
  explicit constexpr SLAFVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegMsgRsp(const SLAFVrfRegMsgRsp& from);
  SLAFVrfRegMsgRsp(SLAFVrfRegMsgRsp&& from) noexcept
    : SLAFVrfRegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegMsgRsp& operator=(const SLAFVrfRegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegMsgRsp& operator=(SLAFVrfRegMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegMsgRsp*>(
               &_SLAFVrfRegMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLAFVrfRegMsgRsp& a, SLAFVrfRegMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegMsgRsp";
  }
  protected:
  explicit SLAFVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kStatusSummaryFieldNumber = 1,
  };
  // repeated .service_layer.SLAFVrfRegMsgRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLAFVrfRegMsgRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >*
      mutable_results();
  private:
  const ::service_layer::SLAFVrfRegMsgRes& _internal_results(int index) const;
  ::service_layer::SLAFVrfRegMsgRes* _internal_add_results();
  public:
  const ::service_layer::SLAFVrfRegMsgRes& results(int index) const;
  ::service_layer::SLAFVrfRegMsgRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 1;
  bool has_statussummary() const;
  private:
  bool _internal_has_statussummary() const;
  public:
  void clear_statussummary();
  const ::service_layer::SLErrorStatus& statussummary() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);
  private:
  const ::service_layer::SLErrorStatus& _internal_statussummary() const;
  ::service_layer::SLErrorStatus* _internal_mutable_statussummary();
  public:
  void unsafe_arena_set_allocated_statussummary(
      ::service_layer::SLErrorStatus* statussummary);
  ::service_layer::SLErrorStatus* unsafe_arena_release_statussummary();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegGetMsg) */ {
 public:
  inline SLAFVrfRegGetMsg() : SLAFVrfRegGetMsg(nullptr) {}
  ~SLAFVrfRegGetMsg() override;
  explicit constexpr SLAFVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegGetMsg(const SLAFVrfRegGetMsg& from);
  SLAFVrfRegGetMsg(SLAFVrfRegGetMsg&& from) noexcept
    : SLAFVrfRegGetMsg() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegGetMsg& operator=(const SLAFVrfRegGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegGetMsg& operator=(SLAFVrfRegGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegGetMsg*>(
               &_SLAFVrfRegGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLAFVrfRegGetMsg& a, SLAFVrfRegGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegGetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegGetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegGetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegGetMsg";
  }
  protected:
  explicit SLAFVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetAllFieldNumber = 1,
  };
  // bool GetAll = 1;
  void clear_getall();
  bool getall() const;
  void set_getall(bool value);
  private:
  bool _internal_getall() const;
  void _internal_set_getall(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool getall_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFVrfRegGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFVrfRegGetMsgRsp) */ {
 public:
  inline SLAFVrfRegGetMsgRsp() : SLAFVrfRegGetMsgRsp(nullptr) {}
  ~SLAFVrfRegGetMsgRsp() override;
  explicit constexpr SLAFVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFVrfRegGetMsgRsp(const SLAFVrfRegGetMsgRsp& from);
  SLAFVrfRegGetMsgRsp(SLAFVrfRegGetMsgRsp&& from) noexcept
    : SLAFVrfRegGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFVrfRegGetMsgRsp& operator=(const SLAFVrfRegGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFVrfRegGetMsgRsp& operator=(SLAFVrfRegGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFVrfRegGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFVrfRegGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFVrfRegGetMsgRsp*>(
               &_SLAFVrfRegGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLAFVrfRegGetMsgRsp& a, SLAFVrfRegGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFVrfRegGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFVrfRegGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFVrfRegGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFVrfRegGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFVrfRegGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFVrfRegGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFVrfRegGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFVrfRegGetMsgRsp";
  }
  protected:
  explicit SLAFVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 4,
    kErrStatusFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // repeated .service_layer.SLVrfReg Entries = 4;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::service_layer::SLVrfReg* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
      mutable_entries();
  private:
  const ::service_layer::SLVrfReg& _internal_entries(int index) const;
  ::service_layer::SLVrfReg* _internal_add_entries();
  public:
  const ::service_layer::SLVrfReg& entries(int index) const;
  ::service_layer::SLVrfReg* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
      entries() const;

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint64 ClientID = 2;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFVrfRegGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg > entries_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint64_t clientid_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup_SLPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup.SLPath) */ {
 public:
  inline SLPathGroup_SLPath() : SLPathGroup_SLPath(nullptr) {}
  ~SLPathGroup_SLPath() override;
  explicit constexpr SLPathGroup_SLPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup_SLPath(const SLPathGroup_SLPath& from);
  SLPathGroup_SLPath(SLPathGroup_SLPath&& from) noexcept
    : SLPathGroup_SLPath() {
    *this = ::std::move(from);
  }

  inline SLPathGroup_SLPath& operator=(const SLPathGroup_SLPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup_SLPath& operator=(SLPathGroup_SLPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup_SLPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPathGroup_SLPath* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup_SLPath*>(
               &_SLPathGroup_SLPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLPathGroup_SLPath& a, SLPathGroup_SLPath& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup_SLPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup_SLPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup_SLPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup_SLPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup_SLPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup_SLPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup_SLPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup.SLPath";
  }
  protected:
  explicit SLPathGroup_SLPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // .service_layer.SLRoutePath Path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::service_layer::SLRoutePath& path() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePath* release_path();
  ::service_layer::SLRoutePath* mutable_path();
  void set_allocated_path(::service_layer::SLRoutePath* path);
  private:
  const ::service_layer::SLRoutePath& _internal_path() const;
  ::service_layer::SLRoutePath* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::service_layer::SLRoutePath* path);
  ::service_layer::SLRoutePath* unsafe_arena_release_path();

  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup.SLPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLRoutePath* path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup_SLPathList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup.SLPathList) */ {
 public:
  inline SLPathGroup_SLPathList() : SLPathGroup_SLPathList(nullptr) {}
  ~SLPathGroup_SLPathList() override;
  explicit constexpr SLPathGroup_SLPathList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup_SLPathList(const SLPathGroup_SLPathList& from);
  SLPathGroup_SLPathList(SLPathGroup_SLPathList&& from) noexcept
    : SLPathGroup_SLPathList() {
    *this = ::std::move(from);
  }

  inline SLPathGroup_SLPathList& operator=(const SLPathGroup_SLPathList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup_SLPathList& operator=(SLPathGroup_SLPathList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup_SLPathList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPathGroup_SLPathList* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup_SLPathList*>(
               &_SLPathGroup_SLPathList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLPathGroup_SLPathList& a, SLPathGroup_SLPathList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup_SLPathList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup_SLPathList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup_SLPathList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup_SLPathList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup_SLPathList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup_SLPathList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup_SLPathList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup.SLPathList";
  }
  protected:
  explicit SLPathGroup_SLPathList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 1,
  };
  // repeated .service_layer.SLPathGroup.SLPath Paths = 1;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::service_layer::SLPathGroup_SLPath* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >*
      mutable_paths();
  private:
  const ::service_layer::SLPathGroup_SLPath& _internal_paths(int index) const;
  ::service_layer::SLPathGroup_SLPath* _internal_add_paths();
  public:
  const ::service_layer::SLPathGroup_SLPath& paths(int index) const;
  ::service_layer::SLPathGroup_SLPath* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >&
      paths() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup.SLPathList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath > paths_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroup) */ {
 public:
  inline SLPathGroup() : SLPathGroup(nullptr) {}
  ~SLPathGroup() override;
  explicit constexpr SLPathGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroup(const SLPathGroup& from);
  SLPathGroup(SLPathGroup&& from) noexcept
    : SLPathGroup() {
    *this = ::std::move(from);
  }

  inline SLPathGroup& operator=(const SLPathGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroup& operator=(SLPathGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroup& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kPathList = 3,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLPathGroup* internal_default_instance() {
    return reinterpret_cast<const SLPathGroup*>(
               &_SLPathGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLPathGroup& a, SLPathGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroup";
  }
  protected:
  explicit SLPathGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLPathGroup_SLPath SLPath;
  typedef SLPathGroup_SLPathList SLPathList;

  // accessors -------------------------------------------------------

  enum : int {
    kPgFlagsFieldNumber = 4,
    kPathGroupIdFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kPathListFieldNumber = 3,
  };
  // repeated .service_layer.SLRouteFlags PgFlags = 4;
  int pgflags_size() const;
  private:
  int _internal_pgflags_size() const;
  public:
  void clear_pgflags();
  private:
  ::service_layer::SLRouteFlags _internal_pgflags(int index) const;
  void _internal_add_pgflags(::service_layer::SLRouteFlags value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_pgflags();
  public:
  ::service_layer::SLRouteFlags pgflags(int index) const;
  void set_pgflags(int index, ::service_layer::SLRouteFlags value);
  void add_pgflags(::service_layer::SLRouteFlags value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& pgflags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_pgflags();

  // .service_layer.SLObjectId PathGroupId = 1;
  bool has_pathgroupid() const;
  private:
  bool _internal_has_pathgroupid() const;
  public:
  void clear_pathgroupid();
  const ::service_layer::SLObjectId& pathgroupid() const;
  PROTOBUF_NODISCARD ::service_layer::SLObjectId* release_pathgroupid();
  ::service_layer::SLObjectId* mutable_pathgroupid();
  void set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid);
  private:
  const ::service_layer::SLObjectId& _internal_pathgroupid() const;
  ::service_layer::SLObjectId* _internal_mutable_pathgroupid();
  public:
  void unsafe_arena_set_allocated_pathgroupid(
      ::service_layer::SLObjectId* pathgroupid);
  ::service_layer::SLObjectId* unsafe_arena_release_pathgroupid();

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // .service_layer.SLPathGroup.SLPathList PathList = 3;
  bool has_pathlist() const;
  private:
  bool _internal_has_pathlist() const;
  public:
  void clear_pathlist();
  const ::service_layer::SLPathGroup_SLPathList& pathlist() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroup_SLPathList* release_pathlist();
  ::service_layer::SLPathGroup_SLPathList* mutable_pathlist();
  void set_allocated_pathlist(::service_layer::SLPathGroup_SLPathList* pathlist);
  private:
  const ::service_layer::SLPathGroup_SLPathList& _internal_pathlist() const;
  ::service_layer::SLPathGroup_SLPathList* _internal_mutable_pathlist();
  public:
  void unsafe_arena_set_allocated_pathlist(
      ::service_layer::SLPathGroup_SLPathList* pathlist);
  ::service_layer::SLPathGroup_SLPathList* unsafe_arena_release_pathlist();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroup)
 private:
  class _Internal;
  void set_has_pathlist();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> pgflags_;
  mutable std::atomic<int> _pgflags_cached_byte_size_;
  ::service_layer::SLObjectId* pathgroupid_;
  uint32_t admindistance_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLPathGroup_SLPathList* pathlist_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLMplsEntryKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLMplsEntryKey) */ {
 public:
  inline SLMplsEntryKey() : SLMplsEntryKey(nullptr) {}
  ~SLMplsEntryKey() override;
  explicit constexpr SLMplsEntryKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLMplsEntryKey(const SLMplsEntryKey& from);
  SLMplsEntryKey(SLMplsEntryKey&& from) noexcept
    : SLMplsEntryKey() {
    *this = ::std::move(from);
  }

  inline SLMplsEntryKey& operator=(const SLMplsEntryKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLMplsEntryKey& operator=(SLMplsEntryKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLMplsEntryKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLMplsEntryKey* internal_default_instance() {
    return reinterpret_cast<const SLMplsEntryKey*>(
               &_SLMplsEntryKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLMplsEntryKey& a, SLMplsEntryKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLMplsEntryKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLMplsEntryKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLMplsEntryKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLMplsEntryKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLMplsEntryKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLMplsEntryKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLMplsEntryKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLMplsEntryKey";
  }
  protected:
  explicit SLMplsEntryKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // uint32 Label = 1;
  void clear_label();
  uint32_t label() const;
  void set_label(uint32_t value);
  private:
  uint32_t _internal_label() const;
  void _internal_set_label(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLMplsEntryKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLMplsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLMplsEntry) */ {
 public:
  inline SLMplsEntry() : SLMplsEntry(nullptr) {}
  ~SLMplsEntry() override;
  explicit constexpr SLMplsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLMplsEntry(const SLMplsEntry& from);
  SLMplsEntry(SLMplsEntry&& from) noexcept
    : SLMplsEntry() {
    *this = ::std::move(from);
  }

  inline SLMplsEntry& operator=(const SLMplsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLMplsEntry& operator=(SLMplsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLMplsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLMplsEntry* internal_default_instance() {
    return reinterpret_cast<const SLMplsEntry*>(
               &_SLMplsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLMplsEntry& a, SLMplsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLMplsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLMplsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLMplsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLMplsEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLMplsEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLMplsEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLMplsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLMplsEntry";
  }
  protected:
  explicit SLMplsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathListFieldNumber = 3,
    kMplsFlagsFieldNumber = 4,
    kMplsKeyFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kPriorityFieldNumber = 5,
  };
  // repeated .service_layer.SLRoutePath PathList = 3;
  int pathlist_size() const;
  private:
  int _internal_pathlist_size() const;
  public:
  void clear_pathlist();
  ::service_layer::SLRoutePath* mutable_pathlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
      mutable_pathlist();
  private:
  const ::service_layer::SLRoutePath& _internal_pathlist(int index) const;
  ::service_layer::SLRoutePath* _internal_add_pathlist();
  public:
  const ::service_layer::SLRoutePath& pathlist(int index) const;
  ::service_layer::SLRoutePath* add_pathlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
      pathlist() const;

  // repeated .service_layer.SLRouteFlags MplsFlags = 4;
  int mplsflags_size() const;
  private:
  int _internal_mplsflags_size() const;
  public:
  void clear_mplsflags();
  private:
  ::service_layer::SLRouteFlags _internal_mplsflags(int index) const;
  void _internal_add_mplsflags(::service_layer::SLRouteFlags value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_mplsflags();
  public:
  ::service_layer::SLRouteFlags mplsflags(int index) const;
  void set_mplsflags(int index, ::service_layer::SLRouteFlags value);
  void add_mplsflags(::service_layer::SLRouteFlags value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& mplsflags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_mplsflags();

  // .service_layer.SLMplsEntryKey MplsKey = 1;
  bool has_mplskey() const;
  private:
  bool _internal_has_mplskey() const;
  public:
  void clear_mplskey();
  const ::service_layer::SLMplsEntryKey& mplskey() const;
  PROTOBUF_NODISCARD ::service_layer::SLMplsEntryKey* release_mplskey();
  ::service_layer::SLMplsEntryKey* mutable_mplskey();
  void set_allocated_mplskey(::service_layer::SLMplsEntryKey* mplskey);
  private:
  const ::service_layer::SLMplsEntryKey& _internal_mplskey() const;
  ::service_layer::SLMplsEntryKey* _internal_mutable_mplskey();
  public:
  void unsafe_arena_set_allocated_mplskey(
      ::service_layer::SLMplsEntryKey* mplskey);
  ::service_layer::SLMplsEntryKey* unsafe_arena_release_mplskey();

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // .service_layer.SLUpdatePriority Priority = 5;
  void clear_priority();
  ::service_layer::SLUpdatePriority priority() const;
  void set_priority(::service_layer::SLUpdatePriority value);
  private:
  ::service_layer::SLUpdatePriority _internal_priority() const;
  void _internal_set_priority(::service_layer::SLUpdatePriority value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLMplsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath > pathlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> mplsflags_;
  mutable std::atomic<int> _mplsflags_cached_byte_size_;
  ::service_layer::SLMplsEntryKey* mplskey_;
  uint32_t admindistance_;
  int priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFIPRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFIPRoute) */ {
 public:
  inline SLAFIPRoute() : SLAFIPRoute(nullptr) {}
  ~SLAFIPRoute() override;
  explicit constexpr SLAFIPRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFIPRoute(const SLAFIPRoute& from);
  SLAFIPRoute(SLAFIPRoute&& from) noexcept
    : SLAFIPRoute() {
    *this = ::std::move(from);
  }

  inline SLAFIPRoute& operator=(const SLAFIPRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFIPRoute& operator=(SLAFIPRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFIPRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFIPRoute* internal_default_instance() {
    return reinterpret_cast<const SLAFIPRoute*>(
               &_SLAFIPRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLAFIPRoute& a, SLAFIPRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFIPRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFIPRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFIPRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFIPRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFIPRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFIPRoute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFIPRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFIPRoute";
  }
  protected:
  explicit SLAFIPRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathListFieldNumber = 3,
    kIPRoutePrefixFieldNumber = 1,
    kRouteCommonFieldNumber = 2,
  };
  // repeated .service_layer.SLRoutePath PathList = 3;
  int pathlist_size() const;
  private:
  int _internal_pathlist_size() const;
  public:
  void clear_pathlist();
  ::service_layer::SLRoutePath* mutable_pathlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
      mutable_pathlist();
  private:
  const ::service_layer::SLRoutePath& _internal_pathlist(int index) const;
  ::service_layer::SLRoutePath* _internal_add_pathlist();
  public:
  const ::service_layer::SLRoutePath& pathlist(int index) const;
  ::service_layer::SLRoutePath* add_pathlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
      pathlist() const;

  // .service_layer.SLRoutePrefix IPRoutePrefix = 1;
  bool has_iprouteprefix() const;
  private:
  bool _internal_has_iprouteprefix() const;
  public:
  void clear_iprouteprefix();
  const ::service_layer::SLRoutePrefix& iprouteprefix() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePrefix* release_iprouteprefix();
  ::service_layer::SLRoutePrefix* mutable_iprouteprefix();
  void set_allocated_iprouteprefix(::service_layer::SLRoutePrefix* iprouteprefix);
  private:
  const ::service_layer::SLRoutePrefix& _internal_iprouteprefix() const;
  ::service_layer::SLRoutePrefix* _internal_mutable_iprouteprefix();
  public:
  void unsafe_arena_set_allocated_iprouteprefix(
      ::service_layer::SLRoutePrefix* iprouteprefix);
  ::service_layer::SLRoutePrefix* unsafe_arena_release_iprouteprefix();

  // .service_layer.SLRouteCommon RouteCommon = 2;
  bool has_routecommon() const;
  private:
  bool _internal_has_routecommon() const;
  public:
  void clear_routecommon();
  const ::service_layer::SLRouteCommon& routecommon() const;
  PROTOBUF_NODISCARD ::service_layer::SLRouteCommon* release_routecommon();
  ::service_layer::SLRouteCommon* mutable_routecommon();
  void set_allocated_routecommon(::service_layer::SLRouteCommon* routecommon);
  private:
  const ::service_layer::SLRouteCommon& _internal_routecommon() const;
  ::service_layer::SLRouteCommon* _internal_mutable_routecommon();
  public:
  void unsafe_arena_set_allocated_routecommon(
      ::service_layer::SLRouteCommon* routecommon);
  ::service_layer::SLRouteCommon* unsafe_arena_release_routecommon();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFIPRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath > pathlist_;
  ::service_layer::SLRoutePrefix* iprouteprefix_;
  ::service_layer::SLRouteCommon* routecommon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFObject) */ {
 public:
  inline SLAFObject() : SLAFObject(nullptr) {}
  ~SLAFObject() override;
  explicit constexpr SLAFObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFObject(const SLAFObject& from);
  SLAFObject(SLAFObject&& from) noexcept
    : SLAFObject() {
    *this = ::std::move(from);
  }

  inline SLAFObject& operator=(const SLAFObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFObject& operator=(SLAFObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFObject& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kIPRoute = 1,
    kMplsLabel = 2,
    kPathGroup = 3,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLAFObject* internal_default_instance() {
    return reinterpret_cast<const SLAFObject*>(
               &_SLAFObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLAFObject& a, SLAFObject& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFObject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFObject";
  }
  protected:
  explicit SLAFObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPRouteFieldNumber = 1,
    kMplsLabelFieldNumber = 2,
    kPathGroupFieldNumber = 3,
  };
  // .service_layer.SLAFIPRoute IPRoute = 1;
  bool has_iproute() const;
  private:
  bool _internal_has_iproute() const;
  public:
  void clear_iproute();
  const ::service_layer::SLAFIPRoute& iproute() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFIPRoute* release_iproute();
  ::service_layer::SLAFIPRoute* mutable_iproute();
  void set_allocated_iproute(::service_layer::SLAFIPRoute* iproute);
  private:
  const ::service_layer::SLAFIPRoute& _internal_iproute() const;
  ::service_layer::SLAFIPRoute* _internal_mutable_iproute();
  public:
  void unsafe_arena_set_allocated_iproute(
      ::service_layer::SLAFIPRoute* iproute);
  ::service_layer::SLAFIPRoute* unsafe_arena_release_iproute();

  // .service_layer.SLMplsEntry MplsLabel = 2;
  bool has_mplslabel() const;
  private:
  bool _internal_has_mplslabel() const;
  public:
  void clear_mplslabel();
  const ::service_layer::SLMplsEntry& mplslabel() const;
  PROTOBUF_NODISCARD ::service_layer::SLMplsEntry* release_mplslabel();
  ::service_layer::SLMplsEntry* mutable_mplslabel();
  void set_allocated_mplslabel(::service_layer::SLMplsEntry* mplslabel);
  private:
  const ::service_layer::SLMplsEntry& _internal_mplslabel() const;
  ::service_layer::SLMplsEntry* _internal_mutable_mplslabel();
  public:
  void unsafe_arena_set_allocated_mplslabel(
      ::service_layer::SLMplsEntry* mplslabel);
  ::service_layer::SLMplsEntry* unsafe_arena_release_mplslabel();

  // .service_layer.SLPathGroup PathGroup = 3;
  bool has_pathgroup() const;
  private:
  bool _internal_has_pathgroup() const;
  public:
  void clear_pathgroup();
  const ::service_layer::SLPathGroup& pathgroup() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroup* release_pathgroup();
  ::service_layer::SLPathGroup* mutable_pathgroup();
  void set_allocated_pathgroup(::service_layer::SLPathGroup* pathgroup);
  private:
  const ::service_layer::SLPathGroup& _internal_pathgroup() const;
  ::service_layer::SLPathGroup* _internal_mutable_pathgroup();
  public:
  void unsafe_arena_set_allocated_pathgroup(
      ::service_layer::SLPathGroup* pathgroup);
  ::service_layer::SLPathGroup* unsafe_arena_release_pathgroup();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFObject)
 private:
  class _Internal;
  void set_has_iproute();
  void set_has_mplslabel();
  void set_has_pathgroup();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFIPRoute* iproute_;
    ::service_layer::SLMplsEntry* mplslabel_;
    ::service_layer::SLPathGroup* pathgroup_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFOpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFOpMsg) */ {
 public:
  inline SLAFOpMsg() : SLAFOpMsg(nullptr) {}
  ~SLAFOpMsg() override;
  explicit constexpr SLAFOpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFOpMsg(const SLAFOpMsg& from);
  SLAFOpMsg(SLAFOpMsg&& from) noexcept
    : SLAFOpMsg() {
    *this = ::std::move(from);
  }

  inline SLAFOpMsg& operator=(const SLAFOpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFOpMsg& operator=(SLAFOpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFOpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFOpMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFOpMsg*>(
               &_SLAFOpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLAFOpMsg& a, SLAFOpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFOpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFOpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFOpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFOpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFOpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFOpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFOpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFOpMsg";
  }
  protected:
  explicit SLAFOpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckPermitsFieldNumber = 4,
    kAFObjectFieldNumber = 1,
    kOperationIDFieldNumber = 2,
    kAckTypeFieldNumber = 3,
    kAckCadenceFieldNumber = 5,
  };
  // repeated .service_layer.SLRspACKPermit AckPermits = 4;
  int ackpermits_size() const;
  private:
  int _internal_ackpermits_size() const;
  public:
  void clear_ackpermits();
  private:
  ::service_layer::SLRspACKPermit _internal_ackpermits(int index) const;
  void _internal_add_ackpermits(::service_layer::SLRspACKPermit value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ackpermits();
  public:
  ::service_layer::SLRspACKPermit ackpermits(int index) const;
  void set_ackpermits(int index, ::service_layer::SLRspACKPermit value);
  void add_ackpermits(::service_layer::SLRspACKPermit value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ackpermits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ackpermits();

  // .service_layer.SLAFObject AFObject = 1;
  bool has_afobject() const;
  private:
  bool _internal_has_afobject() const;
  public:
  void clear_afobject();
  const ::service_layer::SLAFObject& afobject() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObject* release_afobject();
  ::service_layer::SLAFObject* mutable_afobject();
  void set_allocated_afobject(::service_layer::SLAFObject* afobject);
  private:
  const ::service_layer::SLAFObject& _internal_afobject() const;
  ::service_layer::SLAFObject* _internal_mutable_afobject();
  public:
  void unsafe_arena_set_allocated_afobject(
      ::service_layer::SLAFObject* afobject);
  ::service_layer::SLAFObject* unsafe_arena_release_afobject();

  // uint64 OperationID = 2;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLRspACKType AckType = 3;
  void clear_acktype();
  ::service_layer::SLRspACKType acktype() const;
  void set_acktype(::service_layer::SLRspACKType value);
  private:
  ::service_layer::SLRspACKType _internal_acktype() const;
  void _internal_set_acktype(::service_layer::SLRspACKType value);
  public:

  // .service_layer.SLRspAckCadence AckCadence = 5;
  void clear_ackcadence();
  ::service_layer::SLRspAckCadence ackcadence() const;
  void set_ackcadence(::service_layer::SLRspAckCadence value);
  private:
  ::service_layer::SLRspAckCadence _internal_ackcadence() const;
  void _internal_set_ackcadence(::service_layer::SLRspAckCadence value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFOpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ackpermits_;
  mutable std::atomic<int> _ackpermits_cached_byte_size_;
  ::service_layer::SLAFObject* afobject_;
  uint64_t operationid_;
  int acktype_;
  int ackcadence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFClientIDList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFClientIDList) */ {
 public:
  inline SLAFClientIDList() : SLAFClientIDList(nullptr) {}
  ~SLAFClientIDList() override;
  explicit constexpr SLAFClientIDList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFClientIDList(const SLAFClientIDList& from);
  SLAFClientIDList(SLAFClientIDList&& from) noexcept
    : SLAFClientIDList() {
    *this = ::std::move(from);
  }

  inline SLAFClientIDList& operator=(const SLAFClientIDList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFClientIDList& operator=(SLAFClientIDList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFClientIDList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFClientIDList* internal_default_instance() {
    return reinterpret_cast<const SLAFClientIDList*>(
               &_SLAFClientIDList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLAFClientIDList& a, SLAFClientIDList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFClientIDList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFClientIDList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFClientIDList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFClientIDList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFClientIDList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFClientIDList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFClientIDList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFClientIDList";
  }
  protected:
  explicit SLAFClientIDList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIDListFieldNumber = 1,
  };
  // repeated uint64 ClientIDList = 1;
  int clientidlist_size() const;
  private:
  int _internal_clientidlist_size() const;
  public:
  void clear_clientidlist();
  private:
  uint64_t _internal_clientidlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_clientidlist() const;
  void _internal_add_clientidlist(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_clientidlist();
  public:
  uint64_t clientidlist(int index) const;
  void set_clientidlist(int index, uint64_t value);
  void add_clientidlist(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      clientidlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_clientidlist();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFClientIDList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > clientidlist_;
  mutable std::atomic<int> _clientidlist_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLTableTypeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLTableTypeList) */ {
 public:
  inline SLTableTypeList() : SLTableTypeList(nullptr) {}
  ~SLTableTypeList() override;
  explicit constexpr SLTableTypeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLTableTypeList(const SLTableTypeList& from);
  SLTableTypeList(SLTableTypeList&& from) noexcept
    : SLTableTypeList() {
    *this = ::std::move(from);
  }

  inline SLTableTypeList& operator=(const SLTableTypeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLTableTypeList& operator=(SLTableTypeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLTableTypeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLTableTypeList* internal_default_instance() {
    return reinterpret_cast<const SLTableTypeList*>(
               &_SLTableTypeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLTableTypeList& a, SLTableTypeList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLTableTypeList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLTableTypeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLTableTypeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLTableTypeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLTableTypeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLTableTypeList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLTableTypeList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLTableTypeList";
  }
  protected:
  explicit SLTableTypeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 1,
  };
  // repeated .service_layer.SLTableType Table = 1;
  int table_size() const;
  private:
  int _internal_table_size() const;
  public:
  void clear_table();
  private:
  ::service_layer::SLTableType _internal_table(int index) const;
  void _internal_add_table(::service_layer::SLTableType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_table();
  public:
  ::service_layer::SLTableType table(int index) const;
  void set_table(int index, ::service_layer::SLTableType value);
  void add_table(::service_layer::SLTableType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& table() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_table();

  // @@protoc_insertion_point(class_scope:service_layer.SLTableTypeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> table_;
  mutable std::atomic<int> _table_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFObjectKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFObjectKey) */ {
 public:
  inline SLAFObjectKey() : SLAFObjectKey(nullptr) {}
  ~SLAFObjectKey() override;
  explicit constexpr SLAFObjectKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFObjectKey(const SLAFObjectKey& from);
  SLAFObjectKey(SLAFObjectKey&& from) noexcept
    : SLAFObjectKey() {
    *this = ::std::move(from);
  }

  inline SLAFObjectKey& operator=(const SLAFObjectKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFObjectKey& operator=(SLAFObjectKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFObjectKey& default_instance() {
    return *internal_default_instance();
  }
  enum KeyCase {
    kIPRoutePrefix = 1,
    kMplsLabel = 2,
    kPathGroupId = 3,
    KEY_NOT_SET = 0,
  };

  static inline const SLAFObjectKey* internal_default_instance() {
    return reinterpret_cast<const SLAFObjectKey*>(
               &_SLAFObjectKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLAFObjectKey& a, SLAFObjectKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFObjectKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFObjectKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFObjectKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFObjectKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFObjectKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFObjectKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFObjectKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFObjectKey";
  }
  protected:
  explicit SLAFObjectKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPRoutePrefixFieldNumber = 1,
    kMplsLabelFieldNumber = 2,
    kPathGroupIdFieldNumber = 3,
  };
  // .service_layer.SLRoutePrefix IPRoutePrefix = 1;
  bool has_iprouteprefix() const;
  private:
  bool _internal_has_iprouteprefix() const;
  public:
  void clear_iprouteprefix();
  const ::service_layer::SLRoutePrefix& iprouteprefix() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePrefix* release_iprouteprefix();
  ::service_layer::SLRoutePrefix* mutable_iprouteprefix();
  void set_allocated_iprouteprefix(::service_layer::SLRoutePrefix* iprouteprefix);
  private:
  const ::service_layer::SLRoutePrefix& _internal_iprouteprefix() const;
  ::service_layer::SLRoutePrefix* _internal_mutable_iprouteprefix();
  public:
  void unsafe_arena_set_allocated_iprouteprefix(
      ::service_layer::SLRoutePrefix* iprouteprefix);
  ::service_layer::SLRoutePrefix* unsafe_arena_release_iprouteprefix();

  // .service_layer.SLMplsEntryKey MplsLabel = 2;
  bool has_mplslabel() const;
  private:
  bool _internal_has_mplslabel() const;
  public:
  void clear_mplslabel();
  const ::service_layer::SLMplsEntryKey& mplslabel() const;
  PROTOBUF_NODISCARD ::service_layer::SLMplsEntryKey* release_mplslabel();
  ::service_layer::SLMplsEntryKey* mutable_mplslabel();
  void set_allocated_mplslabel(::service_layer::SLMplsEntryKey* mplslabel);
  private:
  const ::service_layer::SLMplsEntryKey& _internal_mplslabel() const;
  ::service_layer::SLMplsEntryKey* _internal_mutable_mplslabel();
  public:
  void unsafe_arena_set_allocated_mplslabel(
      ::service_layer::SLMplsEntryKey* mplslabel);
  ::service_layer::SLMplsEntryKey* unsafe_arena_release_mplslabel();

  // .service_layer.SLObjectId PathGroupId = 3;
  bool has_pathgroupid() const;
  private:
  bool _internal_has_pathgroupid() const;
  public:
  void clear_pathgroupid();
  const ::service_layer::SLObjectId& pathgroupid() const;
  PROTOBUF_NODISCARD ::service_layer::SLObjectId* release_pathgroupid();
  ::service_layer::SLObjectId* mutable_pathgroupid();
  void set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid);
  private:
  const ::service_layer::SLObjectId& _internal_pathgroupid() const;
  ::service_layer::SLObjectId* _internal_mutable_pathgroupid();
  public:
  void unsafe_arena_set_allocated_pathgroupid(
      ::service_layer::SLObjectId* pathgroupid);
  ::service_layer::SLObjectId* unsafe_arena_release_pathgroupid();

  void clear_key();
  KeyCase key_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFObjectKey)
 private:
  class _Internal;
  void set_has_iprouteprefix();
  void set_has_mplslabel();
  void set_has_pathgroupid();

  inline bool has_key() const;
  inline void clear_has_key();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KeyUnion {
    constexpr KeyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLRoutePrefix* iprouteprefix_;
    ::service_layer::SLMplsEntryKey* mplslabel_;
    ::service_layer::SLObjectId* pathgroupid_;
  } key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMatch) */ {
 public:
  inline SLAFGetMatch() : SLAFGetMatch(nullptr) {}
  ~SLAFGetMatch() override;
  explicit constexpr SLAFGetMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMatch(const SLAFGetMatch& from);
  SLAFGetMatch(SLAFGetMatch&& from) noexcept
    : SLAFGetMatch() {
    *this = ::std::move(from);
  }

  inline SLAFGetMatch& operator=(const SLAFGetMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMatch& operator=(SLAFGetMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMatch& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kKey = 1,
    kPathGroupRegex = 2,
    kVxlanVniId = 3,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLAFGetMatch* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMatch*>(
               &_SLAFGetMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SLAFGetMatch& a, SLAFGetMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMatch";
  }
  protected:
  explicit SLAFGetMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kPathGroupRegexFieldNumber = 2,
    kVxlanVniIdFieldNumber = 3,
  };
  // .service_layer.SLAFObjectKey Key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLAFObjectKey& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObjectKey* release_key();
  ::service_layer::SLAFObjectKey* mutable_key();
  void set_allocated_key(::service_layer::SLAFObjectKey* key);
  private:
  const ::service_layer::SLAFObjectKey& _internal_key() const;
  ::service_layer::SLAFObjectKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLAFObjectKey* key);
  ::service_layer::SLAFObjectKey* unsafe_arena_release_key();

  // string PathGroupRegex = 2;
  bool has_pathgroupregex() const;
  private:
  bool _internal_has_pathgroupregex() const;
  public:
  void clear_pathgroupregex();
  const std::string& pathgroupregex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathgroupregex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathgroupregex();
  PROTOBUF_NODISCARD std::string* release_pathgroupregex();
  void set_allocated_pathgroupregex(std::string* pathgroupregex);
  private:
  const std::string& _internal_pathgroupregex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathgroupregex(const std::string& value);
  std::string* _internal_mutable_pathgroupregex();
  public:

  // uint32 VxlanVniId = 3;
  bool has_vxlanvniid() const;
  private:
  bool _internal_has_vxlanvniid() const;
  public:
  void clear_vxlanvniid();
  uint32_t vxlanvniid() const;
  void set_vxlanvniid(uint32_t value);
  private:
  uint32_t _internal_vxlanvniid() const;
  void _internal_set_vxlanvniid(uint32_t value);
  public:

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMatch)
 private:
  class _Internal;
  void set_has_key();
  void set_has_pathgroupregex();
  void set_has_vxlanvniid();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFObjectKey* key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathgroupregex_;
    uint32_t vxlanvniid_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMatchList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMatchList) */ {
 public:
  inline SLAFGetMatchList() : SLAFGetMatchList(nullptr) {}
  ~SLAFGetMatchList() override;
  explicit constexpr SLAFGetMatchList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMatchList(const SLAFGetMatchList& from);
  SLAFGetMatchList(SLAFGetMatchList&& from) noexcept
    : SLAFGetMatchList() {
    *this = ::std::move(from);
  }

  inline SLAFGetMatchList& operator=(const SLAFGetMatchList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMatchList& operator=(SLAFGetMatchList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMatchList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMatchList* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMatchList*>(
               &_SLAFGetMatchList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SLAFGetMatchList& a, SLAFGetMatchList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMatchList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMatchList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMatchList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMatchList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMatchList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMatchList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMatchList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMatchList";
  }
  protected:
  explicit SLAFGetMatchList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 1,
  };
  // repeated .service_layer.SLAFGetMatch Match = 1;
  int match_size() const;
  private:
  int _internal_match_size() const;
  public:
  void clear_match();
  ::service_layer::SLAFGetMatch* mutable_match(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMatch >*
      mutable_match();
  private:
  const ::service_layer::SLAFGetMatch& _internal_match(int index) const;
  ::service_layer::SLAFGetMatch* _internal_add_match();
  public:
  const ::service_layer::SLAFGetMatch& match(int index) const;
  ::service_layer::SLAFGetMatch* add_match();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMatch >&
      match() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMatchList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMatch > match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsg) */ {
 public:
  inline SLAFGetMsg() : SLAFGetMsg(nullptr) {}
  ~SLAFGetMsg() override;
  explicit constexpr SLAFGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsg(const SLAFGetMsg& from);
  SLAFGetMsg(SLAFGetMsg&& from) noexcept
    : SLAFGetMsg() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsg& operator=(const SLAFGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsg& operator=(SLAFGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsg& default_instance() {
    return *internal_default_instance();
  }
  enum ClientCase {
    kClientIDList = 2,
    kAllClients = 3,
    CLIENT_NOT_SET = 0,
  };

  enum MatchCase {
    kTableList = 4,
    kRouteMatchList = 5,
    MATCH_NOT_SET = 0,
  };

  static inline const SLAFGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsg*>(
               &_SLAFGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SLAFGetMsg& a, SLAFGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsg";
  }
  protected:
  explicit SLAFGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kClientIDListFieldNumber = 2,
    kAllClientsFieldNumber = 3,
    kTableListFieldNumber = 4,
    kRouteMatchListFieldNumber = 5,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLAFClientIDList ClientIDList = 2;
  bool has_clientidlist() const;
  private:
  bool _internal_has_clientidlist() const;
  public:
  void clear_clientidlist();
  const ::service_layer::SLAFClientIDList& clientidlist() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFClientIDList* release_clientidlist();
  ::service_layer::SLAFClientIDList* mutable_clientidlist();
  void set_allocated_clientidlist(::service_layer::SLAFClientIDList* clientidlist);
  private:
  const ::service_layer::SLAFClientIDList& _internal_clientidlist() const;
  ::service_layer::SLAFClientIDList* _internal_mutable_clientidlist();
  public:
  void unsafe_arena_set_allocated_clientidlist(
      ::service_layer::SLAFClientIDList* clientidlist);
  ::service_layer::SLAFClientIDList* unsafe_arena_release_clientidlist();

  // bool AllClients = 3;
  bool has_allclients() const;
  private:
  bool _internal_has_allclients() const;
  public:
  void clear_allclients();
  bool allclients() const;
  void set_allclients(bool value);
  private:
  bool _internal_allclients() const;
  void _internal_set_allclients(bool value);
  public:

  // .service_layer.SLTableTypeList TableList = 4;
  bool has_tablelist() const;
  private:
  bool _internal_has_tablelist() const;
  public:
  void clear_tablelist();
  const ::service_layer::SLTableTypeList& tablelist() const;
  PROTOBUF_NODISCARD ::service_layer::SLTableTypeList* release_tablelist();
  ::service_layer::SLTableTypeList* mutable_tablelist();
  void set_allocated_tablelist(::service_layer::SLTableTypeList* tablelist);
  private:
  const ::service_layer::SLTableTypeList& _internal_tablelist() const;
  ::service_layer::SLTableTypeList* _internal_mutable_tablelist();
  public:
  void unsafe_arena_set_allocated_tablelist(
      ::service_layer::SLTableTypeList* tablelist);
  ::service_layer::SLTableTypeList* unsafe_arena_release_tablelist();

  // .service_layer.SLAFGetMatchList RouteMatchList = 5;
  bool has_routematchlist() const;
  private:
  bool _internal_has_routematchlist() const;
  public:
  void clear_routematchlist();
  const ::service_layer::SLAFGetMatchList& routematchlist() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFGetMatchList* release_routematchlist();
  ::service_layer::SLAFGetMatchList* mutable_routematchlist();
  void set_allocated_routematchlist(::service_layer::SLAFGetMatchList* routematchlist);
  private:
  const ::service_layer::SLAFGetMatchList& _internal_routematchlist() const;
  ::service_layer::SLAFGetMatchList* _internal_mutable_routematchlist();
  public:
  void unsafe_arena_set_allocated_routematchlist(
      ::service_layer::SLAFGetMatchList* routematchlist);
  ::service_layer::SLAFGetMatchList* unsafe_arena_release_routematchlist();

  void clear_client();
  ClientCase client_case() const;
  void clear_match();
  MatchCase match_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsg)
 private:
  class _Internal;
  void set_has_clientidlist();
  void set_has_allclients();
  void set_has_tablelist();
  void set_has_routematchlist();

  inline bool has_client() const;
  inline void clear_has_client();

  inline bool has_match() const;
  inline void clear_has_match();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  union ClientUnion {
    constexpr ClientUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFClientIDList* clientidlist_;
    bool allclients_;
  } client_;
  union MatchUnion {
    constexpr MatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLTableTypeList* tablelist_;
    ::service_layer::SLAFGetMatchList* routematchlist_;
  } match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsgRspEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsgRspEntry) */ {
 public:
  inline SLAFGetMsgRspEntry() : SLAFGetMsgRspEntry(nullptr) {}
  ~SLAFGetMsgRspEntry() override;
  explicit constexpr SLAFGetMsgRspEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsgRspEntry(const SLAFGetMsgRspEntry& from);
  SLAFGetMsgRspEntry(SLAFGetMsgRspEntry&& from) noexcept
    : SLAFGetMsgRspEntry() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsgRspEntry& operator=(const SLAFGetMsgRspEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsgRspEntry& operator=(SLAFGetMsgRspEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsgRspEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMsgRspEntry* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsgRspEntry*>(
               &_SLAFGetMsgRspEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SLAFGetMsgRspEntry& a, SLAFGetMsgRspEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsgRspEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsgRspEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsgRspEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsgRspEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsgRspEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsgRspEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsgRspEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsgRspEntry";
  }
  protected:
  explicit SLAFGetMsgRspEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFOpMsgFieldNumber = 1,
    kFIBStatusFieldNumber = 2,
  };
  // .service_layer.SLAFOpMsg AFOpMsg = 1;
  bool has_afopmsg() const;
  private:
  bool _internal_has_afopmsg() const;
  public:
  void clear_afopmsg();
  const ::service_layer::SLAFOpMsg& afopmsg() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFOpMsg* release_afopmsg();
  ::service_layer::SLAFOpMsg* mutable_afopmsg();
  void set_allocated_afopmsg(::service_layer::SLAFOpMsg* afopmsg);
  private:
  const ::service_layer::SLAFOpMsg& _internal_afopmsg() const;
  ::service_layer::SLAFOpMsg* _internal_mutable_afopmsg();
  public:
  void unsafe_arena_set_allocated_afopmsg(
      ::service_layer::SLAFOpMsg* afopmsg);
  ::service_layer::SLAFOpMsg* unsafe_arena_release_afopmsg();

  // .service_layer.SLAFFibStatus FIBStatus = 2;
  void clear_fibstatus();
  ::service_layer::SLAFFibStatus fibstatus() const;
  void set_fibstatus(::service_layer::SLAFFibStatus value);
  private:
  ::service_layer::SLAFFibStatus _internal_fibstatus() const;
  void _internal_set_fibstatus(::service_layer::SLAFFibStatus value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsgRspEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFOpMsg* afopmsg_;
  int fibstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFGetMsgRsp) */ {
 public:
  inline SLAFGetMsgRsp() : SLAFGetMsgRsp(nullptr) {}
  ~SLAFGetMsgRsp() override;
  explicit constexpr SLAFGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFGetMsgRsp(const SLAFGetMsgRsp& from);
  SLAFGetMsgRsp(SLAFGetMsgRsp&& from) noexcept
    : SLAFGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFGetMsgRsp& operator=(const SLAFGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFGetMsgRsp& operator=(SLAFGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFGetMsgRsp*>(
               &_SLAFGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SLAFGetMsgRsp& a, SLAFGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFGetMsgRsp";
  }
  protected:
  explicit SLAFGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFListFieldNumber = 4,
    kVrfNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
    kClientIDFieldNumber = 3,
  };
  // repeated .service_layer.SLAFGetMsgRspEntry AFList = 4;
  int aflist_size() const;
  private:
  int _internal_aflist_size() const;
  public:
  void clear_aflist();
  ::service_layer::SLAFGetMsgRspEntry* mutable_aflist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >*
      mutable_aflist();
  private:
  const ::service_layer::SLAFGetMsgRspEntry& _internal_aflist(int index) const;
  ::service_layer::SLAFGetMsgRspEntry* _internal_add_aflist();
  public:
  const ::service_layer::SLAFGetMsgRspEntry& aflist(int index) const;
  ::service_layer::SLAFGetMsgRspEntry* add_aflist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >&
      aflist() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint64 ClientID = 3;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry > aflist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint64_t clientid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFMsg) */ {
 public:
  inline SLAFMsg() : SLAFMsg(nullptr) {}
  ~SLAFMsg() override;
  explicit constexpr SLAFMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFMsg(const SLAFMsg& from);
  SLAFMsg(SLAFMsg&& from) noexcept
    : SLAFMsg() {
    *this = ::std::move(from);
  }

  inline SLAFMsg& operator=(const SLAFMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFMsg& operator=(SLAFMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFMsg*>(
               &_SLAFMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SLAFMsg& a, SLAFMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFMsg";
  }
  protected:
  explicit SLAFMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpListFieldNumber = 3,
    kVrfNameFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFOpMsg OpList = 3;
  int oplist_size() const;
  private:
  int _internal_oplist_size() const;
  public:
  void clear_oplist();
  ::service_layer::SLAFOpMsg* mutable_oplist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOpMsg >*
      mutable_oplist();
  private:
  const ::service_layer::SLAFOpMsg& _internal_oplist(int index) const;
  ::service_layer::SLAFOpMsg* _internal_add_oplist();
  public:
  const ::service_layer::SLAFOpMsg& oplist(int index) const;
  ::service_layer::SLAFOpMsg* add_oplist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOpMsg >&
      oplist() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLObjectOp Oper = 1;
  void clear_oper();
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);
  private:
  ::service_layer::SLObjectOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOpMsg > oplist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFRes) */ {
 public:
  inline SLAFRes() : SLAFRes(nullptr) {}
  ~SLAFRes() override;
  explicit constexpr SLAFRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFRes(const SLAFRes& from);
  SLAFRes(SLAFRes&& from) noexcept
    : SLAFRes() {
    *this = ::std::move(from);
  }

  inline SLAFRes& operator=(const SLAFRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFRes& operator=(SLAFRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFRes* internal_default_instance() {
    return reinterpret_cast<const SLAFRes*>(
               &_SLAFRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SLAFRes& a, SLAFRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFRes";
  }
  protected:
  explicit SLAFRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorStringFieldNumber = 5,
    kStatusFieldNumber = 1,
    kKeyFieldNumber = 2,
    kOperationIDFieldNumber = 3,
    kFIBStatusFieldNumber = 4,
  };
  // string ErrorString = 5;
  void clear_errorstring();
  const std::string& errorstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errorstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errorstring();
  PROTOBUF_NODISCARD std::string* release_errorstring();
  void set_allocated_errorstring(std::string* errorstring);
  private:
  const std::string& _internal_errorstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errorstring(const std::string& value);
  std::string* _internal_mutable_errorstring();
  public:

  // .service_layer.SLErrorStatus Status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::service_layer::SLErrorStatus& status() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_status();
  ::service_layer::SLErrorStatus* mutable_status();
  void set_allocated_status(::service_layer::SLErrorStatus* status);
  private:
  const ::service_layer::SLErrorStatus& _internal_status() const;
  ::service_layer::SLErrorStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::service_layer::SLErrorStatus* status);
  ::service_layer::SLErrorStatus* unsafe_arena_release_status();

  // .service_layer.SLAFObjectKey Key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLAFObjectKey& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObjectKey* release_key();
  ::service_layer::SLAFObjectKey* mutable_key();
  void set_allocated_key(::service_layer::SLAFObjectKey* key);
  private:
  const ::service_layer::SLAFObjectKey& _internal_key() const;
  ::service_layer::SLAFObjectKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLAFObjectKey* key);
  ::service_layer::SLAFObjectKey* unsafe_arena_release_key();

  // uint64 OperationID = 3;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLAFFibStatus FIBStatus = 4;
  void clear_fibstatus();
  ::service_layer::SLAFFibStatus fibstatus() const;
  void set_fibstatus(::service_layer::SLAFFibStatus value);
  private:
  ::service_layer::SLAFFibStatus _internal_fibstatus() const;
  void _internal_set_fibstatus(::service_layer::SLAFFibStatus value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errorstring_;
  ::service_layer::SLErrorStatus* status_;
  ::service_layer::SLAFObjectKey* key_;
  uint64_t operationid_;
  int fibstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFMsgRsp) */ {
 public:
  inline SLAFMsgRsp() : SLAFMsgRsp(nullptr) {}
  ~SLAFMsgRsp() override;
  explicit constexpr SLAFMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFMsgRsp(const SLAFMsgRsp& from);
  SLAFMsgRsp(SLAFMsgRsp&& from) noexcept
    : SLAFMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLAFMsgRsp& operator=(const SLAFMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFMsgRsp& operator=(SLAFMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFMsgRsp*>(
               &_SLAFMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SLAFMsgRsp& a, SLAFMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFMsgRsp";
  }
  protected:
  explicit SLAFMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kVrfNameFieldNumber = 1,
  };
  // repeated .service_layer.SLAFRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLAFRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >*
      mutable_results();
  private:
  const ::service_layer::SLAFRes& _internal_results(int index) const;
  ::service_layer::SLAFRes* _internal_add_results();
  public:
  const ::service_layer::SLAFRes& results(int index) const;
  ::service_layer::SLAFRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >&
      results() const;

  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes > results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFRedistRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFRedistRegMsg) */ {
 public:
  inline SLAFRedistRegMsg() : SLAFRedistRegMsg(nullptr) {}
  ~SLAFRedistRegMsg() override;
  explicit constexpr SLAFRedistRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFRedistRegMsg(const SLAFRedistRegMsg& from);
  SLAFRedistRegMsg(SLAFRedistRegMsg&& from) noexcept
    : SLAFRedistRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFRedistRegMsg& operator=(const SLAFRedistRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFRedistRegMsg& operator=(SLAFRedistRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFRedistRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFRedistRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFRedistRegMsg*>(
               &_SLAFRedistRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SLAFRedistRegMsg& a, SLAFRedistRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFRedistRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFRedistRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFRedistRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFRedistRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFRedistRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFRedistRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFRedistRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFRedistRegMsg";
  }
  protected:
  explicit SLAFRedistRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcProtoFieldNumber = 1,
    kSrcProtoTagFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // string SrcProto = 1;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 2;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // .service_layer.SLTableType Table = 3;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFRedistRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegKey_SLNextHopKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegKey.SLNextHopKey) */ {
 public:
  inline SLAFNextHopRegKey_SLNextHopKey() : SLAFNextHopRegKey_SLNextHopKey(nullptr) {}
  ~SLAFNextHopRegKey_SLNextHopKey() override;
  explicit constexpr SLAFNextHopRegKey_SLNextHopKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegKey_SLNextHopKey(const SLAFNextHopRegKey_SLNextHopKey& from);
  SLAFNextHopRegKey_SLNextHopKey(SLAFNextHopRegKey_SLNextHopKey&& from) noexcept
    : SLAFNextHopRegKey_SLNextHopKey() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegKey_SLNextHopKey& operator=(const SLAFNextHopRegKey_SLNextHopKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegKey_SLNextHopKey& operator=(SLAFNextHopRegKey_SLNextHopKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegKey_SLNextHopKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNextHopRegKey_SLNextHopKey* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegKey_SLNextHopKey*>(
               &_SLAFNextHopRegKey_SLNextHopKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SLAFNextHopRegKey_SLNextHopKey& a, SLAFNextHopRegKey_SLNextHopKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegKey_SLNextHopKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegKey_SLNextHopKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegKey_SLNextHopKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegKey_SLNextHopKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegKey_SLNextHopKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegKey_SLNextHopKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegKey_SLNextHopKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegKey.SLNextHopKey";
  }
  protected:
  explicit SLAFNextHopRegKey_SLNextHopKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopIPFieldNumber = 1,
    kExactMatchFieldNumber = 2,
    kAllowDefaultFieldNumber = 3,
    kRecurseFieldNumber = 4,
  };
  // .service_layer.SLRoutePrefix NextHopIP = 1;
  bool has_nexthopip() const;
  private:
  bool _internal_has_nexthopip() const;
  public:
  void clear_nexthopip();
  const ::service_layer::SLRoutePrefix& nexthopip() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePrefix* release_nexthopip();
  ::service_layer::SLRoutePrefix* mutable_nexthopip();
  void set_allocated_nexthopip(::service_layer::SLRoutePrefix* nexthopip);
  private:
  const ::service_layer::SLRoutePrefix& _internal_nexthopip() const;
  ::service_layer::SLRoutePrefix* _internal_mutable_nexthopip();
  public:
  void unsafe_arena_set_allocated_nexthopip(
      ::service_layer::SLRoutePrefix* nexthopip);
  ::service_layer::SLRoutePrefix* unsafe_arena_release_nexthopip();

  // bool ExactMatch = 2;
  void clear_exactmatch();
  bool exactmatch() const;
  void set_exactmatch(bool value);
  private:
  bool _internal_exactmatch() const;
  void _internal_set_exactmatch(bool value);
  public:

  // bool AllowDefault = 3;
  void clear_allowdefault();
  bool allowdefault() const;
  void set_allowdefault(bool value);
  private:
  bool _internal_allowdefault() const;
  void _internal_set_allowdefault(bool value);
  public:

  // bool Recurse = 4;
  void clear_recurse();
  bool recurse() const;
  void set_recurse(bool value);
  private:
  bool _internal_recurse() const;
  void _internal_set_recurse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegKey.SLNextHopKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLRoutePrefix* nexthopip_;
  bool exactmatch_;
  bool allowdefault_;
  bool recurse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegKey) */ {
 public:
  inline SLAFNextHopRegKey() : SLAFNextHopRegKey(nullptr) {}
  ~SLAFNextHopRegKey() override;
  explicit constexpr SLAFNextHopRegKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegKey(const SLAFNextHopRegKey& from);
  SLAFNextHopRegKey(SLAFNextHopRegKey&& from) noexcept
    : SLAFNextHopRegKey() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegKey& operator=(const SLAFNextHopRegKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegKey& operator=(SLAFNextHopRegKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegKey& default_instance() {
    return *internal_default_instance();
  }
  enum NexthopkeyCase {
    kNextHop = 1,
    NEXTHOPKEY_NOT_SET = 0,
  };

  static inline const SLAFNextHopRegKey* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegKey*>(
               &_SLAFNextHopRegKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SLAFNextHopRegKey& a, SLAFNextHopRegKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegKey";
  }
  protected:
  explicit SLAFNextHopRegKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLAFNextHopRegKey_SLNextHopKey SLNextHopKey;

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopFieldNumber = 1,
  };
  // .service_layer.SLAFNextHopRegKey.SLNextHopKey NextHop = 1;
  bool has_nexthop() const;
  private:
  bool _internal_has_nexthop() const;
  public:
  void clear_nexthop();
  const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& nexthop() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey_SLNextHopKey* release_nexthop();
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* mutable_nexthop();
  void set_allocated_nexthop(::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop);
  private:
  const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& _internal_nexthop() const;
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* _internal_mutable_nexthop();
  public:
  void unsafe_arena_set_allocated_nexthop(
      ::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop);
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* unsafe_arena_release_nexthop();

  void clear_nexthopkey();
  NexthopkeyCase nexthopkey_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegKey)
 private:
  class _Internal;
  void set_has_nexthop();

  inline bool has_nexthopkey() const;
  inline void clear_has_nexthopkey();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union NexthopkeyUnion {
    constexpr NexthopkeyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop_;
  } nexthopkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNextHopRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNextHopRegMsg) */ {
 public:
  inline SLAFNextHopRegMsg() : SLAFNextHopRegMsg(nullptr) {}
  ~SLAFNextHopRegMsg() override;
  explicit constexpr SLAFNextHopRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNextHopRegMsg(const SLAFNextHopRegMsg& from);
  SLAFNextHopRegMsg(SLAFNextHopRegMsg&& from) noexcept
    : SLAFNextHopRegMsg() {
    *this = ::std::move(from);
  }

  inline SLAFNextHopRegMsg& operator=(const SLAFNextHopRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNextHopRegMsg& operator=(SLAFNextHopRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNextHopRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNextHopRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFNextHopRegMsg*>(
               &_SLAFNextHopRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SLAFNextHopRegMsg& a, SLAFNextHopRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNextHopRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNextHopRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNextHopRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNextHopRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNextHopRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNextHopRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNextHopRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNextHopRegMsg";
  }
  protected:
  explicit SLAFNextHopRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopKeyFieldNumber = 1,
  };
  // .service_layer.SLAFNextHopRegKey NextHopKey = 1;
  bool has_nexthopkey() const;
  private:
  bool _internal_has_nexthopkey() const;
  public:
  void clear_nexthopkey();
  const ::service_layer::SLAFNextHopRegKey& nexthopkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey* release_nexthopkey();
  ::service_layer::SLAFNextHopRegKey* mutable_nexthopkey();
  void set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey);
  private:
  const ::service_layer::SLAFNextHopRegKey& _internal_nexthopkey() const;
  ::service_layer::SLAFNextHopRegKey* _internal_mutable_nexthopkey();
  public:
  void unsafe_arena_set_allocated_nexthopkey(
      ::service_layer::SLAFNextHopRegKey* nexthopkey);
  ::service_layer::SLAFNextHopRegKey* unsafe_arena_release_nexthopkey();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNextHopRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFNextHopRegKey* nexthopkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifRegReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifRegReq) */ {
 public:
  inline SLAFNotifRegReq() : SLAFNotifRegReq(nullptr) {}
  ~SLAFNotifRegReq() override;
  explicit constexpr SLAFNotifRegReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifRegReq(const SLAFNotifRegReq& from);
  SLAFNotifRegReq(SLAFNotifRegReq&& from) noexcept
    : SLAFNotifRegReq() {
    *this = ::std::move(from);
  }

  inline SLAFNotifRegReq& operator=(const SLAFNotifRegReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifRegReq& operator=(SLAFNotifRegReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifRegReq& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kRedistReq = 1,
    kNextHopReq = 2,
    REQUEST_NOT_SET = 0,
  };

  static inline const SLAFNotifRegReq* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifRegReq*>(
               &_SLAFNotifRegReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SLAFNotifRegReq& a, SLAFNotifRegReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifRegReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifRegReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifRegReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifRegReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifRegReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifRegReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifRegReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifRegReq";
  }
  protected:
  explicit SLAFNotifRegReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationIDFieldNumber = 3,
    kRedistReqFieldNumber = 1,
    kNextHopReqFieldNumber = 2,
  };
  // uint64 OperationID = 3;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLAFRedistRegMsg RedistReq = 1;
  bool has_redistreq() const;
  private:
  bool _internal_has_redistreq() const;
  public:
  void clear_redistreq();
  const ::service_layer::SLAFRedistRegMsg& redistreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFRedistRegMsg* release_redistreq();
  ::service_layer::SLAFRedistRegMsg* mutable_redistreq();
  void set_allocated_redistreq(::service_layer::SLAFRedistRegMsg* redistreq);
  private:
  const ::service_layer::SLAFRedistRegMsg& _internal_redistreq() const;
  ::service_layer::SLAFRedistRegMsg* _internal_mutable_redistreq();
  public:
  void unsafe_arena_set_allocated_redistreq(
      ::service_layer::SLAFRedistRegMsg* redistreq);
  ::service_layer::SLAFRedistRegMsg* unsafe_arena_release_redistreq();

  // .service_layer.SLAFNextHopRegMsg NextHopReq = 2;
  bool has_nexthopreq() const;
  private:
  bool _internal_has_nexthopreq() const;
  public:
  void clear_nexthopreq();
  const ::service_layer::SLAFNextHopRegMsg& nexthopreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegMsg* release_nexthopreq();
  ::service_layer::SLAFNextHopRegMsg* mutable_nexthopreq();
  void set_allocated_nexthopreq(::service_layer::SLAFNextHopRegMsg* nexthopreq);
  private:
  const ::service_layer::SLAFNextHopRegMsg& _internal_nexthopreq() const;
  ::service_layer::SLAFNextHopRegMsg* _internal_mutable_nexthopreq();
  public:
  void unsafe_arena_set_allocated_nexthopreq(
      ::service_layer::SLAFNextHopRegMsg* nexthopreq);
  ::service_layer::SLAFNextHopRegMsg* unsafe_arena_release_nexthopreq();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifRegReq)
 private:
  class _Internal;
  void set_has_redistreq();
  void set_has_nexthopreq();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t operationid_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFRedistRegMsg* redistreq_;
    ::service_layer::SLAFNextHopRegMsg* nexthopreq_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifReq) */ {
 public:
  inline SLAFNotifReq() : SLAFNotifReq(nullptr) {}
  ~SLAFNotifReq() override;
  explicit constexpr SLAFNotifReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifReq(const SLAFNotifReq& from);
  SLAFNotifReq(SLAFNotifReq&& from) noexcept
    : SLAFNotifReq() {
    *this = ::std::move(from);
  }

  inline SLAFNotifReq& operator=(const SLAFNotifReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifReq& operator=(SLAFNotifReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifReq* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifReq*>(
               &_SLAFNotifReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SLAFNotifReq& a, SLAFNotifReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifReq";
  }
  protected:
  explicit SLAFNotifReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifReqFieldNumber = 3,
    kVrfNameFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLAFNotifRegReq NotifReq = 3;
  int notifreq_size() const;
  private:
  int _internal_notifreq_size() const;
  public:
  void clear_notifreq();
  ::service_layer::SLAFNotifRegReq* mutable_notifreq(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >*
      mutable_notifreq();
  private:
  const ::service_layer::SLAFNotifRegReq& _internal_notifreq(int index) const;
  ::service_layer::SLAFNotifRegReq* _internal_add_notifreq();
  public:
  const ::service_layer::SLAFNotifRegReq& notifreq(int index) const;
  ::service_layer::SLAFNotifRegReq* add_notifreq();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >&
      notifreq() const;

  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq > notifreq_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifRsp) */ {
 public:
  inline SLAFNotifRsp() : SLAFNotifRsp(nullptr) {}
  ~SLAFNotifRsp() override;
  explicit constexpr SLAFNotifRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifRsp(const SLAFNotifRsp& from);
  SLAFNotifRsp(SLAFNotifRsp&& from) noexcept
    : SLAFNotifRsp() {
    *this = ::std::move(from);
  }

  inline SLAFNotifRsp& operator=(const SLAFNotifRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifRsp& operator=(SLAFNotifRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifRsp* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifRsp*>(
               &_SLAFNotifRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SLAFNotifRsp& a, SLAFNotifRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifRsp";
  }
  protected:
  explicit SLAFNotifRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifReqFieldNumber = 1,
    kNotifStatusFieldNumber = 2,
  };
  // .service_layer.SLAFNotifRegReq NotifReq = 1;
  bool has_notifreq() const;
  private:
  bool _internal_has_notifreq() const;
  public:
  void clear_notifreq();
  const ::service_layer::SLAFNotifRegReq& notifreq() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotifRegReq* release_notifreq();
  ::service_layer::SLAFNotifRegReq* mutable_notifreq();
  void set_allocated_notifreq(::service_layer::SLAFNotifRegReq* notifreq);
  private:
  const ::service_layer::SLAFNotifRegReq& _internal_notifreq() const;
  ::service_layer::SLAFNotifRegReq* _internal_mutable_notifreq();
  public:
  void unsafe_arena_set_allocated_notifreq(
      ::service_layer::SLAFNotifRegReq* notifreq);
  ::service_layer::SLAFNotifRegReq* unsafe_arena_release_notifreq();

  // .service_layer.SLErrorStatus NotifStatus = 2;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLErrorStatus& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_notifstatus();
  ::service_layer::SLErrorStatus* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_notifstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLErrorStatus* notifstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_notifstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLAFNotifRegReq* notifreq_;
  ::service_layer::SLErrorStatus* notifstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLNextHop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLNextHop) */ {
 public:
  inline SLNextHop() : SLNextHop(nullptr) {}
  ~SLNextHop() override;
  explicit constexpr SLNextHop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLNextHop(const SLNextHop& from);
  SLNextHop(SLNextHop&& from) noexcept
    : SLNextHop() {
    *this = ::std::move(from);
  }

  inline SLNextHop& operator=(const SLNextHop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLNextHop& operator=(SLNextHop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLNextHop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLNextHop* internal_default_instance() {
    return reinterpret_cast<const SLNextHop*>(
               &_SLNextHop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SLNextHop& a, SLNextHop& b) {
    a.Swap(&b);
  }
  inline void Swap(SLNextHop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLNextHop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLNextHop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLNextHop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLNextHop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLNextHop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLNextHop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLNextHop";
  }
  protected:
  explicit SLNextHop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 7,
    kSrcProtoFieldNumber = 3,
    kSrcProtoTagFieldNumber = 4,
    kNextHopKeyFieldNumber = 1,
    kResolvingPrefixFieldNumber = 2,
    kAdminDistanceFieldNumber = 5,
    kMetricFieldNumber = 6,
  };
  // repeated .service_layer.SLRoutePath Paths = 7;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::service_layer::SLRoutePath* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
      mutable_paths();
  private:
  const ::service_layer::SLRoutePath& _internal_paths(int index) const;
  ::service_layer::SLRoutePath* _internal_add_paths();
  public:
  const ::service_layer::SLRoutePath& paths(int index) const;
  ::service_layer::SLRoutePath* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
      paths() const;

  // string SrcProto = 3;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 4;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // .service_layer.SLAFNextHopRegKey NextHopKey = 1;
  bool has_nexthopkey() const;
  private:
  bool _internal_has_nexthopkey() const;
  public:
  void clear_nexthopkey();
  const ::service_layer::SLAFNextHopRegKey& nexthopkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNextHopRegKey* release_nexthopkey();
  ::service_layer::SLAFNextHopRegKey* mutable_nexthopkey();
  void set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey);
  private:
  const ::service_layer::SLAFNextHopRegKey& _internal_nexthopkey() const;
  ::service_layer::SLAFNextHopRegKey* _internal_mutable_nexthopkey();
  public:
  void unsafe_arena_set_allocated_nexthopkey(
      ::service_layer::SLAFNextHopRegKey* nexthopkey);
  ::service_layer::SLAFNextHopRegKey* unsafe_arena_release_nexthopkey();

  // .service_layer.SLRoutePrefix ResolvingPrefix = 2;
  bool has_resolvingprefix() const;
  private:
  bool _internal_has_resolvingprefix() const;
  public:
  void clear_resolvingprefix();
  const ::service_layer::SLRoutePrefix& resolvingprefix() const;
  PROTOBUF_NODISCARD ::service_layer::SLRoutePrefix* release_resolvingprefix();
  ::service_layer::SLRoutePrefix* mutable_resolvingprefix();
  void set_allocated_resolvingprefix(::service_layer::SLRoutePrefix* resolvingprefix);
  private:
  const ::service_layer::SLRoutePrefix& _internal_resolvingprefix() const;
  ::service_layer::SLRoutePrefix* _internal_mutable_resolvingprefix();
  public:
  void unsafe_arena_set_allocated_resolvingprefix(
      ::service_layer::SLRoutePrefix* resolvingprefix);
  ::service_layer::SLRoutePrefix* unsafe_arena_release_resolvingprefix();

  // uint32 AdminDistance = 5;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 Metric = 6;
  void clear_metric();
  uint32_t metric() const;
  void set_metric(uint32_t value);
  private:
  uint32_t _internal_metric() const;
  void _internal_set_metric(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLNextHop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath > paths_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  ::service_layer::SLAFNextHopRegKey* nexthopkey_;
  ::service_layer::SLRoutePrefix* resolvingprefix_;
  uint32_t admindistance_;
  uint32_t metric_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotif_SLRedistMarker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotif.SLRedistMarker) */ {
 public:
  inline SLAFNotif_SLRedistMarker() : SLAFNotif_SLRedistMarker(nullptr) {}
  ~SLAFNotif_SLRedistMarker() override;
  explicit constexpr SLAFNotif_SLRedistMarker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotif_SLRedistMarker(const SLAFNotif_SLRedistMarker& from);
  SLAFNotif_SLRedistMarker(SLAFNotif_SLRedistMarker&& from) noexcept
    : SLAFNotif_SLRedistMarker() {
    *this = ::std::move(from);
  }

  inline SLAFNotif_SLRedistMarker& operator=(const SLAFNotif_SLRedistMarker& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotif_SLRedistMarker& operator=(SLAFNotif_SLRedistMarker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotif_SLRedistMarker& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotif_SLRedistMarker* internal_default_instance() {
    return reinterpret_cast<const SLAFNotif_SLRedistMarker*>(
               &_SLAFNotif_SLRedistMarker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SLAFNotif_SLRedistMarker& a, SLAFNotif_SLRedistMarker& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotif_SLRedistMarker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotif_SLRedistMarker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotif_SLRedistMarker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotif_SLRedistMarker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotif_SLRedistMarker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotif_SLRedistMarker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotif_SLRedistMarker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotif.SLRedistMarker";
  }
  protected:
  explicit SLAFNotif_SLRedistMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 1,
  };
  // .service_layer.SLTableType Table = 1;
  void clear_table();
  ::service_layer::SLTableType table() const;
  void set_table(::service_layer::SLTableType value);
  private:
  ::service_layer::SLTableType _internal_table() const;
  void _internal_set_table(::service_layer::SLTableType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotif.SLRedistMarker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotif) */ {
 public:
  inline SLAFNotif() : SLAFNotif(nullptr) {}
  ~SLAFNotif() override;
  explicit constexpr SLAFNotif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotif(const SLAFNotif& from);
  SLAFNotif(SLAFNotif&& from) noexcept
    : SLAFNotif() {
    *this = ::std::move(from);
  }

  inline SLAFNotif& operator=(const SLAFNotif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotif& operator=(SLAFNotif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotif& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kNotifStatus = 1,
    kStartMarker = 2,
    kEndMarker = 3,
    kRedistObject = 4,
    kNextHop = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const SLAFNotif* internal_default_instance() {
    return reinterpret_cast<const SLAFNotif*>(
               &_SLAFNotif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SLAFNotif& a, SLAFNotif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotif";
  }
  protected:
  explicit SLAFNotif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLAFNotif_SLRedistMarker SLRedistMarker;

  // accessors -------------------------------------------------------

  enum : int {
    kNotifStatusFieldNumber = 1,
    kStartMarkerFieldNumber = 2,
    kEndMarkerFieldNumber = 3,
    kRedistObjectFieldNumber = 4,
    kNextHopFieldNumber = 5,
  };
  // .service_layer.SLAFNotifRsp NotifStatus = 1;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLAFNotifRsp& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotifRsp* release_notifstatus();
  ::service_layer::SLAFNotifRsp* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLAFNotifRsp* notifstatus);
  private:
  const ::service_layer::SLAFNotifRsp& _internal_notifstatus() const;
  ::service_layer::SLAFNotifRsp* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLAFNotifRsp* notifstatus);
  ::service_layer::SLAFNotifRsp* unsafe_arena_release_notifstatus();

  // .service_layer.SLAFNotif.SLRedistMarker StartMarker = 2;
  bool has_startmarker() const;
  private:
  bool _internal_has_startmarker() const;
  public:
  void clear_startmarker();
  const ::service_layer::SLAFNotif_SLRedistMarker& startmarker() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotif_SLRedistMarker* release_startmarker();
  ::service_layer::SLAFNotif_SLRedistMarker* mutable_startmarker();
  void set_allocated_startmarker(::service_layer::SLAFNotif_SLRedistMarker* startmarker);
  private:
  const ::service_layer::SLAFNotif_SLRedistMarker& _internal_startmarker() const;
  ::service_layer::SLAFNotif_SLRedistMarker* _internal_mutable_startmarker();
  public:
  void unsafe_arena_set_allocated_startmarker(
      ::service_layer::SLAFNotif_SLRedistMarker* startmarker);
  ::service_layer::SLAFNotif_SLRedistMarker* unsafe_arena_release_startmarker();

  // .service_layer.SLAFNotif.SLRedistMarker EndMarker = 3;
  bool has_endmarker() const;
  private:
  bool _internal_has_endmarker() const;
  public:
  void clear_endmarker();
  const ::service_layer::SLAFNotif_SLRedistMarker& endmarker() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFNotif_SLRedistMarker* release_endmarker();
  ::service_layer::SLAFNotif_SLRedistMarker* mutable_endmarker();
  void set_allocated_endmarker(::service_layer::SLAFNotif_SLRedistMarker* endmarker);
  private:
  const ::service_layer::SLAFNotif_SLRedistMarker& _internal_endmarker() const;
  ::service_layer::SLAFNotif_SLRedistMarker* _internal_mutable_endmarker();
  public:
  void unsafe_arena_set_allocated_endmarker(
      ::service_layer::SLAFNotif_SLRedistMarker* endmarker);
  ::service_layer::SLAFNotif_SLRedistMarker* unsafe_arena_release_endmarker();

  // .service_layer.SLAFObject RedistObject = 4;
  bool has_redistobject() const;
  private:
  bool _internal_has_redistobject() const;
  public:
  void clear_redistobject();
  const ::service_layer::SLAFObject& redistobject() const;
  PROTOBUF_NODISCARD ::service_layer::SLAFObject* release_redistobject();
  ::service_layer::SLAFObject* mutable_redistobject();
  void set_allocated_redistobject(::service_layer::SLAFObject* redistobject);
  private:
  const ::service_layer::SLAFObject& _internal_redistobject() const;
  ::service_layer::SLAFObject* _internal_mutable_redistobject();
  public:
  void unsafe_arena_set_allocated_redistobject(
      ::service_layer::SLAFObject* redistobject);
  ::service_layer::SLAFObject* unsafe_arena_release_redistobject();

  // .service_layer.SLNextHop NextHop = 5;
  bool has_nexthop() const;
  private:
  bool _internal_has_nexthop() const;
  public:
  void clear_nexthop();
  const ::service_layer::SLNextHop& nexthop() const;
  PROTOBUF_NODISCARD ::service_layer::SLNextHop* release_nexthop();
  ::service_layer::SLNextHop* mutable_nexthop();
  void set_allocated_nexthop(::service_layer::SLNextHop* nexthop);
  private:
  const ::service_layer::SLNextHop& _internal_nexthop() const;
  ::service_layer::SLNextHop* _internal_mutable_nexthop();
  public:
  void unsafe_arena_set_allocated_nexthop(
      ::service_layer::SLNextHop* nexthop);
  ::service_layer::SLNextHop* unsafe_arena_release_nexthop();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotif)
 private:
  class _Internal;
  void set_has_notifstatus();
  void set_has_startmarker();
  void set_has_endmarker();
  void set_has_redistobject();
  void set_has_nexthop();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLAFNotifRsp* notifstatus_;
    ::service_layer::SLAFNotif_SLRedistMarker* startmarker_;
    ::service_layer::SLAFNotif_SLRedistMarker* endmarker_;
    ::service_layer::SLAFObject* redistobject_;
    ::service_layer::SLNextHop* nexthop_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5faf_2eproto;
};
// -------------------------------------------------------------------

class SLAFNotifMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAFNotifMsg) */ {
 public:
  inline SLAFNotifMsg() : SLAFNotifMsg(nullptr) {}
  ~SLAFNotifMsg() override;
  explicit constexpr SLAFNotifMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAFNotifMsg(const SLAFNotifMsg& from);
  SLAFNotifMsg(SLAFNotifMsg&& from) noexcept
    : SLAFNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLAFNotifMsg& operator=(const SLAFNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAFNotifMsg& operator=(SLAFNotifMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAFNotifMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAFNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLAFNotifMsg*>(
               &_SLAFNotifMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SLAFNotifMsg& a, SLAFNotifMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAFNotifMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAFNotifMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAFNotifMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAFNotifMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAFNotifMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAFNotifMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAFNotifMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAFNotifMsg";
  }
  protected:
  explicit SLAFNotifMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFNotifsFieldNumber = 3,
    kVrfNameFieldNumber = 1,
  };
  // repeated .service_layer.SLAFNotif AFNotifs = 3;
  int afnotifs_size() const;
  private:
  int _internal_afnotifs_size() const;
  public:
  void clear_afnotifs();
  ::service_layer::SLAFNotif* mutable_afnotifs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >*
      mutable_afnotifs();
  private:
  const ::service_layer::SLAFNotif& _internal_afnotifs(int index) const;
  ::service_layer::SLAFNotif* _internal_add_afnotifs();
  public:
  const ::service_layer::SLAFNotif& afnotifs(int index) const;
  ::service_layer::SLAFNotif* add_afnotifs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >&
      afnotifs() const;

  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAFNotifMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif > afnotifs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5faf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLAFVrfReg

// .service_layer.SLTableType Table = 1;
inline void SLAFVrfReg::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfReg::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfReg::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfReg.Table)
  return _internal_table();
}
inline void SLAFVrfReg::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfReg::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfReg.Table)
}

// .service_layer.SLVrfReg VrfReg = 2;
inline bool SLAFVrfReg::_internal_has_vrfreg() const {
  return this != internal_default_instance() && vrfreg_ != nullptr;
}
inline bool SLAFVrfReg::has_vrfreg() const {
  return _internal_has_vrfreg();
}
inline const ::service_layer::SLVrfReg& SLAFVrfReg::_internal_vrfreg() const {
  const ::service_layer::SLVrfReg* p = vrfreg_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLVrfReg&>(
      ::service_layer::_SLVrfReg_default_instance_);
}
inline const ::service_layer::SLVrfReg& SLAFVrfReg::vrfreg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfReg.VrfReg)
  return _internal_vrfreg();
}
inline void SLAFVrfReg::unsafe_arena_set_allocated_vrfreg(
    ::service_layer::SLVrfReg* vrfreg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg_);
  }
  vrfreg_ = vrfreg;
  if (vrfreg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfReg.VrfReg)
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::release_vrfreg() {
  
  ::service_layer::SLVrfReg* temp = vrfreg_;
  vrfreg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::unsafe_arena_release_vrfreg() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfReg.VrfReg)
  
  ::service_layer::SLVrfReg* temp = vrfreg_;
  vrfreg_ = nullptr;
  return temp;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::_internal_mutable_vrfreg() {
  
  if (vrfreg_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLVrfReg>(GetArenaForAllocation());
    vrfreg_ = p;
  }
  return vrfreg_;
}
inline ::service_layer::SLVrfReg* SLAFVrfReg::mutable_vrfreg() {
  ::service_layer::SLVrfReg* _msg = _internal_mutable_vrfreg();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfReg.VrfReg)
  return _msg;
}
inline void SLAFVrfReg::set_allocated_vrfreg(::service_layer::SLVrfReg* vrfreg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg_);
  }
  if (vrfreg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfreg));
    if (message_arena != submessage_arena) {
      vrfreg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrfreg, submessage_arena);
    }
    
  } else {
    
  }
  vrfreg_ = vrfreg;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfReg.VrfReg)
}

// -------------------------------------------------------------------

// SLAFVrfRegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLAFVrfRegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLAFVrfRegMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline ::service_layer::SLRegOp SLAFVrfRegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsg.Oper)
  return _internal_oper();
}
inline void SLAFVrfRegMsg::_internal_set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
}
inline void SLAFVrfRegMsg::set_oper(::service_layer::SLRegOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsg.Oper)
}

// repeated .service_layer.SLAFVrfReg VrfRegMsgs = 2;
inline int SLAFVrfRegMsg::_internal_vrfregmsgs_size() const {
  return vrfregmsgs_.size();
}
inline int SLAFVrfRegMsg::vrfregmsgs_size() const {
  return _internal_vrfregmsgs_size();
}
inline void SLAFVrfRegMsg::clear_vrfregmsgs() {
  vrfregmsgs_.Clear();
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::mutable_vrfregmsgs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >*
SLAFVrfRegMsg::mutable_vrfregmsgs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return &vrfregmsgs_;
}
inline const ::service_layer::SLAFVrfReg& SLAFVrfRegMsg::_internal_vrfregmsgs(int index) const {
  return vrfregmsgs_.Get(index);
}
inline const ::service_layer::SLAFVrfReg& SLAFVrfRegMsg::vrfregmsgs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return _internal_vrfregmsgs(index);
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::_internal_add_vrfregmsgs() {
  return vrfregmsgs_.Add();
}
inline ::service_layer::SLAFVrfReg* SLAFVrfRegMsg::add_vrfregmsgs() {
  ::service_layer::SLAFVrfReg* _add = _internal_add_vrfregmsgs();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfReg >&
SLAFVrfRegMsg::vrfregmsgs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_;
}

// -------------------------------------------------------------------

// SLAFVrfRegMsgRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFVrfRegMsgRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFVrfRegMsgRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFVrfRegMsgRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegMsgRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRes.ErrStatus)
  return _msg;
}
inline void SLAFVrfRegMsgRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRes.ErrStatus)
}

// string VrfName = 2;
inline void SLAFVrfRegMsgRes::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFVrfRegMsgRes::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFVrfRegMsgRes::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsgRes.VrfName)
}
inline std::string* SLAFVrfRegMsgRes::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRes.VrfName)
  return _s;
}
inline const std::string& SLAFVrfRegMsgRes::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFVrfRegMsgRes::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFVrfRegMsgRes::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFVrfRegMsgRes::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRes.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFVrfRegMsgRes::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRes.VrfName)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFVrfRegMsgRes::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfRegMsgRes::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfRegMsgRes::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRes.Table)
  return _internal_table();
}
inline void SLAFVrfRegMsgRes::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfRegMsgRes::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegMsgRes.Table)
}

// -------------------------------------------------------------------

// SLAFVrfRegMsgRsp

// .service_layer.SLErrorStatus StatusSummary = 1;
inline bool SLAFVrfRegMsgRsp::_internal_has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != nullptr;
}
inline bool SLAFVrfRegMsgRsp::has_statussummary() const {
  return _internal_has_statussummary();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRsp::_internal_statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegMsgRsp::statussummary() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  return _internal_statussummary();
}
inline void SLAFVrfRegMsgRsp::unsafe_arena_set_allocated_statussummary(
    ::service_layer::SLErrorStatus* statussummary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  statussummary_ = statussummary;
  if (statussummary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::release_statussummary() {
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::unsafe_arena_release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::_internal_mutable_statussummary() {
  
  if (statussummary_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    statussummary_ = p;
  }
  return statussummary_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegMsgRsp::mutable_statussummary() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_statussummary();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
  return _msg;
}
inline void SLAFVrfRegMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary));
    if (message_arena != submessage_arena) {
      statussummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegMsgRsp.StatusSummary)
}

// repeated .service_layer.SLAFVrfRegMsgRes Results = 2;
inline int SLAFVrfRegMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLAFVrfRegMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLAFVrfRegMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >*
SLAFVrfRegMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLAFVrfRegMsgRes& SLAFVrfRegMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLAFVrfRegMsgRes& SLAFVrfRegMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLAFVrfRegMsgRes* SLAFVrfRegMsgRsp::add_results() {
  ::service_layer::SLAFVrfRegMsgRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFVrfRegMsgRes >&
SLAFVrfRegMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLAFVrfRegGetMsg

// bool GetAll = 1;
inline void SLAFVrfRegGetMsg::clear_getall() {
  getall_ = false;
}
inline bool SLAFVrfRegGetMsg::_internal_getall() const {
  return getall_;
}
inline bool SLAFVrfRegGetMsg::getall() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsg.GetAll)
  return _internal_getall();
}
inline void SLAFVrfRegGetMsg::_internal_set_getall(bool value) {
  
  getall_ = value;
}
inline void SLAFVrfRegGetMsg::set_getall(bool value) {
  _internal_set_getall(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsg.GetAll)
}

// -------------------------------------------------------------------

// SLAFVrfRegGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFVrfRegGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFVrfRegGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFVrfRegGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFVrfRegGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFVrfRegGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLAFVrfRegGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFVrfRegGetMsgRsp.ErrStatus)
}

// uint64 ClientID = 2;
inline void SLAFVrfRegGetMsgRsp::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t SLAFVrfRegGetMsgRsp::_internal_clientid() const {
  return clientid_;
}
inline uint64_t SLAFVrfRegGetMsgRsp::clientid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.ClientID)
  return _internal_clientid();
}
inline void SLAFVrfRegGetMsgRsp::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void SLAFVrfRegGetMsgRsp::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsgRsp.ClientID)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFVrfRegGetMsgRsp::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFVrfRegGetMsgRsp::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFVrfRegGetMsgRsp::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.Table)
  return _internal_table();
}
inline void SLAFVrfRegGetMsgRsp::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFVrfRegGetMsgRsp::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFVrfRegGetMsgRsp.Table)
}

// repeated .service_layer.SLVrfReg Entries = 4;
inline int SLAFVrfRegGetMsgRsp::_internal_entries_size() const {
  return entries_.size();
}
inline int SLAFVrfRegGetMsgRsp::entries_size() const {
  return _internal_entries_size();
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
SLAFVrfRegGetMsgRsp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return &entries_;
}
inline const ::service_layer::SLVrfReg& SLAFVrfRegGetMsgRsp::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::service_layer::SLVrfReg& SLAFVrfRegGetMsgRsp::entries(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return _internal_entries(index);
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::_internal_add_entries() {
  return entries_.Add();
}
inline ::service_layer::SLVrfReg* SLAFVrfRegGetMsgRsp::add_entries() {
  ::service_layer::SLVrfReg* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
SLAFVrfRegGetMsgRsp::entries() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFVrfRegGetMsgRsp.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SLPathGroup_SLPath

// .service_layer.SLRoutePath Path = 1;
inline bool SLPathGroup_SLPath::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool SLPathGroup_SLPath::has_path() const {
  return _internal_has_path();
}
inline const ::service_layer::SLRoutePath& SLPathGroup_SLPath::_internal_path() const {
  const ::service_layer::SLRoutePath* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRoutePath&>(
      ::service_layer::_SLRoutePath_default_instance_);
}
inline const ::service_layer::SLRoutePath& SLPathGroup_SLPath::path() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.SLPath.Path)
  return _internal_path();
}
inline void SLPathGroup_SLPath::unsafe_arena_set_allocated_path(
    ::service_layer::SLRoutePath* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.SLPath.Path)
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::release_path() {
  
  ::service_layer::SLRoutePath* temp = path_;
  path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.SLPath.Path)
  
  ::service_layer::SLRoutePath* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRoutePath>(GetArenaForAllocation());
    path_ = p;
  }
  return path_;
}
inline ::service_layer::SLRoutePath* SLPathGroup_SLPath::mutable_path() {
  ::service_layer::SLRoutePath* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.SLPath.Path)
  return _msg;
}
inline void SLPathGroup_SLPath::set_allocated_path(::service_layer::SLRoutePath* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path));
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroup.SLPath.Path)
}

// -------------------------------------------------------------------

// SLPathGroup_SLPathList

// repeated .service_layer.SLPathGroup.SLPath Paths = 1;
inline int SLPathGroup_SLPathList::_internal_paths_size() const {
  return paths_.size();
}
inline int SLPathGroup_SLPathList::paths_size() const {
  return _internal_paths_size();
}
inline void SLPathGroup_SLPathList::clear_paths() {
  paths_.Clear();
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.SLPathList.Paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >*
SLPathGroup_SLPathList::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPathGroup.SLPathList.Paths)
  return &paths_;
}
inline const ::service_layer::SLPathGroup_SLPath& SLPathGroup_SLPathList::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::service_layer::SLPathGroup_SLPath& SLPathGroup_SLPathList::paths(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.SLPathList.Paths)
  return _internal_paths(index);
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::_internal_add_paths() {
  return paths_.Add();
}
inline ::service_layer::SLPathGroup_SLPath* SLPathGroup_SLPathList::add_paths() {
  ::service_layer::SLPathGroup_SLPath* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:service_layer.SLPathGroup.SLPathList.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPathGroup_SLPath >&
SLPathGroup_SLPathList::paths() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPathGroup.SLPathList.Paths)
  return paths_;
}

// -------------------------------------------------------------------

// SLPathGroup

// .service_layer.SLObjectId PathGroupId = 1;
inline bool SLPathGroup::_internal_has_pathgroupid() const {
  return this != internal_default_instance() && pathgroupid_ != nullptr;
}
inline bool SLPathGroup::has_pathgroupid() const {
  return _internal_has_pathgroupid();
}
inline const ::service_layer::SLObjectId& SLPathGroup::_internal_pathgroupid() const {
  const ::service_layer::SLObjectId* p = pathgroupid_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLObjectId&>(
      ::service_layer::_SLObjectId_default_instance_);
}
inline const ::service_layer::SLObjectId& SLPathGroup::pathgroupid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.PathGroupId)
  return _internal_pathgroupid();
}
inline void SLPathGroup::unsafe_arena_set_allocated_pathgroupid(
    ::service_layer::SLObjectId* pathgroupid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid_);
  }
  pathgroupid_ = pathgroupid;
  if (pathgroupid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.PathGroupId)
}
inline ::service_layer::SLObjectId* SLPathGroup::release_pathgroupid() {
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroup::unsafe_arena_release_pathgroupid() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.PathGroupId)
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroup::_internal_mutable_pathgroupid() {
  
  if (pathgroupid_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLObjectId>(GetArenaForAllocation());
    pathgroupid_ = p;
  }
  return pathgroupid_;
}
inline ::service_layer::SLObjectId* SLPathGroup::mutable_pathgroupid() {
  ::service_layer::SLObjectId* _msg = _internal_mutable_pathgroupid();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.PathGroupId)
  return _msg;
}
inline void SLPathGroup::set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid_);
  }
  if (pathgroupid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid));
    if (message_arena != submessage_arena) {
      pathgroupid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathgroupid, submessage_arena);
    }
    
  } else {
    
  }
  pathgroupid_ = pathgroupid;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroup.PathGroupId)
}

// uint32 AdminDistance = 2;
inline void SLPathGroup::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLPathGroup::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLPathGroup::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.AdminDistance)
  return _internal_admindistance();
}
inline void SLPathGroup::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLPathGroup::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPathGroup.AdminDistance)
}

// .service_layer.SLPathGroup.SLPathList PathList = 3;
inline bool SLPathGroup::_internal_has_pathlist() const {
  return entry_case() == kPathList;
}
inline bool SLPathGroup::has_pathlist() const {
  return _internal_has_pathlist();
}
inline void SLPathGroup::set_has_pathlist() {
  _oneof_case_[0] = kPathList;
}
inline void SLPathGroup::clear_pathlist() {
  if (_internal_has_pathlist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.pathlist_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::release_pathlist() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroup.PathList)
  if (_internal_has_pathlist()) {
    clear_has_entry();
      ::service_layer::SLPathGroup_SLPathList* temp = entry_.pathlist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroup_SLPathList& SLPathGroup::_internal_pathlist() const {
  return _internal_has_pathlist()
      ? *entry_.pathlist_
      : reinterpret_cast< ::service_layer::SLPathGroup_SLPathList&>(::service_layer::_SLPathGroup_SLPathList_default_instance_);
}
inline const ::service_layer::SLPathGroup_SLPathList& SLPathGroup::pathlist() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.PathList)
  return _internal_pathlist();
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::unsafe_arena_release_pathlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPathGroup.PathList)
  if (_internal_has_pathlist()) {
    clear_has_entry();
    ::service_layer::SLPathGroup_SLPathList* temp = entry_.pathlist_;
    entry_.pathlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPathGroup::unsafe_arena_set_allocated_pathlist(::service_layer::SLPathGroup_SLPathList* pathlist) {
  clear_entry();
  if (pathlist) {
    set_has_pathlist();
    entry_.pathlist_ = pathlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroup.PathList)
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::_internal_mutable_pathlist() {
  if (!_internal_has_pathlist()) {
    clear_entry();
    set_has_pathlist();
    entry_.pathlist_ = CreateMaybeMessage< ::service_layer::SLPathGroup_SLPathList >(GetArenaForAllocation());
  }
  return entry_.pathlist_;
}
inline ::service_layer::SLPathGroup_SLPathList* SLPathGroup::mutable_pathlist() {
  ::service_layer::SLPathGroup_SLPathList* _msg = _internal_mutable_pathlist();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroup.PathList)
  return _msg;
}

// repeated .service_layer.SLRouteFlags PgFlags = 4;
inline int SLPathGroup::_internal_pgflags_size() const {
  return pgflags_.size();
}
inline int SLPathGroup::pgflags_size() const {
  return _internal_pgflags_size();
}
inline void SLPathGroup::clear_pgflags() {
  pgflags_.Clear();
}
inline ::service_layer::SLRouteFlags SLPathGroup::_internal_pgflags(int index) const {
  return static_cast< ::service_layer::SLRouteFlags >(pgflags_.Get(index));
}
inline ::service_layer::SLRouteFlags SLPathGroup::pgflags(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroup.PgFlags)
  return _internal_pgflags(index);
}
inline void SLPathGroup::set_pgflags(int index, ::service_layer::SLRouteFlags value) {
  pgflags_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLPathGroup.PgFlags)
}
inline void SLPathGroup::_internal_add_pgflags(::service_layer::SLRouteFlags value) {
  pgflags_.Add(value);
}
inline void SLPathGroup::add_pgflags(::service_layer::SLRouteFlags value) {
  _internal_add_pgflags(value);
  // @@protoc_insertion_point(field_add:service_layer.SLPathGroup.PgFlags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLPathGroup::pgflags() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPathGroup.PgFlags)
  return pgflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLPathGroup::_internal_mutable_pgflags() {
  return &pgflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLPathGroup::mutable_pgflags() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPathGroup.PgFlags)
  return _internal_mutable_pgflags();
}

inline bool SLPathGroup::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLPathGroup::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLPathGroup::EntryCase SLPathGroup::entry_case() const {
  return SLPathGroup::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLMplsEntryKey

// uint32 Label = 1;
inline void SLMplsEntryKey::clear_label() {
  label_ = 0u;
}
inline uint32_t SLMplsEntryKey::_internal_label() const {
  return label_;
}
inline uint32_t SLMplsEntryKey::label() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntryKey.Label)
  return _internal_label();
}
inline void SLMplsEntryKey::_internal_set_label(uint32_t value) {
  
  label_ = value;
}
inline void SLMplsEntryKey::set_label(uint32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntryKey.Label)
}

// -------------------------------------------------------------------

// SLMplsEntry

// .service_layer.SLMplsEntryKey MplsKey = 1;
inline bool SLMplsEntry::_internal_has_mplskey() const {
  return this != internal_default_instance() && mplskey_ != nullptr;
}
inline bool SLMplsEntry::has_mplskey() const {
  return _internal_has_mplskey();
}
inline void SLMplsEntry::clear_mplskey() {
  if (GetArenaForAllocation() == nullptr && mplskey_ != nullptr) {
    delete mplskey_;
  }
  mplskey_ = nullptr;
}
inline const ::service_layer::SLMplsEntryKey& SLMplsEntry::_internal_mplskey() const {
  const ::service_layer::SLMplsEntryKey* p = mplskey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLMplsEntryKey&>(
      ::service_layer::_SLMplsEntryKey_default_instance_);
}
inline const ::service_layer::SLMplsEntryKey& SLMplsEntry::mplskey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.MplsKey)
  return _internal_mplskey();
}
inline void SLMplsEntry::unsafe_arena_set_allocated_mplskey(
    ::service_layer::SLMplsEntryKey* mplskey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mplskey_);
  }
  mplskey_ = mplskey;
  if (mplskey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLMplsEntry.MplsKey)
}
inline ::service_layer::SLMplsEntryKey* SLMplsEntry::release_mplskey() {
  
  ::service_layer::SLMplsEntryKey* temp = mplskey_;
  mplskey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLMplsEntryKey* SLMplsEntry::unsafe_arena_release_mplskey() {
  // @@protoc_insertion_point(field_release:service_layer.SLMplsEntry.MplsKey)
  
  ::service_layer::SLMplsEntryKey* temp = mplskey_;
  mplskey_ = nullptr;
  return temp;
}
inline ::service_layer::SLMplsEntryKey* SLMplsEntry::_internal_mutable_mplskey() {
  
  if (mplskey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLMplsEntryKey>(GetArenaForAllocation());
    mplskey_ = p;
  }
  return mplskey_;
}
inline ::service_layer::SLMplsEntryKey* SLMplsEntry::mutable_mplskey() {
  ::service_layer::SLMplsEntryKey* _msg = _internal_mutable_mplskey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLMplsEntry.MplsKey)
  return _msg;
}
inline void SLMplsEntry::set_allocated_mplskey(::service_layer::SLMplsEntryKey* mplskey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mplskey_;
  }
  if (mplskey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLMplsEntryKey>::GetOwningArena(mplskey);
    if (message_arena != submessage_arena) {
      mplskey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mplskey, submessage_arena);
    }
    
  } else {
    
  }
  mplskey_ = mplskey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLMplsEntry.MplsKey)
}

// uint32 AdminDistance = 2;
inline void SLMplsEntry::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLMplsEntry::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLMplsEntry::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.AdminDistance)
  return _internal_admindistance();
}
inline void SLMplsEntry::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLMplsEntry::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.AdminDistance)
}

// repeated .service_layer.SLRoutePath PathList = 3;
inline int SLMplsEntry::_internal_pathlist_size() const {
  return pathlist_.size();
}
inline int SLMplsEntry::pathlist_size() const {
  return _internal_pathlist_size();
}
inline ::service_layer::SLRoutePath* SLMplsEntry::mutable_pathlist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLMplsEntry.PathList)
  return pathlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
SLMplsEntry::mutable_pathlist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLMplsEntry.PathList)
  return &pathlist_;
}
inline const ::service_layer::SLRoutePath& SLMplsEntry::_internal_pathlist(int index) const {
  return pathlist_.Get(index);
}
inline const ::service_layer::SLRoutePath& SLMplsEntry::pathlist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.PathList)
  return _internal_pathlist(index);
}
inline ::service_layer::SLRoutePath* SLMplsEntry::_internal_add_pathlist() {
  return pathlist_.Add();
}
inline ::service_layer::SLRoutePath* SLMplsEntry::add_pathlist() {
  ::service_layer::SLRoutePath* _add = _internal_add_pathlist();
  // @@protoc_insertion_point(field_add:service_layer.SLMplsEntry.PathList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
SLMplsEntry::pathlist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLMplsEntry.PathList)
  return pathlist_;
}

// repeated .service_layer.SLRouteFlags MplsFlags = 4;
inline int SLMplsEntry::_internal_mplsflags_size() const {
  return mplsflags_.size();
}
inline int SLMplsEntry::mplsflags_size() const {
  return _internal_mplsflags_size();
}
inline void SLMplsEntry::clear_mplsflags() {
  mplsflags_.Clear();
}
inline ::service_layer::SLRouteFlags SLMplsEntry::_internal_mplsflags(int index) const {
  return static_cast< ::service_layer::SLRouteFlags >(mplsflags_.Get(index));
}
inline ::service_layer::SLRouteFlags SLMplsEntry::mplsflags(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.MplsFlags)
  return _internal_mplsflags(index);
}
inline void SLMplsEntry::set_mplsflags(int index, ::service_layer::SLRouteFlags value) {
  mplsflags_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.MplsFlags)
}
inline void SLMplsEntry::_internal_add_mplsflags(::service_layer::SLRouteFlags value) {
  mplsflags_.Add(value);
}
inline void SLMplsEntry::add_mplsflags(::service_layer::SLRouteFlags value) {
  _internal_add_mplsflags(value);
  // @@protoc_insertion_point(field_add:service_layer.SLMplsEntry.MplsFlags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLMplsEntry::mplsflags() const {
  // @@protoc_insertion_point(field_list:service_layer.SLMplsEntry.MplsFlags)
  return mplsflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLMplsEntry::_internal_mutable_mplsflags() {
  return &mplsflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLMplsEntry::mutable_mplsflags() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLMplsEntry.MplsFlags)
  return _internal_mutable_mplsflags();
}

// .service_layer.SLUpdatePriority Priority = 5;
inline void SLMplsEntry::clear_priority() {
  priority_ = 0;
}
inline ::service_layer::SLUpdatePriority SLMplsEntry::_internal_priority() const {
  return static_cast< ::service_layer::SLUpdatePriority >(priority_);
}
inline ::service_layer::SLUpdatePriority SLMplsEntry::priority() const {
  // @@protoc_insertion_point(field_get:service_layer.SLMplsEntry.Priority)
  return _internal_priority();
}
inline void SLMplsEntry::_internal_set_priority(::service_layer::SLUpdatePriority value) {
  
  priority_ = value;
}
inline void SLMplsEntry::set_priority(::service_layer::SLUpdatePriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:service_layer.SLMplsEntry.Priority)
}

// -------------------------------------------------------------------

// SLAFIPRoute

// .service_layer.SLRoutePrefix IPRoutePrefix = 1;
inline bool SLAFIPRoute::_internal_has_iprouteprefix() const {
  return this != internal_default_instance() && iprouteprefix_ != nullptr;
}
inline bool SLAFIPRoute::has_iprouteprefix() const {
  return _internal_has_iprouteprefix();
}
inline const ::service_layer::SLRoutePrefix& SLAFIPRoute::_internal_iprouteprefix() const {
  const ::service_layer::SLRoutePrefix* p = iprouteprefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRoutePrefix&>(
      ::service_layer::_SLRoutePrefix_default_instance_);
}
inline const ::service_layer::SLRoutePrefix& SLAFIPRoute::iprouteprefix() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFIPRoute.IPRoutePrefix)
  return _internal_iprouteprefix();
}
inline void SLAFIPRoute::unsafe_arena_set_allocated_iprouteprefix(
    ::service_layer::SLRoutePrefix* iprouteprefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(iprouteprefix_);
  }
  iprouteprefix_ = iprouteprefix;
  if (iprouteprefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFIPRoute.IPRoutePrefix)
}
inline ::service_layer::SLRoutePrefix* SLAFIPRoute::release_iprouteprefix() {
  
  ::service_layer::SLRoutePrefix* temp = iprouteprefix_;
  iprouteprefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLAFIPRoute::unsafe_arena_release_iprouteprefix() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFIPRoute.IPRoutePrefix)
  
  ::service_layer::SLRoutePrefix* temp = iprouteprefix_;
  iprouteprefix_ = nullptr;
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLAFIPRoute::_internal_mutable_iprouteprefix() {
  
  if (iprouteprefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRoutePrefix>(GetArenaForAllocation());
    iprouteprefix_ = p;
  }
  return iprouteprefix_;
}
inline ::service_layer::SLRoutePrefix* SLAFIPRoute::mutable_iprouteprefix() {
  ::service_layer::SLRoutePrefix* _msg = _internal_mutable_iprouteprefix();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFIPRoute.IPRoutePrefix)
  return _msg;
}
inline void SLAFIPRoute::set_allocated_iprouteprefix(::service_layer::SLRoutePrefix* iprouteprefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(iprouteprefix_);
  }
  if (iprouteprefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(iprouteprefix));
    if (message_arena != submessage_arena) {
      iprouteprefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, iprouteprefix, submessage_arena);
    }
    
  } else {
    
  }
  iprouteprefix_ = iprouteprefix;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFIPRoute.IPRoutePrefix)
}

// .service_layer.SLRouteCommon RouteCommon = 2;
inline bool SLAFIPRoute::_internal_has_routecommon() const {
  return this != internal_default_instance() && routecommon_ != nullptr;
}
inline bool SLAFIPRoute::has_routecommon() const {
  return _internal_has_routecommon();
}
inline const ::service_layer::SLRouteCommon& SLAFIPRoute::_internal_routecommon() const {
  const ::service_layer::SLRouteCommon* p = routecommon_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRouteCommon&>(
      ::service_layer::_SLRouteCommon_default_instance_);
}
inline const ::service_layer::SLRouteCommon& SLAFIPRoute::routecommon() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFIPRoute.RouteCommon)
  return _internal_routecommon();
}
inline void SLAFIPRoute::unsafe_arena_set_allocated_routecommon(
    ::service_layer::SLRouteCommon* routecommon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routecommon_);
  }
  routecommon_ = routecommon;
  if (routecommon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFIPRoute.RouteCommon)
}
inline ::service_layer::SLRouteCommon* SLAFIPRoute::release_routecommon() {
  
  ::service_layer::SLRouteCommon* temp = routecommon_;
  routecommon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRouteCommon* SLAFIPRoute::unsafe_arena_release_routecommon() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFIPRoute.RouteCommon)
  
  ::service_layer::SLRouteCommon* temp = routecommon_;
  routecommon_ = nullptr;
  return temp;
}
inline ::service_layer::SLRouteCommon* SLAFIPRoute::_internal_mutable_routecommon() {
  
  if (routecommon_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRouteCommon>(GetArenaForAllocation());
    routecommon_ = p;
  }
  return routecommon_;
}
inline ::service_layer::SLRouteCommon* SLAFIPRoute::mutable_routecommon() {
  ::service_layer::SLRouteCommon* _msg = _internal_mutable_routecommon();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFIPRoute.RouteCommon)
  return _msg;
}
inline void SLAFIPRoute::set_allocated_routecommon(::service_layer::SLRouteCommon* routecommon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(routecommon_);
  }
  if (routecommon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routecommon));
    if (message_arena != submessage_arena) {
      routecommon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routecommon, submessage_arena);
    }
    
  } else {
    
  }
  routecommon_ = routecommon;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFIPRoute.RouteCommon)
}

// repeated .service_layer.SLRoutePath PathList = 3;
inline int SLAFIPRoute::_internal_pathlist_size() const {
  return pathlist_.size();
}
inline int SLAFIPRoute::pathlist_size() const {
  return _internal_pathlist_size();
}
inline ::service_layer::SLRoutePath* SLAFIPRoute::mutable_pathlist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFIPRoute.PathList)
  return pathlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
SLAFIPRoute::mutable_pathlist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFIPRoute.PathList)
  return &pathlist_;
}
inline const ::service_layer::SLRoutePath& SLAFIPRoute::_internal_pathlist(int index) const {
  return pathlist_.Get(index);
}
inline const ::service_layer::SLRoutePath& SLAFIPRoute::pathlist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFIPRoute.PathList)
  return _internal_pathlist(index);
}
inline ::service_layer::SLRoutePath* SLAFIPRoute::_internal_add_pathlist() {
  return pathlist_.Add();
}
inline ::service_layer::SLRoutePath* SLAFIPRoute::add_pathlist() {
  ::service_layer::SLRoutePath* _add = _internal_add_pathlist();
  // @@protoc_insertion_point(field_add:service_layer.SLAFIPRoute.PathList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
SLAFIPRoute::pathlist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFIPRoute.PathList)
  return pathlist_;
}

// -------------------------------------------------------------------

// SLAFObject

// .service_layer.SLAFIPRoute IPRoute = 1;
inline bool SLAFObject::_internal_has_iproute() const {
  return entry_case() == kIPRoute;
}
inline bool SLAFObject::has_iproute() const {
  return _internal_has_iproute();
}
inline void SLAFObject::set_has_iproute() {
  _oneof_case_[0] = kIPRoute;
}
inline void SLAFObject::clear_iproute() {
  if (_internal_has_iproute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.iproute_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLAFIPRoute* SLAFObject::release_iproute() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.IPRoute)
  if (_internal_has_iproute()) {
    clear_has_entry();
      ::service_layer::SLAFIPRoute* temp = entry_.iproute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.iproute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFIPRoute& SLAFObject::_internal_iproute() const {
  return _internal_has_iproute()
      ? *entry_.iproute_
      : reinterpret_cast< ::service_layer::SLAFIPRoute&>(::service_layer::_SLAFIPRoute_default_instance_);
}
inline const ::service_layer::SLAFIPRoute& SLAFObject::iproute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.IPRoute)
  return _internal_iproute();
}
inline ::service_layer::SLAFIPRoute* SLAFObject::unsafe_arena_release_iproute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.IPRoute)
  if (_internal_has_iproute()) {
    clear_has_entry();
    ::service_layer::SLAFIPRoute* temp = entry_.iproute_;
    entry_.iproute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_iproute(::service_layer::SLAFIPRoute* iproute) {
  clear_entry();
  if (iproute) {
    set_has_iproute();
    entry_.iproute_ = iproute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.IPRoute)
}
inline ::service_layer::SLAFIPRoute* SLAFObject::_internal_mutable_iproute() {
  if (!_internal_has_iproute()) {
    clear_entry();
    set_has_iproute();
    entry_.iproute_ = CreateMaybeMessage< ::service_layer::SLAFIPRoute >(GetArenaForAllocation());
  }
  return entry_.iproute_;
}
inline ::service_layer::SLAFIPRoute* SLAFObject::mutable_iproute() {
  ::service_layer::SLAFIPRoute* _msg = _internal_mutable_iproute();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.IPRoute)
  return _msg;
}

// .service_layer.SLMplsEntry MplsLabel = 2;
inline bool SLAFObject::_internal_has_mplslabel() const {
  return entry_case() == kMplsLabel;
}
inline bool SLAFObject::has_mplslabel() const {
  return _internal_has_mplslabel();
}
inline void SLAFObject::set_has_mplslabel() {
  _oneof_case_[0] = kMplsLabel;
}
inline void SLAFObject::clear_mplslabel() {
  if (_internal_has_mplslabel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.mplslabel_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLMplsEntry* SLAFObject::release_mplslabel() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_entry();
      ::service_layer::SLMplsEntry* temp = entry_.mplslabel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLMplsEntry& SLAFObject::_internal_mplslabel() const {
  return _internal_has_mplslabel()
      ? *entry_.mplslabel_
      : reinterpret_cast< ::service_layer::SLMplsEntry&>(::service_layer::_SLMplsEntry_default_instance_);
}
inline const ::service_layer::SLMplsEntry& SLAFObject::mplslabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.MplsLabel)
  return _internal_mplslabel();
}
inline ::service_layer::SLMplsEntry* SLAFObject::unsafe_arena_release_mplslabel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_entry();
    ::service_layer::SLMplsEntry* temp = entry_.mplslabel_;
    entry_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_mplslabel(::service_layer::SLMplsEntry* mplslabel) {
  clear_entry();
  if (mplslabel) {
    set_has_mplslabel();
    entry_.mplslabel_ = mplslabel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.MplsLabel)
}
inline ::service_layer::SLMplsEntry* SLAFObject::_internal_mutable_mplslabel() {
  if (!_internal_has_mplslabel()) {
    clear_entry();
    set_has_mplslabel();
    entry_.mplslabel_ = CreateMaybeMessage< ::service_layer::SLMplsEntry >(GetArenaForAllocation());
  }
  return entry_.mplslabel_;
}
inline ::service_layer::SLMplsEntry* SLAFObject::mutable_mplslabel() {
  ::service_layer::SLMplsEntry* _msg = _internal_mutable_mplslabel();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.MplsLabel)
  return _msg;
}

// .service_layer.SLPathGroup PathGroup = 3;
inline bool SLAFObject::_internal_has_pathgroup() const {
  return entry_case() == kPathGroup;
}
inline bool SLAFObject::has_pathgroup() const {
  return _internal_has_pathgroup();
}
inline void SLAFObject::set_has_pathgroup() {
  _oneof_case_[0] = kPathGroup;
}
inline void SLAFObject::clear_pathgroup() {
  if (_internal_has_pathgroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.pathgroup_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLPathGroup* SLAFObject::release_pathgroup() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObject.PathGroup)
  if (_internal_has_pathgroup()) {
    clear_has_entry();
      ::service_layer::SLPathGroup* temp = entry_.pathgroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathgroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroup& SLAFObject::_internal_pathgroup() const {
  return _internal_has_pathgroup()
      ? *entry_.pathgroup_
      : reinterpret_cast< ::service_layer::SLPathGroup&>(::service_layer::_SLPathGroup_default_instance_);
}
inline const ::service_layer::SLPathGroup& SLAFObject::pathgroup() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObject.PathGroup)
  return _internal_pathgroup();
}
inline ::service_layer::SLPathGroup* SLAFObject::unsafe_arena_release_pathgroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObject.PathGroup)
  if (_internal_has_pathgroup()) {
    clear_has_entry();
    ::service_layer::SLPathGroup* temp = entry_.pathgroup_;
    entry_.pathgroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObject::unsafe_arena_set_allocated_pathgroup(::service_layer::SLPathGroup* pathgroup) {
  clear_entry();
  if (pathgroup) {
    set_has_pathgroup();
    entry_.pathgroup_ = pathgroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObject.PathGroup)
}
inline ::service_layer::SLPathGroup* SLAFObject::_internal_mutable_pathgroup() {
  if (!_internal_has_pathgroup()) {
    clear_entry();
    set_has_pathgroup();
    entry_.pathgroup_ = CreateMaybeMessage< ::service_layer::SLPathGroup >(GetArenaForAllocation());
  }
  return entry_.pathgroup_;
}
inline ::service_layer::SLPathGroup* SLAFObject::mutable_pathgroup() {
  ::service_layer::SLPathGroup* _msg = _internal_mutable_pathgroup();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObject.PathGroup)
  return _msg;
}

inline bool SLAFObject::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLAFObject::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLAFObject::EntryCase SLAFObject::entry_case() const {
  return SLAFObject::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFOpMsg

// .service_layer.SLAFObject AFObject = 1;
inline bool SLAFOpMsg::_internal_has_afobject() const {
  return this != internal_default_instance() && afobject_ != nullptr;
}
inline bool SLAFOpMsg::has_afobject() const {
  return _internal_has_afobject();
}
inline void SLAFOpMsg::clear_afobject() {
  if (GetArenaForAllocation() == nullptr && afobject_ != nullptr) {
    delete afobject_;
  }
  afobject_ = nullptr;
}
inline const ::service_layer::SLAFObject& SLAFOpMsg::_internal_afobject() const {
  const ::service_layer::SLAFObject* p = afobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFObject&>(
      ::service_layer::_SLAFObject_default_instance_);
}
inline const ::service_layer::SLAFObject& SLAFOpMsg::afobject() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOpMsg.AFObject)
  return _internal_afobject();
}
inline void SLAFOpMsg::unsafe_arena_set_allocated_afobject(
    ::service_layer::SLAFObject* afobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(afobject_);
  }
  afobject_ = afobject;
  if (afobject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFOpMsg.AFObject)
}
inline ::service_layer::SLAFObject* SLAFOpMsg::release_afobject() {
  
  ::service_layer::SLAFObject* temp = afobject_;
  afobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFObject* SLAFOpMsg::unsafe_arena_release_afobject() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFOpMsg.AFObject)
  
  ::service_layer::SLAFObject* temp = afobject_;
  afobject_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFObject* SLAFOpMsg::_internal_mutable_afobject() {
  
  if (afobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFObject>(GetArenaForAllocation());
    afobject_ = p;
  }
  return afobject_;
}
inline ::service_layer::SLAFObject* SLAFOpMsg::mutable_afobject() {
  ::service_layer::SLAFObject* _msg = _internal_mutable_afobject();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFOpMsg.AFObject)
  return _msg;
}
inline void SLAFOpMsg::set_allocated_afobject(::service_layer::SLAFObject* afobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete afobject_;
  }
  if (afobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFObject>::GetOwningArena(afobject);
    if (message_arena != submessage_arena) {
      afobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, afobject, submessage_arena);
    }
    
  } else {
    
  }
  afobject_ = afobject;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFOpMsg.AFObject)
}

// uint64 OperationID = 2;
inline void SLAFOpMsg::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFOpMsg::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFOpMsg::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOpMsg.OperationID)
  return _internal_operationid();
}
inline void SLAFOpMsg::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFOpMsg::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOpMsg.OperationID)
}

// .service_layer.SLRspACKType AckType = 3;
inline void SLAFOpMsg::clear_acktype() {
  acktype_ = 0;
}
inline ::service_layer::SLRspACKType SLAFOpMsg::_internal_acktype() const {
  return static_cast< ::service_layer::SLRspACKType >(acktype_);
}
inline ::service_layer::SLRspACKType SLAFOpMsg::acktype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOpMsg.AckType)
  return _internal_acktype();
}
inline void SLAFOpMsg::_internal_set_acktype(::service_layer::SLRspACKType value) {
  
  acktype_ = value;
}
inline void SLAFOpMsg::set_acktype(::service_layer::SLRspACKType value) {
  _internal_set_acktype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOpMsg.AckType)
}

// repeated .service_layer.SLRspACKPermit AckPermits = 4;
inline int SLAFOpMsg::_internal_ackpermits_size() const {
  return ackpermits_.size();
}
inline int SLAFOpMsg::ackpermits_size() const {
  return _internal_ackpermits_size();
}
inline void SLAFOpMsg::clear_ackpermits() {
  ackpermits_.Clear();
}
inline ::service_layer::SLRspACKPermit SLAFOpMsg::_internal_ackpermits(int index) const {
  return static_cast< ::service_layer::SLRspACKPermit >(ackpermits_.Get(index));
}
inline ::service_layer::SLRspACKPermit SLAFOpMsg::ackpermits(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOpMsg.AckPermits)
  return _internal_ackpermits(index);
}
inline void SLAFOpMsg::set_ackpermits(int index, ::service_layer::SLRspACKPermit value) {
  ackpermits_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOpMsg.AckPermits)
}
inline void SLAFOpMsg::_internal_add_ackpermits(::service_layer::SLRspACKPermit value) {
  ackpermits_.Add(value);
}
inline void SLAFOpMsg::add_ackpermits(::service_layer::SLRspACKPermit value) {
  _internal_add_ackpermits(value);
  // @@protoc_insertion_point(field_add:service_layer.SLAFOpMsg.AckPermits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLAFOpMsg::ackpermits() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFOpMsg.AckPermits)
  return ackpermits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLAFOpMsg::_internal_mutable_ackpermits() {
  return &ackpermits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLAFOpMsg::mutable_ackpermits() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFOpMsg.AckPermits)
  return _internal_mutable_ackpermits();
}

// .service_layer.SLRspAckCadence AckCadence = 5;
inline void SLAFOpMsg::clear_ackcadence() {
  ackcadence_ = 0;
}
inline ::service_layer::SLRspAckCadence SLAFOpMsg::_internal_ackcadence() const {
  return static_cast< ::service_layer::SLRspAckCadence >(ackcadence_);
}
inline ::service_layer::SLRspAckCadence SLAFOpMsg::ackcadence() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFOpMsg.AckCadence)
  return _internal_ackcadence();
}
inline void SLAFOpMsg::_internal_set_ackcadence(::service_layer::SLRspAckCadence value) {
  
  ackcadence_ = value;
}
inline void SLAFOpMsg::set_ackcadence(::service_layer::SLRspAckCadence value) {
  _internal_set_ackcadence(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFOpMsg.AckCadence)
}

// -------------------------------------------------------------------

// SLAFClientIDList

// repeated uint64 ClientIDList = 1;
inline int SLAFClientIDList::_internal_clientidlist_size() const {
  return clientidlist_.size();
}
inline int SLAFClientIDList::clientidlist_size() const {
  return _internal_clientidlist_size();
}
inline void SLAFClientIDList::clear_clientidlist() {
  clientidlist_.Clear();
}
inline uint64_t SLAFClientIDList::_internal_clientidlist(int index) const {
  return clientidlist_.Get(index);
}
inline uint64_t SLAFClientIDList::clientidlist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFClientIDList.ClientIDList)
  return _internal_clientidlist(index);
}
inline void SLAFClientIDList::set_clientidlist(int index, uint64_t value) {
  clientidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFClientIDList.ClientIDList)
}
inline void SLAFClientIDList::_internal_add_clientidlist(uint64_t value) {
  clientidlist_.Add(value);
}
inline void SLAFClientIDList::add_clientidlist(uint64_t value) {
  _internal_add_clientidlist(value);
  // @@protoc_insertion_point(field_add:service_layer.SLAFClientIDList.ClientIDList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SLAFClientIDList::_internal_clientidlist() const {
  return clientidlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SLAFClientIDList::clientidlist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFClientIDList.ClientIDList)
  return _internal_clientidlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SLAFClientIDList::_internal_mutable_clientidlist() {
  return &clientidlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SLAFClientIDList::mutable_clientidlist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFClientIDList.ClientIDList)
  return _internal_mutable_clientidlist();
}

// -------------------------------------------------------------------

// SLTableTypeList

// repeated .service_layer.SLTableType Table = 1;
inline int SLTableTypeList::_internal_table_size() const {
  return table_.size();
}
inline int SLTableTypeList::table_size() const {
  return _internal_table_size();
}
inline void SLTableTypeList::clear_table() {
  table_.Clear();
}
inline ::service_layer::SLTableType SLTableTypeList::_internal_table(int index) const {
  return static_cast< ::service_layer::SLTableType >(table_.Get(index));
}
inline ::service_layer::SLTableType SLTableTypeList::table(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLTableTypeList.Table)
  return _internal_table(index);
}
inline void SLTableTypeList::set_table(int index, ::service_layer::SLTableType value) {
  table_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLTableTypeList.Table)
}
inline void SLTableTypeList::_internal_add_table(::service_layer::SLTableType value) {
  table_.Add(value);
}
inline void SLTableTypeList::add_table(::service_layer::SLTableType value) {
  _internal_add_table(value);
  // @@protoc_insertion_point(field_add:service_layer.SLTableTypeList.Table)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLTableTypeList::table() const {
  // @@protoc_insertion_point(field_list:service_layer.SLTableTypeList.Table)
  return table_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLTableTypeList::_internal_mutable_table() {
  return &table_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLTableTypeList::mutable_table() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLTableTypeList.Table)
  return _internal_mutable_table();
}

// -------------------------------------------------------------------

// SLAFObjectKey

// .service_layer.SLRoutePrefix IPRoutePrefix = 1;
inline bool SLAFObjectKey::_internal_has_iprouteprefix() const {
  return key_case() == kIPRoutePrefix;
}
inline bool SLAFObjectKey::has_iprouteprefix() const {
  return _internal_has_iprouteprefix();
}
inline void SLAFObjectKey::set_has_iprouteprefix() {
  _oneof_case_[0] = kIPRoutePrefix;
}
inline ::service_layer::SLRoutePrefix* SLAFObjectKey::release_iprouteprefix() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObjectKey.IPRoutePrefix)
  if (_internal_has_iprouteprefix()) {
    clear_has_key();
      ::service_layer::SLRoutePrefix* temp = key_.iprouteprefix_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    key_.iprouteprefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLRoutePrefix& SLAFObjectKey::_internal_iprouteprefix() const {
  return _internal_has_iprouteprefix()
      ? *key_.iprouteprefix_
      : reinterpret_cast< ::service_layer::SLRoutePrefix&>(::service_layer::_SLRoutePrefix_default_instance_);
}
inline const ::service_layer::SLRoutePrefix& SLAFObjectKey::iprouteprefix() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObjectKey.IPRoutePrefix)
  return _internal_iprouteprefix();
}
inline ::service_layer::SLRoutePrefix* SLAFObjectKey::unsafe_arena_release_iprouteprefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObjectKey.IPRoutePrefix)
  if (_internal_has_iprouteprefix()) {
    clear_has_key();
    ::service_layer::SLRoutePrefix* temp = key_.iprouteprefix_;
    key_.iprouteprefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObjectKey::unsafe_arena_set_allocated_iprouteprefix(::service_layer::SLRoutePrefix* iprouteprefix) {
  clear_key();
  if (iprouteprefix) {
    set_has_iprouteprefix();
    key_.iprouteprefix_ = iprouteprefix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObjectKey.IPRoutePrefix)
}
inline ::service_layer::SLRoutePrefix* SLAFObjectKey::_internal_mutable_iprouteprefix() {
  if (!_internal_has_iprouteprefix()) {
    clear_key();
    set_has_iprouteprefix();
    key_.iprouteprefix_ = CreateMaybeMessage< ::service_layer::SLRoutePrefix >(GetArenaForAllocation());
  }
  return key_.iprouteprefix_;
}
inline ::service_layer::SLRoutePrefix* SLAFObjectKey::mutable_iprouteprefix() {
  ::service_layer::SLRoutePrefix* _msg = _internal_mutable_iprouteprefix();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObjectKey.IPRoutePrefix)
  return _msg;
}

// .service_layer.SLMplsEntryKey MplsLabel = 2;
inline bool SLAFObjectKey::_internal_has_mplslabel() const {
  return key_case() == kMplsLabel;
}
inline bool SLAFObjectKey::has_mplslabel() const {
  return _internal_has_mplslabel();
}
inline void SLAFObjectKey::set_has_mplslabel() {
  _oneof_case_[0] = kMplsLabel;
}
inline void SLAFObjectKey::clear_mplslabel() {
  if (_internal_has_mplslabel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete key_.mplslabel_;
    }
    clear_has_key();
  }
}
inline ::service_layer::SLMplsEntryKey* SLAFObjectKey::release_mplslabel() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObjectKey.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_key();
      ::service_layer::SLMplsEntryKey* temp = key_.mplslabel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    key_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLMplsEntryKey& SLAFObjectKey::_internal_mplslabel() const {
  return _internal_has_mplslabel()
      ? *key_.mplslabel_
      : reinterpret_cast< ::service_layer::SLMplsEntryKey&>(::service_layer::_SLMplsEntryKey_default_instance_);
}
inline const ::service_layer::SLMplsEntryKey& SLAFObjectKey::mplslabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObjectKey.MplsLabel)
  return _internal_mplslabel();
}
inline ::service_layer::SLMplsEntryKey* SLAFObjectKey::unsafe_arena_release_mplslabel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObjectKey.MplsLabel)
  if (_internal_has_mplslabel()) {
    clear_has_key();
    ::service_layer::SLMplsEntryKey* temp = key_.mplslabel_;
    key_.mplslabel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObjectKey::unsafe_arena_set_allocated_mplslabel(::service_layer::SLMplsEntryKey* mplslabel) {
  clear_key();
  if (mplslabel) {
    set_has_mplslabel();
    key_.mplslabel_ = mplslabel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObjectKey.MplsLabel)
}
inline ::service_layer::SLMplsEntryKey* SLAFObjectKey::_internal_mutable_mplslabel() {
  if (!_internal_has_mplslabel()) {
    clear_key();
    set_has_mplslabel();
    key_.mplslabel_ = CreateMaybeMessage< ::service_layer::SLMplsEntryKey >(GetArenaForAllocation());
  }
  return key_.mplslabel_;
}
inline ::service_layer::SLMplsEntryKey* SLAFObjectKey::mutable_mplslabel() {
  ::service_layer::SLMplsEntryKey* _msg = _internal_mutable_mplslabel();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObjectKey.MplsLabel)
  return _msg;
}

// .service_layer.SLObjectId PathGroupId = 3;
inline bool SLAFObjectKey::_internal_has_pathgroupid() const {
  return key_case() == kPathGroupId;
}
inline bool SLAFObjectKey::has_pathgroupid() const {
  return _internal_has_pathgroupid();
}
inline void SLAFObjectKey::set_has_pathgroupid() {
  _oneof_case_[0] = kPathGroupId;
}
inline ::service_layer::SLObjectId* SLAFObjectKey::release_pathgroupid() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFObjectKey.PathGroupId)
  if (_internal_has_pathgroupid()) {
    clear_has_key();
      ::service_layer::SLObjectId* temp = key_.pathgroupid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    key_.pathgroupid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLObjectId& SLAFObjectKey::_internal_pathgroupid() const {
  return _internal_has_pathgroupid()
      ? *key_.pathgroupid_
      : reinterpret_cast< ::service_layer::SLObjectId&>(::service_layer::_SLObjectId_default_instance_);
}
inline const ::service_layer::SLObjectId& SLAFObjectKey::pathgroupid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFObjectKey.PathGroupId)
  return _internal_pathgroupid();
}
inline ::service_layer::SLObjectId* SLAFObjectKey::unsafe_arena_release_pathgroupid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFObjectKey.PathGroupId)
  if (_internal_has_pathgroupid()) {
    clear_has_key();
    ::service_layer::SLObjectId* temp = key_.pathgroupid_;
    key_.pathgroupid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFObjectKey::unsafe_arena_set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid) {
  clear_key();
  if (pathgroupid) {
    set_has_pathgroupid();
    key_.pathgroupid_ = pathgroupid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFObjectKey.PathGroupId)
}
inline ::service_layer::SLObjectId* SLAFObjectKey::_internal_mutable_pathgroupid() {
  if (!_internal_has_pathgroupid()) {
    clear_key();
    set_has_pathgroupid();
    key_.pathgroupid_ = CreateMaybeMessage< ::service_layer::SLObjectId >(GetArenaForAllocation());
  }
  return key_.pathgroupid_;
}
inline ::service_layer::SLObjectId* SLAFObjectKey::mutable_pathgroupid() {
  ::service_layer::SLObjectId* _msg = _internal_mutable_pathgroupid();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFObjectKey.PathGroupId)
  return _msg;
}

inline bool SLAFObjectKey::has_key() const {
  return key_case() != KEY_NOT_SET;
}
inline void SLAFObjectKey::clear_has_key() {
  _oneof_case_[0] = KEY_NOT_SET;
}
inline SLAFObjectKey::KeyCase SLAFObjectKey::key_case() const {
  return SLAFObjectKey::KeyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFGetMatch

// .service_layer.SLAFObjectKey Key = 1;
inline bool SLAFGetMatch::_internal_has_key() const {
  return entry_case() == kKey;
}
inline bool SLAFGetMatch::has_key() const {
  return _internal_has_key();
}
inline void SLAFGetMatch::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void SLAFGetMatch::clear_key() {
  if (_internal_has_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.key_;
    }
    clear_has_entry();
  }
}
inline ::service_layer::SLAFObjectKey* SLAFGetMatch::release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMatch.Key)
  if (_internal_has_key()) {
    clear_has_entry();
      ::service_layer::SLAFObjectKey* temp = entry_.key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFObjectKey& SLAFGetMatch::_internal_key() const {
  return _internal_has_key()
      ? *entry_.key_
      : reinterpret_cast< ::service_layer::SLAFObjectKey&>(::service_layer::_SLAFObjectKey_default_instance_);
}
inline const ::service_layer::SLAFObjectKey& SLAFGetMatch::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMatch.Key)
  return _internal_key();
}
inline ::service_layer::SLAFObjectKey* SLAFGetMatch::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFGetMatch.Key)
  if (_internal_has_key()) {
    clear_has_entry();
    ::service_layer::SLAFObjectKey* temp = entry_.key_;
    entry_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFGetMatch::unsafe_arena_set_allocated_key(::service_layer::SLAFObjectKey* key) {
  clear_entry();
  if (key) {
    set_has_key();
    entry_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMatch.Key)
}
inline ::service_layer::SLAFObjectKey* SLAFGetMatch::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_entry();
    set_has_key();
    entry_.key_ = CreateMaybeMessage< ::service_layer::SLAFObjectKey >(GetArenaForAllocation());
  }
  return entry_.key_;
}
inline ::service_layer::SLAFObjectKey* SLAFGetMatch::mutable_key() {
  ::service_layer::SLAFObjectKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMatch.Key)
  return _msg;
}

// string PathGroupRegex = 2;
inline bool SLAFGetMatch::_internal_has_pathgroupregex() const {
  return entry_case() == kPathGroupRegex;
}
inline bool SLAFGetMatch::has_pathgroupregex() const {
  return _internal_has_pathgroupregex();
}
inline void SLAFGetMatch::set_has_pathgroupregex() {
  _oneof_case_[0] = kPathGroupRegex;
}
inline void SLAFGetMatch::clear_pathgroupregex() {
  if (_internal_has_pathgroupregex()) {
    entry_.pathgroupregex_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_entry();
  }
}
inline const std::string& SLAFGetMatch::pathgroupregex() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMatch.PathGroupRegex)
  return _internal_pathgroupregex();
}
template <typename ArgT0, typename... ArgT>
inline void SLAFGetMatch::set_pathgroupregex(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_pathgroupregex()) {
    clear_entry();
    set_has_pathgroupregex();
    entry_.pathgroupregex_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  entry_.pathgroupregex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMatch.PathGroupRegex)
}
inline std::string* SLAFGetMatch::mutable_pathgroupregex() {
  std::string* _s = _internal_mutable_pathgroupregex();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMatch.PathGroupRegex)
  return _s;
}
inline const std::string& SLAFGetMatch::_internal_pathgroupregex() const {
  if (_internal_has_pathgroupregex()) {
    return entry_.pathgroupregex_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLAFGetMatch::_internal_set_pathgroupregex(const std::string& value) {
  if (!_internal_has_pathgroupregex()) {
    clear_entry();
    set_has_pathgroupregex();
    entry_.pathgroupregex_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  entry_.pathgroupregex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFGetMatch::_internal_mutable_pathgroupregex() {
  if (!_internal_has_pathgroupregex()) {
    clear_entry();
    set_has_pathgroupregex();
    entry_.pathgroupregex_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return entry_.pathgroupregex_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFGetMatch::release_pathgroupregex() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMatch.PathGroupRegex)
  if (_internal_has_pathgroupregex()) {
    clear_has_entry();
    return entry_.pathgroupregex_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SLAFGetMatch::set_allocated_pathgroupregex(std::string* pathgroupregex) {
  if (has_entry()) {
    clear_entry();
  }
  if (pathgroupregex != nullptr) {
    set_has_pathgroupregex();
    entry_.pathgroupregex_.UnsafeSetDefault(pathgroupregex);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(pathgroupregex);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMatch.PathGroupRegex)
}

// uint32 VxlanVniId = 3;
inline bool SLAFGetMatch::_internal_has_vxlanvniid() const {
  return entry_case() == kVxlanVniId;
}
inline bool SLAFGetMatch::has_vxlanvniid() const {
  return _internal_has_vxlanvniid();
}
inline void SLAFGetMatch::set_has_vxlanvniid() {
  _oneof_case_[0] = kVxlanVniId;
}
inline void SLAFGetMatch::clear_vxlanvniid() {
  if (_internal_has_vxlanvniid()) {
    entry_.vxlanvniid_ = 0u;
    clear_has_entry();
  }
}
inline uint32_t SLAFGetMatch::_internal_vxlanvniid() const {
  if (_internal_has_vxlanvniid()) {
    return entry_.vxlanvniid_;
  }
  return 0u;
}
inline void SLAFGetMatch::_internal_set_vxlanvniid(uint32_t value) {
  if (!_internal_has_vxlanvniid()) {
    clear_entry();
    set_has_vxlanvniid();
  }
  entry_.vxlanvniid_ = value;
}
inline uint32_t SLAFGetMatch::vxlanvniid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMatch.VxlanVniId)
  return _internal_vxlanvniid();
}
inline void SLAFGetMatch::set_vxlanvniid(uint32_t value) {
  _internal_set_vxlanvniid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMatch.VxlanVniId)
}

inline bool SLAFGetMatch::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLAFGetMatch::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLAFGetMatch::EntryCase SLAFGetMatch::entry_case() const {
  return SLAFGetMatch::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFGetMatchList

// repeated .service_layer.SLAFGetMatch Match = 1;
inline int SLAFGetMatchList::_internal_match_size() const {
  return match_.size();
}
inline int SLAFGetMatchList::match_size() const {
  return _internal_match_size();
}
inline void SLAFGetMatchList::clear_match() {
  match_.Clear();
}
inline ::service_layer::SLAFGetMatch* SLAFGetMatchList::mutable_match(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMatchList.Match)
  return match_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMatch >*
SLAFGetMatchList::mutable_match() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFGetMatchList.Match)
  return &match_;
}
inline const ::service_layer::SLAFGetMatch& SLAFGetMatchList::_internal_match(int index) const {
  return match_.Get(index);
}
inline const ::service_layer::SLAFGetMatch& SLAFGetMatchList::match(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMatchList.Match)
  return _internal_match(index);
}
inline ::service_layer::SLAFGetMatch* SLAFGetMatchList::_internal_add_match() {
  return match_.Add();
}
inline ::service_layer::SLAFGetMatch* SLAFGetMatchList::add_match() {
  ::service_layer::SLAFGetMatch* _add = _internal_add_match();
  // @@protoc_insertion_point(field_add:service_layer.SLAFGetMatchList.Match)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMatch >&
SLAFGetMatchList::match() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFGetMatchList.Match)
  return match_;
}

// -------------------------------------------------------------------

// SLAFGetMsg

// string VrfName = 1;
inline void SLAFGetMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFGetMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFGetMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsg.VrfName)
}
inline std::string* SLAFGetMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.VrfName)
  return _s;
}
inline const std::string& SLAFGetMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFGetMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFGetMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFGetMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFGetMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsg.VrfName)
}

// .service_layer.SLAFClientIDList ClientIDList = 2;
inline bool SLAFGetMsg::_internal_has_clientidlist() const {
  return client_case() == kClientIDList;
}
inline bool SLAFGetMsg::has_clientidlist() const {
  return _internal_has_clientidlist();
}
inline void SLAFGetMsg::set_has_clientidlist() {
  _oneof_case_[0] = kClientIDList;
}
inline void SLAFGetMsg::clear_clientidlist() {
  if (_internal_has_clientidlist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete client_.clientidlist_;
    }
    clear_has_client();
  }
}
inline ::service_layer::SLAFClientIDList* SLAFGetMsg::release_clientidlist() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsg.ClientIDList)
  if (_internal_has_clientidlist()) {
    clear_has_client();
      ::service_layer::SLAFClientIDList* temp = client_.clientidlist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    client_.clientidlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFClientIDList& SLAFGetMsg::_internal_clientidlist() const {
  return _internal_has_clientidlist()
      ? *client_.clientidlist_
      : reinterpret_cast< ::service_layer::SLAFClientIDList&>(::service_layer::_SLAFClientIDList_default_instance_);
}
inline const ::service_layer::SLAFClientIDList& SLAFGetMsg::clientidlist() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.ClientIDList)
  return _internal_clientidlist();
}
inline ::service_layer::SLAFClientIDList* SLAFGetMsg::unsafe_arena_release_clientidlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFGetMsg.ClientIDList)
  if (_internal_has_clientidlist()) {
    clear_has_client();
    ::service_layer::SLAFClientIDList* temp = client_.clientidlist_;
    client_.clientidlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFGetMsg::unsafe_arena_set_allocated_clientidlist(::service_layer::SLAFClientIDList* clientidlist) {
  clear_client();
  if (clientidlist) {
    set_has_clientidlist();
    client_.clientidlist_ = clientidlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsg.ClientIDList)
}
inline ::service_layer::SLAFClientIDList* SLAFGetMsg::_internal_mutable_clientidlist() {
  if (!_internal_has_clientidlist()) {
    clear_client();
    set_has_clientidlist();
    client_.clientidlist_ = CreateMaybeMessage< ::service_layer::SLAFClientIDList >(GetArenaForAllocation());
  }
  return client_.clientidlist_;
}
inline ::service_layer::SLAFClientIDList* SLAFGetMsg::mutable_clientidlist() {
  ::service_layer::SLAFClientIDList* _msg = _internal_mutable_clientidlist();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.ClientIDList)
  return _msg;
}

// bool AllClients = 3;
inline bool SLAFGetMsg::_internal_has_allclients() const {
  return client_case() == kAllClients;
}
inline bool SLAFGetMsg::has_allclients() const {
  return _internal_has_allclients();
}
inline void SLAFGetMsg::set_has_allclients() {
  _oneof_case_[0] = kAllClients;
}
inline void SLAFGetMsg::clear_allclients() {
  if (_internal_has_allclients()) {
    client_.allclients_ = false;
    clear_has_client();
  }
}
inline bool SLAFGetMsg::_internal_allclients() const {
  if (_internal_has_allclients()) {
    return client_.allclients_;
  }
  return false;
}
inline void SLAFGetMsg::_internal_set_allclients(bool value) {
  if (!_internal_has_allclients()) {
    clear_client();
    set_has_allclients();
  }
  client_.allclients_ = value;
}
inline bool SLAFGetMsg::allclients() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.AllClients)
  return _internal_allclients();
}
inline void SLAFGetMsg::set_allclients(bool value) {
  _internal_set_allclients(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsg.AllClients)
}

// .service_layer.SLTableTypeList TableList = 4;
inline bool SLAFGetMsg::_internal_has_tablelist() const {
  return match_case() == kTableList;
}
inline bool SLAFGetMsg::has_tablelist() const {
  return _internal_has_tablelist();
}
inline void SLAFGetMsg::set_has_tablelist() {
  _oneof_case_[1] = kTableList;
}
inline void SLAFGetMsg::clear_tablelist() {
  if (_internal_has_tablelist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete match_.tablelist_;
    }
    clear_has_match();
  }
}
inline ::service_layer::SLTableTypeList* SLAFGetMsg::release_tablelist() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsg.TableList)
  if (_internal_has_tablelist()) {
    clear_has_match();
      ::service_layer::SLTableTypeList* temp = match_.tablelist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    match_.tablelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLTableTypeList& SLAFGetMsg::_internal_tablelist() const {
  return _internal_has_tablelist()
      ? *match_.tablelist_
      : reinterpret_cast< ::service_layer::SLTableTypeList&>(::service_layer::_SLTableTypeList_default_instance_);
}
inline const ::service_layer::SLTableTypeList& SLAFGetMsg::tablelist() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.TableList)
  return _internal_tablelist();
}
inline ::service_layer::SLTableTypeList* SLAFGetMsg::unsafe_arena_release_tablelist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFGetMsg.TableList)
  if (_internal_has_tablelist()) {
    clear_has_match();
    ::service_layer::SLTableTypeList* temp = match_.tablelist_;
    match_.tablelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFGetMsg::unsafe_arena_set_allocated_tablelist(::service_layer::SLTableTypeList* tablelist) {
  clear_match();
  if (tablelist) {
    set_has_tablelist();
    match_.tablelist_ = tablelist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsg.TableList)
}
inline ::service_layer::SLTableTypeList* SLAFGetMsg::_internal_mutable_tablelist() {
  if (!_internal_has_tablelist()) {
    clear_match();
    set_has_tablelist();
    match_.tablelist_ = CreateMaybeMessage< ::service_layer::SLTableTypeList >(GetArenaForAllocation());
  }
  return match_.tablelist_;
}
inline ::service_layer::SLTableTypeList* SLAFGetMsg::mutable_tablelist() {
  ::service_layer::SLTableTypeList* _msg = _internal_mutable_tablelist();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.TableList)
  return _msg;
}

// .service_layer.SLAFGetMatchList RouteMatchList = 5;
inline bool SLAFGetMsg::_internal_has_routematchlist() const {
  return match_case() == kRouteMatchList;
}
inline bool SLAFGetMsg::has_routematchlist() const {
  return _internal_has_routematchlist();
}
inline void SLAFGetMsg::set_has_routematchlist() {
  _oneof_case_[1] = kRouteMatchList;
}
inline void SLAFGetMsg::clear_routematchlist() {
  if (_internal_has_routematchlist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete match_.routematchlist_;
    }
    clear_has_match();
  }
}
inline ::service_layer::SLAFGetMatchList* SLAFGetMsg::release_routematchlist() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsg.RouteMatchList)
  if (_internal_has_routematchlist()) {
    clear_has_match();
      ::service_layer::SLAFGetMatchList* temp = match_.routematchlist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    match_.routematchlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFGetMatchList& SLAFGetMsg::_internal_routematchlist() const {
  return _internal_has_routematchlist()
      ? *match_.routematchlist_
      : reinterpret_cast< ::service_layer::SLAFGetMatchList&>(::service_layer::_SLAFGetMatchList_default_instance_);
}
inline const ::service_layer::SLAFGetMatchList& SLAFGetMsg::routematchlist() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsg.RouteMatchList)
  return _internal_routematchlist();
}
inline ::service_layer::SLAFGetMatchList* SLAFGetMsg::unsafe_arena_release_routematchlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFGetMsg.RouteMatchList)
  if (_internal_has_routematchlist()) {
    clear_has_match();
    ::service_layer::SLAFGetMatchList* temp = match_.routematchlist_;
    match_.routematchlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFGetMsg::unsafe_arena_set_allocated_routematchlist(::service_layer::SLAFGetMatchList* routematchlist) {
  clear_match();
  if (routematchlist) {
    set_has_routematchlist();
    match_.routematchlist_ = routematchlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsg.RouteMatchList)
}
inline ::service_layer::SLAFGetMatchList* SLAFGetMsg::_internal_mutable_routematchlist() {
  if (!_internal_has_routematchlist()) {
    clear_match();
    set_has_routematchlist();
    match_.routematchlist_ = CreateMaybeMessage< ::service_layer::SLAFGetMatchList >(GetArenaForAllocation());
  }
  return match_.routematchlist_;
}
inline ::service_layer::SLAFGetMatchList* SLAFGetMsg::mutable_routematchlist() {
  ::service_layer::SLAFGetMatchList* _msg = _internal_mutable_routematchlist();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsg.RouteMatchList)
  return _msg;
}

inline bool SLAFGetMsg::has_client() const {
  return client_case() != CLIENT_NOT_SET;
}
inline void SLAFGetMsg::clear_has_client() {
  _oneof_case_[0] = CLIENT_NOT_SET;
}
inline bool SLAFGetMsg::has_match() const {
  return match_case() != MATCH_NOT_SET;
}
inline void SLAFGetMsg::clear_has_match() {
  _oneof_case_[1] = MATCH_NOT_SET;
}
inline SLAFGetMsg::ClientCase SLAFGetMsg::client_case() const {
  return SLAFGetMsg::ClientCase(_oneof_case_[0]);
}
inline SLAFGetMsg::MatchCase SLAFGetMsg::match_case() const {
  return SLAFGetMsg::MatchCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// SLAFGetMsgRspEntry

// .service_layer.SLAFOpMsg AFOpMsg = 1;
inline bool SLAFGetMsgRspEntry::_internal_has_afopmsg() const {
  return this != internal_default_instance() && afopmsg_ != nullptr;
}
inline bool SLAFGetMsgRspEntry::has_afopmsg() const {
  return _internal_has_afopmsg();
}
inline void SLAFGetMsgRspEntry::clear_afopmsg() {
  if (GetArenaForAllocation() == nullptr && afopmsg_ != nullptr) {
    delete afopmsg_;
  }
  afopmsg_ = nullptr;
}
inline const ::service_layer::SLAFOpMsg& SLAFGetMsgRspEntry::_internal_afopmsg() const {
  const ::service_layer::SLAFOpMsg* p = afopmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFOpMsg&>(
      ::service_layer::_SLAFOpMsg_default_instance_);
}
inline const ::service_layer::SLAFOpMsg& SLAFGetMsgRspEntry::afopmsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRspEntry.AFOpMsg)
  return _internal_afopmsg();
}
inline void SLAFGetMsgRspEntry::unsafe_arena_set_allocated_afopmsg(
    ::service_layer::SLAFOpMsg* afopmsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(afopmsg_);
  }
  afopmsg_ = afopmsg;
  if (afopmsg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsgRspEntry.AFOpMsg)
}
inline ::service_layer::SLAFOpMsg* SLAFGetMsgRspEntry::release_afopmsg() {
  
  ::service_layer::SLAFOpMsg* temp = afopmsg_;
  afopmsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFOpMsg* SLAFGetMsgRspEntry::unsafe_arena_release_afopmsg() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRspEntry.AFOpMsg)
  
  ::service_layer::SLAFOpMsg* temp = afopmsg_;
  afopmsg_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFOpMsg* SLAFGetMsgRspEntry::_internal_mutable_afopmsg() {
  
  if (afopmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFOpMsg>(GetArenaForAllocation());
    afopmsg_ = p;
  }
  return afopmsg_;
}
inline ::service_layer::SLAFOpMsg* SLAFGetMsgRspEntry::mutable_afopmsg() {
  ::service_layer::SLAFOpMsg* _msg = _internal_mutable_afopmsg();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRspEntry.AFOpMsg)
  return _msg;
}
inline void SLAFGetMsgRspEntry::set_allocated_afopmsg(::service_layer::SLAFOpMsg* afopmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete afopmsg_;
  }
  if (afopmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFOpMsg>::GetOwningArena(afopmsg);
    if (message_arena != submessage_arena) {
      afopmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, afopmsg, submessage_arena);
    }
    
  } else {
    
  }
  afopmsg_ = afopmsg;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRspEntry.AFOpMsg)
}

// .service_layer.SLAFFibStatus FIBStatus = 2;
inline void SLAFGetMsgRspEntry::clear_fibstatus() {
  fibstatus_ = 0;
}
inline ::service_layer::SLAFFibStatus SLAFGetMsgRspEntry::_internal_fibstatus() const {
  return static_cast< ::service_layer::SLAFFibStatus >(fibstatus_);
}
inline ::service_layer::SLAFFibStatus SLAFGetMsgRspEntry::fibstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRspEntry.FIBStatus)
  return _internal_fibstatus();
}
inline void SLAFGetMsgRspEntry::_internal_set_fibstatus(::service_layer::SLAFFibStatus value) {
  
  fibstatus_ = value;
}
inline void SLAFGetMsgRspEntry::set_fibstatus(::service_layer::SLAFFibStatus value) {
  _internal_set_fibstatus(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsgRspEntry.FIBStatus)
}

// -------------------------------------------------------------------

// SLAFGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLAFGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLAFGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLAFGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLAFGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRsp.ErrStatus)
}

// string VrfName = 2;
inline void SLAFGetMsgRsp::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFGetMsgRsp::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFGetMsgRsp::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsgRsp.VrfName)
}
inline std::string* SLAFGetMsgRsp::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.VrfName)
  return _s;
}
inline const std::string& SLAFGetMsgRsp::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFGetMsgRsp::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFGetMsgRsp::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFGetMsgRsp::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFGetMsgRsp.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFGetMsgRsp::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFGetMsgRsp.VrfName)
}

// uint64 ClientID = 3;
inline void SLAFGetMsgRsp::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t SLAFGetMsgRsp::_internal_clientid() const {
  return clientid_;
}
inline uint64_t SLAFGetMsgRsp::clientid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.ClientID)
  return _internal_clientid();
}
inline void SLAFGetMsgRsp::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void SLAFGetMsgRsp::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFGetMsgRsp.ClientID)
}

// repeated .service_layer.SLAFGetMsgRspEntry AFList = 4;
inline int SLAFGetMsgRsp::_internal_aflist_size() const {
  return aflist_.size();
}
inline int SLAFGetMsgRsp::aflist_size() const {
  return _internal_aflist_size();
}
inline void SLAFGetMsgRsp::clear_aflist() {
  aflist_.Clear();
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::mutable_aflist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFGetMsgRsp.AFList)
  return aflist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >*
SLAFGetMsgRsp::mutable_aflist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFGetMsgRsp.AFList)
  return &aflist_;
}
inline const ::service_layer::SLAFGetMsgRspEntry& SLAFGetMsgRsp::_internal_aflist(int index) const {
  return aflist_.Get(index);
}
inline const ::service_layer::SLAFGetMsgRspEntry& SLAFGetMsgRsp::aflist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFGetMsgRsp.AFList)
  return _internal_aflist(index);
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::_internal_add_aflist() {
  return aflist_.Add();
}
inline ::service_layer::SLAFGetMsgRspEntry* SLAFGetMsgRsp::add_aflist() {
  ::service_layer::SLAFGetMsgRspEntry* _add = _internal_add_aflist();
  // @@protoc_insertion_point(field_add:service_layer.SLAFGetMsgRsp.AFList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFGetMsgRspEntry >&
SLAFGetMsgRsp::aflist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFGetMsgRsp.AFList)
  return aflist_;
}

// -------------------------------------------------------------------

// SLAFMsg

// .service_layer.SLObjectOp Oper = 1;
inline void SLAFMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLAFMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline ::service_layer::SLObjectOp SLAFMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.Oper)
  return _internal_oper();
}
inline void SLAFMsg::_internal_set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
}
inline void SLAFMsg::set_oper(::service_layer::SLObjectOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsg.Oper)
}

// string VrfName = 2;
inline void SLAFMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsg.VrfName)
}
inline std::string* SLAFMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsg.VrfName)
  return _s;
}
inline const std::string& SLAFMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFMsg.VrfName)
}

// repeated .service_layer.SLAFOpMsg OpList = 3;
inline int SLAFMsg::_internal_oplist_size() const {
  return oplist_.size();
}
inline int SLAFMsg::oplist_size() const {
  return _internal_oplist_size();
}
inline void SLAFMsg::clear_oplist() {
  oplist_.Clear();
}
inline ::service_layer::SLAFOpMsg* SLAFMsg::mutable_oplist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsg.OpList)
  return oplist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOpMsg >*
SLAFMsg::mutable_oplist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFMsg.OpList)
  return &oplist_;
}
inline const ::service_layer::SLAFOpMsg& SLAFMsg::_internal_oplist(int index) const {
  return oplist_.Get(index);
}
inline const ::service_layer::SLAFOpMsg& SLAFMsg::oplist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsg.OpList)
  return _internal_oplist(index);
}
inline ::service_layer::SLAFOpMsg* SLAFMsg::_internal_add_oplist() {
  return oplist_.Add();
}
inline ::service_layer::SLAFOpMsg* SLAFMsg::add_oplist() {
  ::service_layer::SLAFOpMsg* _add = _internal_add_oplist();
  // @@protoc_insertion_point(field_add:service_layer.SLAFMsg.OpList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFOpMsg >&
SLAFMsg::oplist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFMsg.OpList)
  return oplist_;
}

// -------------------------------------------------------------------

// SLAFRes

// .service_layer.SLErrorStatus Status = 1;
inline bool SLAFRes::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SLAFRes::has_status() const {
  return _internal_has_status();
}
inline const ::service_layer::SLErrorStatus& SLAFRes::_internal_status() const {
  const ::service_layer::SLErrorStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFRes::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.Status)
  return _internal_status();
}
inline void SLAFRes::unsafe_arena_set_allocated_status(
    ::service_layer::SLErrorStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFRes.Status)
}
inline ::service_layer::SLErrorStatus* SLAFRes::release_status() {
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFRes::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.Status)
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFRes::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::service_layer::SLErrorStatus* SLAFRes::mutable_status() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.Status)
  return _msg;
}
inline void SLAFRes::set_allocated_status(::service_layer::SLErrorStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.Status)
}

// .service_layer.SLAFObjectKey Key = 2;
inline bool SLAFRes::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLAFRes::has_key() const {
  return _internal_has_key();
}
inline void SLAFRes::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::service_layer::SLAFObjectKey& SLAFRes::_internal_key() const {
  const ::service_layer::SLAFObjectKey* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFObjectKey&>(
      ::service_layer::_SLAFObjectKey_default_instance_);
}
inline const ::service_layer::SLAFObjectKey& SLAFRes::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.Key)
  return _internal_key();
}
inline void SLAFRes::unsafe_arena_set_allocated_key(
    ::service_layer::SLAFObjectKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFRes.Key)
}
inline ::service_layer::SLAFObjectKey* SLAFRes::release_key() {
  
  ::service_layer::SLAFObjectKey* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFObjectKey* SLAFRes::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.Key)
  
  ::service_layer::SLAFObjectKey* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFObjectKey* SLAFRes::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFObjectKey>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLAFObjectKey* SLAFRes::mutable_key() {
  ::service_layer::SLAFObjectKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.Key)
  return _msg;
}
inline void SLAFRes::set_allocated_key(::service_layer::SLAFObjectKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFObjectKey>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.Key)
}

// uint64 OperationID = 3;
inline void SLAFRes::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFRes::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFRes::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.OperationID)
  return _internal_operationid();
}
inline void SLAFRes::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFRes::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFRes.OperationID)
}

// .service_layer.SLAFFibStatus FIBStatus = 4;
inline void SLAFRes::clear_fibstatus() {
  fibstatus_ = 0;
}
inline ::service_layer::SLAFFibStatus SLAFRes::_internal_fibstatus() const {
  return static_cast< ::service_layer::SLAFFibStatus >(fibstatus_);
}
inline ::service_layer::SLAFFibStatus SLAFRes::fibstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.FIBStatus)
  return _internal_fibstatus();
}
inline void SLAFRes::_internal_set_fibstatus(::service_layer::SLAFFibStatus value) {
  
  fibstatus_ = value;
}
inline void SLAFRes::set_fibstatus(::service_layer::SLAFFibStatus value) {
  _internal_set_fibstatus(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFRes.FIBStatus)
}

// string ErrorString = 5;
inline void SLAFRes::clear_errorstring() {
  errorstring_.ClearToEmpty();
}
inline const std::string& SLAFRes::errorstring() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRes.ErrorString)
  return _internal_errorstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFRes::set_errorstring(ArgT0&& arg0, ArgT... args) {
 
 errorstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFRes.ErrorString)
}
inline std::string* SLAFRes::mutable_errorstring() {
  std::string* _s = _internal_mutable_errorstring();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRes.ErrorString)
  return _s;
}
inline const std::string& SLAFRes::_internal_errorstring() const {
  return errorstring_.Get();
}
inline void SLAFRes::_internal_set_errorstring(const std::string& value) {
  
  errorstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFRes::_internal_mutable_errorstring() {
  
  return errorstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFRes::release_errorstring() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRes.ErrorString)
  return errorstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFRes::set_allocated_errorstring(std::string* errorstring) {
  if (errorstring != nullptr) {
    
  } else {
    
  }
  errorstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errorstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errorstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errorstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRes.ErrorString)
}

// -------------------------------------------------------------------

// SLAFMsgRsp

// string VrfName = 1;
inline void SLAFMsgRsp::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFMsgRsp::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsgRsp.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFMsgRsp::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFMsgRsp.VrfName)
}
inline std::string* SLAFMsgRsp::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsgRsp.VrfName)
  return _s;
}
inline const std::string& SLAFMsgRsp::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFMsgRsp::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFMsgRsp::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFMsgRsp::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFMsgRsp.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFMsgRsp::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFMsgRsp.VrfName)
}

// repeated .service_layer.SLAFRes Results = 2;
inline int SLAFMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLAFMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLAFMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >*
SLAFMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLAFRes& SLAFMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLAFRes& SLAFMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLAFRes* SLAFMsgRsp::add_results() {
  ::service_layer::SLAFRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLAFMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFRes >&
SLAFMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLAFRedistRegMsg

// string SrcProto = 1;
inline void SLAFRedistRegMsg::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLAFRedistRegMsg::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFRedistRegMsg::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.SrcProto)
}
inline std::string* SLAFRedistRegMsg::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRedistRegMsg.SrcProto)
  return _s;
}
inline const std::string& SLAFRedistRegMsg::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLAFRedistRegMsg::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRedistRegMsg.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFRedistRegMsg::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRedistRegMsg.SrcProto)
}

// string SrcProtoTag = 2;
inline void SLAFRedistRegMsg::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLAFRedistRegMsg::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFRedistRegMsg::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.SrcProtoTag)
}
inline std::string* SLAFRedistRegMsg::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return _s;
}
inline const std::string& SLAFRedistRegMsg::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLAFRedistRegMsg::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFRedistRegMsg::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFRedistRegMsg.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFRedistRegMsg::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFRedistRegMsg.SrcProtoTag)
}

// .service_layer.SLTableType Table = 3;
inline void SLAFRedistRegMsg::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFRedistRegMsg::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFRedistRegMsg::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFRedistRegMsg.Table)
  return _internal_table();
}
inline void SLAFRedistRegMsg::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFRedistRegMsg::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFRedistRegMsg.Table)
}

// -------------------------------------------------------------------

// SLAFNextHopRegKey_SLNextHopKey

// .service_layer.SLRoutePrefix NextHopIP = 1;
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_has_nexthopip() const {
  return this != internal_default_instance() && nexthopip_ != nullptr;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::has_nexthopip() const {
  return _internal_has_nexthopip();
}
inline const ::service_layer::SLRoutePrefix& SLAFNextHopRegKey_SLNextHopKey::_internal_nexthopip() const {
  const ::service_layer::SLRoutePrefix* p = nexthopip_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRoutePrefix&>(
      ::service_layer::_SLRoutePrefix_default_instance_);
}
inline const ::service_layer::SLRoutePrefix& SLAFNextHopRegKey_SLNextHopKey::nexthopip() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopIP)
  return _internal_nexthopip();
}
inline void SLAFNextHopRegKey_SLNextHopKey::unsafe_arena_set_allocated_nexthopip(
    ::service_layer::SLRoutePrefix* nexthopip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopip_);
  }
  nexthopip_ = nexthopip;
  if (nexthopip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopIP)
}
inline ::service_layer::SLRoutePrefix* SLAFNextHopRegKey_SLNextHopKey::release_nexthopip() {
  
  ::service_layer::SLRoutePrefix* temp = nexthopip_;
  nexthopip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLAFNextHopRegKey_SLNextHopKey::unsafe_arena_release_nexthopip() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopIP)
  
  ::service_layer::SLRoutePrefix* temp = nexthopip_;
  nexthopip_ = nullptr;
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLAFNextHopRegKey_SLNextHopKey::_internal_mutable_nexthopip() {
  
  if (nexthopip_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRoutePrefix>(GetArenaForAllocation());
    nexthopip_ = p;
  }
  return nexthopip_;
}
inline ::service_layer::SLRoutePrefix* SLAFNextHopRegKey_SLNextHopKey::mutable_nexthopip() {
  ::service_layer::SLRoutePrefix* _msg = _internal_mutable_nexthopip();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopIP)
  return _msg;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_allocated_nexthopip(::service_layer::SLRoutePrefix* nexthopip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopip_);
  }
  if (nexthopip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopip));
    if (message_arena != submessage_arena) {
      nexthopip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopip, submessage_arena);
    }
    
  } else {
    
  }
  nexthopip_ = nexthopip;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNextHopRegKey.SLNextHopKey.NextHopIP)
}

// bool ExactMatch = 2;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_exactmatch() {
  exactmatch_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_exactmatch() const {
  return exactmatch_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::exactmatch() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.ExactMatch)
  return _internal_exactmatch();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_exactmatch(bool value) {
  
  exactmatch_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_exactmatch(bool value) {
  _internal_set_exactmatch(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.ExactMatch)
}

// bool AllowDefault = 3;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_allowdefault() {
  allowdefault_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_allowdefault() const {
  return allowdefault_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::allowdefault() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.AllowDefault)
  return _internal_allowdefault();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_allowdefault(bool value) {
  
  allowdefault_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_allowdefault(bool value) {
  _internal_set_allowdefault(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.AllowDefault)
}

// bool Recurse = 4;
inline void SLAFNextHopRegKey_SLNextHopKey::clear_recurse() {
  recurse_ = false;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::_internal_recurse() const {
  return recurse_;
}
inline bool SLAFNextHopRegKey_SLNextHopKey::recurse() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.SLNextHopKey.Recurse)
  return _internal_recurse();
}
inline void SLAFNextHopRegKey_SLNextHopKey::_internal_set_recurse(bool value) {
  
  recurse_ = value;
}
inline void SLAFNextHopRegKey_SLNextHopKey::set_recurse(bool value) {
  _internal_set_recurse(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNextHopRegKey.SLNextHopKey.Recurse)
}

// -------------------------------------------------------------------

// SLAFNextHopRegKey

// .service_layer.SLAFNextHopRegKey.SLNextHopKey NextHop = 1;
inline bool SLAFNextHopRegKey::_internal_has_nexthop() const {
  return nexthopkey_case() == kNextHop;
}
inline bool SLAFNextHopRegKey::has_nexthop() const {
  return _internal_has_nexthop();
}
inline void SLAFNextHopRegKey::set_has_nexthop() {
  _oneof_case_[0] = kNextHop;
}
inline void SLAFNextHopRegKey::clear_nexthop() {
  if (_internal_has_nexthop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nexthopkey_.nexthop_;
    }
    clear_has_nexthopkey();
  }
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::release_nexthop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegKey.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_nexthopkey();
      ::service_layer::SLAFNextHopRegKey_SLNextHopKey* temp = nexthopkey_.nexthop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nexthopkey_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& SLAFNextHopRegKey::_internal_nexthop() const {
  return _internal_has_nexthop()
      ? *nexthopkey_.nexthop_
      : reinterpret_cast< ::service_layer::SLAFNextHopRegKey_SLNextHopKey&>(::service_layer::_SLAFNextHopRegKey_SLNextHopKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey_SLNextHopKey& SLAFNextHopRegKey::nexthop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegKey.NextHop)
  return _internal_nexthop();
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::unsafe_arena_release_nexthop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNextHopRegKey.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_nexthopkey();
    ::service_layer::SLAFNextHopRegKey_SLNextHopKey* temp = nexthopkey_.nexthop_;
    nexthopkey_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNextHopRegKey::unsafe_arena_set_allocated_nexthop(::service_layer::SLAFNextHopRegKey_SLNextHopKey* nexthop) {
  clear_nexthopkey();
  if (nexthop) {
    set_has_nexthop();
    nexthopkey_.nexthop_ = nexthop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegKey.NextHop)
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::_internal_mutable_nexthop() {
  if (!_internal_has_nexthop()) {
    clear_nexthopkey();
    set_has_nexthop();
    nexthopkey_.nexthop_ = CreateMaybeMessage< ::service_layer::SLAFNextHopRegKey_SLNextHopKey >(GetArenaForAllocation());
  }
  return nexthopkey_.nexthop_;
}
inline ::service_layer::SLAFNextHopRegKey_SLNextHopKey* SLAFNextHopRegKey::mutable_nexthop() {
  ::service_layer::SLAFNextHopRegKey_SLNextHopKey* _msg = _internal_mutable_nexthop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegKey.NextHop)
  return _msg;
}

inline bool SLAFNextHopRegKey::has_nexthopkey() const {
  return nexthopkey_case() != NEXTHOPKEY_NOT_SET;
}
inline void SLAFNextHopRegKey::clear_has_nexthopkey() {
  _oneof_case_[0] = NEXTHOPKEY_NOT_SET;
}
inline SLAFNextHopRegKey::NexthopkeyCase SLAFNextHopRegKey::nexthopkey_case() const {
  return SLAFNextHopRegKey::NexthopkeyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNextHopRegMsg

// .service_layer.SLAFNextHopRegKey NextHopKey = 1;
inline bool SLAFNextHopRegMsg::_internal_has_nexthopkey() const {
  return this != internal_default_instance() && nexthopkey_ != nullptr;
}
inline bool SLAFNextHopRegMsg::has_nexthopkey() const {
  return _internal_has_nexthopkey();
}
inline void SLAFNextHopRegMsg::clear_nexthopkey() {
  if (GetArenaForAllocation() == nullptr && nexthopkey_ != nullptr) {
    delete nexthopkey_;
  }
  nexthopkey_ = nullptr;
}
inline const ::service_layer::SLAFNextHopRegKey& SLAFNextHopRegMsg::_internal_nexthopkey() const {
  const ::service_layer::SLAFNextHopRegKey* p = nexthopkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNextHopRegKey&>(
      ::service_layer::_SLAFNextHopRegKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey& SLAFNextHopRegMsg::nexthopkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNextHopRegMsg.NextHopKey)
  return _internal_nexthopkey();
}
inline void SLAFNextHopRegMsg::unsafe_arena_set_allocated_nexthopkey(
    ::service_layer::SLAFNextHopRegKey* nexthopkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopkey_);
  }
  nexthopkey_ = nexthopkey;
  if (nexthopkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNextHopRegMsg.NextHopKey)
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::release_nexthopkey() {
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::unsafe_arena_release_nexthopkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNextHopRegMsg.NextHopKey)
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::_internal_mutable_nexthopkey() {
  
  if (nexthopkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(GetArenaForAllocation());
    nexthopkey_ = p;
  }
  return nexthopkey_;
}
inline ::service_layer::SLAFNextHopRegKey* SLAFNextHopRegMsg::mutable_nexthopkey() {
  ::service_layer::SLAFNextHopRegKey* _msg = _internal_mutable_nexthopkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNextHopRegMsg.NextHopKey)
  return _msg;
}
inline void SLAFNextHopRegMsg::set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nexthopkey_;
  }
  if (nexthopkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNextHopRegKey>::GetOwningArena(nexthopkey);
    if (message_arena != submessage_arena) {
      nexthopkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopkey, submessage_arena);
    }
    
  } else {
    
  }
  nexthopkey_ = nexthopkey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNextHopRegMsg.NextHopKey)
}

// -------------------------------------------------------------------

// SLAFNotifRegReq

// .service_layer.SLAFRedistRegMsg RedistReq = 1;
inline bool SLAFNotifRegReq::_internal_has_redistreq() const {
  return request_case() == kRedistReq;
}
inline bool SLAFNotifRegReq::has_redistreq() const {
  return _internal_has_redistreq();
}
inline void SLAFNotifRegReq::set_has_redistreq() {
  _oneof_case_[0] = kRedistReq;
}
inline void SLAFNotifRegReq::clear_redistreq() {
  if (_internal_has_redistreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.redistreq_;
    }
    clear_has_request();
  }
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::release_redistreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRegReq.RedistReq)
  if (_internal_has_redistreq()) {
    clear_has_request();
      ::service_layer::SLAFRedistRegMsg* temp = request_.redistreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.redistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFRedistRegMsg& SLAFNotifRegReq::_internal_redistreq() const {
  return _internal_has_redistreq()
      ? *request_.redistreq_
      : reinterpret_cast< ::service_layer::SLAFRedistRegMsg&>(::service_layer::_SLAFRedistRegMsg_default_instance_);
}
inline const ::service_layer::SLAFRedistRegMsg& SLAFNotifRegReq::redistreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.RedistReq)
  return _internal_redistreq();
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::unsafe_arena_release_redistreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotifRegReq.RedistReq)
  if (_internal_has_redistreq()) {
    clear_has_request();
    ::service_layer::SLAFRedistRegMsg* temp = request_.redistreq_;
    request_.redistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotifRegReq::unsafe_arena_set_allocated_redistreq(::service_layer::SLAFRedistRegMsg* redistreq) {
  clear_request();
  if (redistreq) {
    set_has_redistreq();
    request_.redistreq_ = redistreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRegReq.RedistReq)
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::_internal_mutable_redistreq() {
  if (!_internal_has_redistreq()) {
    clear_request();
    set_has_redistreq();
    request_.redistreq_ = CreateMaybeMessage< ::service_layer::SLAFRedistRegMsg >(GetArenaForAllocation());
  }
  return request_.redistreq_;
}
inline ::service_layer::SLAFRedistRegMsg* SLAFNotifRegReq::mutable_redistreq() {
  ::service_layer::SLAFRedistRegMsg* _msg = _internal_mutable_redistreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRegReq.RedistReq)
  return _msg;
}

// .service_layer.SLAFNextHopRegMsg NextHopReq = 2;
inline bool SLAFNotifRegReq::_internal_has_nexthopreq() const {
  return request_case() == kNextHopReq;
}
inline bool SLAFNotifRegReq::has_nexthopreq() const {
  return _internal_has_nexthopreq();
}
inline void SLAFNotifRegReq::set_has_nexthopreq() {
  _oneof_case_[0] = kNextHopReq;
}
inline void SLAFNotifRegReq::clear_nexthopreq() {
  if (_internal_has_nexthopreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.nexthopreq_;
    }
    clear_has_request();
  }
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::release_nexthopreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRegReq.NextHopReq)
  if (_internal_has_nexthopreq()) {
    clear_has_request();
      ::service_layer::SLAFNextHopRegMsg* temp = request_.nexthopreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.nexthopreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNextHopRegMsg& SLAFNotifRegReq::_internal_nexthopreq() const {
  return _internal_has_nexthopreq()
      ? *request_.nexthopreq_
      : reinterpret_cast< ::service_layer::SLAFNextHopRegMsg&>(::service_layer::_SLAFNextHopRegMsg_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegMsg& SLAFNotifRegReq::nexthopreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.NextHopReq)
  return _internal_nexthopreq();
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::unsafe_arena_release_nexthopreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotifRegReq.NextHopReq)
  if (_internal_has_nexthopreq()) {
    clear_has_request();
    ::service_layer::SLAFNextHopRegMsg* temp = request_.nexthopreq_;
    request_.nexthopreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotifRegReq::unsafe_arena_set_allocated_nexthopreq(::service_layer::SLAFNextHopRegMsg* nexthopreq) {
  clear_request();
  if (nexthopreq) {
    set_has_nexthopreq();
    request_.nexthopreq_ = nexthopreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRegReq.NextHopReq)
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::_internal_mutable_nexthopreq() {
  if (!_internal_has_nexthopreq()) {
    clear_request();
    set_has_nexthopreq();
    request_.nexthopreq_ = CreateMaybeMessage< ::service_layer::SLAFNextHopRegMsg >(GetArenaForAllocation());
  }
  return request_.nexthopreq_;
}
inline ::service_layer::SLAFNextHopRegMsg* SLAFNotifRegReq::mutable_nexthopreq() {
  ::service_layer::SLAFNextHopRegMsg* _msg = _internal_mutable_nexthopreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRegReq.NextHopReq)
  return _msg;
}

// uint64 OperationID = 3;
inline void SLAFNotifRegReq::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLAFNotifRegReq::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLAFNotifRegReq::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRegReq.OperationID)
  return _internal_operationid();
}
inline void SLAFNotifRegReq::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLAFNotifRegReq::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifRegReq.OperationID)
}

inline bool SLAFNotifRegReq::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void SLAFNotifRegReq::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline SLAFNotifRegReq::RequestCase SLAFNotifRegReq::request_case() const {
  return SLAFNotifRegReq::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNotifReq

// .service_layer.SLNotifOp Oper = 1;
inline void SLAFNotifReq::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLAFNotifReq::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLAFNotifReq::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.Oper)
  return _internal_oper();
}
inline void SLAFNotifReq::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLAFNotifReq::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifReq.Oper)
}

// string VrfName = 2;
inline void SLAFNotifReq::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFNotifReq::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFNotifReq::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifReq.VrfName)
}
inline std::string* SLAFNotifReq::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifReq.VrfName)
  return _s;
}
inline const std::string& SLAFNotifReq::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFNotifReq::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFNotifReq::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFNotifReq::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifReq.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFNotifReq::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifReq.VrfName)
}

// repeated .service_layer.SLAFNotifRegReq NotifReq = 3;
inline int SLAFNotifReq::_internal_notifreq_size() const {
  return notifreq_.size();
}
inline int SLAFNotifReq::notifreq_size() const {
  return _internal_notifreq_size();
}
inline void SLAFNotifReq::clear_notifreq() {
  notifreq_.Clear();
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::mutable_notifreq(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifReq.NotifReq)
  return notifreq_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >*
SLAFNotifReq::mutable_notifreq() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFNotifReq.NotifReq)
  return &notifreq_;
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifReq::_internal_notifreq(int index) const {
  return notifreq_.Get(index);
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifReq::notifreq(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifReq.NotifReq)
  return _internal_notifreq(index);
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::_internal_add_notifreq() {
  return notifreq_.Add();
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifReq::add_notifreq() {
  ::service_layer::SLAFNotifRegReq* _add = _internal_add_notifreq();
  // @@protoc_insertion_point(field_add:service_layer.SLAFNotifReq.NotifReq)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotifRegReq >&
SLAFNotifReq::notifreq() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFNotifReq.NotifReq)
  return notifreq_;
}

// -------------------------------------------------------------------

// SLAFNotifRsp

// .service_layer.SLAFNotifRegReq NotifReq = 1;
inline bool SLAFNotifRsp::_internal_has_notifreq() const {
  return this != internal_default_instance() && notifreq_ != nullptr;
}
inline bool SLAFNotifRsp::has_notifreq() const {
  return _internal_has_notifreq();
}
inline void SLAFNotifRsp::clear_notifreq() {
  if (GetArenaForAllocation() == nullptr && notifreq_ != nullptr) {
    delete notifreq_;
  }
  notifreq_ = nullptr;
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifRsp::_internal_notifreq() const {
  const ::service_layer::SLAFNotifRegReq* p = notifreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNotifRegReq&>(
      ::service_layer::_SLAFNotifRegReq_default_instance_);
}
inline const ::service_layer::SLAFNotifRegReq& SLAFNotifRsp::notifreq() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRsp.NotifReq)
  return _internal_notifreq();
}
inline void SLAFNotifRsp::unsafe_arena_set_allocated_notifreq(
    ::service_layer::SLAFNotifRegReq* notifreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifreq_);
  }
  notifreq_ = notifreq;
  if (notifreq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRsp.NotifReq)
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::release_notifreq() {
  
  ::service_layer::SLAFNotifRegReq* temp = notifreq_;
  notifreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::unsafe_arena_release_notifreq() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRsp.NotifReq)
  
  ::service_layer::SLAFNotifRegReq* temp = notifreq_;
  notifreq_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::_internal_mutable_notifreq() {
  
  if (notifreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNotifRegReq>(GetArenaForAllocation());
    notifreq_ = p;
  }
  return notifreq_;
}
inline ::service_layer::SLAFNotifRegReq* SLAFNotifRsp::mutable_notifreq() {
  ::service_layer::SLAFNotifRegReq* _msg = _internal_mutable_notifreq();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRsp.NotifReq)
  return _msg;
}
inline void SLAFNotifRsp::set_allocated_notifreq(::service_layer::SLAFNotifRegReq* notifreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete notifreq_;
  }
  if (notifreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNotifRegReq>::GetOwningArena(notifreq);
    if (message_arena != submessage_arena) {
      notifreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifreq, submessage_arena);
    }
    
  } else {
    
  }
  notifreq_ = notifreq;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifRsp.NotifReq)
}

// .service_layer.SLErrorStatus NotifStatus = 2;
inline bool SLAFNotifRsp::_internal_has_notifstatus() const {
  return this != internal_default_instance() && notifstatus_ != nullptr;
}
inline bool SLAFNotifRsp::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline const ::service_layer::SLErrorStatus& SLAFNotifRsp::_internal_notifstatus() const {
  const ::service_layer::SLErrorStatus* p = notifstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLAFNotifRsp::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifRsp.NotifStatus)
  return _internal_notifstatus();
}
inline void SLAFNotifRsp::unsafe_arena_set_allocated_notifstatus(
    ::service_layer::SLErrorStatus* notifstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  notifstatus_ = notifstatus;
  if (notifstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotifRsp.NotifStatus)
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::release_notifstatus() {
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifRsp.NotifStatus)
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::_internal_mutable_notifstatus() {
  
  if (notifstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    notifstatus_ = p;
  }
  return notifstatus_;
}
inline ::service_layer::SLErrorStatus* SLAFNotifRsp::mutable_notifstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifRsp.NotifStatus)
  return _msg;
}
inline void SLAFNotifRsp::set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  if (notifstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus));
    if (message_arena != submessage_arena) {
      notifstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifstatus, submessage_arena);
    }
    
  } else {
    
  }
  notifstatus_ = notifstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifRsp.NotifStatus)
}

// -------------------------------------------------------------------

// SLNextHop

// .service_layer.SLAFNextHopRegKey NextHopKey = 1;
inline bool SLNextHop::_internal_has_nexthopkey() const {
  return this != internal_default_instance() && nexthopkey_ != nullptr;
}
inline bool SLNextHop::has_nexthopkey() const {
  return _internal_has_nexthopkey();
}
inline void SLNextHop::clear_nexthopkey() {
  if (GetArenaForAllocation() == nullptr && nexthopkey_ != nullptr) {
    delete nexthopkey_;
  }
  nexthopkey_ = nullptr;
}
inline const ::service_layer::SLAFNextHopRegKey& SLNextHop::_internal_nexthopkey() const {
  const ::service_layer::SLAFNextHopRegKey* p = nexthopkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLAFNextHopRegKey&>(
      ::service_layer::_SLAFNextHopRegKey_default_instance_);
}
inline const ::service_layer::SLAFNextHopRegKey& SLNextHop::nexthopkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.NextHopKey)
  return _internal_nexthopkey();
}
inline void SLNextHop::unsafe_arena_set_allocated_nexthopkey(
    ::service_layer::SLAFNextHopRegKey* nexthopkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopkey_);
  }
  nexthopkey_ = nexthopkey;
  if (nexthopkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLNextHop.NextHopKey)
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::release_nexthopkey() {
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::unsafe_arena_release_nexthopkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.NextHopKey)
  
  ::service_layer::SLAFNextHopRegKey* temp = nexthopkey_;
  nexthopkey_ = nullptr;
  return temp;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::_internal_mutable_nexthopkey() {
  
  if (nexthopkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLAFNextHopRegKey>(GetArenaForAllocation());
    nexthopkey_ = p;
  }
  return nexthopkey_;
}
inline ::service_layer::SLAFNextHopRegKey* SLNextHop::mutable_nexthopkey() {
  ::service_layer::SLAFNextHopRegKey* _msg = _internal_mutable_nexthopkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.NextHopKey)
  return _msg;
}
inline void SLNextHop::set_allocated_nexthopkey(::service_layer::SLAFNextHopRegKey* nexthopkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nexthopkey_;
  }
  if (nexthopkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLAFNextHopRegKey>::GetOwningArena(nexthopkey);
    if (message_arena != submessage_arena) {
      nexthopkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopkey, submessage_arena);
    }
    
  } else {
    
  }
  nexthopkey_ = nexthopkey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.NextHopKey)
}

// .service_layer.SLRoutePrefix ResolvingPrefix = 2;
inline bool SLNextHop::_internal_has_resolvingprefix() const {
  return this != internal_default_instance() && resolvingprefix_ != nullptr;
}
inline bool SLNextHop::has_resolvingprefix() const {
  return _internal_has_resolvingprefix();
}
inline const ::service_layer::SLRoutePrefix& SLNextHop::_internal_resolvingprefix() const {
  const ::service_layer::SLRoutePrefix* p = resolvingprefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRoutePrefix&>(
      ::service_layer::_SLRoutePrefix_default_instance_);
}
inline const ::service_layer::SLRoutePrefix& SLNextHop::resolvingprefix() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.ResolvingPrefix)
  return _internal_resolvingprefix();
}
inline void SLNextHop::unsafe_arena_set_allocated_resolvingprefix(
    ::service_layer::SLRoutePrefix* resolvingprefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingprefix_);
  }
  resolvingprefix_ = resolvingprefix;
  if (resolvingprefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLNextHop.ResolvingPrefix)
}
inline ::service_layer::SLRoutePrefix* SLNextHop::release_resolvingprefix() {
  
  ::service_layer::SLRoutePrefix* temp = resolvingprefix_;
  resolvingprefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLNextHop::unsafe_arena_release_resolvingprefix() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.ResolvingPrefix)
  
  ::service_layer::SLRoutePrefix* temp = resolvingprefix_;
  resolvingprefix_ = nullptr;
  return temp;
}
inline ::service_layer::SLRoutePrefix* SLNextHop::_internal_mutable_resolvingprefix() {
  
  if (resolvingprefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRoutePrefix>(GetArenaForAllocation());
    resolvingprefix_ = p;
  }
  return resolvingprefix_;
}
inline ::service_layer::SLRoutePrefix* SLNextHop::mutable_resolvingprefix() {
  ::service_layer::SLRoutePrefix* _msg = _internal_mutable_resolvingprefix();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.ResolvingPrefix)
  return _msg;
}
inline void SLNextHop::set_allocated_resolvingprefix(::service_layer::SLRoutePrefix* resolvingprefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingprefix_);
  }
  if (resolvingprefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolvingprefix));
    if (message_arena != submessage_arena) {
      resolvingprefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolvingprefix, submessage_arena);
    }
    
  } else {
    
  }
  resolvingprefix_ = resolvingprefix;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.ResolvingPrefix)
}

// string SrcProto = 3;
inline void SLNextHop::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLNextHop::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLNextHop::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.SrcProto)
}
inline std::string* SLNextHop::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.SrcProto)
  return _s;
}
inline const std::string& SLNextHop::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLNextHop::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLNextHop::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLNextHop::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLNextHop::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.SrcProto)
}

// string SrcProtoTag = 4;
inline void SLNextHop::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLNextHop::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLNextHop::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.SrcProtoTag)
}
inline std::string* SLNextHop::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.SrcProtoTag)
  return _s;
}
inline const std::string& SLNextHop::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLNextHop::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLNextHop::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLNextHop::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLNextHop.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLNextHop::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLNextHop.SrcProtoTag)
}

// uint32 AdminDistance = 5;
inline void SLNextHop::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLNextHop::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLNextHop::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.AdminDistance)
  return _internal_admindistance();
}
inline void SLNextHop::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLNextHop::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.AdminDistance)
}

// uint32 Metric = 6;
inline void SLNextHop::clear_metric() {
  metric_ = 0u;
}
inline uint32_t SLNextHop::_internal_metric() const {
  return metric_;
}
inline uint32_t SLNextHop::metric() const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.Metric)
  return _internal_metric();
}
inline void SLNextHop::_internal_set_metric(uint32_t value) {
  
  metric_ = value;
}
inline void SLNextHop::set_metric(uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:service_layer.SLNextHop.Metric)
}

// repeated .service_layer.SLRoutePath Paths = 7;
inline int SLNextHop::_internal_paths_size() const {
  return paths_.size();
}
inline int SLNextHop::paths_size() const {
  return _internal_paths_size();
}
inline ::service_layer::SLRoutePath* SLNextHop::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLNextHop.Paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >*
SLNextHop::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLNextHop.Paths)
  return &paths_;
}
inline const ::service_layer::SLRoutePath& SLNextHop::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::service_layer::SLRoutePath& SLNextHop::paths(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLNextHop.Paths)
  return _internal_paths(index);
}
inline ::service_layer::SLRoutePath* SLNextHop::_internal_add_paths() {
  return paths_.Add();
}
inline ::service_layer::SLRoutePath* SLNextHop::add_paths() {
  ::service_layer::SLRoutePath* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:service_layer.SLNextHop.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLRoutePath >&
SLNextHop::paths() const {
  // @@protoc_insertion_point(field_list:service_layer.SLNextHop.Paths)
  return paths_;
}

// -------------------------------------------------------------------

// SLAFNotif_SLRedistMarker

// .service_layer.SLTableType Table = 1;
inline void SLAFNotif_SLRedistMarker::clear_table() {
  table_ = 0;
}
inline ::service_layer::SLTableType SLAFNotif_SLRedistMarker::_internal_table() const {
  return static_cast< ::service_layer::SLTableType >(table_);
}
inline ::service_layer::SLTableType SLAFNotif_SLRedistMarker::table() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.SLRedistMarker.Table)
  return _internal_table();
}
inline void SLAFNotif_SLRedistMarker::_internal_set_table(::service_layer::SLTableType value) {
  
  table_ = value;
}
inline void SLAFNotif_SLRedistMarker::set_table(::service_layer::SLTableType value) {
  _internal_set_table(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotif.SLRedistMarker.Table)
}

// -------------------------------------------------------------------

// SLAFNotif

// .service_layer.SLAFNotifRsp NotifStatus = 1;
inline bool SLAFNotif::_internal_has_notifstatus() const {
  return Event_case() == kNotifStatus;
}
inline bool SLAFNotif::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline void SLAFNotif::set_has_notifstatus() {
  _oneof_case_[0] = kNotifStatus;
}
inline void SLAFNotif::clear_notifstatus() {
  if (_internal_has_notifstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.notifstatus_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
      ::service_layer::SLAFNotifRsp* temp = Event_.notifstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNotifRsp& SLAFNotif::_internal_notifstatus() const {
  return _internal_has_notifstatus()
      ? *Event_.notifstatus_
      : reinterpret_cast< ::service_layer::SLAFNotifRsp&>(::service_layer::_SLAFNotifRsp_default_instance_);
}
inline const ::service_layer::SLAFNotifRsp& SLAFNotif::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.NotifStatus)
  return _internal_notifstatus();
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
    ::service_layer::SLAFNotifRsp* temp = Event_.notifstatus_;
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_notifstatus(::service_layer::SLAFNotifRsp* notifstatus) {
  clear_Event();
  if (notifstatus) {
    set_has_notifstatus();
    Event_.notifstatus_ = notifstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.NotifStatus)
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::_internal_mutable_notifstatus() {
  if (!_internal_has_notifstatus()) {
    clear_Event();
    set_has_notifstatus();
    Event_.notifstatus_ = CreateMaybeMessage< ::service_layer::SLAFNotifRsp >(GetArenaForAllocation());
  }
  return Event_.notifstatus_;
}
inline ::service_layer::SLAFNotifRsp* SLAFNotif::mutable_notifstatus() {
  ::service_layer::SLAFNotifRsp* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.NotifStatus)
  return _msg;
}

// .service_layer.SLAFNotif.SLRedistMarker StartMarker = 2;
inline bool SLAFNotif::_internal_has_startmarker() const {
  return Event_case() == kStartMarker;
}
inline bool SLAFNotif::has_startmarker() const {
  return _internal_has_startmarker();
}
inline void SLAFNotif::set_has_startmarker() {
  _oneof_case_[0] = kStartMarker;
}
inline void SLAFNotif::clear_startmarker() {
  if (_internal_has_startmarker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.startmarker_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::release_startmarker() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.StartMarker)
  if (_internal_has_startmarker()) {
    clear_has_Event();
      ::service_layer::SLAFNotif_SLRedistMarker* temp = Event_.startmarker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.startmarker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNotif_SLRedistMarker& SLAFNotif::_internal_startmarker() const {
  return _internal_has_startmarker()
      ? *Event_.startmarker_
      : reinterpret_cast< ::service_layer::SLAFNotif_SLRedistMarker&>(::service_layer::_SLAFNotif_SLRedistMarker_default_instance_);
}
inline const ::service_layer::SLAFNotif_SLRedistMarker& SLAFNotif::startmarker() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.StartMarker)
  return _internal_startmarker();
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::unsafe_arena_release_startmarker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.StartMarker)
  if (_internal_has_startmarker()) {
    clear_has_Event();
    ::service_layer::SLAFNotif_SLRedistMarker* temp = Event_.startmarker_;
    Event_.startmarker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_startmarker(::service_layer::SLAFNotif_SLRedistMarker* startmarker) {
  clear_Event();
  if (startmarker) {
    set_has_startmarker();
    Event_.startmarker_ = startmarker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.StartMarker)
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::_internal_mutable_startmarker() {
  if (!_internal_has_startmarker()) {
    clear_Event();
    set_has_startmarker();
    Event_.startmarker_ = CreateMaybeMessage< ::service_layer::SLAFNotif_SLRedistMarker >(GetArenaForAllocation());
  }
  return Event_.startmarker_;
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::mutable_startmarker() {
  ::service_layer::SLAFNotif_SLRedistMarker* _msg = _internal_mutable_startmarker();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.StartMarker)
  return _msg;
}

// .service_layer.SLAFNotif.SLRedistMarker EndMarker = 3;
inline bool SLAFNotif::_internal_has_endmarker() const {
  return Event_case() == kEndMarker;
}
inline bool SLAFNotif::has_endmarker() const {
  return _internal_has_endmarker();
}
inline void SLAFNotif::set_has_endmarker() {
  _oneof_case_[0] = kEndMarker;
}
inline void SLAFNotif::clear_endmarker() {
  if (_internal_has_endmarker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.endmarker_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::release_endmarker() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.EndMarker)
  if (_internal_has_endmarker()) {
    clear_has_Event();
      ::service_layer::SLAFNotif_SLRedistMarker* temp = Event_.endmarker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.endmarker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFNotif_SLRedistMarker& SLAFNotif::_internal_endmarker() const {
  return _internal_has_endmarker()
      ? *Event_.endmarker_
      : reinterpret_cast< ::service_layer::SLAFNotif_SLRedistMarker&>(::service_layer::_SLAFNotif_SLRedistMarker_default_instance_);
}
inline const ::service_layer::SLAFNotif_SLRedistMarker& SLAFNotif::endmarker() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.EndMarker)
  return _internal_endmarker();
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::unsafe_arena_release_endmarker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.EndMarker)
  if (_internal_has_endmarker()) {
    clear_has_Event();
    ::service_layer::SLAFNotif_SLRedistMarker* temp = Event_.endmarker_;
    Event_.endmarker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_endmarker(::service_layer::SLAFNotif_SLRedistMarker* endmarker) {
  clear_Event();
  if (endmarker) {
    set_has_endmarker();
    Event_.endmarker_ = endmarker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.EndMarker)
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::_internal_mutable_endmarker() {
  if (!_internal_has_endmarker()) {
    clear_Event();
    set_has_endmarker();
    Event_.endmarker_ = CreateMaybeMessage< ::service_layer::SLAFNotif_SLRedistMarker >(GetArenaForAllocation());
  }
  return Event_.endmarker_;
}
inline ::service_layer::SLAFNotif_SLRedistMarker* SLAFNotif::mutable_endmarker() {
  ::service_layer::SLAFNotif_SLRedistMarker* _msg = _internal_mutable_endmarker();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.EndMarker)
  return _msg;
}

// .service_layer.SLAFObject RedistObject = 4;
inline bool SLAFNotif::_internal_has_redistobject() const {
  return Event_case() == kRedistObject;
}
inline bool SLAFNotif::has_redistobject() const {
  return _internal_has_redistobject();
}
inline void SLAFNotif::set_has_redistobject() {
  _oneof_case_[0] = kRedistObject;
}
inline void SLAFNotif::clear_redistobject() {
  if (_internal_has_redistobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.redistobject_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLAFObject* SLAFNotif::release_redistobject() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.RedistObject)
  if (_internal_has_redistobject()) {
    clear_has_Event();
      ::service_layer::SLAFObject* temp = Event_.redistobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.redistobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLAFObject& SLAFNotif::_internal_redistobject() const {
  return _internal_has_redistobject()
      ? *Event_.redistobject_
      : reinterpret_cast< ::service_layer::SLAFObject&>(::service_layer::_SLAFObject_default_instance_);
}
inline const ::service_layer::SLAFObject& SLAFNotif::redistobject() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.RedistObject)
  return _internal_redistobject();
}
inline ::service_layer::SLAFObject* SLAFNotif::unsafe_arena_release_redistobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.RedistObject)
  if (_internal_has_redistobject()) {
    clear_has_Event();
    ::service_layer::SLAFObject* temp = Event_.redistobject_;
    Event_.redistobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_redistobject(::service_layer::SLAFObject* redistobject) {
  clear_Event();
  if (redistobject) {
    set_has_redistobject();
    Event_.redistobject_ = redistobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.RedistObject)
}
inline ::service_layer::SLAFObject* SLAFNotif::_internal_mutable_redistobject() {
  if (!_internal_has_redistobject()) {
    clear_Event();
    set_has_redistobject();
    Event_.redistobject_ = CreateMaybeMessage< ::service_layer::SLAFObject >(GetArenaForAllocation());
  }
  return Event_.redistobject_;
}
inline ::service_layer::SLAFObject* SLAFNotif::mutable_redistobject() {
  ::service_layer::SLAFObject* _msg = _internal_mutable_redistobject();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.RedistObject)
  return _msg;
}

// .service_layer.SLNextHop NextHop = 5;
inline bool SLAFNotif::_internal_has_nexthop() const {
  return Event_case() == kNextHop;
}
inline bool SLAFNotif::has_nexthop() const {
  return _internal_has_nexthop();
}
inline void SLAFNotif::set_has_nexthop() {
  _oneof_case_[0] = kNextHop;
}
inline void SLAFNotif::clear_nexthop() {
  if (_internal_has_nexthop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.nexthop_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLNextHop* SLAFNotif::release_nexthop() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotif.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_Event();
      ::service_layer::SLNextHop* temp = Event_.nexthop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLNextHop& SLAFNotif::_internal_nexthop() const {
  return _internal_has_nexthop()
      ? *Event_.nexthop_
      : reinterpret_cast< ::service_layer::SLNextHop&>(::service_layer::_SLNextHop_default_instance_);
}
inline const ::service_layer::SLNextHop& SLAFNotif::nexthop() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotif.NextHop)
  return _internal_nexthop();
}
inline ::service_layer::SLNextHop* SLAFNotif::unsafe_arena_release_nexthop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLAFNotif.NextHop)
  if (_internal_has_nexthop()) {
    clear_has_Event();
    ::service_layer::SLNextHop* temp = Event_.nexthop_;
    Event_.nexthop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLAFNotif::unsafe_arena_set_allocated_nexthop(::service_layer::SLNextHop* nexthop) {
  clear_Event();
  if (nexthop) {
    set_has_nexthop();
    Event_.nexthop_ = nexthop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLAFNotif.NextHop)
}
inline ::service_layer::SLNextHop* SLAFNotif::_internal_mutable_nexthop() {
  if (!_internal_has_nexthop()) {
    clear_Event();
    set_has_nexthop();
    Event_.nexthop_ = CreateMaybeMessage< ::service_layer::SLNextHop >(GetArenaForAllocation());
  }
  return Event_.nexthop_;
}
inline ::service_layer::SLNextHop* SLAFNotif::mutable_nexthop() {
  ::service_layer::SLNextHop* _msg = _internal_mutable_nexthop();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotif.NextHop)
  return _msg;
}

inline bool SLAFNotif::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLAFNotif::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLAFNotif::EventCase SLAFNotif::Event_case() const {
  return SLAFNotif::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLAFNotifMsg

// string VrfName = 1;
inline void SLAFNotifMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLAFNotifMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLAFNotifMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLAFNotifMsg.VrfName)
}
inline std::string* SLAFNotifMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifMsg.VrfName)
  return _s;
}
inline const std::string& SLAFNotifMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLAFNotifMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLAFNotifMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLAFNotifMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLAFNotifMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLAFNotifMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLAFNotifMsg.VrfName)
}

// repeated .service_layer.SLAFNotif AFNotifs = 3;
inline int SLAFNotifMsg::_internal_afnotifs_size() const {
  return afnotifs_.size();
}
inline int SLAFNotifMsg::afnotifs_size() const {
  return _internal_afnotifs_size();
}
inline void SLAFNotifMsg::clear_afnotifs() {
  afnotifs_.Clear();
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::mutable_afnotifs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLAFNotifMsg.AFNotifs)
  return afnotifs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >*
SLAFNotifMsg::mutable_afnotifs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLAFNotifMsg.AFNotifs)
  return &afnotifs_;
}
inline const ::service_layer::SLAFNotif& SLAFNotifMsg::_internal_afnotifs(int index) const {
  return afnotifs_.Get(index);
}
inline const ::service_layer::SLAFNotif& SLAFNotifMsg::afnotifs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLAFNotifMsg.AFNotifs)
  return _internal_afnotifs(index);
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::_internal_add_afnotifs() {
  return afnotifs_.Add();
}
inline ::service_layer::SLAFNotif* SLAFNotifMsg::add_afnotifs() {
  ::service_layer::SLAFNotif* _add = _internal_add_afnotifs();
  // @@protoc_insertion_point(field_add:service_layer.SLAFNotifMsg.AFNotifs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLAFNotif >&
SLAFNotifMsg::afnotifs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLAFNotifMsg.AFNotifs)
  return afnotifs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5faf_2eproto
