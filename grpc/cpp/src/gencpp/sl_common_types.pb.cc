// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_common_types.proto

#include "sl_common_types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace service_layer {
constexpr SLErrorStatus::SLErrorStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(0)
{}
struct SLErrorStatusDefaultTypeInternal {
  constexpr SLErrorStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SLErrorStatusDefaultTypeInternal() {}
  union {
    SLErrorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SLErrorStatusDefaultTypeInternal _SLErrorStatus_default_instance_;
constexpr SLInterface::SLInterface(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SLInterfaceDefaultTypeInternal {
  constexpr SLInterfaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SLInterfaceDefaultTypeInternal() {}
  union {
    SLInterface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SLInterfaceDefaultTypeInternal _SLInterface_default_instance_;
constexpr SLIpAddress::SLIpAddress(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SLIpAddressDefaultTypeInternal {
  constexpr SLIpAddressDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SLIpAddressDefaultTypeInternal() {}
  union {
    SLIpAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SLIpAddressDefaultTypeInternal _SLIpAddress_default_instance_;
}  // namespace service_layer
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_sl_5fcommon_5ftypes_2eproto[3];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_sl_5fcommon_5ftypes_2eproto = nullptr;

const uint32_t TableStruct_sl_5fcommon_5ftypes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLErrorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLErrorStatus, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLInterface, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLInterface, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::service_layer::SLInterface, Interface_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLIpAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::service_layer::SLIpAddress, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::service_layer::SLIpAddress, Address_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::service_layer::SLErrorStatus)},
  { 7, -1, -1, sizeof(::service_layer::SLInterface)},
  { 16, -1, -1, sizeof(::service_layer::SLIpAddress)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::service_layer::_SLErrorStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::service_layer::_SLInterface_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::service_layer::_SLIpAddress_default_instance_),
};

const char descriptor_table_protodef_sl_5fcommon_5ftypes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025sl_common_types.proto\022\rservice_layer\"\217"
  "D\n\rSLErrorStatus\0224\n\006Status\030\001 \001(\0162$.servi"
  "ce_layer.SLErrorStatus.SLErrno\"\307C\n\007SLErr"
  "no\022\016\n\nSL_SUCCESS\020\000\022\024\n\020SL_NOT_CONNECTED\020\001"
  "\022\r\n\tSL_EAGAIN\020\002\022\r\n\tSL_ENOMEM\020\003\022\014\n\010SL_EBU"
  "SY\020\004\022\r\n\tSL_EINVAL\020\005\022\026\n\022SL_UNSUPPORTED_VE"
  "R\020\006\022\024\n\020SL_NOT_AVAILABLE\020\007\022\033\n\027SL_STREAM_N"
  "OT_SUPPORTED\020\010\022\016\n\nSL_ENOTSUP\020\t\022\017\n\013SL_SOM"
  "E_ERR\020\n\022\016\n\nSL_TIMEOUT\020\013\022\021\n\rSL_NOTIF_TERM"
  "\020\014\022\020\n\014SL_AUTH_FAIL\020\r\022\031\n\024SL_INIT_START_OF"
  "FSET\020\200\n\022\030\n\023SL_INIT_STATE_CLEAR\020\201\n\022\030\n\023SL_"
  "INIT_STATE_READY\020\202\n\022\034\n\027SL_INIT_UNSUPPORT"
  "ED_VER\020\203\n\022#\n\036SL_INIT_SERVER_NOT_INITIALI"
  "ZED\020\204\n\022&\n!SL_INIT_SERVER_MODE_CHANGE_FAI"
  "LED\020\205\n\022\034\n\027SL_RPC_VRF_START_OFFSET\020\200 \022%\n "
  "SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS\020\201 \022&\n!S"
  "L_RPC_VRF_SERVER_NOT_INITIALIZED\020\202 \022\030\n\023S"
  "L_VRF_START_OFFSET\020\200@\022\030\n\023SL_VRF_NAME_TOO"
  "LONG\020\201@\022\025\n\020SL_VRF_NOT_FOUND\020\202@\022\027\n\022SL_VRF"
  "_NO_TABLE_ID\020\203@\022&\n!SL_VRF_REG_INVALID_AD"
  "MIN_DISTANCE\020\204@\022\031\n\024SL_VRF_TABLE_ADD_ERR\020"
  "\205@\022\"\n\035SL_VRF_TABLE_REGISTRATION_ERR\020\206@\022$"
  "\n\037SL_VRF_TABLE_UNREGISTRATION_ERR\020\207@\022\031\n\024"
  "SL_VRF_TABLE_EOF_ERR\020\210@\022 \n\033SL_VRF_REG_VR"
  "F_NAME_MISSING\020\211@\022\'\n\"SL_VRF_V4_ROUTE_REP"
  "LAY_FATAL_ERROR\020\220@\022\'\n\"SL_VRF_V6_ROUTE_RE"
  "PLAY_FATAL_ERROR\020\221@\022\036\n\031SL_VRF_V4_ROUTE_R"
  "EPLAY_OK\020\222@\022\036\n\031SL_VRF_V6_ROUTE_REPLAY_OK"
  "\020\223@\022\036\n\031SL_RPC_ROUTE_START_OFFSET\020\200`\022!\n\034S"
  "L_RPC_ROUTE_TOO_MANY_ROUTES\020\201`\022\"\n\035SL_RPC"
  "_ROUTE_VRF_NAME_TOOLONG\020\202`\022\037\n\032SL_RPC_ROU"
  "TE_VRF_NOT_FOUND\020\203`\022\036\n\031SL_RPC_ROUTE_VRF_"
  "NO_TABLE\020\204`\022*\n%SL_RPC_ROUTE_VRF_TABLE_NO"
  "T_REGISTERED\020\205`\022\"\n\035SL_RPC_ROUTE_VRF_NAME"
  "_MISSING\020\206`\022(\n#SL_RPC_ROUTE_INIT_MODE_IN"
  "COMPATIBLE\020\207`\022(\n#SL_RPC_ROUTE_SERVER_NOT"
  "_INITIALIZED\020\210`\022)\n$SL_RPC_ROUTE_NOTIF_SR"
  "C_PROTO_TOOLONG\020\211`\022-\n(SL_RPC_ROUTE_NOTIF"
  "_SRC_PROTO_TAG_TOOLONG\020\212`\022\033\n\025SL_ROUTE_ST"
  "ART_OFFSET\020\200\200\001\022\033\n\025SL_ROUTE_ADD_NO_PATHS\020"
  "\201\200\001\022\036\n\030SL_ROUTE_UPDATE_NO_PATHS\020\202\200\001\022!\n\033S"
  "L_ROUTE_INVALID_PREFIX_LEN\020\203\200\001\022%\n\037SL_ROU"
  "TE_INVALID_ADMIN_DISTANCE\020\204\200\001\022 \n\032SL_ROUT"
  "E_INVALID_NUM_PATHS\020\205\200\001\022 \n\032SL_ROUTE_INVA"
  "LID_PREFIX_SZ\020\206\200\001\022\035\n\027SL_ROUTE_INVALID_PR"
  "EFIX\020\207\200\001\022*\n$SL_ROUTE_ERR_RIB_TABLE_LIMIT"
  "_REACHED\020\210\200\001\022#\n\035SL_ROUTE_ERR_RIB_INVALID"
  "_ARGS\020\211\200\001\022\'\n!SL_ROUTE_ERR_RIB_PATH_TABLE"
  "_LIMIT\020\212\200\001\022#\n\035SL_ROUTE_ERR_RIB_TOOMANYPA"
  "THS\020\213\200\001\022\025\n\017SL_ROUTE_EEXIST\020\214\200\001\022\034\n\026SL_ROU"
  "TE_HOST_BITS_SET\020\215\200\001\022#\n\035SL_ROUTE_INVALID"
  "_PREFIX_MCAST\020\216\200\001\022 \n\032SL_ROUTE_PATH_AFI_M"
  "ISMATCH\020\217\200\001\022$\n\036SL_ROUTE_TOOMANY_PRIMARY_"
  "PATHS\020\220\200\001\022#\n\035SL_ROUTE_TOOMANY_BACKUP_PAT"
  "HS\020\221\200\001\022\027\n\021SL_ROUTE_DB_NOMEM\020\222\200\001\022\"\n\034SL_RO"
  "UTE_INVALID_LOCAL_LABEL\020\223\200\001\022\032\n\024SL_PATH_S"
  "TART_OFFSET\020\200\240\001\022\031\n\023SL_PATH_NH_NO_TABLE\020\201"
  "\240\001\022\037\n\031SL_PATH_NH_INTF_NOT_FOUND\020\202\240\001\022!\n\033S"
  "L_PATH_INVALID_LABEL_COUNT\020\203\240\001\022\030\n\022SL_PAT"
  "H_INVALID_ID\020\204\240\001\022\036\n\030SL_PATH_VRF_NAME_TOO"
  "LONG\020\205\240\001\022\"\n\034SL_PATH_NH_INTF_NAME_TOOLONG"
  "\020\206\240\001\022 \n\032SL_PATH_NH_INVALID_ADDR_SZ\020\207\240\001\022!"
  "\n\033SL_PATH_NH_INF_NAME_MISSING\020\210\240\001\022#\n\035SL_"
  "PATH_INVALID_NEXT_HOP_ADDR\020\211\240\001\022\'\n!SL_PAT"
  "H_INVALID_REMOTE_ADDR_COUNT\020\212\240\001\022$\n\036SL_PA"
  "TH_REMOTE_ADDR_INVALID_SZ\020\213\240\001\022&\n SL_PATH"
  "_REMOTE_ADDR_AFI_MISMATCH\020\214\240\001\022&\n SL_PATH"
  "_INVALID_PROTECTED_BITMAP\020\215\240\001\022)\n#SL_PATH"
  "_BACKUP_MISSING_PRIMARY_PATH\020\216\240\001\022!\n\033SL_P"
  "ATH_PRIMARY_ID_REPEATED\020\217\240\001\022 \n\032SL_PATH_B"
  "ACKUP_ID_REPEATED\020\220\240\001\022*\n$SL_PATH_PRIMARY"
  "_TOOMANY_BACKUP_PATHS\020\221\240\001\022$\n\036SL_PATH_PRI"
  "MARY_TOOMANY_LABELS\020\222\240\001\022)\n#SL_PATH_PRIMA"
  "RY_TOOMANY_REMOTE_ADDR\020\223\240\001\022!\n\033SL_PATH_RE"
  "MOTE_ADDR_INVALID\020\224\240\001\022\033\n\025SL_PATH_INVALID"
  "_LABEL\020\225\240\001\022(\n\"SL_PATH_ROUTER_MAC_ADDR_IN"
  "VALID_SZ\020\226\240\001\022#\n\035SL_PATH_BACKUP_TOOMANY_L"
  "ABELS\020\227\240\001\022\035\n\027SL_RPC_BFD_START_OFFSET\020\200\300\001"
  "\022&\n SL_RPC_BFD_TOO_MANY_BFD_SESSIONS\020\201\300\001"
  "\022\"\n\034SL_RPC_BFD_API_BAD_PARAMETER\020\202\300\001\022*\n$"
  "SL_RPC_BFD_API_CLIENT_NOT_REGISTERED\020\203\300\001"
  "\022#\n\035SL_RPC_BFD_API_INTERNAL_ERROR\020\204\300\001\022\'\n"
  "!SL_RPC_BFD_SERVER_NOT_INITIALIZED\020\205\300\001\022\""
  "\n\034SL_RPC_BFD_V4_NOT_REGISTERED\020\206\300\001\022\"\n\034SL"
  "_RPC_BFD_V6_NOT_REGISTERED\020\207\300\001\022\031\n\023SL_BFD"
  "_START_OFFSET\020\200\340\001\022\036\n\030SL_BFD_INTF_NAME_TO"
  "OLONG\020\201\340\001\022\033\n\025SL_BFD_INTF_NOT_FOUND\020\202\340\001\022\036"
  "\n\030SL_BFD_INVALID_ATTRIBUTE\020\203\340\001\022\036\n\030SL_BFD"
  "_INTF_NAME_MISSING\020\204\340\001\022\036\n\030SL_BFD_INVALID"
  "_NBR_MCAST\020\205\340\001\022\030\n\022SL_BFD_INVALID_NBR\020\206\340\001"
  "\022\035\n\027SL_BFD_VRF_NAME_TOOLONG\020\207\340\001\022\032\n\024SL_BF"
  "D_BAD_PARAMETER\020\210\340\001\022\037\n\031SL_BFD_API_INTERN"
  "AL_ERROR\020\211\340\001\022\032\n\024SL_BFD_VRF_NOT_FOUND\020\212\340\001"
  "\022 \n\032SL_BFD_INVALID_PREFIX_SIZE\020\213\340\001\022!\n\033SL"
  "_BFD_INVALID_SESSION_TYPE\020\214\340\001\022\030\n\022SL_BFD_"
  "INVALID_VRF\020\215\340\001\022\036\n\030SL_BFD_SESSION_NOT_FO"
  "UND\020\216\340\001\022\033\n\025SL_BFD_SESSION_EXISTS\020\217\340\001\022\036\n\030"
  "SL_BFD_INTERNAL_DB_ERROR\020\220\340\001\022\033\n\025SL_BFD_R"
  "ECOVERY_ERROR\020\221\340\001\022\036\n\030SL_RPC_MPLS_START_O"
  "FFSET\020\200\200\002\022#\n\035SL_RPC_MPLS_ILM_TOO_MANY_IL"
  "MS\020\201\200\002\022(\n\"SL_RPC_MPLS_SERVER_NOT_INITIAL"
  "IZED\020\202\200\002\022(\n\"SL_RPC_MPLS_INIT_MODE_INCOMP"
  "ATIBLE\020\203\200\002\022/\n)SL_RPC_MPLS_LABEL_BLK_TOO_"
  "MANY_LABEL_BLKS\020\204\200\002\022 \n\032SL_RPC_MPLS_NOT_R"
  "EGISTERED\020\205\200\002\022\027\n\021SL_ILM_ERR_OFFSET\020\200\240\002\022\027"
  "\n\021SL_ILM_ADD_FAILED\020\201\240\002\022\033\n\025SL_ILM_LSD_AD"
  "D_FAILED\020\202\240\002\022\036\n\030SL_ILM_INVALID_NUM_NHLFE"
  "\020\203\240\002\022\032\n\024SL_ILM_INVALID_LABEL\020\204\240\002\022\032\n\024SL_I"
  "LM_DELETE_FAILED\020\205\240\002\022\036\n\030SL_ILM_LSD_DELET"
  "E_FAILED\020\206\240\002\022#\n\035SL_ILM_TOOMANY_PRIMARY_N"
  "HLFES\020\207\240\002\022\"\n\034SL_ILM_TOOMANY_BACKUP_NHLFE"
  "S\020\210\240\002\022\'\n!SL_ILM_LSD_ADD_LABEL_ALLOC_FAIL"
  "ED\020\211\240\002\022%\n\037SL_ILM_LSD_NHLFE_INVALID_ATTRI"
  "B\020\212\240\002\022\023\n\rSL_ILM_EEXIST\020\213\240\002\022\025\n\017SL_ILM_DB_"
  "NOMEM\020\214\240\002\022\035\n\027SL_ILM_INVALID_ELSP_EXP\020\215\240\002"
  "\022)\n#SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET\020"
  "\216\240\002\022\031\n\023SL_ILM_ADD_NO_PATHS\020\217\240\002\022\034\n\026SL_ILM"
  "_UPDATE_NO_PATHS\020\220\240\002\022\035\n\027SL_ILM_UNSUPPORT"
  "ED_ELSP\020\221\240\002\022&\n SL_ILM_LABEL_TOOMANY_EXP_"
  "CLASSES\020\222\240\002\022\037\n\031SL_ILM_REPLAY_FATAL_ERROR"
  "\020\223\240\002\022\026\n\020SL_ILM_REPLAY_OK\020\224\240\002\022\037\n\031SL_ILM_I"
  "NVALID_PREFIX_LEN\020\225\240\002\022\032\n\024SL_ILM_HOST_BIT"
  "S_SET\020\226\240\002\022\036\n\030SL_ILM_INVALID_PREFIX_SZ\020\227\240"
  "\002\022\033\n\025SL_ILM_INVALID_PREFIX\020\230\240\002\022!\n\033SL_ILM"
  "_INVALID_PREFIX_MCAST\020\231\240\002\022\035\n\027SL_ILM_VRF_"
  "NAME_TOOLONG\020\240\240\002\022\034\n\026SL_ILM_VRF_NO_TABLE_"
  "ID\020\241\240\002\022\035\n\027SL_ILM_VRF_NAME_MISSING\020\242\240\002\022\031\n"
  "\023SL_NHLFE_ERR_OFFSET\020\200\300\002\022\032\n\024SL_NHLFE_NH_"
  "NO_TABLE\020\201\300\002\022!\n\033SL_NHLFE_NH_INVALID_ADDR"
  "_SZ\020\202\300\002\022$\n\036SL_NHLFE_INVALID_NEXT_HOP_ADD"
  "R\020\203\300\002\022\037\n\031SL_NHLFE_VRF_NAME_TOOLONG\020\204\300\002\022\""
  "\n\034SL_NHLFE_NH_INF_NAME_MISSING\020\205\300\002\022#\n\035SL"
  "_NHLFE_NH_INTF_NAME_TOOLONG\020\206\300\002\022\"\n\034SL_NH"
  "LFE_INVALID_LABEL_COUNT\020\207\300\002\022\036\n\030SL_NHLFE_"
  "INVALID_PATH_ID\020\210\300\002\022\034\n\026SL_NHLFE_INVALID_"
  "LABEL\020\211\300\002\022\'\n!SL_NHLFE_INVALID_PROTECTED_"
  "BITMAP\020\212\300\002\022(\n\"SL_NHLFE_INVALID_REMOTE_AD"
  "DR_COUNT\020\213\300\002\022%\n\037SL_NHLFE_REMOTE_ADDR_INV"
  "ALID_SZ\020\214\300\002\022%\n\037SL_NHLFE_PRIMARY_TOOMANY_"
  "LABELS\020\215\300\002\022*\n$SL_NHLFE_PRIMARY_TOOMANY_R"
  "EMOTE_ADDR\020\216\300\002\022!\n\033SL_NHLFE_BACKUP_ID_REP"
  "EATED\020\217\300\002\022\"\n\034SL_NHLFE_PRIMARY_ID_REPEATE"
  "D\020\220\300\002\022,\n&SL_NHLFE_BACKUP_PROTECTED_BITMA"
  "P_EMPTY\020\221\300\002\022+\n%SL_NHLFE_PRIMARY_TOOMANY_"
  "BACKUP_PATHS\020\222\300\002\022\"\n\034SL_NHLFE_REMOTE_ADDR"
  "_INVALID\020\223\300\002\022*\n$SL_NHLFE_BACKUP_MISSING_"
  "PRIMARY_PATH\020\224\300\002\022\037\n\031SL_NHLFE_NEXT_HOP_MI"
  "SSING\020\225\300\002\022#\n\035SL_NHLFE_LABEL_ACTION_INVAL"
  "ID\020\226\300\002\022 \n\032SL_NHLFE_NH_INTF_NOT_FOUND\020\227\300\002"
  "\022\032\n\024SL_NHLFE_OPER_FAILED\020\230\300\002\022#\n\035SL_NHLFE"
  "_LABEL_ACTION_MISSING\020\231\300\002\022\035\n\027SL_NHLFE_EX"
  "P_SET_FAILED\020\232\300\002\022*\n$SL_NHLFE_ELSP_PROTEC"
  "TION_UNSUPPORTED\020\233\300\002\022\037\n\031SL_NHLFE_INVALID"
  "_ELSP_EXP\020\234\300\002\022$\n\036SL_NHLFE_INVALID_PATH_P"
  "RIORITY\020\235\300\002\022\"\n\034SL_NHLFE_INVALID_LOAD_MET"
  "RIC\020\236\300\002\022\034\n\026SL_NHLFE_INVALID_SETID\020\237\300\002\022%\n"
  "\037SL_NHLFE_INVALID_SETID_PRIORITY\020\240\300\002\022.\n("
  "SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS"
  "\020\241\300\002\022$\n\036SL_NHLFE_NON_CONTIGUOUS_SETIDS\020\242"
  "\300\002\022!\n\033SL_NHLFE_NON_CONTIGUOUS_EXP\020\243\300\002\022\'\n"
  "!SL_NHLFE_INCONSISTENT_EXP_ON_PATH\020\244\300\002\022\035"
  "\n\027SL_LABEL_BLK_ERR_OFFSET\020\200\340\002\022!\n\033SL_LABE"
  "L_BLK_LSD_ADD_FAILED\020\201\340\002\022$\n\036SL_LABEL_BLK"
  "_LSD_DELETE_FAILED\020\202\340\002\022*\n$SL_LABEL_BLK_L"
  "SD_LABEL_BLK_NOT_FOUND\020\203\340\002\022\'\n!SL_LABEL_B"
  "LK_LSD_LABEL_BLK_IN_USE\020\204\340\002\022%\n\037SL_LABEL_"
  "BLK_LSD_INVALID_ATTRIB\020\205\340\002\022%\n\037SL_LABEL_B"
  "LK_INVALID_BLOCK_SIZE\020\206\340\002\022&\n SL_LABEL_BL"
  "K_INVALID_START_LABEL\020\207\340\002\022\031\n\023SL_LABEL_BL"
  "K_EEXIST\020\210\340\002\022\033\n\025SL_LABEL_BLK_DB_NOMEM\020\211\340"
  "\002\022\037\n\031SL_LABEL_BLK_TYPE_INVALID\020\212\340\002\022&\n SL"
  "_LABEL_BLK_CLIENT_NAME_TOOLONG\020\213\340\002\022\034\n\026SL"
  "_MPLS_REG_ERR_OFFSET\020\200\200\003\022\025\n\017SL_MPLS_REG_"
  "ERR\020\201\200\003\022\027\n\021SL_MPLS_UNREG_ERR\020\202\200\003\022\025\n\017SL_M"
  "PLS_EOF_ERR\020\203\200\003\022\036\n\030SL_RPC_INTF_START_OFF"
  "SET\020\200\240\003\022%\n\037SL_RPC_INTF_TOO_MANY_INTERFAC"
  "ES\020\201\240\003\022(\n\"SL_RPC_INTF_SERVER_NOT_INITIAL"
  "IZED\020\202\240\003\022+\n%SL_RPC_INTF_API_CLIENT_NOT_R"
  "EGISTERED\020\203\240\003\022\032\n\024SL_INTF_START_OFFSET\020\200\300"
  "\003\022$\n\036SL_INTF_INTERFACE_NAME_MISSING\020\201\300\003\022"
  "$\n\036SL_INTF_INTERFACE_NAME_TOOLONG\020\202\300\003\022\037\n"
  "\031SL_INTF_INTERFACE_REG_ERR\020\203\300\003\022\037\n\031SL_INT"
  "F_INTERNAL_DB_ERROR\020\204\300\003\022\034\n\026SL_INTF_RECOV"
  "ERY_ERROR\020\205\300\003\022\036\n\030SL_INTF_INTERFACE_EXIST"
  "S\020\206\300\003\022!\n\033SL_INTF_INTERFACE_NOT_FOUND\020\207\300\003"
  "\022\034\n\026SL_L2_REG_START_OFFSET\020\200\340\003\022\034\n\026SL_L2_"
  "REGISTRATION_ERR\020\201\340\003\022\036\n\030SL_L2_UNREGISTRA"
  "TION_ERR\020\202\340\003\022\023\n\rSL_L2_EOF_ERR\020\203\340\003\022&\n SL_"
  "L2_REG_INVALID_ADMIN_DISTANCE\020\204\340\003\022\034\n\026SL_"
  "L2_REG_IS_DUPLICATE\020\205\340\003\022&\n SL_L2_REG_SER"
  "VER_NOT_INITIALIZED\020\206\340\003\022#\n\035SL_RPC_L2_BD_"
  "REG_START_OFFSET\020\200\200\004\022#\n\035SL_RPC_L2_BD_REG"
  "_NAME_MISSING\020\201\200\004\022$\n\036SL_RPC_L2_BD_REG_TO"
  "O_MANY_MSGS\020\202\200\004\022-\n\'SL_RPC_L2_BD_REG_SERV"
  "ER_NOT_INITIALIZED\020\203\200\004\022,\n&SL_RPC_L2_BD_R"
  "EG_CLIENT_NOT_REGISTERED\020\204\200\004\022\037\n\031SL_L2_BD"
  "_REG_START_OFFSET\020\200\240\004\022\037\n\031SL_L2_BD_REGIST"
  "RATION_ERR\020\201\240\004\022!\n\033SL_L2_BD_UNREGISTRATIO"
  "N_ERR\020\202\240\004\022\026\n\020SL_L2_BD_EOF_ERR\020\203\240\004\022 \n\032SL_"
  "L2_BD_REG_NAME_TOO_LONG\020\204\240\004\022\037\n\031SL_L2_BD_"
  "REG_BD_NOT_FOUND\020\205\240\004\022\"\n\034SL_RPC_L2_ROUTE_"
  "START_OFFSET\020\200\300\004\022#\n\035SL_RPC_L2_ROUTE_TOO_"
  "MANY_MSGS\020\201\300\004\022,\n&SL_RPC_L2_ROUTE_SERVER_"
  "NOT_INITIALIZED\020\202\300\004\022+\n%SL_RPC_L2_ROUTE_C"
  "LIENT_NOT_REGISTERED\020\203\300\004\022\036\n\030SL_L2_ROUTE_"
  "START_OFFSET\020\200\340\004\022!\n\033SL_L2_ROUTE_BD_NAME_"
  "MISSING\020\201\340\004\022!\n\033SL_L2_ROUTE_BD_NAME_TOOLO"
  "NG\020\202\340\004\022\036\n\030SL_L2_ROUTE_BD_NOT_FOUND\020\203\340\004\022#"
  "\n\035SL_L2_ROUTE_BD_NOT_REGISTERED\020\204\340\004\022\036\n\030S"
  "L_L2_ROUTE_INVALID_ARGS\020\205\340\004\022\"\n\034SL_RPC_L2"
  "_NOTIF_START_OFFSET\020\201\200\005\022,\n&SL_RPC_L2_NOT"
  "IF_SERVER_NOT_INITIALIZED\020\202\200\005\022+\n%SL_RPC_"
  "L2_NOTIF_CLIENT_NOT_REGISTERED\020\203\200\005\022 \n\032SL"
  "_RPC_L2_NOTIF_ENABLE_ERR\020\204\200\005\022!\n\033SL_RPC_L"
  "2_NOTIF_DISABLE_ERR\020\205\200\005\022\035\n\027SL_RPC_L2_NOT"
  "IF_EOF_ERR\020\206\200\005\022%\n\037SL_RPC_L2_NOTIF_BD_NAM"
  "E_MISSING\020\207\200\005\022%\n\037SL_RPC_L2_NOTIF_BD_NAME"
  "_TOOLONG\020\210\200\005\022\"\n\034SL_RPC_L2_NOTIF_BD_NOT_F"
  "OUND\020\211\200\005\022\036\n\030SL_INTERNAL_START_OFFSET\020\200\200@"
  "\"<\n\013SLInterface\022\016\n\004Name\030\001 \001(\tH\000\022\020\n\006Handl"
  "e\030\002 \001(\rH\000B\013\n\tInterface\"B\n\013SLIpAddress\022\023\n"
  "\tV4Address\030\001 \001(\rH\000\022\023\n\tV6Address\030\002 \001(\014H\000B"
  "\t\n\007Address*b\n\007SLRegOp\022\025\n\021SL_REGOP_RESERV"
  "ED\020\000\022\025\n\021SL_REGOP_REGISTER\020\001\022\027\n\023SL_REGOP_"
  "UNREGISTER\020\002\022\020\n\014SL_REGOP_EOF\020\003*_\n\nSLObje"
  "ctOp\022\025\n\021SL_OBJOP_RESERVED\020\000\022\020\n\014SL_OBJOP_"
  "ADD\020\001\022\023\n\017SL_OBJOP_UPDATE\020\002\022\023\n\017SL_OBJOP_D"
  "ELETE\020\003*S\n\tSLNotifOp\022\027\n\023SL_NOTIFOP_RESER"
  "VED\020\000\022\025\n\021SL_NOTIFOP_ENABLE\020\001\022\026\n\022SL_NOTIF"
  "OP_DISABLE\020\002*K\n\013SLEncapType\022\025\n\021SL_ENCAP_"
  "RESERVED\020\000\022\022\n\016SL_ENCAP_VXLAN\020\001\022\021\n\rSL_ENC"
  "AP_MPLS\020\002BQZOgithub.com/Cisco-service-la"
  "yer/service-layer-objmodel/grpc/protos;s"
  "ervice_layerb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_sl_5fcommon_5ftypes_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5fcommon_5ftypes_2eproto = {
  false, false, 9340, descriptor_table_protodef_sl_5fcommon_5ftypes_2eproto, "sl_common_types.proto", 
  &descriptor_table_sl_5fcommon_5ftypes_2eproto_once, nullptr, 0, 3,
  schemas, file_default_instances, TableStruct_sl_5fcommon_5ftypes_2eproto::offsets,
  file_level_metadata_sl_5fcommon_5ftypes_2eproto, file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto, file_level_service_descriptors_sl_5fcommon_5ftypes_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_sl_5fcommon_5ftypes_2eproto_getter() {
  return &descriptor_table_sl_5fcommon_5ftypes_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_sl_5fcommon_5ftypes_2eproto(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
namespace service_layer {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLErrorStatus_SLErrno_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
  return file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[0];
}
bool SLErrorStatus_SLErrno_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 1280:
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 4096:
    case 4097:
    case 4098:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8208:
    case 8209:
    case 8210:
    case 8211:
    case 12288:
    case 12289:
    case 12290:
    case 12291:
    case 12292:
    case 12293:
    case 12294:
    case 12295:
    case 12296:
    case 12297:
    case 12298:
    case 16384:
    case 16385:
    case 16386:
    case 16387:
    case 16388:
    case 16389:
    case 16390:
    case 16391:
    case 16392:
    case 16393:
    case 16394:
    case 16395:
    case 16396:
    case 16397:
    case 16398:
    case 16399:
    case 16400:
    case 16401:
    case 16402:
    case 16403:
    case 20480:
    case 20481:
    case 20482:
    case 20483:
    case 20484:
    case 20485:
    case 20486:
    case 20487:
    case 20488:
    case 20489:
    case 20490:
    case 20491:
    case 20492:
    case 20493:
    case 20494:
    case 20495:
    case 20496:
    case 20497:
    case 20498:
    case 20499:
    case 20500:
    case 20501:
    case 20502:
    case 20503:
    case 24576:
    case 24577:
    case 24578:
    case 24579:
    case 24580:
    case 24581:
    case 24582:
    case 24583:
    case 28672:
    case 28673:
    case 28674:
    case 28675:
    case 28676:
    case 28677:
    case 28678:
    case 28679:
    case 28680:
    case 28681:
    case 28682:
    case 28683:
    case 28684:
    case 28685:
    case 28686:
    case 28687:
    case 28688:
    case 28689:
    case 32768:
    case 32769:
    case 32770:
    case 32771:
    case 32772:
    case 32773:
    case 36864:
    case 36865:
    case 36866:
    case 36867:
    case 36868:
    case 36869:
    case 36870:
    case 36871:
    case 36872:
    case 36873:
    case 36874:
    case 36875:
    case 36876:
    case 36877:
    case 36878:
    case 36879:
    case 36880:
    case 36881:
    case 36882:
    case 36883:
    case 36884:
    case 36885:
    case 36886:
    case 36887:
    case 36888:
    case 36889:
    case 36896:
    case 36897:
    case 36898:
    case 40960:
    case 40961:
    case 40962:
    case 40963:
    case 40964:
    case 40965:
    case 40966:
    case 40967:
    case 40968:
    case 40969:
    case 40970:
    case 40971:
    case 40972:
    case 40973:
    case 40974:
    case 40975:
    case 40976:
    case 40977:
    case 40978:
    case 40979:
    case 40980:
    case 40981:
    case 40982:
    case 40983:
    case 40984:
    case 40985:
    case 40986:
    case 40987:
    case 40988:
    case 40989:
    case 40990:
    case 40991:
    case 40992:
    case 40993:
    case 40994:
    case 40995:
    case 40996:
    case 45056:
    case 45057:
    case 45058:
    case 45059:
    case 45060:
    case 45061:
    case 45062:
    case 45063:
    case 45064:
    case 45065:
    case 45066:
    case 45067:
    case 49152:
    case 49153:
    case 49154:
    case 49155:
    case 53248:
    case 53249:
    case 53250:
    case 53251:
    case 57344:
    case 57345:
    case 57346:
    case 57347:
    case 57348:
    case 57349:
    case 57350:
    case 57351:
    case 61440:
    case 61441:
    case 61442:
    case 61443:
    case 61444:
    case 61445:
    case 61446:
    case 65536:
    case 65537:
    case 65538:
    case 65539:
    case 65540:
    case 69632:
    case 69633:
    case 69634:
    case 69635:
    case 69636:
    case 69637:
    case 73728:
    case 73729:
    case 73730:
    case 73731:
    case 77824:
    case 77825:
    case 77826:
    case 77827:
    case 77828:
    case 77829:
    case 81921:
    case 81922:
    case 81923:
    case 81924:
    case 81925:
    case 81926:
    case 81927:
    case 81928:
    case 81929:
    case 1048576:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_SUCCESS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NOT_CONNECTED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_EAGAIN;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ENOMEM;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_EBUSY;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_EINVAL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_UNSUPPORTED_VER;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NOT_AVAILABLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_STREAM_NOT_SUPPORTED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ENOTSUP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_SOME_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_TIMEOUT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NOTIF_TERM;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_AUTH_FAIL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_STATE_CLEAR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_STATE_READY;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_UNSUPPORTED_VER;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INIT_SERVER_MODE_CHANGE_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_VRF_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_VRF_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_NO_TABLE_ID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_REG_INVALID_ADMIN_DISTANCE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_TABLE_ADD_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_TABLE_REGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_TABLE_UNREGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_TABLE_EOF_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_REG_VRF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_V4_ROUTE_REPLAY_OK;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_VRF_V6_ROUTE_REPLAY_OK;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_TOO_MANY_ROUTES;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_VRF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_VRF_NO_TABLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_VRF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_ADD_NO_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_UPDATE_NO_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_PREFIX_LEN;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_ADMIN_DISTANCE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_NUM_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_PREFIX_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_PREFIX;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_ERR_RIB_INVALID_ARGS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_ERR_RIB_TOOMANYPATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_EEXIST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_HOST_BITS_SET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_PREFIX_MCAST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_PATH_AFI_MISMATCH;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_TOOMANY_PRIMARY_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_TOOMANY_BACKUP_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_DB_NOMEM;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ROUTE_INVALID_LOCAL_LABEL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_NH_NO_TABLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_NH_INTF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_LABEL_COUNT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_ID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_NH_INTF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_NH_INVALID_ADDR_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_NH_INF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_NEXT_HOP_ADDR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_REMOTE_ADDR_COUNT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_REMOTE_ADDR_INVALID_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_REMOTE_ADDR_AFI_MISMATCH;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_PROTECTED_BITMAP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_BACKUP_MISSING_PRIMARY_PATH;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_PRIMARY_ID_REPEATED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_BACKUP_ID_REPEATED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_PRIMARY_TOOMANY_LABELS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_REMOTE_ADDR_INVALID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_INVALID_LABEL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_PATH_BACKUP_TOOMANY_LABELS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_TOO_MANY_BFD_SESSIONS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_API_BAD_PARAMETER;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_API_CLIENT_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_API_INTERNAL_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_V4_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_BFD_V6_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INTF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INTF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_ATTRIBUTE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INTF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_NBR_MCAST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_NBR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_BAD_PARAMETER;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_API_INTERNAL_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_VRF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_PREFIX_SIZE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_SESSION_TYPE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INVALID_VRF;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_SESSION_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_SESSION_EXISTS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_INTERNAL_DB_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_BFD_RECOVERY_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_ILM_TOO_MANY_ILMS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_MPLS_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_ERR_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_ADD_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_LSD_ADD_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_NUM_NHLFE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_LABEL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_DELETE_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_LSD_DELETE_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_TOOMANY_PRIMARY_NHLFES;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_TOOMANY_BACKUP_NHLFES;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_LSD_NHLFE_INVALID_ATTRIB;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_EEXIST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_DB_NOMEM;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_ELSP_EXP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_ADD_NO_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_UPDATE_NO_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_UNSUPPORTED_ELSP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_LABEL_TOOMANY_EXP_CLASSES;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_REPLAY_FATAL_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_REPLAY_OK;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_PREFIX_LEN;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_HOST_BITS_SET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_PREFIX_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_PREFIX;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_INVALID_PREFIX_MCAST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_VRF_NO_TABLE_ID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_ILM_VRF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_ERR_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NH_NO_TABLE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NH_INVALID_ADDR_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_NEXT_HOP_ADDR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_VRF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NH_INF_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NH_INTF_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_LABEL_COUNT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_PATH_ID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_LABEL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_PROTECTED_BITMAP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_REMOTE_ADDR_COUNT;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_REMOTE_ADDR_INVALID_SZ;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_PRIMARY_TOOMANY_LABELS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_BACKUP_ID_REPEATED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_PRIMARY_ID_REPEATED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_REMOTE_ADDR_INVALID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NEXT_HOP_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_LABEL_ACTION_INVALID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NH_INTF_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_OPER_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_LABEL_ACTION_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_EXP_SET_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_ELSP_EXP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_PATH_PRIORITY;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_LOAD_METRIC;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_SETID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_SETID_PRIORITY;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NON_CONTIGUOUS_SETIDS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_NON_CONTIGUOUS_EXP;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_NHLFE_INCONSISTENT_EXP_ON_PATH;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_ERR_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_LSD_ADD_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_LSD_DELETE_FAILED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_LSD_INVALID_ATTRIB;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_INVALID_BLOCK_SIZE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_INVALID_START_LABEL;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_EEXIST;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_DB_NOMEM;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_TYPE_INVALID;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_LABEL_BLK_CLIENT_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_MPLS_REG_ERR_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_MPLS_REG_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_MPLS_UNREG_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_MPLS_EOF_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_INTF_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_INTF_TOO_MANY_INTERFACES;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_INTF_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_INTF_API_CLIENT_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERFACE_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERFACE_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERFACE_REG_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERNAL_DB_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_RECOVERY_ERROR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERFACE_EXISTS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTF_INTERFACE_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_REG_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_REGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_UNREGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_EOF_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_REG_INVALID_ADMIN_DISTANCE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_REG_IS_DUPLICATE;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_REG_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_BD_REG_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_BD_REG_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_BD_REG_TOO_MANY_MSGS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_REG_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_REGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_UNREGISTRATION_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_EOF_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_REG_NAME_TOO_LONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_BD_REG_BD_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_ROUTE_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_ROUTE_TOO_MANY_MSGS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_BD_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_BD_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_BD_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_BD_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_L2_ROUTE_INVALID_ARGS;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_ENABLE_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_DISABLE_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_EOF_ERR;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_BD_NAME_MISSING;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_BD_NAME_TOOLONG;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_RPC_L2_NOTIF_BD_NOT_FOUND;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SL_INTERNAL_START_OFFSET;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SLErrno_MIN;
constexpr SLErrorStatus_SLErrno SLErrorStatus::SLErrno_MAX;
constexpr int SLErrorStatus::SLErrno_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRegOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
  return file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[1];
}
bool SLRegOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLObjectOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
  return file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[2];
}
bool SLObjectOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLNotifOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
  return file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[3];
}
bool SLNotifOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLEncapType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sl_5fcommon_5ftypes_2eproto);
  return file_level_enum_descriptors_sl_5fcommon_5ftypes_2eproto[4];
}
bool SLEncapType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SLErrorStatus::_Internal {
 public:
};

SLErrorStatus::SLErrorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:service_layer.SLErrorStatus)
}
SLErrorStatus::SLErrorStatus(const SLErrorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:service_layer.SLErrorStatus)
}

inline void SLErrorStatus::SharedCtor() {
status_ = 0;
}

SLErrorStatus::~SLErrorStatus() {
  // @@protoc_insertion_point(destructor:service_layer.SLErrorStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SLErrorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SLErrorStatus::ArenaDtor(void* object) {
  SLErrorStatus* _this = reinterpret_cast< SLErrorStatus* >(object);
  (void)_this;
}
void SLErrorStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SLErrorStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SLErrorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:service_layer.SLErrorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SLErrorStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .service_layer.SLErrorStatus.SLErrno Status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::service_layer::SLErrorStatus_SLErrno>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SLErrorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:service_layer.SLErrorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .service_layer.SLErrorStatus.SLErrno Status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:service_layer.SLErrorStatus)
  return target;
}

size_t SLErrorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:service_layer.SLErrorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .service_layer.SLErrorStatus.SLErrno Status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SLErrorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SLErrorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SLErrorStatus::GetClassData() const { return &_class_data_; }

void SLErrorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SLErrorStatus *>(to)->MergeFrom(
      static_cast<const SLErrorStatus &>(from));
}


void SLErrorStatus::MergeFrom(const SLErrorStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:service_layer.SLErrorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SLErrorStatus::CopyFrom(const SLErrorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:service_layer.SLErrorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SLErrorStatus::IsInitialized() const {
  return true;
}

void SLErrorStatus::InternalSwap(SLErrorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SLErrorStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sl_5fcommon_5ftypes_2eproto_getter, &descriptor_table_sl_5fcommon_5ftypes_2eproto_once,
      file_level_metadata_sl_5fcommon_5ftypes_2eproto[0]);
}

// ===================================================================

class SLInterface::_Internal {
 public:
};

SLInterface::SLInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:service_layer.SLInterface)
}
SLInterface::SLInterface(const SLInterface& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_Interface();
  switch (from.Interface_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kHandle: {
      _internal_set_handle(from._internal_handle());
      break;
    }
    case INTERFACE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:service_layer.SLInterface)
}

inline void SLInterface::SharedCtor() {
clear_has_Interface();
}

SLInterface::~SLInterface() {
  // @@protoc_insertion_point(destructor:service_layer.SLInterface)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SLInterface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Interface()) {
    clear_Interface();
  }
}

void SLInterface::ArenaDtor(void* object) {
  SLInterface* _this = reinterpret_cast< SLInterface* >(object);
  (void)_this;
}
void SLInterface::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SLInterface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SLInterface::clear_Interface() {
// @@protoc_insertion_point(one_of_clear_start:service_layer.SLInterface)
  switch (Interface_case()) {
    case kName: {
      Interface_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kHandle: {
      // No need to clear
      break;
    }
    case INTERFACE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INTERFACE_NOT_SET;
}


void SLInterface::Clear() {
// @@protoc_insertion_point(message_clear_start:service_layer.SLInterface)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Interface();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SLInterface::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "service_layer.SLInterface.Name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 Handle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_handle(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SLInterface::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:service_layer.SLInterface)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Name = 1;
  if (_internal_has_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "service_layer.SLInterface.Name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint32 Handle = 2;
  if (_internal_has_handle()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:service_layer.SLInterface)
  return target;
}

size_t SLInterface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:service_layer.SLInterface)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Interface_case()) {
    // string Name = 1;
    case kName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
      break;
    }
    // uint32 Handle = 2;
    case kHandle: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_handle());
      break;
    }
    case INTERFACE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SLInterface::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SLInterface::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SLInterface::GetClassData() const { return &_class_data_; }

void SLInterface::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SLInterface *>(to)->MergeFrom(
      static_cast<const SLInterface &>(from));
}


void SLInterface::MergeFrom(const SLInterface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:service_layer.SLInterface)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Interface_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kHandle: {
      _internal_set_handle(from._internal_handle());
      break;
    }
    case INTERFACE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SLInterface::CopyFrom(const SLInterface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:service_layer.SLInterface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SLInterface::IsInitialized() const {
  return true;
}

void SLInterface::InternalSwap(SLInterface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(Interface_, other->Interface_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SLInterface::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sl_5fcommon_5ftypes_2eproto_getter, &descriptor_table_sl_5fcommon_5ftypes_2eproto_once,
      file_level_metadata_sl_5fcommon_5ftypes_2eproto[1]);
}

// ===================================================================

class SLIpAddress::_Internal {
 public:
};

SLIpAddress::SLIpAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:service_layer.SLIpAddress)
}
SLIpAddress::SLIpAddress(const SLIpAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_Address();
  switch (from.Address_case()) {
    case kV4Address: {
      _internal_set_v4address(from._internal_v4address());
      break;
    }
    case kV6Address: {
      _internal_set_v6address(from._internal_v6address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:service_layer.SLIpAddress)
}

inline void SLIpAddress::SharedCtor() {
clear_has_Address();
}

SLIpAddress::~SLIpAddress() {
  // @@protoc_insertion_point(destructor:service_layer.SLIpAddress)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SLIpAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Address()) {
    clear_Address();
  }
}

void SLIpAddress::ArenaDtor(void* object) {
  SLIpAddress* _this = reinterpret_cast< SLIpAddress* >(object);
  (void)_this;
}
void SLIpAddress::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SLIpAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SLIpAddress::clear_Address() {
// @@protoc_insertion_point(one_of_clear_start:service_layer.SLIpAddress)
  switch (Address_case()) {
    case kV4Address: {
      // No need to clear
      break;
    }
    case kV6Address: {
      Address_.v6address_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ADDRESS_NOT_SET;
}


void SLIpAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:service_layer.SLIpAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Address();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SLIpAddress::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 V4Address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_v4address(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes V6Address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_v6address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SLIpAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:service_layer.SLIpAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 V4Address = 1;
  if (_internal_has_v4address()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_v4address(), target);
  }

  // bytes V6Address = 2;
  if (_internal_has_v6address()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_v6address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:service_layer.SLIpAddress)
  return target;
}

size_t SLIpAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:service_layer.SLIpAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Address_case()) {
    // uint32 V4Address = 1;
    case kV4Address: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_v4address());
      break;
    }
    // bytes V6Address = 2;
    case kV6Address: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_v6address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SLIpAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SLIpAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SLIpAddress::GetClassData() const { return &_class_data_; }

void SLIpAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SLIpAddress *>(to)->MergeFrom(
      static_cast<const SLIpAddress &>(from));
}


void SLIpAddress::MergeFrom(const SLIpAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:service_layer.SLIpAddress)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Address_case()) {
    case kV4Address: {
      _internal_set_v4address(from._internal_v4address());
      break;
    }
    case kV6Address: {
      _internal_set_v6address(from._internal_v6address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SLIpAddress::CopyFrom(const SLIpAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:service_layer.SLIpAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SLIpAddress::IsInitialized() const {
  return true;
}

void SLIpAddress::InternalSwap(SLIpAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(Address_, other->Address_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SLIpAddress::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sl_5fcommon_5ftypes_2eproto_getter, &descriptor_table_sl_5fcommon_5ftypes_2eproto_once,
      file_level_metadata_sl_5fcommon_5ftypes_2eproto[2]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::service_layer::SLErrorStatus* Arena::CreateMaybeMessage< ::service_layer::SLErrorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::service_layer::SLErrorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::service_layer::SLInterface* Arena::CreateMaybeMessage< ::service_layer::SLInterface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::service_layer::SLInterface >(arena);
}
template<> PROTOBUF_NOINLINE ::service_layer::SLIpAddress* Arena::CreateMaybeMessage< ::service_layer::SLIpAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::service_layer::SLIpAddress >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
