// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_common_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5fcommon_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5fcommon_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5fcommon_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5fcommon_5ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5fcommon_5ftypes_2eproto;
namespace service_layer {
class SLAutonomousSystemNumber;
struct SLAutonomousSystemNumberDefaultTypeInternal;
extern SLAutonomousSystemNumberDefaultTypeInternal _SLAutonomousSystemNumber_default_instance_;
class SLErrorStatus;
struct SLErrorStatusDefaultTypeInternal;
extern SLErrorStatusDefaultTypeInternal _SLErrorStatus_default_instance_;
class SLInterface;
struct SLInterfaceDefaultTypeInternal;
extern SLInterfaceDefaultTypeInternal _SLInterface_default_instance_;
class SLIpAddress;
struct SLIpAddressDefaultTypeInternal;
extern SLIpAddressDefaultTypeInternal _SLIpAddress_default_instance_;
class SLIpv6Address;
struct SLIpv6AddressDefaultTypeInternal;
extern SLIpv6AddressDefaultTypeInternal _SLIpv6Address_default_instance_;
class SLObjectId;
struct SLObjectIdDefaultTypeInternal;
extern SLObjectIdDefaultTypeInternal _SLObjectId_default_instance_;
class SLPathGroupRefKey;
struct SLPathGroupRefKeyDefaultTypeInternal;
extern SLPathGroupRefKeyDefaultTypeInternal _SLPathGroupRefKey_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLAutonomousSystemNumber* Arena::CreateMaybeMessage<::service_layer::SLAutonomousSystemNumber>(Arena*);
template<> ::service_layer::SLErrorStatus* Arena::CreateMaybeMessage<::service_layer::SLErrorStatus>(Arena*);
template<> ::service_layer::SLInterface* Arena::CreateMaybeMessage<::service_layer::SLInterface>(Arena*);
template<> ::service_layer::SLIpAddress* Arena::CreateMaybeMessage<::service_layer::SLIpAddress>(Arena*);
template<> ::service_layer::SLIpv6Address* Arena::CreateMaybeMessage<::service_layer::SLIpv6Address>(Arena*);
template<> ::service_layer::SLObjectId* Arena::CreateMaybeMessage<::service_layer::SLObjectId>(Arena*);
template<> ::service_layer::SLPathGroupRefKey* Arena::CreateMaybeMessage<::service_layer::SLPathGroupRefKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

enum SLErrorStatus_SLErrno : int {
  SLErrorStatus_SLErrno_SL_SUCCESS = 0,
  SLErrorStatus_SLErrno_SL_NOT_CONNECTED = 1,
  SLErrorStatus_SLErrno_SL_EAGAIN = 2,
  SLErrorStatus_SLErrno_SL_ENOMEM = 3,
  SLErrorStatus_SLErrno_SL_EBUSY = 4,
  SLErrorStatus_SLErrno_SL_EINVAL = 5,
  SLErrorStatus_SLErrno_SL_UNSUPPORTED_VER = 6,
  SLErrorStatus_SLErrno_SL_NOT_AVAILABLE = 7,
  SLErrorStatus_SLErrno_SL_STREAM_NOT_SUPPORTED = 8,
  SLErrorStatus_SLErrno_SL_ENOTSUP = 9,
  SLErrorStatus_SLErrno_SL_SOME_ERR = 10,
  SLErrorStatus_SLErrno_SL_TIMEOUT = 11,
  SLErrorStatus_SLErrno_SL_NOTIF_TERM = 12,
  SLErrorStatus_SLErrno_SL_AUTH_FAIL = 13,
  SLErrorStatus_SLErrno_SL_ACK_TYPE_NOT_SUPPORTED = 14,
  SLErrorStatus_SLErrno_SL_INIT_START_OFFSET = 1280,
  SLErrorStatus_SLErrno_SL_INIT_STATE_CLEAR = 1281,
  SLErrorStatus_SLErrno_SL_INIT_STATE_READY = 1282,
  SLErrorStatus_SLErrno_SL_INIT_UNSUPPORTED_VER = 1283,
  SLErrorStatus_SLErrno_SL_INIT_SERVER_NOT_INITIALIZED = 1284,
  SLErrorStatus_SLErrno_SL_INIT_SERVER_MODE_CHANGE_FAILED = 1285,
  SLErrorStatus_SLErrno_SL_RPC_VRF_START_OFFSET = 4096,
  SLErrorStatus_SLErrno_SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS = 4097,
  SLErrorStatus_SLErrno_SL_RPC_VRF_SERVER_NOT_INITIALIZED = 4098,
  SLErrorStatus_SLErrno_SL_RPC_VRF_OP_NOTSUP_WITH_AUTOREG = 4099,
  SLErrorStatus_SLErrno_SL_VRF_START_OFFSET = 8192,
  SLErrorStatus_SLErrno_SL_VRF_NAME_TOOLONG = 8193,
  SLErrorStatus_SLErrno_SL_VRF_NOT_FOUND = 8194,
  SLErrorStatus_SLErrno_SL_VRF_NO_TABLE_ID = 8195,
  SLErrorStatus_SLErrno_SL_VRF_REG_INVALID_ADMIN_DISTANCE = 8196,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_ADD_ERR = 8197,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_REGISTRATION_ERR = 8198,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_UNREGISTRATION_ERR = 8199,
  SLErrorStatus_SLErrno_SL_VRF_TABLE_EOF_ERR = 8200,
  SLErrorStatus_SLErrno_SL_VRF_REG_VRF_NAME_MISSING = 8201,
  SLErrorStatus_SLErrno_SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR = 8208,
  SLErrorStatus_SLErrno_SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR = 8209,
  SLErrorStatus_SLErrno_SL_VRF_V4_ROUTE_REPLAY_OK = 8210,
  SLErrorStatus_SLErrno_SL_VRF_V6_ROUTE_REPLAY_OK = 8211,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_START_OFFSET = 12288,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_TOO_MANY_ROUTES = 12289,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_TOOLONG = 12290,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NOT_FOUND = 12291,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NO_TABLE = 12292,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED = 12293,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_MISSING = 12294,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE = 12295,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_SERVER_NOT_INITIALIZED = 12296,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG = 12297,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG = 12298,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_GET_MATCH_INVALID = 12299,
  SLErrorStatus_SLErrno_SL_RPC_ROUTE_GET_MATCH_NOTSUP = 12300,
  SLErrorStatus_SLErrno_SL_ROUTE_START_OFFSET = 16384,
  SLErrorStatus_SLErrno_SL_ROUTE_ADD_NO_PATHS = 16385,
  SLErrorStatus_SLErrno_SL_ROUTE_UPDATE_NO_PATHS = 16386,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_LEN = 16387,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_ADMIN_DISTANCE = 16388,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_NUM_PATHS = 16389,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_SZ = 16390,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX = 16391,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED = 16392,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_INVALID_ARGS = 16393,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT = 16394,
  SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TOOMANYPATHS = 16395,
  SLErrorStatus_SLErrno_SL_ROUTE_EEXIST = 16396,
  SLErrorStatus_SLErrno_SL_ROUTE_HOST_BITS_SET = 16397,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_MCAST = 16398,
  SLErrorStatus_SLErrno_SL_ROUTE_PATH_AFI_MISMATCH = 16399,
  SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_PRIMARY_PATHS = 16400,
  SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_BACKUP_PATHS = 16401,
  SLErrorStatus_SLErrno_SL_ROUTE_DB_NOMEM = 16402,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_LOCAL_LABEL = 16403,
  SLErrorStatus_SLErrno_SL_ROUTE_INVALID_FLAGS = 16404,
  SLErrorStatus_SLErrno_SL_PATH_START_OFFSET = 20480,
  SLErrorStatus_SLErrno_SL_PATH_NH_NO_TABLE = 20481,
  SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NOT_FOUND = 20482,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL_COUNT = 20483,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_ID = 20484,
  SLErrorStatus_SLErrno_SL_PATH_VRF_NAME_TOOLONG = 20485,
  SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NAME_TOOLONG = 20486,
  SLErrorStatus_SLErrno_SL_PATH_NH_INVALID_ADDR_SZ = 20487,
  SLErrorStatus_SLErrno_SL_PATH_NH_INF_NAME_MISSING = 20488,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_NEXT_HOP_ADDR = 20489,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_REMOTE_ADDR_COUNT = 20490,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID_SZ = 20491,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_AFI_MISMATCH = 20492,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_PROTECTED_BITMAP = 20493,
  SLErrorStatus_SLErrno_SL_PATH_BACKUP_MISSING_PRIMARY_PATH = 20494,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_ID_REPEATED = 20495,
  SLErrorStatus_SLErrno_SL_PATH_BACKUP_ID_REPEATED = 20496,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS = 20497,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_LABELS = 20498,
  SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR = 20499,
  SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID = 20500,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL = 20501,
  SLErrorStatus_SLErrno_SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ = 20502,
  SLErrorStatus_SLErrno_SL_PATH_BACKUP_TOOMANY_LABELS = 20503,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_VNI = 20504,
  SLErrorStatus_SLErrno_SL_PATH_INVALID_ENCAP_ADDR = 20505,
  SLErrorStatus_SLErrno_SL_PATH_ENCAP_SRC_DST_AFI_MISMATCH = 20506,
  SLErrorStatus_SLErrno_SL_PATH_RTR_MAC_NOSUP = 20507,
  SLErrorStatus_SLErrno_SL_PATH_ENCAP_TYPE_MISMATCH = 20508,
  SLErrorStatus_SLErrno_SL_RPC_BFD_START_OFFSET = 24576,
  SLErrorStatus_SLErrno_SL_RPC_BFD_TOO_MANY_BFD_SESSIONS = 24577,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_BAD_PARAMETER = 24578,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_CLIENT_NOT_REGISTERED = 24579,
  SLErrorStatus_SLErrno_SL_RPC_BFD_API_INTERNAL_ERROR = 24580,
  SLErrorStatus_SLErrno_SL_RPC_BFD_SERVER_NOT_INITIALIZED = 24581,
  SLErrorStatus_SLErrno_SL_RPC_BFD_V4_NOT_REGISTERED = 24582,
  SLErrorStatus_SLErrno_SL_RPC_BFD_V6_NOT_REGISTERED = 24583,
  SLErrorStatus_SLErrno_SL_BFD_START_OFFSET = 28672,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_TOOLONG = 28673,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NOT_FOUND = 28674,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_ATTRIBUTE = 28675,
  SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_MISSING = 28676,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR_MCAST = 28677,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR = 28678,
  SLErrorStatus_SLErrno_SL_BFD_VRF_NAME_TOOLONG = 28679,
  SLErrorStatus_SLErrno_SL_BFD_BAD_PARAMETER = 28680,
  SLErrorStatus_SLErrno_SL_BFD_API_INTERNAL_ERROR = 28681,
  SLErrorStatus_SLErrno_SL_BFD_VRF_NOT_FOUND = 28682,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_PREFIX_SIZE = 28683,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_SESSION_TYPE = 28684,
  SLErrorStatus_SLErrno_SL_BFD_INVALID_VRF = 28685,
  SLErrorStatus_SLErrno_SL_BFD_SESSION_NOT_FOUND = 28686,
  SLErrorStatus_SLErrno_SL_BFD_SESSION_EXISTS = 28687,
  SLErrorStatus_SLErrno_SL_BFD_INTERNAL_DB_ERROR = 28688,
  SLErrorStatus_SLErrno_SL_BFD_RECOVERY_ERROR = 28689,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_START_OFFSET = 32768,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_ILM_TOO_MANY_ILMS = 32769,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_SERVER_NOT_INITIALIZED = 32770,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE = 32771,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS = 32772,
  SLErrorStatus_SLErrno_SL_RPC_MPLS_NOT_REGISTERED = 32773,
  SLErrorStatus_SLErrno_SL_ILM_ERR_OFFSET = 36864,
  SLErrorStatus_SLErrno_SL_ILM_ADD_FAILED = 36865,
  SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_FAILED = 36866,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_NUM_NHLFE = 36867,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_LABEL = 36868,
  SLErrorStatus_SLErrno_SL_ILM_DELETE_FAILED = 36869,
  SLErrorStatus_SLErrno_SL_ILM_LSD_DELETE_FAILED = 36870,
  SLErrorStatus_SLErrno_SL_ILM_TOOMANY_PRIMARY_NHLFES = 36871,
  SLErrorStatus_SLErrno_SL_ILM_TOOMANY_BACKUP_NHLFES = 36872,
  SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED = 36873,
  SLErrorStatus_SLErrno_SL_ILM_LSD_NHLFE_INVALID_ATTRIB = 36874,
  SLErrorStatus_SLErrno_SL_ILM_EEXIST = 36875,
  SLErrorStatus_SLErrno_SL_ILM_DB_NOMEM = 36876,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_ELSP_EXP = 36877,
  SLErrorStatus_SLErrno_SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET = 36878,
  SLErrorStatus_SLErrno_SL_ILM_ADD_NO_PATHS = 36879,
  SLErrorStatus_SLErrno_SL_ILM_UPDATE_NO_PATHS = 36880,
  SLErrorStatus_SLErrno_SL_ILM_UNSUPPORTED_ELSP = 36881,
  SLErrorStatus_SLErrno_SL_ILM_LABEL_TOOMANY_EXP_CLASSES = 36882,
  SLErrorStatus_SLErrno_SL_ILM_REPLAY_FATAL_ERROR = 36883,
  SLErrorStatus_SLErrno_SL_ILM_REPLAY_OK = 36884,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_LEN = 36885,
  SLErrorStatus_SLErrno_SL_ILM_HOST_BITS_SET = 36886,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_SZ = 36887,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX = 36888,
  SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_MCAST = 36889,
  SLErrorStatus_SLErrno_SL_ILM_VRF_NAME_TOOLONG = 36896,
  SLErrorStatus_SLErrno_SL_ILM_VRF_NO_TABLE_ID = 36897,
  SLErrorStatus_SLErrno_SL_ILM_VRF_NAME_MISSING = 36898,
  SLErrorStatus_SLErrno_SL_NHLFE_ERR_OFFSET = 40960,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_NO_TABLE = 40961,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INVALID_ADDR_SZ = 40962,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_NEXT_HOP_ADDR = 40963,
  SLErrorStatus_SLErrno_SL_NHLFE_VRF_NAME_TOOLONG = 40964,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INF_NAME_MISSING = 40965,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NAME_TOOLONG = 40966,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL_COUNT = 40967,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_ID = 40968,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL = 40969,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PROTECTED_BITMAP = 40970,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_REMOTE_ADDR_COUNT = 40971,
  SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID_SZ = 40972,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_LABELS = 40973,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR = 40974,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_ID_REPEATED = 40975,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_ID_REPEATED = 40976,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY = 40977,
  SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS = 40978,
  SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID = 40979,
  SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH = 40980,
  SLErrorStatus_SLErrno_SL_NHLFE_NEXT_HOP_MISSING = 40981,
  SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_INVALID = 40982,
  SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NOT_FOUND = 40983,
  SLErrorStatus_SLErrno_SL_NHLFE_OPER_FAILED = 40984,
  SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_MISSING = 40985,
  SLErrorStatus_SLErrno_SL_NHLFE_EXP_SET_FAILED = 40986,
  SLErrorStatus_SLErrno_SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED = 40987,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_ELSP_EXP = 40988,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_PRIORITY = 40989,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LOAD_METRIC = 40990,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_SETID = 40991,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_SETID_PRIORITY = 40992,
  SLErrorStatus_SLErrno_SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS = 40993,
  SLErrorStatus_SLErrno_SL_NHLFE_NON_CONTIGUOUS_SETIDS = 40994,
  SLErrorStatus_SLErrno_SL_NHLFE_NON_CONTIGUOUS_EXP = 40995,
  SLErrorStatus_SLErrno_SL_NHLFE_INCONSISTENT_EXP_ON_PATH = 40996,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_ERR_OFFSET = 45056,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_ADD_FAILED = 45057,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_DELETE_FAILED = 45058,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND = 45059,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE = 45060,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_INVALID_ATTRIB = 45061,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_BLOCK_SIZE = 45062,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_START_LABEL = 45063,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_EEXIST = 45064,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_DB_NOMEM = 45065,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_TYPE_INVALID = 45066,
  SLErrorStatus_SLErrno_SL_LABEL_BLK_CLIENT_NAME_TOOLONG = 45067,
  SLErrorStatus_SLErrno_SL_MPLS_REG_ERR_OFFSET = 49152,
  SLErrorStatus_SLErrno_SL_MPLS_REG_ERR = 49153,
  SLErrorStatus_SLErrno_SL_MPLS_UNREG_ERR = 49154,
  SLErrorStatus_SLErrno_SL_MPLS_EOF_ERR = 49155,
  SLErrorStatus_SLErrno_SL_RPC_INTF_START_OFFSET = 53248,
  SLErrorStatus_SLErrno_SL_RPC_INTF_TOO_MANY_INTERFACES = 53249,
  SLErrorStatus_SLErrno_SL_RPC_INTF_SERVER_NOT_INITIALIZED = 53250,
  SLErrorStatus_SLErrno_SL_RPC_INTF_API_CLIENT_NOT_REGISTERED = 53251,
  SLErrorStatus_SLErrno_SL_INTF_START_OFFSET = 57344,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_MISSING = 57345,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_TOOLONG = 57346,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_REG_ERR = 57347,
  SLErrorStatus_SLErrno_SL_INTF_INTERNAL_DB_ERROR = 57348,
  SLErrorStatus_SLErrno_SL_INTF_RECOVERY_ERROR = 57349,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_EXISTS = 57350,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NOT_FOUND = 57351,
  SLErrorStatus_SLErrno_SL_INTF_INTERFACE_STATE_NOT_SUPPORTED = 57352,
  SLErrorStatus_SLErrno_SL_L2_REG_START_OFFSET = 61440,
  SLErrorStatus_SLErrno_SL_L2_REGISTRATION_ERR = 61441,
  SLErrorStatus_SLErrno_SL_L2_UNREGISTRATION_ERR = 61442,
  SLErrorStatus_SLErrno_SL_L2_EOF_ERR = 61443,
  SLErrorStatus_SLErrno_SL_L2_REG_INVALID_ADMIN_DISTANCE = 61444,
  SLErrorStatus_SLErrno_SL_L2_REG_IS_DUPLICATE = 61445,
  SLErrorStatus_SLErrno_SL_L2_REG_SERVER_NOT_INITIALIZED = 61446,
  SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_START_OFFSET = 65536,
  SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_NAME_MISSING = 65537,
  SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_TOO_MANY_MSGS = 65538,
  SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED = 65539,
  SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED = 65540,
  SLErrorStatus_SLErrno_SL_L2_BD_REG_START_OFFSET = 69632,
  SLErrorStatus_SLErrno_SL_L2_BD_REGISTRATION_ERR = 69633,
  SLErrorStatus_SLErrno_SL_L2_BD_UNREGISTRATION_ERR = 69634,
  SLErrorStatus_SLErrno_SL_L2_BD_EOF_ERR = 69635,
  SLErrorStatus_SLErrno_SL_L2_BD_REG_NAME_TOO_LONG = 69636,
  SLErrorStatus_SLErrno_SL_L2_BD_REG_BD_NOT_FOUND = 69637,
  SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_START_OFFSET = 73728,
  SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_TOO_MANY_MSGS = 73729,
  SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED = 73730,
  SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED = 73731,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_START_OFFSET = 77824,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NAME_MISSING = 77825,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NAME_TOOLONG = 77826,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NOT_FOUND = 77827,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NOT_REGISTERED = 77828,
  SLErrorStatus_SLErrno_SL_L2_ROUTE_INVALID_ARGS = 77829,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_START_OFFSET = 81921,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED = 81922,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED = 81923,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_ENABLE_ERR = 81924,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_DISABLE_ERR = 81925,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_EOF_ERR = 81926,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NAME_MISSING = 81927,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NAME_TOOLONG = 81928,
  SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NOT_FOUND = 81929,
  SLErrorStatus_SLErrno_SL_PG_VRF_ADD_ERR = 86017,
  SLErrorStatus_SLErrno_SL_PG_VRF_NO_VRFID = 86018,
  SLErrorStatus_SLErrno_SL_PG_STR_KEY_TOOLONG = 86019,
  SLErrorStatus_SLErrno_SL_PG_TARGET_VRF_NO_VRFID = 86020,
  SLErrorStatus_SLErrno_SL_PG_STR_KEY_INVALID = 86021,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_START_OFFSET = 90112,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_LEN = 90113,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_HOST_BITS_SET = 90114,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_MCAST = 90115,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX = 90116,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_NEXT_HOP_ADDR = 90117,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_SZ = 90118,
  SLErrorStatus_SLErrno_SL_NEXT_HOP_RIB_ADD_FAILED = 90119,
  SLErrorStatus_SLErrno_SL_ROUTE_REDIST_RIB_ADD_FAILED = 90120,
  SLErrorStatus_SLErrno_SL_ACK_START_OFFSET = 94208,
  SLErrorStatus_SLErrno_SL_ACK_PERMIT_NOT_SUPPORTED = 94209,
  SLErrorStatus_SLErrno_SL_ACK_INVALID_TYPE = 94210,
  SLErrorStatus_SLErrno_SL_POLICY_START_OFFSET = 98304,
  SLErrorStatus_SLErrno_SL_POLICY_ADD_ERR = 98305,
  SLErrorStatus_SLErrno_SL_POLICY_EXISTS_ERR = 98306,
  SLErrorStatus_SLErrno_SL_POLICY_DELETE_ERR = 98307,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_ADD_ERR = 98308,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_EXISTS_ERR = 98309,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_DELETE_ERR = 98310,
  SLErrorStatus_SLErrno_SL_POLICY_APPLY_ERR = 98311,
  SLErrorStatus_SLErrno_SL_POLICY_UNAPPLY_ERR = 98312,
  SLErrorStatus_SLErrno_SL_POLICY_TOO_MANY_POLICIES = 98313,
  SLErrorStatus_SLErrno_SL_POLICY_NAME_TOO_LONG = 98314,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_NAME_TOO_LONG = 98315,
  SLErrorStatus_SLErrno_SL_POLICY_DUPLICATE_PRIORITY_IN_RULE = 98316,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_MOD_NOT_ALLOWED = 98317,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID_RULE = 98318,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_ADD_NO_RULES = 98319,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID_MATCH_COUNT_IN_RULE = 98320,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID_ACTION_COUNT_IN_RULE = 98321,
  SLErrorStatus_SLErrno_SL_POLICY_NOT_FOUND = 98322,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID = 98323,
  SLErrorStatus_SLErrno_SL_POLICY_NAME_MISSING = 98324,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_NAME_MISSING = 98325,
  SLErrorStatus_SLErrno_SL_POLICY_PRIORITY_MISSING_IN_RULE = 98326,
  SLErrorStatus_SLErrno_SL_POLICY_TYPE_INVALID = 98327,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID_DIRECTION = 98328,
  SLErrorStatus_SLErrno_SL_POLICY_INTF_NAME_TOOLONG = 98329,
  SLErrorStatus_SLErrno_SL_POLICY_INTF_NAME_MISSING = 98330,
  SLErrorStatus_SLErrno_SL_POLICY_MAX_RULE_LIMIT_REACHED = 98331,
  SLErrorStatus_SLErrno_SL_POLICY_VRF_NAME_TOO_LONG = 98332,
  SLErrorStatus_SLErrno_SL_POLICY_VRF_NAME_MISSING = 98333,
  SLErrorStatus_SLErrno_SL_POLICY_PATH_GRP_NAME_TOO_LONG = 98334,
  SLErrorStatus_SLErrno_SL_POLICY_PATH_GRP_NAME_MISSING = 98335,
  SLErrorStatus_SLErrno_SL_POLICY_INVALID_DSCP_VALUE = 98336,
  SLErrorStatus_SLErrno_SL_POLICY_PRIORITY_STR_TOO_LONG = 98337,
  SLErrorStatus_SLErrno_SL_POLICY_MAX_INTF_LIMIT_REACHED = 98338,
  SLErrorStatus_SLErrno_SL_POLICY_RULE_DELETE_NO_RULES = 98339,
  SLErrorStatus_SLErrno_SL_POLICY_APPLY_NO_INTFS = 98340,
  SLErrorStatus_SLErrno_SL_POLICY_UNAPPLY_NO_INTFS = 98341,
  SLErrorStatus_SLErrno_SL_POLICY_REPLACE_ERR = 98342,
  SLErrorStatus_SLErrno_SL_BGPLS_TOPO_START_OFFSET = 102400,
  SLErrorStatus_SLErrno_SL_BGPLS_SERVER_NOT_AVAILABLE = 102401,
  SLErrorStatus_SLErrno_SL_BGPLS_MAX_MATCH_FILTER_EXCEEDED = 102402,
  SLErrorStatus_SLErrno_SL_BGPLS_MAX_STREAMS_EXCEEDED = 102403,
  SLErrorStatus_SLErrno_SL_BGP_START_OFFSET = 106496,
  SLErrorStatus_SLErrno_SL_BGP_INST_NAME_TOOLONG = 106497,
  SLErrorStatus_SLErrno_SL_BGP_INST_NAME_EMPTY = 106498,
  SLErrorStatus_SLErrno_SL_BGP_INST_NOT_INITIALIZED = 106499,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_OBJ_TYPE = 106500,
  SLErrorStatus_SLErrno_SL_BGP_VRF_NAME_TOOLONG_V4 = 106501,
  SLErrorStatus_SLErrno_SL_BGP_VRF_NAME_TOOLONG_V6 = 106502,
  SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_VRF_NAME = 106503,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR_MCAST = 106504,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR_EXP = 106505,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR = 106506,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_V6_SZ = 106507,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_KEY = 106508,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR_MCAST = 106509,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR_EXP = 106510,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR = 106511,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_V6_SZ = 106512,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_NBRSAFI_LIST = 106513,
  SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_BGP_AFI_SAFI = 106514,
  SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_AFI = 106515,
  SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_SAFI = 106516,
  SLErrorStatus_SLErrno_SL_BGP_EMPTY_OBJECTS = 106517,
  SLErrorStatus_SLErrno_SL_BGP_EMPTY_OBJECT_LIST = 106518,
  SLErrorStatus_SLErrno_SL_BGP_UPDATE_BW_GRP_FAILED = 106519,
  SLErrorStatus_SLErrno_SL_BGP_UPDATE_MPATH_ADDR_FAILED = 106520,
  SLErrorStatus_SLErrno_SL_BGP_DELETE_BW_GRP_FAILED = 106521,
  SLErrorStatus_SLErrno_SL_BGP_DELETE_NBR_FAILED = 106522,
  SLErrorStatus_SLErrno_SL_BGP_DELETE_AFI_FAILED = 106523,
  SLErrorStatus_SLErrno_SL_BGP_DELETE_MPATH_ADDR_FAILED = 106524,
  SLErrorStatus_SLErrno_SL_BGP_DELETE_FAILED = 106525,
  SLErrorStatus_SLErrno_SL_BGP_BW_GRP_NUM_OUT_OF_RANGE = 106526,
  SLErrorStatus_SLErrno_SL_BGP_IN_BW_GRP_COUNT_EXCEEDED = 106527,
  SLErrorStatus_SLErrno_SL_BGP_OUT_BW_GRP_COUNT_EXCEEDED = 106528,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_IN_BWGRP_LIST = 106529,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_OUT_BWGRP_LIST = 106530,
  SLErrorStatus_SLErrno_SL_BGP_LINK_BW_OUT_OF_RANGE = 106531,
  SLErrorStatus_SLErrno_SL_BGP_NBR_IDX_OUT_OF_RANGE = 106532,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_BW_TYPE = 106533,
  SLErrorStatus_SLErrno_SL_BGP_BW_GRP_LIST_NULL = 106534,
  SLErrorStatus_SLErrno_SL_BGP_NBRSAFI_LIST_NULL = 106535,
  SLErrorStatus_SLErrno_SL_BGP_INST_NOT_CONFIG_IN_SLAPI = 106536,
  SLErrorStatus_SLErrno_SL_BGP_OBJ_LIST_IDX_OUT_OF_RANGE = 106537,
  SLErrorStatus_SLErrno_SL_BGP_ASN_OUT_OF_RANGE = 106538,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_BW_UNIT = 106539,
  SLErrorStatus_SLErrno_SL_BGP_OBJECT_TYPE_REQUIRED = 106540,
  SLErrorStatus_SLErrno_SL_BGP_OBJECT_KEY_REQUIRED = 106541,
  SLErrorStatus_SLErrno_SL_BGP_INVALID_OBJECT_TYPE = 106542,
  SLErrorStatus_SLErrno_SL_BGP_GET_EXACT_MATCH_NOT_FOUND = 106543,
  SLErrorStatus_SLErrno_SL_BGP_MAX_NEIGHBORS_IN_SYSDB = 106544,
  SLErrorStatus_SLErrno_SL_BGP_MAX_OBJECTS_IN_PAYLOAD = 106545,
  SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_1 = 106753,
  SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_2 = 106754,
  SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_3 = 106755,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_START_OFFSET = 110592,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_REQUEST_INVALID = 110593,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_POLICY_KEY_INVALID = 110594,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_POLICY_ATTR_INVALID = 110595,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_CP_KEY_INVALID = 110596,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_CP_ATTR_INVALID = 110597,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_CLIENT_MISMATCH = 110598,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_SERVICE_NOT_UP = 110599,
  SLErrorStatus_SLErrno_SL_SRTE_POLICY_EXCEED_MSG_SIZE = 110600,
  SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET = 1048576,
  SLErrorStatus_SLErrno_SLErrorStatus_SLErrno_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLErrorStatus_SLErrno_SLErrorStatus_SLErrno_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLErrorStatus_SLErrno_IsValid(int value);
constexpr SLErrorStatus_SLErrno SLErrorStatus_SLErrno_SLErrno_MIN = SLErrorStatus_SLErrno_SL_SUCCESS;
constexpr SLErrorStatus_SLErrno SLErrorStatus_SLErrno_SLErrno_MAX = SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET;
constexpr int SLErrorStatus_SLErrno_SLErrno_ARRAYSIZE = SLErrorStatus_SLErrno_SLErrno_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLErrorStatus_SLErrno_descriptor();
template<typename T>
inline const std::string& SLErrorStatus_SLErrno_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLErrorStatus_SLErrno>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLErrorStatus_SLErrno_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLErrorStatus_SLErrno_descriptor(), enum_t_value);
}
inline bool SLErrorStatus_SLErrno_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLErrorStatus_SLErrno* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLErrorStatus_SLErrno>(
    SLErrorStatus_SLErrno_descriptor(), name, value);
}
enum SLRegOp : int {
  SL_REGOP_RESERVED = 0,
  SL_REGOP_REGISTER = 1,
  SL_REGOP_UNREGISTER = 2,
  SL_REGOP_EOF = 3,
  SLRegOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLRegOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLRegOp_IsValid(int value);
constexpr SLRegOp SLRegOp_MIN = SL_REGOP_RESERVED;
constexpr SLRegOp SLRegOp_MAX = SL_REGOP_EOF;
constexpr int SLRegOp_ARRAYSIZE = SLRegOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRegOp_descriptor();
template<typename T>
inline const std::string& SLRegOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLRegOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLRegOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLRegOp_descriptor(), enum_t_value);
}
inline bool SLRegOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLRegOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLRegOp>(
    SLRegOp_descriptor(), name, value);
}
enum SLObjectOp : int {
  SL_OBJOP_RESERVED = 0,
  SL_OBJOP_ADD = 1,
  SL_OBJOP_UPDATE = 2,
  SL_OBJOP_DELETE = 3,
  SLObjectOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLObjectOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLObjectOp_IsValid(int value);
constexpr SLObjectOp SLObjectOp_MIN = SL_OBJOP_RESERVED;
constexpr SLObjectOp SLObjectOp_MAX = SL_OBJOP_DELETE;
constexpr int SLObjectOp_ARRAYSIZE = SLObjectOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLObjectOp_descriptor();
template<typename T>
inline const std::string& SLObjectOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLObjectOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLObjectOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLObjectOp_descriptor(), enum_t_value);
}
inline bool SLObjectOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLObjectOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLObjectOp>(
    SLObjectOp_descriptor(), name, value);
}
enum SLNotifOp : int {
  SL_NOTIFOP_RESERVED = 0,
  SL_NOTIFOP_ENABLE = 1,
  SL_NOTIFOP_DISABLE = 2,
  SLNotifOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLNotifOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLNotifOp_IsValid(int value);
constexpr SLNotifOp SLNotifOp_MIN = SL_NOTIFOP_RESERVED;
constexpr SLNotifOp SLNotifOp_MAX = SL_NOTIFOP_DISABLE;
constexpr int SLNotifOp_ARRAYSIZE = SLNotifOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLNotifOp_descriptor();
template<typename T>
inline const std::string& SLNotifOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLNotifOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLNotifOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLNotifOp_descriptor(), enum_t_value);
}
inline bool SLNotifOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLNotifOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLNotifOp>(
    SLNotifOp_descriptor(), name, value);
}
enum SLUpdatePriority : int {
  SL_PRIORITY_RESERVED = 0,
  SL_PRIORITY_CRITICAL = 4,
  SL_PRIORITY_HIGH = 8,
  SL_PRIORITY_MEDIUM = 12,
  SL_PRIORITY_LOW = 16,
  SLUpdatePriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLUpdatePriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLUpdatePriority_IsValid(int value);
constexpr SLUpdatePriority SLUpdatePriority_MIN = SL_PRIORITY_RESERVED;
constexpr SLUpdatePriority SLUpdatePriority_MAX = SL_PRIORITY_LOW;
constexpr int SLUpdatePriority_ARRAYSIZE = SLUpdatePriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLUpdatePriority_descriptor();
template<typename T>
inline const std::string& SLUpdatePriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLUpdatePriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLUpdatePriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLUpdatePriority_descriptor(), enum_t_value);
}
inline bool SLUpdatePriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLUpdatePriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLUpdatePriority>(
    SLUpdatePriority_descriptor(), name, value);
}
enum SLEncapType : int {
  SL_ENCAP_RESERVED = 0,
  SL_ENCAP_VXLAN = 1,
  SL_ENCAP_MPLS = 2,
  SLEncapType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLEncapType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLEncapType_IsValid(int value);
constexpr SLEncapType SLEncapType_MIN = SL_ENCAP_RESERVED;
constexpr SLEncapType SLEncapType_MAX = SL_ENCAP_MPLS;
constexpr int SLEncapType_ARRAYSIZE = SLEncapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLEncapType_descriptor();
template<typename T>
inline const std::string& SLEncapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLEncapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLEncapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLEncapType_descriptor(), enum_t_value);
}
inline bool SLEncapType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLEncapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLEncapType>(
    SLEncapType_descriptor(), name, value);
}
enum SLTableType : int {
  SL_TABLE_TYPE_RESERVED = 0,
  SL_IPv4_ROUTE_TABLE = 1,
  SL_IPv6_ROUTE_TABLE = 2,
  SL_MPLS_LABEL_TABLE = 3,
  SL_PATH_GROUP_TABLE = 4,
  SLTableType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLTableType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLTableType_IsValid(int value);
constexpr SLTableType SLTableType_MIN = SL_TABLE_TYPE_RESERVED;
constexpr SLTableType SLTableType_MAX = SL_PATH_GROUP_TABLE;
constexpr int SLTableType_ARRAYSIZE = SLTableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLTableType_descriptor();
template<typename T>
inline const std::string& SLTableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLTableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLTableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLTableType_descriptor(), enum_t_value);
}
inline bool SLTableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLTableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLTableType>(
    SLTableType_descriptor(), name, value);
}
enum SLRspACKType : int {
  RIB_ACK = 0,
  RIB_AND_FIB_ACK = 1,
  RIB_FIB_INUSE_ACK = 2,
  SLRspACKType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLRspACKType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLRspACKType_IsValid(int value);
constexpr SLRspACKType SLRspACKType_MIN = RIB_ACK;
constexpr SLRspACKType SLRspACKType_MAX = RIB_FIB_INUSE_ACK;
constexpr int SLRspACKType_ARRAYSIZE = SLRspACKType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRspACKType_descriptor();
template<typename T>
inline const std::string& SLRspACKType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLRspACKType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLRspACKType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLRspACKType_descriptor(), enum_t_value);
}
inline bool SLRspACKType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLRspACKType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLRspACKType>(
    SLRspACKType_descriptor(), name, value);
}
enum SLAFFibStatus : int {
  SL_FIB_UNKNOWN = 0,
  SL_FIB_SUCCESS = 1,
  SL_FIB_FAILED = 2,
  SL_FIB_INELIGIBLE = 3,
  SL_FIB_INUSE_SUCCESS = 4,
  SLAFFibStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLAFFibStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLAFFibStatus_IsValid(int value);
constexpr SLAFFibStatus SLAFFibStatus_MIN = SL_FIB_UNKNOWN;
constexpr SLAFFibStatus SLAFFibStatus_MAX = SL_FIB_INUSE_SUCCESS;
constexpr int SLAFFibStatus_ARRAYSIZE = SLAFFibStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLAFFibStatus_descriptor();
template<typename T>
inline const std::string& SLAFFibStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLAFFibStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLAFFibStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLAFFibStatus_descriptor(), enum_t_value);
}
inline bool SLAFFibStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLAFFibStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLAFFibStatus>(
    SLAFFibStatus_descriptor(), name, value);
}
enum SLRspACKPermit : int {
  SL_PERMIT_FIB_STATUS_ALL = 0,
  SL_PERMIT_FIB_SUCCESS = 1,
  SL_PERMIT_FIB_FAILED = 2,
  SL_PERMIT_FIB_INELIGIBLE = 3,
  SL_PERMIT_FIB_INUSE_SUCCESS = 4,
  SLRspACKPermit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLRspACKPermit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLRspACKPermit_IsValid(int value);
constexpr SLRspACKPermit SLRspACKPermit_MIN = SL_PERMIT_FIB_STATUS_ALL;
constexpr SLRspACKPermit SLRspACKPermit_MAX = SL_PERMIT_FIB_INUSE_SUCCESS;
constexpr int SLRspACKPermit_ARRAYSIZE = SLRspACKPermit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRspACKPermit_descriptor();
template<typename T>
inline const std::string& SLRspACKPermit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLRspACKPermit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLRspACKPermit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLRspACKPermit_descriptor(), enum_t_value);
}
inline bool SLRspACKPermit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLRspACKPermit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLRspACKPermit>(
    SLRspACKPermit_descriptor(), name, value);
}
enum SLRspAckCadence : int {
  SL_RSP_CONTINUOUS = 0,
  SL_RSP_JUST_ONCE = 1,
  SL_RSP_ONCE_EACH = 2,
  SL_RSP_NONE = 3,
  SLRspAckCadence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLRspAckCadence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLRspAckCadence_IsValid(int value);
constexpr SLRspAckCadence SLRspAckCadence_MIN = SL_RSP_CONTINUOUS;
constexpr SLRspAckCadence SLRspAckCadence_MAX = SL_RSP_NONE;
constexpr int SLRspAckCadence_ARRAYSIZE = SLRspAckCadence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRspAckCadence_descriptor();
template<typename T>
inline const std::string& SLRspAckCadence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLRspAckCadence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLRspAckCadence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLRspAckCadence_descriptor(), enum_t_value);
}
inline bool SLRspAckCadence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLRspAckCadence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLRspAckCadence>(
    SLRspAckCadence_descriptor(), name, value);
}
// ===================================================================

class SLErrorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLErrorStatus) */ {
 public:
  inline SLErrorStatus() : SLErrorStatus(nullptr) {}
  ~SLErrorStatus() override;
  explicit constexpr SLErrorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLErrorStatus(const SLErrorStatus& from);
  SLErrorStatus(SLErrorStatus&& from) noexcept
    : SLErrorStatus() {
    *this = ::std::move(from);
  }

  inline SLErrorStatus& operator=(const SLErrorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLErrorStatus& operator=(SLErrorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLErrorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLErrorStatus* internal_default_instance() {
    return reinterpret_cast<const SLErrorStatus*>(
               &_SLErrorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLErrorStatus& a, SLErrorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SLErrorStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLErrorStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLErrorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLErrorStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLErrorStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLErrorStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLErrorStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLErrorStatus";
  }
  protected:
  explicit SLErrorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLErrorStatus_SLErrno SLErrno;
  static constexpr SLErrno SL_SUCCESS =
    SLErrorStatus_SLErrno_SL_SUCCESS;
  static constexpr SLErrno SL_NOT_CONNECTED =
    SLErrorStatus_SLErrno_SL_NOT_CONNECTED;
  static constexpr SLErrno SL_EAGAIN =
    SLErrorStatus_SLErrno_SL_EAGAIN;
  static constexpr SLErrno SL_ENOMEM =
    SLErrorStatus_SLErrno_SL_ENOMEM;
  static constexpr SLErrno SL_EBUSY =
    SLErrorStatus_SLErrno_SL_EBUSY;
  static constexpr SLErrno SL_EINVAL =
    SLErrorStatus_SLErrno_SL_EINVAL;
  static constexpr SLErrno SL_UNSUPPORTED_VER =
    SLErrorStatus_SLErrno_SL_UNSUPPORTED_VER;
  static constexpr SLErrno SL_NOT_AVAILABLE =
    SLErrorStatus_SLErrno_SL_NOT_AVAILABLE;
  static constexpr SLErrno SL_STREAM_NOT_SUPPORTED =
    SLErrorStatus_SLErrno_SL_STREAM_NOT_SUPPORTED;
  static constexpr SLErrno SL_ENOTSUP =
    SLErrorStatus_SLErrno_SL_ENOTSUP;
  static constexpr SLErrno SL_SOME_ERR =
    SLErrorStatus_SLErrno_SL_SOME_ERR;
  static constexpr SLErrno SL_TIMEOUT =
    SLErrorStatus_SLErrno_SL_TIMEOUT;
  static constexpr SLErrno SL_NOTIF_TERM =
    SLErrorStatus_SLErrno_SL_NOTIF_TERM;
  static constexpr SLErrno SL_AUTH_FAIL =
    SLErrorStatus_SLErrno_SL_AUTH_FAIL;
  static constexpr SLErrno SL_ACK_TYPE_NOT_SUPPORTED =
    SLErrorStatus_SLErrno_SL_ACK_TYPE_NOT_SUPPORTED;
  static constexpr SLErrno SL_INIT_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INIT_START_OFFSET;
  static constexpr SLErrno SL_INIT_STATE_CLEAR =
    SLErrorStatus_SLErrno_SL_INIT_STATE_CLEAR;
  static constexpr SLErrno SL_INIT_STATE_READY =
    SLErrorStatus_SLErrno_SL_INIT_STATE_READY;
  static constexpr SLErrno SL_INIT_UNSUPPORTED_VER =
    SLErrorStatus_SLErrno_SL_INIT_UNSUPPORTED_VER;
  static constexpr SLErrno SL_INIT_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_INIT_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_INIT_SERVER_MODE_CHANGE_FAILED =
    SLErrorStatus_SLErrno_SL_INIT_SERVER_MODE_CHANGE_FAILED;
  static constexpr SLErrno SL_RPC_VRF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_VRF_START_OFFSET;
  static constexpr SLErrno SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS =
    SLErrorStatus_SLErrno_SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS;
  static constexpr SLErrno SL_RPC_VRF_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_VRF_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_VRF_OP_NOTSUP_WITH_AUTOREG =
    SLErrorStatus_SLErrno_SL_RPC_VRF_OP_NOTSUP_WITH_AUTOREG;
  static constexpr SLErrno SL_VRF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_VRF_START_OFFSET;
  static constexpr SLErrno SL_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_VRF_NOT_FOUND;
  static constexpr SLErrno SL_VRF_NO_TABLE_ID =
    SLErrorStatus_SLErrno_SL_VRF_NO_TABLE_ID;
  static constexpr SLErrno SL_VRF_REG_INVALID_ADMIN_DISTANCE =
    SLErrorStatus_SLErrno_SL_VRF_REG_INVALID_ADMIN_DISTANCE;
  static constexpr SLErrno SL_VRF_TABLE_ADD_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_ADD_ERR;
  static constexpr SLErrno SL_VRF_TABLE_REGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_REGISTRATION_ERR;
  static constexpr SLErrno SL_VRF_TABLE_UNREGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_UNREGISTRATION_ERR;
  static constexpr SLErrno SL_VRF_TABLE_EOF_ERR =
    SLErrorStatus_SLErrno_SL_VRF_TABLE_EOF_ERR;
  static constexpr SLErrno SL_VRF_REG_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_VRF_REG_VRF_NAME_MISSING;
  static constexpr SLErrno SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR =
    SLErrorStatus_SLErrno_SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR;
  static constexpr SLErrno SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR =
    SLErrorStatus_SLErrno_SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR;
  static constexpr SLErrno SL_VRF_V4_ROUTE_REPLAY_OK =
    SLErrorStatus_SLErrno_SL_VRF_V4_ROUTE_REPLAY_OK;
  static constexpr SLErrno SL_VRF_V6_ROUTE_REPLAY_OK =
    SLErrorStatus_SLErrno_SL_VRF_V6_ROUTE_REPLAY_OK;
  static constexpr SLErrno SL_RPC_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_START_OFFSET;
  static constexpr SLErrno SL_RPC_ROUTE_TOO_MANY_ROUTES =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_TOO_MANY_ROUTES;
  static constexpr SLErrno SL_RPC_ROUTE_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_RPC_ROUTE_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NOT_FOUND;
  static constexpr SLErrno SL_RPC_ROUTE_VRF_NO_TABLE =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NO_TABLE;
  static constexpr SLErrno SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED;
  static constexpr SLErrno SL_RPC_ROUTE_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_VRF_NAME_MISSING;
  static constexpr SLErrno SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE;
  static constexpr SLErrno SL_RPC_ROUTE_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG;
  static constexpr SLErrno SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG;
  static constexpr SLErrno SL_RPC_ROUTE_GET_MATCH_INVALID =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_GET_MATCH_INVALID;
  static constexpr SLErrno SL_RPC_ROUTE_GET_MATCH_NOTSUP =
    SLErrorStatus_SLErrno_SL_RPC_ROUTE_GET_MATCH_NOTSUP;
  static constexpr SLErrno SL_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_ROUTE_START_OFFSET;
  static constexpr SLErrno SL_ROUTE_ADD_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_ADD_NO_PATHS;
  static constexpr SLErrno SL_ROUTE_UPDATE_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_UPDATE_NO_PATHS;
  static constexpr SLErrno SL_ROUTE_INVALID_PREFIX_LEN =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_LEN;
  static constexpr SLErrno SL_ROUTE_INVALID_ADMIN_DISTANCE =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_ADMIN_DISTANCE;
  static constexpr SLErrno SL_ROUTE_INVALID_NUM_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_NUM_PATHS;
  static constexpr SLErrno SL_ROUTE_INVALID_PREFIX_SZ =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_SZ;
  static constexpr SLErrno SL_ROUTE_INVALID_PREFIX =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX;
  static constexpr SLErrno SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED;
  static constexpr SLErrno SL_ROUTE_ERR_RIB_INVALID_ARGS =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_INVALID_ARGS;
  static constexpr SLErrno SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT;
  static constexpr SLErrno SL_ROUTE_ERR_RIB_TOOMANYPATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_ERR_RIB_TOOMANYPATHS;
  static constexpr SLErrno SL_ROUTE_EEXIST =
    SLErrorStatus_SLErrno_SL_ROUTE_EEXIST;
  static constexpr SLErrno SL_ROUTE_HOST_BITS_SET =
    SLErrorStatus_SLErrno_SL_ROUTE_HOST_BITS_SET;
  static constexpr SLErrno SL_ROUTE_INVALID_PREFIX_MCAST =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_PREFIX_MCAST;
  static constexpr SLErrno SL_ROUTE_PATH_AFI_MISMATCH =
    SLErrorStatus_SLErrno_SL_ROUTE_PATH_AFI_MISMATCH;
  static constexpr SLErrno SL_ROUTE_TOOMANY_PRIMARY_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_PRIMARY_PATHS;
  static constexpr SLErrno SL_ROUTE_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_ROUTE_TOOMANY_BACKUP_PATHS;
  static constexpr SLErrno SL_ROUTE_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_ROUTE_DB_NOMEM;
  static constexpr SLErrno SL_ROUTE_INVALID_LOCAL_LABEL =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_LOCAL_LABEL;
  static constexpr SLErrno SL_ROUTE_INVALID_FLAGS =
    SLErrorStatus_SLErrno_SL_ROUTE_INVALID_FLAGS;
  static constexpr SLErrno SL_PATH_START_OFFSET =
    SLErrorStatus_SLErrno_SL_PATH_START_OFFSET;
  static constexpr SLErrno SL_PATH_NH_NO_TABLE =
    SLErrorStatus_SLErrno_SL_PATH_NH_NO_TABLE;
  static constexpr SLErrno SL_PATH_NH_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NOT_FOUND;
  static constexpr SLErrno SL_PATH_INVALID_LABEL_COUNT =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL_COUNT;
  static constexpr SLErrno SL_PATH_INVALID_ID =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_ID;
  static constexpr SLErrno SL_PATH_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_PATH_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_PATH_NH_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_PATH_NH_INTF_NAME_TOOLONG;
  static constexpr SLErrno SL_PATH_NH_INVALID_ADDR_SZ =
    SLErrorStatus_SLErrno_SL_PATH_NH_INVALID_ADDR_SZ;
  static constexpr SLErrno SL_PATH_NH_INF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_PATH_NH_INF_NAME_MISSING;
  static constexpr SLErrno SL_PATH_INVALID_NEXT_HOP_ADDR =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_NEXT_HOP_ADDR;
  static constexpr SLErrno SL_PATH_INVALID_REMOTE_ADDR_COUNT =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_REMOTE_ADDR_COUNT;
  static constexpr SLErrno SL_PATH_REMOTE_ADDR_INVALID_SZ =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID_SZ;
  static constexpr SLErrno SL_PATH_REMOTE_ADDR_AFI_MISMATCH =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_AFI_MISMATCH;
  static constexpr SLErrno SL_PATH_INVALID_PROTECTED_BITMAP =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_PROTECTED_BITMAP;
  static constexpr SLErrno SL_PATH_BACKUP_MISSING_PRIMARY_PATH =
    SLErrorStatus_SLErrno_SL_PATH_BACKUP_MISSING_PRIMARY_PATH;
  static constexpr SLErrno SL_PATH_PRIMARY_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_ID_REPEATED;
  static constexpr SLErrno SL_PATH_BACKUP_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_PATH_BACKUP_ID_REPEATED;
  static constexpr SLErrno SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS;
  static constexpr SLErrno SL_PATH_PRIMARY_TOOMANY_LABELS =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_LABELS;
  static constexpr SLErrno SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR =
    SLErrorStatus_SLErrno_SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR;
  static constexpr SLErrno SL_PATH_REMOTE_ADDR_INVALID =
    SLErrorStatus_SLErrno_SL_PATH_REMOTE_ADDR_INVALID;
  static constexpr SLErrno SL_PATH_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_LABEL;
  static constexpr SLErrno SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ =
    SLErrorStatus_SLErrno_SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ;
  static constexpr SLErrno SL_PATH_BACKUP_TOOMANY_LABELS =
    SLErrorStatus_SLErrno_SL_PATH_BACKUP_TOOMANY_LABELS;
  static constexpr SLErrno SL_PATH_INVALID_VNI =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_VNI;
  static constexpr SLErrno SL_PATH_INVALID_ENCAP_ADDR =
    SLErrorStatus_SLErrno_SL_PATH_INVALID_ENCAP_ADDR;
  static constexpr SLErrno SL_PATH_ENCAP_SRC_DST_AFI_MISMATCH =
    SLErrorStatus_SLErrno_SL_PATH_ENCAP_SRC_DST_AFI_MISMATCH;
  static constexpr SLErrno SL_PATH_RTR_MAC_NOSUP =
    SLErrorStatus_SLErrno_SL_PATH_RTR_MAC_NOSUP;
  static constexpr SLErrno SL_PATH_ENCAP_TYPE_MISMATCH =
    SLErrorStatus_SLErrno_SL_PATH_ENCAP_TYPE_MISMATCH;
  static constexpr SLErrno SL_RPC_BFD_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_BFD_START_OFFSET;
  static constexpr SLErrno SL_RPC_BFD_TOO_MANY_BFD_SESSIONS =
    SLErrorStatus_SLErrno_SL_RPC_BFD_TOO_MANY_BFD_SESSIONS;
  static constexpr SLErrno SL_RPC_BFD_API_BAD_PARAMETER =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_BAD_PARAMETER;
  static constexpr SLErrno SL_RPC_BFD_API_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_CLIENT_NOT_REGISTERED;
  static constexpr SLErrno SL_RPC_BFD_API_INTERNAL_ERROR =
    SLErrorStatus_SLErrno_SL_RPC_BFD_API_INTERNAL_ERROR;
  static constexpr SLErrno SL_RPC_BFD_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_BFD_V4_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_V4_NOT_REGISTERED;
  static constexpr SLErrno SL_RPC_BFD_V6_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_BFD_V6_NOT_REGISTERED;
  static constexpr SLErrno SL_BFD_START_OFFSET =
    SLErrorStatus_SLErrno_SL_BFD_START_OFFSET;
  static constexpr SLErrno SL_BFD_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_TOOLONG;
  static constexpr SLErrno SL_BFD_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NOT_FOUND;
  static constexpr SLErrno SL_BFD_INVALID_ATTRIBUTE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_ATTRIBUTE;
  static constexpr SLErrno SL_BFD_INTF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_BFD_INTF_NAME_MISSING;
  static constexpr SLErrno SL_BFD_INVALID_NBR_MCAST =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR_MCAST;
  static constexpr SLErrno SL_BFD_INVALID_NBR =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_NBR;
  static constexpr SLErrno SL_BFD_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_BFD_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_BFD_BAD_PARAMETER =
    SLErrorStatus_SLErrno_SL_BFD_BAD_PARAMETER;
  static constexpr SLErrno SL_BFD_API_INTERNAL_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_API_INTERNAL_ERROR;
  static constexpr SLErrno SL_BFD_VRF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_VRF_NOT_FOUND;
  static constexpr SLErrno SL_BFD_INVALID_PREFIX_SIZE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_PREFIX_SIZE;
  static constexpr SLErrno SL_BFD_INVALID_SESSION_TYPE =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_SESSION_TYPE;
  static constexpr SLErrno SL_BFD_INVALID_VRF =
    SLErrorStatus_SLErrno_SL_BFD_INVALID_VRF;
  static constexpr SLErrno SL_BFD_SESSION_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BFD_SESSION_NOT_FOUND;
  static constexpr SLErrno SL_BFD_SESSION_EXISTS =
    SLErrorStatus_SLErrno_SL_BFD_SESSION_EXISTS;
  static constexpr SLErrno SL_BFD_INTERNAL_DB_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_INTERNAL_DB_ERROR;
  static constexpr SLErrno SL_BFD_RECOVERY_ERROR =
    SLErrorStatus_SLErrno_SL_BFD_RECOVERY_ERROR;
  static constexpr SLErrno SL_RPC_MPLS_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_START_OFFSET;
  static constexpr SLErrno SL_RPC_MPLS_ILM_TOO_MANY_ILMS =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_ILM_TOO_MANY_ILMS;
  static constexpr SLErrno SL_RPC_MPLS_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE;
  static constexpr SLErrno SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS;
  static constexpr SLErrno SL_RPC_MPLS_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_MPLS_NOT_REGISTERED;
  static constexpr SLErrno SL_ILM_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_ILM_ERR_OFFSET;
  static constexpr SLErrno SL_ILM_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_ADD_FAILED;
  static constexpr SLErrno SL_ILM_LSD_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_FAILED;
  static constexpr SLErrno SL_ILM_INVALID_NUM_NHLFE =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_NUM_NHLFE;
  static constexpr SLErrno SL_ILM_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_LABEL;
  static constexpr SLErrno SL_ILM_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_DELETE_FAILED;
  static constexpr SLErrno SL_ILM_LSD_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_DELETE_FAILED;
  static constexpr SLErrno SL_ILM_TOOMANY_PRIMARY_NHLFES =
    SLErrorStatus_SLErrno_SL_ILM_TOOMANY_PRIMARY_NHLFES;
  static constexpr SLErrno SL_ILM_TOOMANY_BACKUP_NHLFES =
    SLErrorStatus_SLErrno_SL_ILM_TOOMANY_BACKUP_NHLFES;
  static constexpr SLErrno SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED =
    SLErrorStatus_SLErrno_SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED;
  static constexpr SLErrno SL_ILM_LSD_NHLFE_INVALID_ATTRIB =
    SLErrorStatus_SLErrno_SL_ILM_LSD_NHLFE_INVALID_ATTRIB;
  static constexpr SLErrno SL_ILM_EEXIST =
    SLErrorStatus_SLErrno_SL_ILM_EEXIST;
  static constexpr SLErrno SL_ILM_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_ILM_DB_NOMEM;
  static constexpr SLErrno SL_ILM_INVALID_ELSP_EXP =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_ELSP_EXP;
  static constexpr SLErrno SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET =
    SLErrorStatus_SLErrno_SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET;
  static constexpr SLErrno SL_ILM_ADD_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ILM_ADD_NO_PATHS;
  static constexpr SLErrno SL_ILM_UPDATE_NO_PATHS =
    SLErrorStatus_SLErrno_SL_ILM_UPDATE_NO_PATHS;
  static constexpr SLErrno SL_ILM_UNSUPPORTED_ELSP =
    SLErrorStatus_SLErrno_SL_ILM_UNSUPPORTED_ELSP;
  static constexpr SLErrno SL_ILM_LABEL_TOOMANY_EXP_CLASSES =
    SLErrorStatus_SLErrno_SL_ILM_LABEL_TOOMANY_EXP_CLASSES;
  static constexpr SLErrno SL_ILM_REPLAY_FATAL_ERROR =
    SLErrorStatus_SLErrno_SL_ILM_REPLAY_FATAL_ERROR;
  static constexpr SLErrno SL_ILM_REPLAY_OK =
    SLErrorStatus_SLErrno_SL_ILM_REPLAY_OK;
  static constexpr SLErrno SL_ILM_INVALID_PREFIX_LEN =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_LEN;
  static constexpr SLErrno SL_ILM_HOST_BITS_SET =
    SLErrorStatus_SLErrno_SL_ILM_HOST_BITS_SET;
  static constexpr SLErrno SL_ILM_INVALID_PREFIX_SZ =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_SZ;
  static constexpr SLErrno SL_ILM_INVALID_PREFIX =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX;
  static constexpr SLErrno SL_ILM_INVALID_PREFIX_MCAST =
    SLErrorStatus_SLErrno_SL_ILM_INVALID_PREFIX_MCAST;
  static constexpr SLErrno SL_ILM_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_ILM_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_ILM_VRF_NO_TABLE_ID =
    SLErrorStatus_SLErrno_SL_ILM_VRF_NO_TABLE_ID;
  static constexpr SLErrno SL_ILM_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_ILM_VRF_NAME_MISSING;
  static constexpr SLErrno SL_NHLFE_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_NHLFE_ERR_OFFSET;
  static constexpr SLErrno SL_NHLFE_NH_NO_TABLE =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_NO_TABLE;
  static constexpr SLErrno SL_NHLFE_NH_INVALID_ADDR_SZ =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INVALID_ADDR_SZ;
  static constexpr SLErrno SL_NHLFE_INVALID_NEXT_HOP_ADDR =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_NEXT_HOP_ADDR;
  static constexpr SLErrno SL_NHLFE_VRF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_NHLFE_VRF_NAME_TOOLONG;
  static constexpr SLErrno SL_NHLFE_NH_INF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INF_NAME_MISSING;
  static constexpr SLErrno SL_NHLFE_NH_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NAME_TOOLONG;
  static constexpr SLErrno SL_NHLFE_INVALID_LABEL_COUNT =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL_COUNT;
  static constexpr SLErrno SL_NHLFE_INVALID_PATH_ID =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_ID;
  static constexpr SLErrno SL_NHLFE_INVALID_LABEL =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LABEL;
  static constexpr SLErrno SL_NHLFE_INVALID_PROTECTED_BITMAP =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PROTECTED_BITMAP;
  static constexpr SLErrno SL_NHLFE_INVALID_REMOTE_ADDR_COUNT =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_REMOTE_ADDR_COUNT;
  static constexpr SLErrno SL_NHLFE_REMOTE_ADDR_INVALID_SZ =
    SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID_SZ;
  static constexpr SLErrno SL_NHLFE_PRIMARY_TOOMANY_LABELS =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_LABELS;
  static constexpr SLErrno SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR;
  static constexpr SLErrno SL_NHLFE_BACKUP_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_ID_REPEATED;
  static constexpr SLErrno SL_NHLFE_PRIMARY_ID_REPEATED =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_ID_REPEATED;
  static constexpr SLErrno SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY;
  static constexpr SLErrno SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS =
    SLErrorStatus_SLErrno_SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS;
  static constexpr SLErrno SL_NHLFE_REMOTE_ADDR_INVALID =
    SLErrorStatus_SLErrno_SL_NHLFE_REMOTE_ADDR_INVALID;
  static constexpr SLErrno SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH =
    SLErrorStatus_SLErrno_SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH;
  static constexpr SLErrno SL_NHLFE_NEXT_HOP_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_NEXT_HOP_MISSING;
  static constexpr SLErrno SL_NHLFE_LABEL_ACTION_INVALID =
    SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_INVALID;
  static constexpr SLErrno SL_NHLFE_NH_INTF_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_NHLFE_NH_INTF_NOT_FOUND;
  static constexpr SLErrno SL_NHLFE_OPER_FAILED =
    SLErrorStatus_SLErrno_SL_NHLFE_OPER_FAILED;
  static constexpr SLErrno SL_NHLFE_LABEL_ACTION_MISSING =
    SLErrorStatus_SLErrno_SL_NHLFE_LABEL_ACTION_MISSING;
  static constexpr SLErrno SL_NHLFE_EXP_SET_FAILED =
    SLErrorStatus_SLErrno_SL_NHLFE_EXP_SET_FAILED;
  static constexpr SLErrno SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED =
    SLErrorStatus_SLErrno_SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED;
  static constexpr SLErrno SL_NHLFE_INVALID_ELSP_EXP =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_ELSP_EXP;
  static constexpr SLErrno SL_NHLFE_INVALID_PATH_PRIORITY =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_PATH_PRIORITY;
  static constexpr SLErrno SL_NHLFE_INVALID_LOAD_METRIC =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_LOAD_METRIC;
  static constexpr SLErrno SL_NHLFE_INVALID_SETID =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_SETID;
  static constexpr SLErrno SL_NHLFE_INVALID_SETID_PRIORITY =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_SETID_PRIORITY;
  static constexpr SLErrno SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS =
    SLErrorStatus_SLErrno_SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS;
  static constexpr SLErrno SL_NHLFE_NON_CONTIGUOUS_SETIDS =
    SLErrorStatus_SLErrno_SL_NHLFE_NON_CONTIGUOUS_SETIDS;
  static constexpr SLErrno SL_NHLFE_NON_CONTIGUOUS_EXP =
    SLErrorStatus_SLErrno_SL_NHLFE_NON_CONTIGUOUS_EXP;
  static constexpr SLErrno SL_NHLFE_INCONSISTENT_EXP_ON_PATH =
    SLErrorStatus_SLErrno_SL_NHLFE_INCONSISTENT_EXP_ON_PATH;
  static constexpr SLErrno SL_LABEL_BLK_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_ERR_OFFSET;
  static constexpr SLErrno SL_LABEL_BLK_LSD_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_ADD_FAILED;
  static constexpr SLErrno SL_LABEL_BLK_LSD_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_DELETE_FAILED;
  static constexpr SLErrno SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND;
  static constexpr SLErrno SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE;
  static constexpr SLErrno SL_LABEL_BLK_LSD_INVALID_ATTRIB =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_LSD_INVALID_ATTRIB;
  static constexpr SLErrno SL_LABEL_BLK_INVALID_BLOCK_SIZE =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_BLOCK_SIZE;
  static constexpr SLErrno SL_LABEL_BLK_INVALID_START_LABEL =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_INVALID_START_LABEL;
  static constexpr SLErrno SL_LABEL_BLK_EEXIST =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_EEXIST;
  static constexpr SLErrno SL_LABEL_BLK_DB_NOMEM =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_DB_NOMEM;
  static constexpr SLErrno SL_LABEL_BLK_TYPE_INVALID =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_TYPE_INVALID;
  static constexpr SLErrno SL_LABEL_BLK_CLIENT_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_LABEL_BLK_CLIENT_NAME_TOOLONG;
  static constexpr SLErrno SL_MPLS_REG_ERR_OFFSET =
    SLErrorStatus_SLErrno_SL_MPLS_REG_ERR_OFFSET;
  static constexpr SLErrno SL_MPLS_REG_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_REG_ERR;
  static constexpr SLErrno SL_MPLS_UNREG_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_UNREG_ERR;
  static constexpr SLErrno SL_MPLS_EOF_ERR =
    SLErrorStatus_SLErrno_SL_MPLS_EOF_ERR;
  static constexpr SLErrno SL_RPC_INTF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_INTF_START_OFFSET;
  static constexpr SLErrno SL_RPC_INTF_TOO_MANY_INTERFACES =
    SLErrorStatus_SLErrno_SL_RPC_INTF_TOO_MANY_INTERFACES;
  static constexpr SLErrno SL_RPC_INTF_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_INTF_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_INTF_API_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_INTF_API_CLIENT_NOT_REGISTERED;
  static constexpr SLErrno SL_INTF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INTF_START_OFFSET;
  static constexpr SLErrno SL_INTF_INTERFACE_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_MISSING;
  static constexpr SLErrno SL_INTF_INTERFACE_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NAME_TOOLONG;
  static constexpr SLErrno SL_INTF_INTERFACE_REG_ERR =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_REG_ERR;
  static constexpr SLErrno SL_INTF_INTERNAL_DB_ERROR =
    SLErrorStatus_SLErrno_SL_INTF_INTERNAL_DB_ERROR;
  static constexpr SLErrno SL_INTF_RECOVERY_ERROR =
    SLErrorStatus_SLErrno_SL_INTF_RECOVERY_ERROR;
  static constexpr SLErrno SL_INTF_INTERFACE_EXISTS =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_EXISTS;
  static constexpr SLErrno SL_INTF_INTERFACE_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_NOT_FOUND;
  static constexpr SLErrno SL_INTF_INTERFACE_STATE_NOT_SUPPORTED =
    SLErrorStatus_SLErrno_SL_INTF_INTERFACE_STATE_NOT_SUPPORTED;
  static constexpr SLErrno SL_L2_REG_START_OFFSET =
    SLErrorStatus_SLErrno_SL_L2_REG_START_OFFSET;
  static constexpr SLErrno SL_L2_REGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_L2_REGISTRATION_ERR;
  static constexpr SLErrno SL_L2_UNREGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_L2_UNREGISTRATION_ERR;
  static constexpr SLErrno SL_L2_EOF_ERR =
    SLErrorStatus_SLErrno_SL_L2_EOF_ERR;
  static constexpr SLErrno SL_L2_REG_INVALID_ADMIN_DISTANCE =
    SLErrorStatus_SLErrno_SL_L2_REG_INVALID_ADMIN_DISTANCE;
  static constexpr SLErrno SL_L2_REG_IS_DUPLICATE =
    SLErrorStatus_SLErrno_SL_L2_REG_IS_DUPLICATE;
  static constexpr SLErrno SL_L2_REG_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_L2_REG_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_L2_BD_REG_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_START_OFFSET;
  static constexpr SLErrno SL_RPC_L2_BD_REG_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_NAME_MISSING;
  static constexpr SLErrno SL_RPC_L2_BD_REG_TOO_MANY_MSGS =
    SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_TOO_MANY_MSGS;
  static constexpr SLErrno SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED;
  static constexpr SLErrno SL_L2_BD_REG_START_OFFSET =
    SLErrorStatus_SLErrno_SL_L2_BD_REG_START_OFFSET;
  static constexpr SLErrno SL_L2_BD_REGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_L2_BD_REGISTRATION_ERR;
  static constexpr SLErrno SL_L2_BD_UNREGISTRATION_ERR =
    SLErrorStatus_SLErrno_SL_L2_BD_UNREGISTRATION_ERR;
  static constexpr SLErrno SL_L2_BD_EOF_ERR =
    SLErrorStatus_SLErrno_SL_L2_BD_EOF_ERR;
  static constexpr SLErrno SL_L2_BD_REG_NAME_TOO_LONG =
    SLErrorStatus_SLErrno_SL_L2_BD_REG_NAME_TOO_LONG;
  static constexpr SLErrno SL_L2_BD_REG_BD_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_L2_BD_REG_BD_NOT_FOUND;
  static constexpr SLErrno SL_RPC_L2_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_START_OFFSET;
  static constexpr SLErrno SL_RPC_L2_ROUTE_TOO_MANY_MSGS =
    SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_TOO_MANY_MSGS;
  static constexpr SLErrno SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED;
  static constexpr SLErrno SL_L2_ROUTE_START_OFFSET =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_START_OFFSET;
  static constexpr SLErrno SL_L2_ROUTE_BD_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NAME_MISSING;
  static constexpr SLErrno SL_L2_ROUTE_BD_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NAME_TOOLONG;
  static constexpr SLErrno SL_L2_ROUTE_BD_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NOT_FOUND;
  static constexpr SLErrno SL_L2_ROUTE_BD_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_BD_NOT_REGISTERED;
  static constexpr SLErrno SL_L2_ROUTE_INVALID_ARGS =
    SLErrorStatus_SLErrno_SL_L2_ROUTE_INVALID_ARGS;
  static constexpr SLErrno SL_RPC_L2_NOTIF_START_OFFSET =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_START_OFFSET;
  static constexpr SLErrno SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED;
  static constexpr SLErrno SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED;
  static constexpr SLErrno SL_RPC_L2_NOTIF_ENABLE_ERR =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_ENABLE_ERR;
  static constexpr SLErrno SL_RPC_L2_NOTIF_DISABLE_ERR =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_DISABLE_ERR;
  static constexpr SLErrno SL_RPC_L2_NOTIF_EOF_ERR =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_EOF_ERR;
  static constexpr SLErrno SL_RPC_L2_NOTIF_BD_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NAME_MISSING;
  static constexpr SLErrno SL_RPC_L2_NOTIF_BD_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NAME_TOOLONG;
  static constexpr SLErrno SL_RPC_L2_NOTIF_BD_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_RPC_L2_NOTIF_BD_NOT_FOUND;
  static constexpr SLErrno SL_PG_VRF_ADD_ERR =
    SLErrorStatus_SLErrno_SL_PG_VRF_ADD_ERR;
  static constexpr SLErrno SL_PG_VRF_NO_VRFID =
    SLErrorStatus_SLErrno_SL_PG_VRF_NO_VRFID;
  static constexpr SLErrno SL_PG_STR_KEY_TOOLONG =
    SLErrorStatus_SLErrno_SL_PG_STR_KEY_TOOLONG;
  static constexpr SLErrno SL_PG_TARGET_VRF_NO_VRFID =
    SLErrorStatus_SLErrno_SL_PG_TARGET_VRF_NO_VRFID;
  static constexpr SLErrno SL_PG_STR_KEY_INVALID =
    SLErrorStatus_SLErrno_SL_PG_STR_KEY_INVALID;
  static constexpr SLErrno SL_NEXT_HOP_START_OFFSET =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_START_OFFSET;
  static constexpr SLErrno SL_NEXT_HOP_INVALID_PREFIX_LEN =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_LEN;
  static constexpr SLErrno SL_NEXT_HOP_HOST_BITS_SET =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_HOST_BITS_SET;
  static constexpr SLErrno SL_NEXT_HOP_INVALID_PREFIX_MCAST =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_MCAST;
  static constexpr SLErrno SL_NEXT_HOP_INVALID_PREFIX =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX;
  static constexpr SLErrno SL_NEXT_HOP_INVALID_NEXT_HOP_ADDR =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_NEXT_HOP_ADDR;
  static constexpr SLErrno SL_NEXT_HOP_INVALID_PREFIX_SZ =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_INVALID_PREFIX_SZ;
  static constexpr SLErrno SL_NEXT_HOP_RIB_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_NEXT_HOP_RIB_ADD_FAILED;
  static constexpr SLErrno SL_ROUTE_REDIST_RIB_ADD_FAILED =
    SLErrorStatus_SLErrno_SL_ROUTE_REDIST_RIB_ADD_FAILED;
  static constexpr SLErrno SL_ACK_START_OFFSET =
    SLErrorStatus_SLErrno_SL_ACK_START_OFFSET;
  static constexpr SLErrno SL_ACK_PERMIT_NOT_SUPPORTED =
    SLErrorStatus_SLErrno_SL_ACK_PERMIT_NOT_SUPPORTED;
  static constexpr SLErrno SL_ACK_INVALID_TYPE =
    SLErrorStatus_SLErrno_SL_ACK_INVALID_TYPE;
  static constexpr SLErrno SL_POLICY_START_OFFSET =
    SLErrorStatus_SLErrno_SL_POLICY_START_OFFSET;
  static constexpr SLErrno SL_POLICY_ADD_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_ADD_ERR;
  static constexpr SLErrno SL_POLICY_EXISTS_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_EXISTS_ERR;
  static constexpr SLErrno SL_POLICY_DELETE_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_DELETE_ERR;
  static constexpr SLErrno SL_POLICY_RULE_ADD_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_ADD_ERR;
  static constexpr SLErrno SL_POLICY_RULE_EXISTS_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_EXISTS_ERR;
  static constexpr SLErrno SL_POLICY_RULE_DELETE_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_DELETE_ERR;
  static constexpr SLErrno SL_POLICY_APPLY_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_APPLY_ERR;
  static constexpr SLErrno SL_POLICY_UNAPPLY_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_UNAPPLY_ERR;
  static constexpr SLErrno SL_POLICY_TOO_MANY_POLICIES =
    SLErrorStatus_SLErrno_SL_POLICY_TOO_MANY_POLICIES;
  static constexpr SLErrno SL_POLICY_NAME_TOO_LONG =
    SLErrorStatus_SLErrno_SL_POLICY_NAME_TOO_LONG;
  static constexpr SLErrno SL_POLICY_RULE_NAME_TOO_LONG =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_NAME_TOO_LONG;
  static constexpr SLErrno SL_POLICY_DUPLICATE_PRIORITY_IN_RULE =
    SLErrorStatus_SLErrno_SL_POLICY_DUPLICATE_PRIORITY_IN_RULE;
  static constexpr SLErrno SL_POLICY_RULE_MOD_NOT_ALLOWED =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_MOD_NOT_ALLOWED;
  static constexpr SLErrno SL_POLICY_INVALID_RULE =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID_RULE;
  static constexpr SLErrno SL_POLICY_RULE_ADD_NO_RULES =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_ADD_NO_RULES;
  static constexpr SLErrno SL_POLICY_INVALID_MATCH_COUNT_IN_RULE =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID_MATCH_COUNT_IN_RULE;
  static constexpr SLErrno SL_POLICY_INVALID_ACTION_COUNT_IN_RULE =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID_ACTION_COUNT_IN_RULE;
  static constexpr SLErrno SL_POLICY_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_POLICY_NOT_FOUND;
  static constexpr SLErrno SL_POLICY_INVALID =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID;
  static constexpr SLErrno SL_POLICY_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_POLICY_NAME_MISSING;
  static constexpr SLErrno SL_POLICY_RULE_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_NAME_MISSING;
  static constexpr SLErrno SL_POLICY_PRIORITY_MISSING_IN_RULE =
    SLErrorStatus_SLErrno_SL_POLICY_PRIORITY_MISSING_IN_RULE;
  static constexpr SLErrno SL_POLICY_TYPE_INVALID =
    SLErrorStatus_SLErrno_SL_POLICY_TYPE_INVALID;
  static constexpr SLErrno SL_POLICY_INVALID_DIRECTION =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID_DIRECTION;
  static constexpr SLErrno SL_POLICY_INTF_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_POLICY_INTF_NAME_TOOLONG;
  static constexpr SLErrno SL_POLICY_INTF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_POLICY_INTF_NAME_MISSING;
  static constexpr SLErrno SL_POLICY_MAX_RULE_LIMIT_REACHED =
    SLErrorStatus_SLErrno_SL_POLICY_MAX_RULE_LIMIT_REACHED;
  static constexpr SLErrno SL_POLICY_VRF_NAME_TOO_LONG =
    SLErrorStatus_SLErrno_SL_POLICY_VRF_NAME_TOO_LONG;
  static constexpr SLErrno SL_POLICY_VRF_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_POLICY_VRF_NAME_MISSING;
  static constexpr SLErrno SL_POLICY_PATH_GRP_NAME_TOO_LONG =
    SLErrorStatus_SLErrno_SL_POLICY_PATH_GRP_NAME_TOO_LONG;
  static constexpr SLErrno SL_POLICY_PATH_GRP_NAME_MISSING =
    SLErrorStatus_SLErrno_SL_POLICY_PATH_GRP_NAME_MISSING;
  static constexpr SLErrno SL_POLICY_INVALID_DSCP_VALUE =
    SLErrorStatus_SLErrno_SL_POLICY_INVALID_DSCP_VALUE;
  static constexpr SLErrno SL_POLICY_PRIORITY_STR_TOO_LONG =
    SLErrorStatus_SLErrno_SL_POLICY_PRIORITY_STR_TOO_LONG;
  static constexpr SLErrno SL_POLICY_MAX_INTF_LIMIT_REACHED =
    SLErrorStatus_SLErrno_SL_POLICY_MAX_INTF_LIMIT_REACHED;
  static constexpr SLErrno SL_POLICY_RULE_DELETE_NO_RULES =
    SLErrorStatus_SLErrno_SL_POLICY_RULE_DELETE_NO_RULES;
  static constexpr SLErrno SL_POLICY_APPLY_NO_INTFS =
    SLErrorStatus_SLErrno_SL_POLICY_APPLY_NO_INTFS;
  static constexpr SLErrno SL_POLICY_UNAPPLY_NO_INTFS =
    SLErrorStatus_SLErrno_SL_POLICY_UNAPPLY_NO_INTFS;
  static constexpr SLErrno SL_POLICY_REPLACE_ERR =
    SLErrorStatus_SLErrno_SL_POLICY_REPLACE_ERR;
  static constexpr SLErrno SL_BGPLS_TOPO_START_OFFSET =
    SLErrorStatus_SLErrno_SL_BGPLS_TOPO_START_OFFSET;
  static constexpr SLErrno SL_BGPLS_SERVER_NOT_AVAILABLE =
    SLErrorStatus_SLErrno_SL_BGPLS_SERVER_NOT_AVAILABLE;
  static constexpr SLErrno SL_BGPLS_MAX_MATCH_FILTER_EXCEEDED =
    SLErrorStatus_SLErrno_SL_BGPLS_MAX_MATCH_FILTER_EXCEEDED;
  static constexpr SLErrno SL_BGPLS_MAX_STREAMS_EXCEEDED =
    SLErrorStatus_SLErrno_SL_BGPLS_MAX_STREAMS_EXCEEDED;
  static constexpr SLErrno SL_BGP_START_OFFSET =
    SLErrorStatus_SLErrno_SL_BGP_START_OFFSET;
  static constexpr SLErrno SL_BGP_INST_NAME_TOOLONG =
    SLErrorStatus_SLErrno_SL_BGP_INST_NAME_TOOLONG;
  static constexpr SLErrno SL_BGP_INST_NAME_EMPTY =
    SLErrorStatus_SLErrno_SL_BGP_INST_NAME_EMPTY;
  static constexpr SLErrno SL_BGP_INST_NOT_INITIALIZED =
    SLErrorStatus_SLErrno_SL_BGP_INST_NOT_INITIALIZED;
  static constexpr SLErrno SL_BGP_INVALID_OBJ_TYPE =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_OBJ_TYPE;
  static constexpr SLErrno SL_BGP_VRF_NAME_TOOLONG_V4 =
    SLErrorStatus_SLErrno_SL_BGP_VRF_NAME_TOOLONG_V4;
  static constexpr SLErrno SL_BGP_VRF_NAME_TOOLONG_V6 =
    SLErrorStatus_SLErrno_SL_BGP_VRF_NAME_TOOLONG_V6;
  static constexpr SLErrno SL_BGP_UNSUPPORTED_VRF_NAME =
    SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_VRF_NAME;
  static constexpr SLErrno SL_BGP_INVALID_NBR_ADDR_MCAST =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR_MCAST;
  static constexpr SLErrno SL_BGP_INVALID_NBR_ADDR_EXP =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR_EXP;
  static constexpr SLErrno SL_BGP_INVALID_NBR_ADDR =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_ADDR;
  static constexpr SLErrno SL_BGP_INVALID_NBR_V6_SZ =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_V6_SZ;
  static constexpr SLErrno SL_BGP_INVALID_NBR_KEY =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBR_KEY;
  static constexpr SLErrno SL_BGP_INVALID_MPATH_ADDR_MCAST =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR_MCAST;
  static constexpr SLErrno SL_BGP_INVALID_MPATH_ADDR_EXP =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR_EXP;
  static constexpr SLErrno SL_BGP_INVALID_MPATH_ADDR =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_ADDR;
  static constexpr SLErrno SL_BGP_INVALID_MPATH_V6_SZ =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_MPATH_V6_SZ;
  static constexpr SLErrno SL_BGP_INVALID_NBRSAFI_LIST =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_NBRSAFI_LIST;
  static constexpr SLErrno SL_BGP_UNSUPPORTED_BGP_AFI_SAFI =
    SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_BGP_AFI_SAFI;
  static constexpr SLErrno SL_BGP_UNSUPPORTED_AFI =
    SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_AFI;
  static constexpr SLErrno SL_BGP_UNSUPPORTED_SAFI =
    SLErrorStatus_SLErrno_SL_BGP_UNSUPPORTED_SAFI;
  static constexpr SLErrno SL_BGP_EMPTY_OBJECTS =
    SLErrorStatus_SLErrno_SL_BGP_EMPTY_OBJECTS;
  static constexpr SLErrno SL_BGP_EMPTY_OBJECT_LIST =
    SLErrorStatus_SLErrno_SL_BGP_EMPTY_OBJECT_LIST;
  static constexpr SLErrno SL_BGP_UPDATE_BW_GRP_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_UPDATE_BW_GRP_FAILED;
  static constexpr SLErrno SL_BGP_UPDATE_MPATH_ADDR_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_UPDATE_MPATH_ADDR_FAILED;
  static constexpr SLErrno SL_BGP_DELETE_BW_GRP_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_DELETE_BW_GRP_FAILED;
  static constexpr SLErrno SL_BGP_DELETE_NBR_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_DELETE_NBR_FAILED;
  static constexpr SLErrno SL_BGP_DELETE_AFI_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_DELETE_AFI_FAILED;
  static constexpr SLErrno SL_BGP_DELETE_MPATH_ADDR_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_DELETE_MPATH_ADDR_FAILED;
  static constexpr SLErrno SL_BGP_DELETE_FAILED =
    SLErrorStatus_SLErrno_SL_BGP_DELETE_FAILED;
  static constexpr SLErrno SL_BGP_BW_GRP_NUM_OUT_OF_RANGE =
    SLErrorStatus_SLErrno_SL_BGP_BW_GRP_NUM_OUT_OF_RANGE;
  static constexpr SLErrno SL_BGP_IN_BW_GRP_COUNT_EXCEEDED =
    SLErrorStatus_SLErrno_SL_BGP_IN_BW_GRP_COUNT_EXCEEDED;
  static constexpr SLErrno SL_BGP_OUT_BW_GRP_COUNT_EXCEEDED =
    SLErrorStatus_SLErrno_SL_BGP_OUT_BW_GRP_COUNT_EXCEEDED;
  static constexpr SLErrno SL_BGP_INVALID_IN_BWGRP_LIST =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_IN_BWGRP_LIST;
  static constexpr SLErrno SL_BGP_INVALID_OUT_BWGRP_LIST =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_OUT_BWGRP_LIST;
  static constexpr SLErrno SL_BGP_LINK_BW_OUT_OF_RANGE =
    SLErrorStatus_SLErrno_SL_BGP_LINK_BW_OUT_OF_RANGE;
  static constexpr SLErrno SL_BGP_NBR_IDX_OUT_OF_RANGE =
    SLErrorStatus_SLErrno_SL_BGP_NBR_IDX_OUT_OF_RANGE;
  static constexpr SLErrno SL_BGP_INVALID_BW_TYPE =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_BW_TYPE;
  static constexpr SLErrno SL_BGP_BW_GRP_LIST_NULL =
    SLErrorStatus_SLErrno_SL_BGP_BW_GRP_LIST_NULL;
  static constexpr SLErrno SL_BGP_NBRSAFI_LIST_NULL =
    SLErrorStatus_SLErrno_SL_BGP_NBRSAFI_LIST_NULL;
  static constexpr SLErrno SL_BGP_INST_NOT_CONFIG_IN_SLAPI =
    SLErrorStatus_SLErrno_SL_BGP_INST_NOT_CONFIG_IN_SLAPI;
  static constexpr SLErrno SL_BGP_OBJ_LIST_IDX_OUT_OF_RANGE =
    SLErrorStatus_SLErrno_SL_BGP_OBJ_LIST_IDX_OUT_OF_RANGE;
  static constexpr SLErrno SL_BGP_ASN_OUT_OF_RANGE =
    SLErrorStatus_SLErrno_SL_BGP_ASN_OUT_OF_RANGE;
  static constexpr SLErrno SL_BGP_INVALID_BW_UNIT =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_BW_UNIT;
  static constexpr SLErrno SL_BGP_OBJECT_TYPE_REQUIRED =
    SLErrorStatus_SLErrno_SL_BGP_OBJECT_TYPE_REQUIRED;
  static constexpr SLErrno SL_BGP_OBJECT_KEY_REQUIRED =
    SLErrorStatus_SLErrno_SL_BGP_OBJECT_KEY_REQUIRED;
  static constexpr SLErrno SL_BGP_INVALID_OBJECT_TYPE =
    SLErrorStatus_SLErrno_SL_BGP_INVALID_OBJECT_TYPE;
  static constexpr SLErrno SL_BGP_GET_EXACT_MATCH_NOT_FOUND =
    SLErrorStatus_SLErrno_SL_BGP_GET_EXACT_MATCH_NOT_FOUND;
  static constexpr SLErrno SL_BGP_MAX_NEIGHBORS_IN_SYSDB =
    SLErrorStatus_SLErrno_SL_BGP_MAX_NEIGHBORS_IN_SYSDB;
  static constexpr SLErrno SL_BGP_MAX_OBJECTS_IN_PAYLOAD =
    SLErrorStatus_SLErrno_SL_BGP_MAX_OBJECTS_IN_PAYLOAD;
  static constexpr SLErrno SL_BGP_INTERNAL_ERR_1 =
    SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_1;
  static constexpr SLErrno SL_BGP_INTERNAL_ERR_2 =
    SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_2;
  static constexpr SLErrno SL_BGP_INTERNAL_ERR_3 =
    SLErrorStatus_SLErrno_SL_BGP_INTERNAL_ERR_3;
  static constexpr SLErrno SL_SRTE_POLICY_START_OFFSET =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_START_OFFSET;
  static constexpr SLErrno SL_SRTE_POLICY_REQUEST_INVALID =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_REQUEST_INVALID;
  static constexpr SLErrno SL_SRTE_POLICY_POLICY_KEY_INVALID =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_POLICY_KEY_INVALID;
  static constexpr SLErrno SL_SRTE_POLICY_POLICY_ATTR_INVALID =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_POLICY_ATTR_INVALID;
  static constexpr SLErrno SL_SRTE_POLICY_CP_KEY_INVALID =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_CP_KEY_INVALID;
  static constexpr SLErrno SL_SRTE_POLICY_CP_ATTR_INVALID =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_CP_ATTR_INVALID;
  static constexpr SLErrno SL_SRTE_POLICY_CLIENT_MISMATCH =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_CLIENT_MISMATCH;
  static constexpr SLErrno SL_SRTE_POLICY_SERVICE_NOT_UP =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_SERVICE_NOT_UP;
  static constexpr SLErrno SL_SRTE_POLICY_EXCEED_MSG_SIZE =
    SLErrorStatus_SLErrno_SL_SRTE_POLICY_EXCEED_MSG_SIZE;
  static constexpr SLErrno SL_INTERNAL_START_OFFSET =
    SLErrorStatus_SLErrno_SL_INTERNAL_START_OFFSET;
  static inline bool SLErrno_IsValid(int value) {
    return SLErrorStatus_SLErrno_IsValid(value);
  }
  static constexpr SLErrno SLErrno_MIN =
    SLErrorStatus_SLErrno_SLErrno_MIN;
  static constexpr SLErrno SLErrno_MAX =
    SLErrorStatus_SLErrno_SLErrno_MAX;
  static constexpr int SLErrno_ARRAYSIZE =
    SLErrorStatus_SLErrno_SLErrno_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SLErrno_descriptor() {
    return SLErrorStatus_SLErrno_descriptor();
  }
  template<typename T>
  static inline const std::string& SLErrno_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SLErrno>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SLErrno_Name.");
    return SLErrorStatus_SLErrno_Name(enum_t_value);
  }
  static inline bool SLErrno_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SLErrno* value) {
    return SLErrorStatus_SLErrno_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .service_layer.SLErrorStatus.SLErrno Status = 1;
  void clear_status();
  ::service_layer::SLErrorStatus_SLErrno status() const;
  void set_status(::service_layer::SLErrorStatus_SLErrno value);
  private:
  ::service_layer::SLErrorStatus_SLErrno _internal_status() const;
  void _internal_set_status(::service_layer::SLErrorStatus_SLErrno value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLErrorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLInterface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterface) */ {
 public:
  inline SLInterface() : SLInterface(nullptr) {}
  ~SLInterface() override;
  explicit constexpr SLInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterface(const SLInterface& from);
  SLInterface(SLInterface&& from) noexcept
    : SLInterface() {
    *this = ::std::move(from);
  }

  inline SLInterface& operator=(const SLInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterface& operator=(SLInterface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterface& default_instance() {
    return *internal_default_instance();
  }
  enum InterfaceCase {
    kName = 1,
    kHandle = 2,
    INTERFACE_NOT_SET = 0,
  };

  static inline const SLInterface* internal_default_instance() {
    return reinterpret_cast<const SLInterface*>(
               &_SLInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLInterface& a, SLInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterface";
  }
  protected:
  explicit SLInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // string Name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 Handle = 2;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  void clear_Interface();
  InterfaceCase Interface_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLInterface)
 private:
  class _Internal;
  void set_has_name();
  void set_has_handle();

  inline bool has_Interface() const;
  inline void clear_has_Interface();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InterfaceUnion {
    constexpr InterfaceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t handle_;
  } Interface_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLIpAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLIpAddress) */ {
 public:
  inline SLIpAddress() : SLIpAddress(nullptr) {}
  ~SLIpAddress() override;
  explicit constexpr SLIpAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLIpAddress(const SLIpAddress& from);
  SLIpAddress(SLIpAddress&& from) noexcept
    : SLIpAddress() {
    *this = ::std::move(from);
  }

  inline SLIpAddress& operator=(const SLIpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLIpAddress& operator=(SLIpAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLIpAddress& default_instance() {
    return *internal_default_instance();
  }
  enum AddressCase {
    kV4Address = 1,
    kV6Address = 2,
    ADDRESS_NOT_SET = 0,
  };

  static inline const SLIpAddress* internal_default_instance() {
    return reinterpret_cast<const SLIpAddress*>(
               &_SLIpAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLIpAddress& a, SLIpAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(SLIpAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLIpAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLIpAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLIpAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLIpAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLIpAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLIpAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLIpAddress";
  }
  protected:
  explicit SLIpAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV4AddressFieldNumber = 1,
    kV6AddressFieldNumber = 2,
  };
  // uint32 V4Address = 1;
  bool has_v4address() const;
  private:
  bool _internal_has_v4address() const;
  public:
  void clear_v4address();
  uint32_t v4address() const;
  void set_v4address(uint32_t value);
  private:
  uint32_t _internal_v4address() const;
  void _internal_set_v4address(uint32_t value);
  public:

  // bytes V6Address = 2;
  bool has_v6address() const;
  private:
  bool _internal_has_v6address() const;
  public:
  void clear_v6address();
  const std::string& v6address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v6address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v6address();
  PROTOBUF_NODISCARD std::string* release_v6address();
  void set_allocated_v6address(std::string* v6address);
  private:
  const std::string& _internal_v6address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v6address(const std::string& value);
  std::string* _internal_mutable_v6address();
  public:

  void clear_Address();
  AddressCase Address_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLIpAddress)
 private:
  class _Internal;
  void set_has_v4address();
  void set_has_v6address();

  inline bool has_Address() const;
  inline void clear_has_Address();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union AddressUnion {
    constexpr AddressUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t v4address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v6address_;
  } Address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLIpv6Address final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLIpv6Address) */ {
 public:
  inline SLIpv6Address() : SLIpv6Address(nullptr) {}
  ~SLIpv6Address() override;
  explicit constexpr SLIpv6Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLIpv6Address(const SLIpv6Address& from);
  SLIpv6Address(SLIpv6Address&& from) noexcept
    : SLIpv6Address() {
    *this = ::std::move(from);
  }

  inline SLIpv6Address& operator=(const SLIpv6Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLIpv6Address& operator=(SLIpv6Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLIpv6Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLIpv6Address* internal_default_instance() {
    return reinterpret_cast<const SLIpv6Address*>(
               &_SLIpv6Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLIpv6Address& a, SLIpv6Address& b) {
    a.Swap(&b);
  }
  inline void Swap(SLIpv6Address* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLIpv6Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLIpv6Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLIpv6Address>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLIpv6Address& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLIpv6Address& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLIpv6Address* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLIpv6Address";
  }
  protected:
  explicit SLIpv6Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLIpv6Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLAutonomousSystemNumber final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLAutonomousSystemNumber) */ {
 public:
  inline SLAutonomousSystemNumber() : SLAutonomousSystemNumber(nullptr) {}
  ~SLAutonomousSystemNumber() override;
  explicit constexpr SLAutonomousSystemNumber(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLAutonomousSystemNumber(const SLAutonomousSystemNumber& from);
  SLAutonomousSystemNumber(SLAutonomousSystemNumber&& from) noexcept
    : SLAutonomousSystemNumber() {
    *this = ::std::move(from);
  }

  inline SLAutonomousSystemNumber& operator=(const SLAutonomousSystemNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLAutonomousSystemNumber& operator=(SLAutonomousSystemNumber&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLAutonomousSystemNumber& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLAutonomousSystemNumber* internal_default_instance() {
    return reinterpret_cast<const SLAutonomousSystemNumber*>(
               &_SLAutonomousSystemNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLAutonomousSystemNumber& a, SLAutonomousSystemNumber& b) {
    a.Swap(&b);
  }
  inline void Swap(SLAutonomousSystemNumber* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLAutonomousSystemNumber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLAutonomousSystemNumber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLAutonomousSystemNumber>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLAutonomousSystemNumber& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLAutonomousSystemNumber& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLAutonomousSystemNumber* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLAutonomousSystemNumber";
  }
  protected:
  explicit SLAutonomousSystemNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsnFieldNumber = 1,
  };
  // uint32 asn = 1;
  void clear_asn();
  uint32_t asn() const;
  void set_asn(uint32_t value);
  private:
  uint32_t _internal_asn() const;
  void _internal_set_asn(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLAutonomousSystemNumber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t asn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLObjectId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLObjectId) */ {
 public:
  inline SLObjectId() : SLObjectId(nullptr) {}
  ~SLObjectId() override;
  explicit constexpr SLObjectId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLObjectId(const SLObjectId& from);
  SLObjectId(SLObjectId&& from) noexcept
    : SLObjectId() {
    *this = ::std::move(from);
  }

  inline SLObjectId& operator=(const SLObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLObjectId& operator=(SLObjectId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLObjectId& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kName = 1,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLObjectId* internal_default_instance() {
    return reinterpret_cast<const SLObjectId*>(
               &_SLObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLObjectId& a, SLObjectId& b) {
    a.Swap(&b);
  }
  inline void Swap(SLObjectId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLObjectId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLObjectId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLObjectId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLObjectId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLObjectId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLObjectId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLObjectId";
  }
  protected:
  explicit SLObjectId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string Name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLObjectId)
 private:
  class _Internal;
  void set_has_name();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SLPathGroupRefKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPathGroupRefKey) */ {
 public:
  inline SLPathGroupRefKey() : SLPathGroupRefKey(nullptr) {}
  ~SLPathGroupRefKey() override;
  explicit constexpr SLPathGroupRefKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPathGroupRefKey(const SLPathGroupRefKey& from);
  SLPathGroupRefKey(SLPathGroupRefKey&& from) noexcept
    : SLPathGroupRefKey() {
    *this = ::std::move(from);
  }

  inline SLPathGroupRefKey& operator=(const SLPathGroupRefKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPathGroupRefKey& operator=(SLPathGroupRefKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPathGroupRefKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPathGroupRefKey* internal_default_instance() {
    return reinterpret_cast<const SLPathGroupRefKey*>(
               &_SLPathGroupRefKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLPathGroupRefKey& a, SLPathGroupRefKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPathGroupRefKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPathGroupRefKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPathGroupRefKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPathGroupRefKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPathGroupRefKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPathGroupRefKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPathGroupRefKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPathGroupRefKey";
  }
  protected:
  explicit SLPathGroupRefKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kPathGroupIdFieldNumber = 2,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLObjectId PathGroupId = 2;
  bool has_pathgroupid() const;
  private:
  bool _internal_has_pathgroupid() const;
  public:
  void clear_pathgroupid();
  const ::service_layer::SLObjectId& pathgroupid() const;
  PROTOBUF_NODISCARD ::service_layer::SLObjectId* release_pathgroupid();
  ::service_layer::SLObjectId* mutable_pathgroupid();
  void set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid);
  private:
  const ::service_layer::SLObjectId& _internal_pathgroupid() const;
  ::service_layer::SLObjectId* _internal_mutable_pathgroupid();
  public:
  void unsafe_arena_set_allocated_pathgroupid(
      ::service_layer::SLObjectId* pathgroupid);
  ::service_layer::SLObjectId* unsafe_arena_release_pathgroupid();

  // @@protoc_insertion_point(class_scope:service_layer.SLPathGroupRefKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLObjectId* pathgroupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fcommon_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLErrorStatus

// .service_layer.SLErrorStatus.SLErrno Status = 1;
inline void SLErrorStatus::clear_status() {
  status_ = 0;
}
inline ::service_layer::SLErrorStatus_SLErrno SLErrorStatus::_internal_status() const {
  return static_cast< ::service_layer::SLErrorStatus_SLErrno >(status_);
}
inline ::service_layer::SLErrorStatus_SLErrno SLErrorStatus::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLErrorStatus.Status)
  return _internal_status();
}
inline void SLErrorStatus::_internal_set_status(::service_layer::SLErrorStatus_SLErrno value) {
  
  status_ = value;
}
inline void SLErrorStatus::set_status(::service_layer::SLErrorStatus_SLErrno value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:service_layer.SLErrorStatus.Status)
}

// -------------------------------------------------------------------

// SLInterface

// string Name = 1;
inline bool SLInterface::_internal_has_name() const {
  return Interface_case() == kName;
}
inline bool SLInterface::has_name() const {
  return _internal_has_name();
}
inline void SLInterface::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void SLInterface::clear_name() {
  if (_internal_has_name()) {
    Interface_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_Interface();
  }
}
inline const std::string& SLInterface::name() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterface.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void SLInterface::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Name)
}
inline std::string* SLInterface::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterface.Name)
  return _s;
}
inline const std::string& SLInterface::_internal_name() const {
  if (_internal_has_name()) {
    return Interface_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLInterface::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Interface_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLInterface::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_Interface();
    set_has_name();
    Interface_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Interface_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLInterface::release_name() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterface.Name)
  if (_internal_has_name()) {
    clear_has_Interface();
    return Interface_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SLInterface::set_allocated_name(std::string* name) {
  if (has_Interface()) {
    clear_Interface();
  }
  if (name != nullptr) {
    set_has_name();
    Interface_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterface.Name)
}

// uint32 Handle = 2;
inline bool SLInterface::_internal_has_handle() const {
  return Interface_case() == kHandle;
}
inline bool SLInterface::has_handle() const {
  return _internal_has_handle();
}
inline void SLInterface::set_has_handle() {
  _oneof_case_[0] = kHandle;
}
inline void SLInterface::clear_handle() {
  if (_internal_has_handle()) {
    Interface_.handle_ = 0u;
    clear_has_Interface();
  }
}
inline uint32_t SLInterface::_internal_handle() const {
  if (_internal_has_handle()) {
    return Interface_.handle_;
  }
  return 0u;
}
inline void SLInterface::_internal_set_handle(uint32_t value) {
  if (!_internal_has_handle()) {
    clear_Interface();
    set_has_handle();
  }
  Interface_.handle_ = value;
}
inline uint32_t SLInterface::handle() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterface.Handle)
  return _internal_handle();
}
inline void SLInterface::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterface.Handle)
}

inline bool SLInterface::has_Interface() const {
  return Interface_case() != INTERFACE_NOT_SET;
}
inline void SLInterface::clear_has_Interface() {
  _oneof_case_[0] = INTERFACE_NOT_SET;
}
inline SLInterface::InterfaceCase SLInterface::Interface_case() const {
  return SLInterface::InterfaceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLIpAddress

// uint32 V4Address = 1;
inline bool SLIpAddress::_internal_has_v4address() const {
  return Address_case() == kV4Address;
}
inline bool SLIpAddress::has_v4address() const {
  return _internal_has_v4address();
}
inline void SLIpAddress::set_has_v4address() {
  _oneof_case_[0] = kV4Address;
}
inline void SLIpAddress::clear_v4address() {
  if (_internal_has_v4address()) {
    Address_.v4address_ = 0u;
    clear_has_Address();
  }
}
inline uint32_t SLIpAddress::_internal_v4address() const {
  if (_internal_has_v4address()) {
    return Address_.v4address_;
  }
  return 0u;
}
inline void SLIpAddress::_internal_set_v4address(uint32_t value) {
  if (!_internal_has_v4address()) {
    clear_Address();
    set_has_v4address();
  }
  Address_.v4address_ = value;
}
inline uint32_t SLIpAddress::v4address() const {
  // @@protoc_insertion_point(field_get:service_layer.SLIpAddress.V4Address)
  return _internal_v4address();
}
inline void SLIpAddress::set_v4address(uint32_t value) {
  _internal_set_v4address(value);
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V4Address)
}

// bytes V6Address = 2;
inline bool SLIpAddress::_internal_has_v6address() const {
  return Address_case() == kV6Address;
}
inline bool SLIpAddress::has_v6address() const {
  return _internal_has_v6address();
}
inline void SLIpAddress::set_has_v6address() {
  _oneof_case_[0] = kV6Address;
}
inline void SLIpAddress::clear_v6address() {
  if (_internal_has_v6address()) {
    Address_.v6address_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_Address();
  }
}
inline const std::string& SLIpAddress::v6address() const {
  // @@protoc_insertion_point(field_get:service_layer.SLIpAddress.V6Address)
  return _internal_v6address();
}
template <typename ArgT0, typename... ArgT>
inline void SLIpAddress::set_v6address(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLIpAddress.V6Address)
}
inline std::string* SLIpAddress::mutable_v6address() {
  std::string* _s = _internal_mutable_v6address();
  // @@protoc_insertion_point(field_mutable:service_layer.SLIpAddress.V6Address)
  return _s;
}
inline const std::string& SLIpAddress::_internal_v6address() const {
  if (_internal_has_v6address()) {
    return Address_.v6address_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLIpAddress::_internal_set_v6address(const std::string& value) {
  if (!_internal_has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Address_.v6address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLIpAddress::_internal_mutable_v6address() {
  if (!_internal_has_v6address()) {
    clear_Address();
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Address_.v6address_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLIpAddress::release_v6address() {
  // @@protoc_insertion_point(field_release:service_layer.SLIpAddress.V6Address)
  if (_internal_has_v6address()) {
    clear_has_Address();
    return Address_.v6address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SLIpAddress::set_allocated_v6address(std::string* v6address) {
  if (has_Address()) {
    clear_Address();
  }
  if (v6address != nullptr) {
    set_has_v6address();
    Address_.v6address_.UnsafeSetDefault(v6address);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(v6address);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLIpAddress.V6Address)
}

inline bool SLIpAddress::has_Address() const {
  return Address_case() != ADDRESS_NOT_SET;
}
inline void SLIpAddress::clear_has_Address() {
  _oneof_case_[0] = ADDRESS_NOT_SET;
}
inline SLIpAddress::AddressCase SLIpAddress::Address_case() const {
  return SLIpAddress::AddressCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLIpv6Address

// bytes address = 1;
inline void SLIpv6Address::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& SLIpv6Address::address() const {
  // @@protoc_insertion_point(field_get:service_layer.SLIpv6Address.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLIpv6Address::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLIpv6Address.address)
}
inline std::string* SLIpv6Address::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:service_layer.SLIpv6Address.address)
  return _s;
}
inline const std::string& SLIpv6Address::_internal_address() const {
  return address_.Get();
}
inline void SLIpv6Address::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLIpv6Address::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLIpv6Address::release_address() {
  // @@protoc_insertion_point(field_release:service_layer.SLIpv6Address.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLIpv6Address::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLIpv6Address.address)
}

// -------------------------------------------------------------------

// SLAutonomousSystemNumber

// uint32 asn = 1;
inline void SLAutonomousSystemNumber::clear_asn() {
  asn_ = 0u;
}
inline uint32_t SLAutonomousSystemNumber::_internal_asn() const {
  return asn_;
}
inline uint32_t SLAutonomousSystemNumber::asn() const {
  // @@protoc_insertion_point(field_get:service_layer.SLAutonomousSystemNumber.asn)
  return _internal_asn();
}
inline void SLAutonomousSystemNumber::_internal_set_asn(uint32_t value) {
  
  asn_ = value;
}
inline void SLAutonomousSystemNumber::set_asn(uint32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:service_layer.SLAutonomousSystemNumber.asn)
}

// -------------------------------------------------------------------

// SLObjectId

// string Name = 1;
inline bool SLObjectId::_internal_has_name() const {
  return entry_case() == kName;
}
inline bool SLObjectId::has_name() const {
  return _internal_has_name();
}
inline void SLObjectId::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void SLObjectId::clear_name() {
  if (_internal_has_name()) {
    entry_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_entry();
  }
}
inline const std::string& SLObjectId::name() const {
  // @@protoc_insertion_point(field_get:service_layer.SLObjectId.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void SLObjectId::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_entry();
    set_has_name();
    entry_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  entry_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLObjectId.Name)
}
inline std::string* SLObjectId::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service_layer.SLObjectId.Name)
  return _s;
}
inline const std::string& SLObjectId::_internal_name() const {
  if (_internal_has_name()) {
    return entry_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLObjectId::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_entry();
    set_has_name();
    entry_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  entry_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLObjectId::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_entry();
    set_has_name();
    entry_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return entry_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLObjectId::release_name() {
  // @@protoc_insertion_point(field_release:service_layer.SLObjectId.Name)
  if (_internal_has_name()) {
    clear_has_entry();
    return entry_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SLObjectId::set_allocated_name(std::string* name) {
  if (has_entry()) {
    clear_entry();
  }
  if (name != nullptr) {
    set_has_name();
    entry_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLObjectId.Name)
}

inline bool SLObjectId::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLObjectId::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLObjectId::EntryCase SLObjectId::entry_case() const {
  return SLObjectId::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLPathGroupRefKey

// string VrfName = 1;
inline void SLPathGroupRefKey::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLPathGroupRefKey::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroupRefKey.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLPathGroupRefKey::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLPathGroupRefKey.VrfName)
}
inline std::string* SLPathGroupRefKey::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroupRefKey.VrfName)
  return _s;
}
inline const std::string& SLPathGroupRefKey::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLPathGroupRefKey::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLPathGroupRefKey::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLPathGroupRefKey::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroupRefKey.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLPathGroupRefKey::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroupRefKey.VrfName)
}

// .service_layer.SLObjectId PathGroupId = 2;
inline bool SLPathGroupRefKey::_internal_has_pathgroupid() const {
  return this != internal_default_instance() && pathgroupid_ != nullptr;
}
inline bool SLPathGroupRefKey::has_pathgroupid() const {
  return _internal_has_pathgroupid();
}
inline void SLPathGroupRefKey::clear_pathgroupid() {
  if (GetArenaForAllocation() == nullptr && pathgroupid_ != nullptr) {
    delete pathgroupid_;
  }
  pathgroupid_ = nullptr;
}
inline const ::service_layer::SLObjectId& SLPathGroupRefKey::_internal_pathgroupid() const {
  const ::service_layer::SLObjectId* p = pathgroupid_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLObjectId&>(
      ::service_layer::_SLObjectId_default_instance_);
}
inline const ::service_layer::SLObjectId& SLPathGroupRefKey::pathgroupid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPathGroupRefKey.PathGroupId)
  return _internal_pathgroupid();
}
inline void SLPathGroupRefKey::unsafe_arena_set_allocated_pathgroupid(
    ::service_layer::SLObjectId* pathgroupid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroupid_);
  }
  pathgroupid_ = pathgroupid;
  if (pathgroupid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPathGroupRefKey.PathGroupId)
}
inline ::service_layer::SLObjectId* SLPathGroupRefKey::release_pathgroupid() {
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroupRefKey::unsafe_arena_release_pathgroupid() {
  // @@protoc_insertion_point(field_release:service_layer.SLPathGroupRefKey.PathGroupId)
  
  ::service_layer::SLObjectId* temp = pathgroupid_;
  pathgroupid_ = nullptr;
  return temp;
}
inline ::service_layer::SLObjectId* SLPathGroupRefKey::_internal_mutable_pathgroupid() {
  
  if (pathgroupid_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLObjectId>(GetArenaForAllocation());
    pathgroupid_ = p;
  }
  return pathgroupid_;
}
inline ::service_layer::SLObjectId* SLPathGroupRefKey::mutable_pathgroupid() {
  ::service_layer::SLObjectId* _msg = _internal_mutable_pathgroupid();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPathGroupRefKey.PathGroupId)
  return _msg;
}
inline void SLPathGroupRefKey::set_allocated_pathgroupid(::service_layer::SLObjectId* pathgroupid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pathgroupid_;
  }
  if (pathgroupid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLObjectId>::GetOwningArena(pathgroupid);
    if (message_arena != submessage_arena) {
      pathgroupid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathgroupid, submessage_arena);
    }
    
  } else {
    
  }
  pathgroupid_ = pathgroupid;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPathGroupRefKey.PathGroupId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service_layer::SLErrorStatus_SLErrno> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLErrorStatus_SLErrno>() {
  return ::service_layer::SLErrorStatus_SLErrno_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRegOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRegOp>() {
  return ::service_layer::SLRegOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLObjectOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLObjectOp>() {
  return ::service_layer::SLObjectOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLNotifOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLNotifOp>() {
  return ::service_layer::SLNotifOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLUpdatePriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLUpdatePriority>() {
  return ::service_layer::SLUpdatePriority_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLEncapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLEncapType>() {
  return ::service_layer::SLEncapType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLTableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLTableType>() {
  return ::service_layer::SLTableType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRspACKType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRspACKType>() {
  return ::service_layer::SLRspACKType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLAFFibStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLAFFibStatus>() {
  return ::service_layer::SLAFFibStatus_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRspACKPermit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRspACKPermit>() {
  return ::service_layer::SLRspACKPermit_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRspAckCadence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRspAckCadence>() {
  return ::service_layer::SLRspAckCadence_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5fcommon_5ftypes_2eproto
