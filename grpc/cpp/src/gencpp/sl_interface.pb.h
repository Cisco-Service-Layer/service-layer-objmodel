// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5finterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5finterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5finterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5finterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5finterface_2eproto;
namespace service_layer {
class SLInterfaceInfoMsg;
struct SLInterfaceInfoMsgDefaultTypeInternal;
extern SLInterfaceInfoMsgDefaultTypeInternal _SLInterfaceInfoMsg_default_instance_;
class SLInterfaceInfoMsgBw;
struct SLInterfaceInfoMsgBwDefaultTypeInternal;
extern SLInterfaceInfoMsgBwDefaultTypeInternal _SLInterfaceInfoMsgBw_default_instance_;
class SLInterfaceNotif;
struct SLInterfaceNotifDefaultTypeInternal;
extern SLInterfaceNotifDefaultTypeInternal _SLInterfaceNotif_default_instance_;
class SLInterfaceNotifMsg;
struct SLInterfaceNotifMsgDefaultTypeInternal;
extern SLInterfaceNotifMsgDefaultTypeInternal _SLInterfaceNotifMsg_default_instance_;
class SLInterfaceNotifMsgEntry;
struct SLInterfaceNotifMsgEntryDefaultTypeInternal;
extern SLInterfaceNotifMsgEntryDefaultTypeInternal _SLInterfaceNotifMsgEntry_default_instance_;
class SLInterfaceNotifMsgErr;
struct SLInterfaceNotifMsgErrDefaultTypeInternal;
extern SLInterfaceNotifMsgErrDefaultTypeInternal _SLInterfaceNotifMsgErr_default_instance_;
class SLInterfaceNotifMsgRes;
struct SLInterfaceNotifMsgResDefaultTypeInternal;
extern SLInterfaceNotifMsgResDefaultTypeInternal _SLInterfaceNotifMsgRes_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLInterfaceInfoMsg* Arena::CreateMaybeMessage<::service_layer::SLInterfaceInfoMsg>(Arena*);
template<> ::service_layer::SLInterfaceInfoMsgBw* Arena::CreateMaybeMessage<::service_layer::SLInterfaceInfoMsgBw>(Arena*);
template<> ::service_layer::SLInterfaceNotif* Arena::CreateMaybeMessage<::service_layer::SLInterfaceNotif>(Arena*);
template<> ::service_layer::SLInterfaceNotifMsg* Arena::CreateMaybeMessage<::service_layer::SLInterfaceNotifMsg>(Arena*);
template<> ::service_layer::SLInterfaceNotifMsgEntry* Arena::CreateMaybeMessage<::service_layer::SLInterfaceNotifMsgEntry>(Arena*);
template<> ::service_layer::SLInterfaceNotifMsgErr* Arena::CreateMaybeMessage<::service_layer::SLInterfaceNotifMsgErr>(Arena*);
template<> ::service_layer::SLInterfaceNotifMsgRes* Arena::CreateMaybeMessage<::service_layer::SLInterfaceNotifMsgRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

enum SLInterfaceState : int {
  SL_IF_STATE_UNKNOWN = 0,
  SL_IF_STATE_CREATED = 1,
  SL_IF_STATE_DOWN = 2,
  SL_IF_STATE_UP = 3,
  SL_IF_STATE_DELETED = 4,
  SL_IF_STATE_BW_CHANGED = 5,
  SL_IF_STATE_L2_UP = 6,
  SL_IF_STATE_L2_DOWN = 7,
  SLInterfaceState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLInterfaceState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLInterfaceState_IsValid(int value);
constexpr SLInterfaceState SLInterfaceState_MIN = SL_IF_STATE_UNKNOWN;
constexpr SLInterfaceState SLInterfaceState_MAX = SL_IF_STATE_L2_DOWN;
constexpr int SLInterfaceState_ARRAYSIZE = SLInterfaceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLInterfaceState_descriptor();
template<typename T>
inline const std::string& SLInterfaceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLInterfaceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLInterfaceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLInterfaceState_descriptor(), enum_t_value);
}
inline bool SLInterfaceState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLInterfaceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLInterfaceState>(
    SLInterfaceState_descriptor(), name, value);
}
// ===================================================================

class SLInterfaceInfoMsgBw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceInfoMsgBw) */ {
 public:
  inline SLInterfaceInfoMsgBw() : SLInterfaceInfoMsgBw(nullptr) {}
  ~SLInterfaceInfoMsgBw() override;
  explicit constexpr SLInterfaceInfoMsgBw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceInfoMsgBw(const SLInterfaceInfoMsgBw& from);
  SLInterfaceInfoMsgBw(SLInterfaceInfoMsgBw&& from) noexcept
    : SLInterfaceInfoMsgBw() {
    *this = ::std::move(from);
  }

  inline SLInterfaceInfoMsgBw& operator=(const SLInterfaceInfoMsgBw& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceInfoMsgBw& operator=(SLInterfaceInfoMsgBw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceInfoMsgBw& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLInterfaceInfoMsgBw* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceInfoMsgBw*>(
               &_SLInterfaceInfoMsgBw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLInterfaceInfoMsgBw& a, SLInterfaceInfoMsgBw& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceInfoMsgBw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceInfoMsgBw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceInfoMsgBw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceInfoMsgBw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceInfoMsgBw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceInfoMsgBw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceInfoMsgBw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceInfoMsgBw";
  }
  protected:
  explicit SLInterfaceInfoMsgBw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewBandwidthFieldNumber = 1,
    kOldBandwidthFieldNumber = 2,
  };
  // uint64 NewBandwidth = 1;
  void clear_newbandwidth();
  uint64_t newbandwidth() const;
  void set_newbandwidth(uint64_t value);
  private:
  uint64_t _internal_newbandwidth() const;
  void _internal_set_newbandwidth(uint64_t value);
  public:

  // uint64 OldBandwidth = 2;
  void clear_oldbandwidth();
  uint64_t oldbandwidth() const;
  void set_oldbandwidth(uint64_t value);
  private:
  uint64_t _internal_oldbandwidth() const;
  void _internal_set_oldbandwidth(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceInfoMsgBw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t newbandwidth_;
  uint64_t oldbandwidth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceInfoMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceInfoMsg) */ {
 public:
  inline SLInterfaceInfoMsg() : SLInterfaceInfoMsg(nullptr) {}
  ~SLInterfaceInfoMsg() override;
  explicit constexpr SLInterfaceInfoMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceInfoMsg(const SLInterfaceInfoMsg& from);
  SLInterfaceInfoMsg(SLInterfaceInfoMsg&& from) noexcept
    : SLInterfaceInfoMsg() {
    *this = ::std::move(from);
  }

  inline SLInterfaceInfoMsg& operator=(const SLInterfaceInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceInfoMsg& operator=(SLInterfaceInfoMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceInfoMsg& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kBwInfo = 10,
    VALUE_NOT_SET = 0,
  };

  static inline const SLInterfaceInfoMsg* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceInfoMsg*>(
               &_SLInterfaceInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLInterfaceInfoMsg& a, SLInterfaceInfoMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceInfoMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceInfoMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceInfoMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceInfoMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceInfoMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceInfoMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceInfoMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceInfoMsg";
  }
  protected:
  explicit SLInterfaceInfoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSLIfInfoFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kIfStateFieldNumber = 2,
    kBwInfoFieldNumber = 10,
  };
  // .service_layer.SLInterface SLIfInfo = 1;
  bool has_slifinfo() const;
  private:
  bool _internal_has_slifinfo() const;
  public:
  void clear_slifinfo();
  const ::service_layer::SLInterface& slifinfo() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_slifinfo();
  ::service_layer::SLInterface* mutable_slifinfo();
  void set_allocated_slifinfo(::service_layer::SLInterface* slifinfo);
  private:
  const ::service_layer::SLInterface& _internal_slifinfo() const;
  ::service_layer::SLInterface* _internal_mutable_slifinfo();
  public:
  void unsafe_arena_set_allocated_slifinfo(
      ::service_layer::SLInterface* slifinfo);
  ::service_layer::SLInterface* unsafe_arena_release_slifinfo();

  // int64 Timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .service_layer.SLInterfaceState IfState = 2;
  void clear_ifstate();
  ::service_layer::SLInterfaceState ifstate() const;
  void set_ifstate(::service_layer::SLInterfaceState value);
  private:
  ::service_layer::SLInterfaceState _internal_ifstate() const;
  void _internal_set_ifstate(::service_layer::SLInterfaceState value);
  public:

  // .service_layer.SLInterfaceInfoMsgBw BwInfo = 10;
  bool has_bwinfo() const;
  private:
  bool _internal_has_bwinfo() const;
  public:
  void clear_bwinfo();
  const ::service_layer::SLInterfaceInfoMsgBw& bwinfo() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterfaceInfoMsgBw* release_bwinfo();
  ::service_layer::SLInterfaceInfoMsgBw* mutable_bwinfo();
  void set_allocated_bwinfo(::service_layer::SLInterfaceInfoMsgBw* bwinfo);
  private:
  const ::service_layer::SLInterfaceInfoMsgBw& _internal_bwinfo() const;
  ::service_layer::SLInterfaceInfoMsgBw* _internal_mutable_bwinfo();
  public:
  void unsafe_arena_set_allocated_bwinfo(
      ::service_layer::SLInterfaceInfoMsgBw* bwinfo);
  ::service_layer::SLInterfaceInfoMsgBw* unsafe_arena_release_bwinfo();

  void clear_Value();
  ValueCase Value_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceInfoMsg)
 private:
  class _Internal;
  void set_has_bwinfo();

  inline bool has_Value() const;
  inline void clear_has_Value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLInterface* slifinfo_;
  int64_t timestamp_;
  int ifstate_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLInterfaceInfoMsgBw* bwinfo_;
  } Value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceNotifMsgEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceNotifMsgEntry) */ {
 public:
  inline SLInterfaceNotifMsgEntry() : SLInterfaceNotifMsgEntry(nullptr) {}
  ~SLInterfaceNotifMsgEntry() override;
  explicit constexpr SLInterfaceNotifMsgEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceNotifMsgEntry(const SLInterfaceNotifMsgEntry& from);
  SLInterfaceNotifMsgEntry(SLInterfaceNotifMsgEntry&& from) noexcept
    : SLInterfaceNotifMsgEntry() {
    *this = ::std::move(from);
  }

  inline SLInterfaceNotifMsgEntry& operator=(const SLInterfaceNotifMsgEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceNotifMsgEntry& operator=(SLInterfaceNotifMsgEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceNotifMsgEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLInterfaceNotifMsgEntry* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceNotifMsgEntry*>(
               &_SLInterfaceNotifMsgEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLInterfaceNotifMsgEntry& a, SLInterfaceNotifMsgEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceNotifMsgEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceNotifMsgEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceNotifMsgEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceNotifMsgEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceNotifMsgEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceNotifMsgEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceNotifMsgEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceNotifMsgEntry";
  }
  protected:
  explicit SLInterfaceNotifMsgEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 4,
    kInterfaceFieldNumber = 3,
    kOperationIdFieldNumber = 1,
    kRegexFieldNumber = 2,
  };
  // repeated .service_layer.SLInterfaceState States = 4;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  private:
  ::service_layer::SLInterfaceState _internal_states(int index) const;
  void _internal_add_states(::service_layer::SLInterfaceState value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_states();
  public:
  ::service_layer::SLInterfaceState states(int index) const;
  void set_states(int index, ::service_layer::SLInterfaceState value);
  void add_states(::service_layer::SLInterfaceState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_states();

  // .service_layer.SLInterface Interface = 3;
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const ::service_layer::SLInterface& interface() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_interface();
  ::service_layer::SLInterface* mutable_interface();
  void set_allocated_interface(::service_layer::SLInterface* interface);
  private:
  const ::service_layer::SLInterface& _internal_interface() const;
  ::service_layer::SLInterface* _internal_mutable_interface();
  public:
  void unsafe_arena_set_allocated_interface(
      ::service_layer::SLInterface* interface);
  ::service_layer::SLInterface* unsafe_arena_release_interface();

  // uint64 OperationId = 1;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // bool Regex = 2;
  void clear_regex();
  bool regex() const;
  void set_regex(bool value);
  private:
  bool _internal_regex() const;
  void _internal_set_regex(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceNotifMsgEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> states_;
  mutable std::atomic<int> _states_cached_byte_size_;
  ::service_layer::SLInterface* interface_;
  uint64_t operationid_;
  bool regex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceNotifMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceNotifMsg) */ {
 public:
  inline SLInterfaceNotifMsg() : SLInterfaceNotifMsg(nullptr) {}
  ~SLInterfaceNotifMsg() override;
  explicit constexpr SLInterfaceNotifMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceNotifMsg(const SLInterfaceNotifMsg& from);
  SLInterfaceNotifMsg(SLInterfaceNotifMsg&& from) noexcept
    : SLInterfaceNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLInterfaceNotifMsg& operator=(const SLInterfaceNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceNotifMsg& operator=(SLInterfaceNotifMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceNotifMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLInterfaceNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceNotifMsg*>(
               &_SLInterfaceNotifMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLInterfaceNotifMsg& a, SLInterfaceNotifMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceNotifMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceNotifMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceNotifMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceNotifMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceNotifMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceNotifMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceNotifMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceNotifMsg";
  }
  protected:
  explicit SLInterfaceNotifMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLInterfaceNotifMsgEntry Entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::service_layer::SLInterfaceNotifMsgEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgEntry >*
      mutable_entries();
  private:
  const ::service_layer::SLInterfaceNotifMsgEntry& _internal_entries(int index) const;
  ::service_layer::SLInterfaceNotifMsgEntry* _internal_add_entries();
  public:
  const ::service_layer::SLInterfaceNotifMsgEntry& entries(int index) const;
  ::service_layer::SLInterfaceNotifMsgEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgEntry >&
      entries() const;

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceNotifMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgEntry > entries_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceNotifMsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceNotifMsgRes) */ {
 public:
  inline SLInterfaceNotifMsgRes() : SLInterfaceNotifMsgRes(nullptr) {}
  ~SLInterfaceNotifMsgRes() override;
  explicit constexpr SLInterfaceNotifMsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceNotifMsgRes(const SLInterfaceNotifMsgRes& from);
  SLInterfaceNotifMsgRes(SLInterfaceNotifMsgRes&& from) noexcept
    : SLInterfaceNotifMsgRes() {
    *this = ::std::move(from);
  }

  inline SLInterfaceNotifMsgRes& operator=(const SLInterfaceNotifMsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceNotifMsgRes& operator=(SLInterfaceNotifMsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceNotifMsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLInterfaceNotifMsgRes* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceNotifMsgRes*>(
               &_SLInterfaceNotifMsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLInterfaceNotifMsgRes& a, SLInterfaceNotifMsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceNotifMsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceNotifMsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceNotifMsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceNotifMsgRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceNotifMsgRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceNotifMsgRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceNotifMsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceNotifMsgRes";
  }
  protected:
  explicit SLInterfaceNotifMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 2,
    kKeyFieldNumber = 3,
    kOperationIdFieldNumber = 1,
  };
  // .service_layer.SLErrorStatus ErrStatus = 2;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLInterface Key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLInterface& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_key();
  ::service_layer::SLInterface* mutable_key();
  void set_allocated_key(::service_layer::SLInterface* key);
  private:
  const ::service_layer::SLInterface& _internal_key() const;
  ::service_layer::SLInterface* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLInterface* key);
  ::service_layer::SLInterface* unsafe_arena_release_key();

  // uint64 OperationId = 1;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceNotifMsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  ::service_layer::SLInterface* key_;
  uint64_t operationid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceNotifMsgErr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceNotifMsgErr) */ {
 public:
  inline SLInterfaceNotifMsgErr() : SLInterfaceNotifMsgErr(nullptr) {}
  ~SLInterfaceNotifMsgErr() override;
  explicit constexpr SLInterfaceNotifMsgErr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceNotifMsgErr(const SLInterfaceNotifMsgErr& from);
  SLInterfaceNotifMsgErr(SLInterfaceNotifMsgErr&& from) noexcept
    : SLInterfaceNotifMsgErr() {
    *this = ::std::move(from);
  }

  inline SLInterfaceNotifMsgErr& operator=(const SLInterfaceNotifMsgErr& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceNotifMsgErr& operator=(SLInterfaceNotifMsgErr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceNotifMsgErr& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLInterfaceNotifMsgErr* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceNotifMsgErr*>(
               &_SLInterfaceNotifMsgErr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLInterfaceNotifMsgErr& a, SLInterfaceNotifMsgErr& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceNotifMsgErr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceNotifMsgErr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceNotifMsgErr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceNotifMsgErr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceNotifMsgErr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceNotifMsgErr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceNotifMsgErr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceNotifMsgErr";
  }
  protected:
  explicit SLInterfaceNotifMsgErr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
  };
  // repeated .service_layer.SLInterfaceNotifMsgRes Details = 1;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  ::service_layer::SLInterfaceNotifMsgRes* mutable_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgRes >*
      mutable_details();
  private:
  const ::service_layer::SLInterfaceNotifMsgRes& _internal_details(int index) const;
  ::service_layer::SLInterfaceNotifMsgRes* _internal_add_details();
  public:
  const ::service_layer::SLInterfaceNotifMsgRes& details(int index) const;
  ::service_layer::SLInterfaceNotifMsgRes* add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgRes >&
      details() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceNotifMsgErr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgRes > details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// -------------------------------------------------------------------

class SLInterfaceNotif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLInterfaceNotif) */ {
 public:
  inline SLInterfaceNotif() : SLInterfaceNotif(nullptr) {}
  ~SLInterfaceNotif() override;
  explicit constexpr SLInterfaceNotif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLInterfaceNotif(const SLInterfaceNotif& from);
  SLInterfaceNotif(SLInterfaceNotif&& from) noexcept
    : SLInterfaceNotif() {
    *this = ::std::move(from);
  }

  inline SLInterfaceNotif& operator=(const SLInterfaceNotif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLInterfaceNotif& operator=(SLInterfaceNotif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLInterfaceNotif& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kInfo = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const SLInterfaceNotif* internal_default_instance() {
    return reinterpret_cast<const SLInterfaceNotif*>(
               &_SLInterfaceNotif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLInterfaceNotif& a, SLInterfaceNotif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLInterfaceNotif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLInterfaceNotif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLInterfaceNotif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLInterfaceNotif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLInterfaceNotif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLInterfaceNotif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLInterfaceNotif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLInterfaceNotif";
  }
  protected:
  explicit SLInterfaceNotif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // .service_layer.SLInterfaceNotifMsgErr Error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::service_layer::SLInterfaceNotifMsgErr& error() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterfaceNotifMsgErr* release_error();
  ::service_layer::SLInterfaceNotifMsgErr* mutable_error();
  void set_allocated_error(::service_layer::SLInterfaceNotifMsgErr* error);
  private:
  const ::service_layer::SLInterfaceNotifMsgErr& _internal_error() const;
  ::service_layer::SLInterfaceNotifMsgErr* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::service_layer::SLInterfaceNotifMsgErr* error);
  ::service_layer::SLInterfaceNotifMsgErr* unsafe_arena_release_error();

  // .service_layer.SLInterfaceInfoMsg Info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::service_layer::SLInterfaceInfoMsg& info() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterfaceInfoMsg* release_info();
  ::service_layer::SLInterfaceInfoMsg* mutable_info();
  void set_allocated_info(::service_layer::SLInterfaceInfoMsg* info);
  private:
  const ::service_layer::SLInterfaceInfoMsg& _internal_info() const;
  ::service_layer::SLInterfaceInfoMsg* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::service_layer::SLInterfaceInfoMsg* info);
  ::service_layer::SLInterfaceInfoMsg* unsafe_arena_release_info();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLInterfaceNotif)
 private:
  class _Internal;
  void set_has_error();
  void set_has_info();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLInterfaceNotifMsgErr* error_;
    ::service_layer::SLInterfaceInfoMsg* info_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5finterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLInterfaceInfoMsgBw

// uint64 NewBandwidth = 1;
inline void SLInterfaceInfoMsgBw::clear_newbandwidth() {
  newbandwidth_ = uint64_t{0u};
}
inline uint64_t SLInterfaceInfoMsgBw::_internal_newbandwidth() const {
  return newbandwidth_;
}
inline uint64_t SLInterfaceInfoMsgBw::newbandwidth() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsgBw.NewBandwidth)
  return _internal_newbandwidth();
}
inline void SLInterfaceInfoMsgBw::_internal_set_newbandwidth(uint64_t value) {
  
  newbandwidth_ = value;
}
inline void SLInterfaceInfoMsgBw::set_newbandwidth(uint64_t value) {
  _internal_set_newbandwidth(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceInfoMsgBw.NewBandwidth)
}

// uint64 OldBandwidth = 2;
inline void SLInterfaceInfoMsgBw::clear_oldbandwidth() {
  oldbandwidth_ = uint64_t{0u};
}
inline uint64_t SLInterfaceInfoMsgBw::_internal_oldbandwidth() const {
  return oldbandwidth_;
}
inline uint64_t SLInterfaceInfoMsgBw::oldbandwidth() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsgBw.OldBandwidth)
  return _internal_oldbandwidth();
}
inline void SLInterfaceInfoMsgBw::_internal_set_oldbandwidth(uint64_t value) {
  
  oldbandwidth_ = value;
}
inline void SLInterfaceInfoMsgBw::set_oldbandwidth(uint64_t value) {
  _internal_set_oldbandwidth(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceInfoMsgBw.OldBandwidth)
}

// -------------------------------------------------------------------

// SLInterfaceInfoMsg

// .service_layer.SLInterface SLIfInfo = 1;
inline bool SLInterfaceInfoMsg::_internal_has_slifinfo() const {
  return this != internal_default_instance() && slifinfo_ != nullptr;
}
inline bool SLInterfaceInfoMsg::has_slifinfo() const {
  return _internal_has_slifinfo();
}
inline const ::service_layer::SLInterface& SLInterfaceInfoMsg::_internal_slifinfo() const {
  const ::service_layer::SLInterface* p = slifinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLInterfaceInfoMsg::slifinfo() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsg.SLIfInfo)
  return _internal_slifinfo();
}
inline void SLInterfaceInfoMsg::unsafe_arena_set_allocated_slifinfo(
    ::service_layer::SLInterface* slifinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slifinfo_);
  }
  slifinfo_ = slifinfo;
  if (slifinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceInfoMsg.SLIfInfo)
}
inline ::service_layer::SLInterface* SLInterfaceInfoMsg::release_slifinfo() {
  
  ::service_layer::SLInterface* temp = slifinfo_;
  slifinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceInfoMsg::unsafe_arena_release_slifinfo() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceInfoMsg.SLIfInfo)
  
  ::service_layer::SLInterface* temp = slifinfo_;
  slifinfo_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceInfoMsg::_internal_mutable_slifinfo() {
  
  if (slifinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    slifinfo_ = p;
  }
  return slifinfo_;
}
inline ::service_layer::SLInterface* SLInterfaceInfoMsg::mutable_slifinfo() {
  ::service_layer::SLInterface* _msg = _internal_mutable_slifinfo();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceInfoMsg.SLIfInfo)
  return _msg;
}
inline void SLInterfaceInfoMsg::set_allocated_slifinfo(::service_layer::SLInterface* slifinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(slifinfo_);
  }
  if (slifinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slifinfo));
    if (message_arena != submessage_arena) {
      slifinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slifinfo, submessage_arena);
    }
    
  } else {
    
  }
  slifinfo_ = slifinfo;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterfaceInfoMsg.SLIfInfo)
}

// .service_layer.SLInterfaceState IfState = 2;
inline void SLInterfaceInfoMsg::clear_ifstate() {
  ifstate_ = 0;
}
inline ::service_layer::SLInterfaceState SLInterfaceInfoMsg::_internal_ifstate() const {
  return static_cast< ::service_layer::SLInterfaceState >(ifstate_);
}
inline ::service_layer::SLInterfaceState SLInterfaceInfoMsg::ifstate() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsg.IfState)
  return _internal_ifstate();
}
inline void SLInterfaceInfoMsg::_internal_set_ifstate(::service_layer::SLInterfaceState value) {
  
  ifstate_ = value;
}
inline void SLInterfaceInfoMsg::set_ifstate(::service_layer::SLInterfaceState value) {
  _internal_set_ifstate(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceInfoMsg.IfState)
}

// int64 Timestamp = 3;
inline void SLInterfaceInfoMsg::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t SLInterfaceInfoMsg::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t SLInterfaceInfoMsg::timestamp() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsg.Timestamp)
  return _internal_timestamp();
}
inline void SLInterfaceInfoMsg::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void SLInterfaceInfoMsg::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceInfoMsg.Timestamp)
}

// .service_layer.SLInterfaceInfoMsgBw BwInfo = 10;
inline bool SLInterfaceInfoMsg::_internal_has_bwinfo() const {
  return Value_case() == kBwInfo;
}
inline bool SLInterfaceInfoMsg::has_bwinfo() const {
  return _internal_has_bwinfo();
}
inline void SLInterfaceInfoMsg::set_has_bwinfo() {
  _oneof_case_[0] = kBwInfo;
}
inline void SLInterfaceInfoMsg::clear_bwinfo() {
  if (_internal_has_bwinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Value_.bwinfo_;
    }
    clear_has_Value();
  }
}
inline ::service_layer::SLInterfaceInfoMsgBw* SLInterfaceInfoMsg::release_bwinfo() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceInfoMsg.BwInfo)
  if (_internal_has_bwinfo()) {
    clear_has_Value();
      ::service_layer::SLInterfaceInfoMsgBw* temp = Value_.bwinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Value_.bwinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLInterfaceInfoMsgBw& SLInterfaceInfoMsg::_internal_bwinfo() const {
  return _internal_has_bwinfo()
      ? *Value_.bwinfo_
      : reinterpret_cast< ::service_layer::SLInterfaceInfoMsgBw&>(::service_layer::_SLInterfaceInfoMsgBw_default_instance_);
}
inline const ::service_layer::SLInterfaceInfoMsgBw& SLInterfaceInfoMsg::bwinfo() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceInfoMsg.BwInfo)
  return _internal_bwinfo();
}
inline ::service_layer::SLInterfaceInfoMsgBw* SLInterfaceInfoMsg::unsafe_arena_release_bwinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLInterfaceInfoMsg.BwInfo)
  if (_internal_has_bwinfo()) {
    clear_has_Value();
    ::service_layer::SLInterfaceInfoMsgBw* temp = Value_.bwinfo_;
    Value_.bwinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLInterfaceInfoMsg::unsafe_arena_set_allocated_bwinfo(::service_layer::SLInterfaceInfoMsgBw* bwinfo) {
  clear_Value();
  if (bwinfo) {
    set_has_bwinfo();
    Value_.bwinfo_ = bwinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceInfoMsg.BwInfo)
}
inline ::service_layer::SLInterfaceInfoMsgBw* SLInterfaceInfoMsg::_internal_mutable_bwinfo() {
  if (!_internal_has_bwinfo()) {
    clear_Value();
    set_has_bwinfo();
    Value_.bwinfo_ = CreateMaybeMessage< ::service_layer::SLInterfaceInfoMsgBw >(GetArenaForAllocation());
  }
  return Value_.bwinfo_;
}
inline ::service_layer::SLInterfaceInfoMsgBw* SLInterfaceInfoMsg::mutable_bwinfo() {
  ::service_layer::SLInterfaceInfoMsgBw* _msg = _internal_mutable_bwinfo();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceInfoMsg.BwInfo)
  return _msg;
}

inline bool SLInterfaceInfoMsg::has_Value() const {
  return Value_case() != VALUE_NOT_SET;
}
inline void SLInterfaceInfoMsg::clear_has_Value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline SLInterfaceInfoMsg::ValueCase SLInterfaceInfoMsg::Value_case() const {
  return SLInterfaceInfoMsg::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLInterfaceNotifMsgEntry

// uint64 OperationId = 1;
inline void SLInterfaceNotifMsgEntry::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLInterfaceNotifMsgEntry::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLInterfaceNotifMsgEntry::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgEntry.OperationId)
  return _internal_operationid();
}
inline void SLInterfaceNotifMsgEntry::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLInterfaceNotifMsgEntry::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceNotifMsgEntry.OperationId)
}

// bool Regex = 2;
inline void SLInterfaceNotifMsgEntry::clear_regex() {
  regex_ = false;
}
inline bool SLInterfaceNotifMsgEntry::_internal_regex() const {
  return regex_;
}
inline bool SLInterfaceNotifMsgEntry::regex() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgEntry.Regex)
  return _internal_regex();
}
inline void SLInterfaceNotifMsgEntry::_internal_set_regex(bool value) {
  
  regex_ = value;
}
inline void SLInterfaceNotifMsgEntry::set_regex(bool value) {
  _internal_set_regex(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceNotifMsgEntry.Regex)
}

// .service_layer.SLInterface Interface = 3;
inline bool SLInterfaceNotifMsgEntry::_internal_has_interface() const {
  return this != internal_default_instance() && interface_ != nullptr;
}
inline bool SLInterfaceNotifMsgEntry::has_interface() const {
  return _internal_has_interface();
}
inline const ::service_layer::SLInterface& SLInterfaceNotifMsgEntry::_internal_interface() const {
  const ::service_layer::SLInterface* p = interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLInterfaceNotifMsgEntry::interface() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgEntry.Interface)
  return _internal_interface();
}
inline void SLInterfaceNotifMsgEntry::unsafe_arena_set_allocated_interface(
    ::service_layer::SLInterface* interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  interface_ = interface;
  if (interface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceNotifMsgEntry.Interface)
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgEntry::release_interface() {
  
  ::service_layer::SLInterface* temp = interface_;
  interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgEntry::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceNotifMsgEntry.Interface)
  
  ::service_layer::SLInterface* temp = interface_;
  interface_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgEntry::_internal_mutable_interface() {
  
  if (interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    interface_ = p;
  }
  return interface_;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgEntry::mutable_interface() {
  ::service_layer::SLInterface* _msg = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotifMsgEntry.Interface)
  return _msg;
}
inline void SLInterfaceNotifMsgEntry::set_allocated_interface(::service_layer::SLInterface* interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_);
  }
  if (interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface));
    if (message_arena != submessage_arena) {
      interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterfaceNotifMsgEntry.Interface)
}

// repeated .service_layer.SLInterfaceState States = 4;
inline int SLInterfaceNotifMsgEntry::_internal_states_size() const {
  return states_.size();
}
inline int SLInterfaceNotifMsgEntry::states_size() const {
  return _internal_states_size();
}
inline void SLInterfaceNotifMsgEntry::clear_states() {
  states_.Clear();
}
inline ::service_layer::SLInterfaceState SLInterfaceNotifMsgEntry::_internal_states(int index) const {
  return static_cast< ::service_layer::SLInterfaceState >(states_.Get(index));
}
inline ::service_layer::SLInterfaceState SLInterfaceNotifMsgEntry::states(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgEntry.States)
  return _internal_states(index);
}
inline void SLInterfaceNotifMsgEntry::set_states(int index, ::service_layer::SLInterfaceState value) {
  states_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceNotifMsgEntry.States)
}
inline void SLInterfaceNotifMsgEntry::_internal_add_states(::service_layer::SLInterfaceState value) {
  states_.Add(value);
}
inline void SLInterfaceNotifMsgEntry::add_states(::service_layer::SLInterfaceState value) {
  _internal_add_states(value);
  // @@protoc_insertion_point(field_add:service_layer.SLInterfaceNotifMsgEntry.States)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLInterfaceNotifMsgEntry::states() const {
  // @@protoc_insertion_point(field_list:service_layer.SLInterfaceNotifMsgEntry.States)
  return states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLInterfaceNotifMsgEntry::_internal_mutable_states() {
  return &states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLInterfaceNotifMsgEntry::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLInterfaceNotifMsgEntry.States)
  return _internal_mutable_states();
}

// -------------------------------------------------------------------

// SLInterfaceNotifMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLInterfaceNotifMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLInterfaceNotifMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLInterfaceNotifMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsg.Oper)
  return _internal_oper();
}
inline void SLInterfaceNotifMsg::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLInterfaceNotifMsg::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceNotifMsg.Oper)
}

// repeated .service_layer.SLInterfaceNotifMsgEntry Entries = 2;
inline int SLInterfaceNotifMsg::_internal_entries_size() const {
  return entries_.size();
}
inline int SLInterfaceNotifMsg::entries_size() const {
  return _internal_entries_size();
}
inline void SLInterfaceNotifMsg::clear_entries() {
  entries_.Clear();
}
inline ::service_layer::SLInterfaceNotifMsgEntry* SLInterfaceNotifMsg::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotifMsg.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgEntry >*
SLInterfaceNotifMsg::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLInterfaceNotifMsg.Entries)
  return &entries_;
}
inline const ::service_layer::SLInterfaceNotifMsgEntry& SLInterfaceNotifMsg::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::service_layer::SLInterfaceNotifMsgEntry& SLInterfaceNotifMsg::entries(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsg.Entries)
  return _internal_entries(index);
}
inline ::service_layer::SLInterfaceNotifMsgEntry* SLInterfaceNotifMsg::_internal_add_entries() {
  return entries_.Add();
}
inline ::service_layer::SLInterfaceNotifMsgEntry* SLInterfaceNotifMsg::add_entries() {
  ::service_layer::SLInterfaceNotifMsgEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:service_layer.SLInterfaceNotifMsg.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgEntry >&
SLInterfaceNotifMsg::entries() const {
  // @@protoc_insertion_point(field_list:service_layer.SLInterfaceNotifMsg.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SLInterfaceNotifMsgRes

// uint64 OperationId = 1;
inline void SLInterfaceNotifMsgRes::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLInterfaceNotifMsgRes::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLInterfaceNotifMsgRes::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgRes.OperationId)
  return _internal_operationid();
}
inline void SLInterfaceNotifMsgRes::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLInterfaceNotifMsgRes::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLInterfaceNotifMsgRes.OperationId)
}

// .service_layer.SLErrorStatus ErrStatus = 2;
inline bool SLInterfaceNotifMsgRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLInterfaceNotifMsgRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLInterfaceNotifMsgRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLInterfaceNotifMsgRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLInterfaceNotifMsgRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceNotifMsgRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLInterfaceNotifMsgRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLInterfaceNotifMsgRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceNotifMsgRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLInterfaceNotifMsgRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLInterfaceNotifMsgRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotifMsgRes.ErrStatus)
  return _msg;
}
inline void SLInterfaceNotifMsgRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterfaceNotifMsgRes.ErrStatus)
}

// .service_layer.SLInterface Key = 3;
inline bool SLInterfaceNotifMsgRes::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLInterfaceNotifMsgRes::has_key() const {
  return _internal_has_key();
}
inline const ::service_layer::SLInterface& SLInterfaceNotifMsgRes::_internal_key() const {
  const ::service_layer::SLInterface* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLInterfaceNotifMsgRes::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgRes.Key)
  return _internal_key();
}
inline void SLInterfaceNotifMsgRes::unsafe_arena_set_allocated_key(
    ::service_layer::SLInterface* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceNotifMsgRes.Key)
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgRes::release_key() {
  
  ::service_layer::SLInterface* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgRes::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceNotifMsgRes.Key)
  
  ::service_layer::SLInterface* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgRes::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLInterface* SLInterfaceNotifMsgRes::mutable_key() {
  ::service_layer::SLInterface* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotifMsgRes.Key)
  return _msg;
}
inline void SLInterfaceNotifMsgRes::set_allocated_key(::service_layer::SLInterface* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key));
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLInterfaceNotifMsgRes.Key)
}

// -------------------------------------------------------------------

// SLInterfaceNotifMsgErr

// repeated .service_layer.SLInterfaceNotifMsgRes Details = 1;
inline int SLInterfaceNotifMsgErr::_internal_details_size() const {
  return details_.size();
}
inline int SLInterfaceNotifMsgErr::details_size() const {
  return _internal_details_size();
}
inline void SLInterfaceNotifMsgErr::clear_details() {
  details_.Clear();
}
inline ::service_layer::SLInterfaceNotifMsgRes* SLInterfaceNotifMsgErr::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotifMsgErr.Details)
  return details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgRes >*
SLInterfaceNotifMsgErr::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLInterfaceNotifMsgErr.Details)
  return &details_;
}
inline const ::service_layer::SLInterfaceNotifMsgRes& SLInterfaceNotifMsgErr::_internal_details(int index) const {
  return details_.Get(index);
}
inline const ::service_layer::SLInterfaceNotifMsgRes& SLInterfaceNotifMsgErr::details(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotifMsgErr.Details)
  return _internal_details(index);
}
inline ::service_layer::SLInterfaceNotifMsgRes* SLInterfaceNotifMsgErr::_internal_add_details() {
  return details_.Add();
}
inline ::service_layer::SLInterfaceNotifMsgRes* SLInterfaceNotifMsgErr::add_details() {
  ::service_layer::SLInterfaceNotifMsgRes* _add = _internal_add_details();
  // @@protoc_insertion_point(field_add:service_layer.SLInterfaceNotifMsgErr.Details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLInterfaceNotifMsgRes >&
SLInterfaceNotifMsgErr::details() const {
  // @@protoc_insertion_point(field_list:service_layer.SLInterfaceNotifMsgErr.Details)
  return details_;
}

// -------------------------------------------------------------------

// SLInterfaceNotif

// .service_layer.SLInterfaceNotifMsgErr Error = 1;
inline bool SLInterfaceNotif::_internal_has_error() const {
  return Event_case() == kError;
}
inline bool SLInterfaceNotif::has_error() const {
  return _internal_has_error();
}
inline void SLInterfaceNotif::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void SLInterfaceNotif::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.error_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLInterfaceNotifMsgErr* SLInterfaceNotif::release_error() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceNotif.Error)
  if (_internal_has_error()) {
    clear_has_Event();
      ::service_layer::SLInterfaceNotifMsgErr* temp = Event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLInterfaceNotifMsgErr& SLInterfaceNotif::_internal_error() const {
  return _internal_has_error()
      ? *Event_.error_
      : reinterpret_cast< ::service_layer::SLInterfaceNotifMsgErr&>(::service_layer::_SLInterfaceNotifMsgErr_default_instance_);
}
inline const ::service_layer::SLInterfaceNotifMsgErr& SLInterfaceNotif::error() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotif.Error)
  return _internal_error();
}
inline ::service_layer::SLInterfaceNotifMsgErr* SLInterfaceNotif::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLInterfaceNotif.Error)
  if (_internal_has_error()) {
    clear_has_Event();
    ::service_layer::SLInterfaceNotifMsgErr* temp = Event_.error_;
    Event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLInterfaceNotif::unsafe_arena_set_allocated_error(::service_layer::SLInterfaceNotifMsgErr* error) {
  clear_Event();
  if (error) {
    set_has_error();
    Event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceNotif.Error)
}
inline ::service_layer::SLInterfaceNotifMsgErr* SLInterfaceNotif::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Event();
    set_has_error();
    Event_.error_ = CreateMaybeMessage< ::service_layer::SLInterfaceNotifMsgErr >(GetArenaForAllocation());
  }
  return Event_.error_;
}
inline ::service_layer::SLInterfaceNotifMsgErr* SLInterfaceNotif::mutable_error() {
  ::service_layer::SLInterfaceNotifMsgErr* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotif.Error)
  return _msg;
}

// .service_layer.SLInterfaceInfoMsg Info = 2;
inline bool SLInterfaceNotif::_internal_has_info() const {
  return Event_case() == kInfo;
}
inline bool SLInterfaceNotif::has_info() const {
  return _internal_has_info();
}
inline void SLInterfaceNotif::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void SLInterfaceNotif::clear_info() {
  if (_internal_has_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.info_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLInterfaceInfoMsg* SLInterfaceNotif::release_info() {
  // @@protoc_insertion_point(field_release:service_layer.SLInterfaceNotif.Info)
  if (_internal_has_info()) {
    clear_has_Event();
      ::service_layer::SLInterfaceInfoMsg* temp = Event_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLInterfaceInfoMsg& SLInterfaceNotif::_internal_info() const {
  return _internal_has_info()
      ? *Event_.info_
      : reinterpret_cast< ::service_layer::SLInterfaceInfoMsg&>(::service_layer::_SLInterfaceInfoMsg_default_instance_);
}
inline const ::service_layer::SLInterfaceInfoMsg& SLInterfaceNotif::info() const {
  // @@protoc_insertion_point(field_get:service_layer.SLInterfaceNotif.Info)
  return _internal_info();
}
inline ::service_layer::SLInterfaceInfoMsg* SLInterfaceNotif::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLInterfaceNotif.Info)
  if (_internal_has_info()) {
    clear_has_Event();
    ::service_layer::SLInterfaceInfoMsg* temp = Event_.info_;
    Event_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLInterfaceNotif::unsafe_arena_set_allocated_info(::service_layer::SLInterfaceInfoMsg* info) {
  clear_Event();
  if (info) {
    set_has_info();
    Event_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLInterfaceNotif.Info)
}
inline ::service_layer::SLInterfaceInfoMsg* SLInterfaceNotif::_internal_mutable_info() {
  if (!_internal_has_info()) {
    clear_Event();
    set_has_info();
    Event_.info_ = CreateMaybeMessage< ::service_layer::SLInterfaceInfoMsg >(GetArenaForAllocation());
  }
  return Event_.info_;
}
inline ::service_layer::SLInterfaceInfoMsg* SLInterfaceNotif::mutable_info() {
  ::service_layer::SLInterfaceInfoMsg* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:service_layer.SLInterfaceNotif.Info)
  return _msg;
}

inline bool SLInterfaceNotif::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLInterfaceNotif::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLInterfaceNotif::EventCase SLInterfaceNotif::Event_case() const {
  return SLInterfaceNotif::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service_layer::SLInterfaceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLInterfaceState>() {
  return ::service_layer::SLInterfaceState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5finterface_2eproto
