// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sl_l2_route.proto
// Original file comments:
// @file
// @brief Server RPC proto file for L2 routes.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016 by cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//
//
#ifndef GRPC_sl_5fl2_5froute_2eproto__INCLUDED
#define GRPC_sl_5fl2_5froute_2eproto__INCLUDED

#include "sl_l2_route.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace service_layer {

// @defgroup SLRouteL2Oper
// @ingroup L2Route
// Defines RPC calls for L2 route changes and Bridge-Domain (BD) registration.
// This service declares calls for adding, deleting, updating and getting
// L2 routes.
// @{
class SLL2Oper final {
 public:
  static constexpr char const* service_full_name() {
    return "service_layer.SLL2Oper";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Global L2 route operations
    //
    //
    // Used to retrieve global L2 info from the server.
    virtual ::grpc::Status SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::service_layer::SLL2GlobalsGetMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>> AsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>>(AsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>> PrepareAsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>>(PrepareAsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    //
    // L2 Registration Operations
    //
    //
    // SLL2RegMsg.Oper = SL_REGOP_REGISTER:
    //     Global L2 registration.
    //     A client Must Register BEFORE sending BD registration messages
    //     (to add/update/delete routes) or BEFORE requesting for L2 route
    //     notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
    //     Global L2 un-registration.
    //     This call is used to convey that the client is no longer
    //     interested in programming L2 routes and in receiving L2 route
    //     notifications. All programmed L2 routes will be deleted on the
    //     server and the server will stop sending L2 route notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_EOF:
    //     Global L2 End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known
    //     objects and to convey the end of requests for L2 route
    //     notifications.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::service_layer::SLL2RegMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>> AsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>>(AsyncSLL2RegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>> PrepareAsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>>(PrepareAsyncSLL2RegOpRaw(context, request, cq));
    }
    //
    // L2 Bridge-Domain (BD) Registration Operations
    //
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
    //     BD registration: Sends a list of BD registration messages and
    //     expects a list of registration responses.
    //     A client Must Register a BD BEFORE L2 Routes can be added/modified
    //     in that BD.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
    //     BD un-registration: Sends a list of BD un-registration messages
    //     and expects a list of un-registration responses.
    //     This can be used to convey that the client is no longer
    //     interested in programming routes in this BD. All installed L2
    //     routes will be lost.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_EOF:
    //     BD End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known objects
    //     in that BD.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::service_layer::SLL2BdRegMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>> AsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>>(AsyncSLL2BdRegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>> PrepareAsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>>(PrepareAsyncSLL2BdRegOpRaw(context, request, cq));
    }
    //
    // L2 Route Operations
    //
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_ADD:
    // Route add. Fails if the route already exists.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
    // Route update. Creates or updates the route.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
    // Route delete. The route path is not necessary to delete the route.
    //
    virtual ::grpc::Status SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::service_layer::SLL2RouteMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpRaw(context, request, cq));
    }
    //
    // L2 Stream Route Operations
    //
    //
    // Stream adds/updates/deletes of L2 Routes.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> SLL2RouteOpStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(SLL2RouteOpStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpStreamRaw(context, cq));
    }
    //
    // L2 Route Redistribution Operations
    //
    //
    // This call is used to get a stream of BD state and route notifications.
    // It can be used to get "push" notifications for route
    // adds/updates/deletes.
    // The caller must maintain the GRPC channel as long as there is
    // interest in route notifications.
    //
    // The call takes 3 types of notification requests:
    // 1. Request for BD state notifications only (pass only Oper and
    //    Correlator).
    // 2. Request for BD state and Route notifications in all BDs.
    // 3. Request for Route notifications per-BD.
    //    This should be sent after requesting for BD state notifications
    //    and after receiving BD-ready notification.
    //
    // The success/failure of the notification request is relayed in the
    // SLL2NotifStatusMsg followed by a Start marker, any routes if present,
    // and an End Marker.
    //
    // After all requests are sent, client should send GetNotifEof = TRUE.
    //
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> SLL2GetNotifStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(SLL2GetNotifStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> AsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(AsyncSLL2GetNotifStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> PrepareAsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(PrepareAsyncSLL2GetNotifStreamRaw(context, cq));
    }
    // @}
    class async_interface {
     public:
      virtual ~async_interface() {}
      //
      // Global L2 route operations
      //
      //
      // Used to retrieve global L2 info from the server.
      virtual void SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // L2 Registration Operations
      //
      //
      // SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      //     Global L2 registration.
      //     A client Must Register BEFORE sending BD registration messages
      //     (to add/update/delete routes) or BEFORE requesting for L2 route
      //     notifications.
      //
      // SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      //     Global L2 un-registration.
      //     This call is used to convey that the client is no longer
      //     interested in programming L2 routes and in receiving L2 route
      //     notifications. All programmed L2 routes will be deleted on the
      //     server and the server will stop sending L2 route notifications.
      //
      // SLL2RegMsg.Oper = SL_REGOP_EOF:
      //     Global L2 End Of File message.
      //     After Registration, the client is expected to send an EOF
      //     message to convey the end of replay of the client's known
      //     objects and to convey the end of requests for L2 route
      //     notifications.
      //     This is especially useful under certain restart scenarios when the
      //     client and the server are trying to synchronize their routes.
      //
      virtual void SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // L2 Bridge-Domain (BD) Registration Operations
      //
      //
      // SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      //     BD registration: Sends a list of BD registration messages and
      //     expects a list of registration responses.
      //     A client Must Register a BD BEFORE L2 Routes can be added/modified
      //     in that BD.
      //
      // SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      //     BD un-registration: Sends a list of BD un-registration messages
      //     and expects a list of un-registration responses.
      //     This can be used to convey that the client is no longer
      //     interested in programming routes in this BD. All installed L2
      //     routes will be lost.
      //
      // SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      //     BD End Of File message.
      //     After Registration, the client is expected to send an EOF
      //     message to convey the end of replay of the client's known objects
      //     in that BD.
      //     This is especially useful under certain restart scenarios when the
      //     client and the server are trying to synchronize their routes.
      //
      virtual void SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // L2 Route Operations
      //
      //
      // SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      // Route add. Fails if the route already exists.
      //
      // SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      // Route update. Creates or updates the route.
      //
      // SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      // Route delete. The route path is not necessary to delete the route.
      //
      virtual void SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // L2 Stream Route Operations
      //
      //
      // Stream adds/updates/deletes of L2 Routes.
      virtual void SLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::service_layer::SLL2RouteMsg,::service_layer::SLL2RouteMsgRsp>* reactor) = 0;
      //
      // L2 Route Redistribution Operations
      //
      //
      // This call is used to get a stream of BD state and route notifications.
      // It can be used to get "push" notifications for route
      // adds/updates/deletes.
      // The caller must maintain the GRPC channel as long as there is
      // interest in route notifications.
      //
      // The call takes 3 types of notification requests:
      // 1. Request for BD state notifications only (pass only Oper and
      //    Correlator).
      // 2. Request for BD state and Route notifications in all BDs.
      // 3. Request for Route notifications per-BD.
      //    This should be sent after requesting for BD state notifications
      //    and after receiving BD-ready notification.
      //
      // The success/failure of the notification request is relayed in the
      // SLL2NotifStatusMsg followed by a Start marker, any routes if present,
      // and an End Marker.
      //
      // After all requests are sent, client should send GetNotifEof = TRUE.
      //
      virtual void SLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::service_layer::SLL2GetNotifMsg,::service_layer::SLL2Notif>* reactor) = 0;
      // @}
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>* AsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>* PrepareAsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>* AsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>* PrepareAsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>* AsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>* PrepareAsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* SLL2RouteOpStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* SLL2GetNotifStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* AsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* PrepareAsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::service_layer::SLL2GlobalsGetMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>> AsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>>(AsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>> PrepareAsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>>(PrepareAsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    ::grpc::Status SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::service_layer::SLL2RegMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>> AsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>>(AsyncSLL2RegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>> PrepareAsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>>(PrepareAsyncSLL2RegOpRaw(context, request, cq));
    }
    ::grpc::Status SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::service_layer::SLL2BdRegMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>> AsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>>(AsyncSLL2BdRegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>> PrepareAsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>>(PrepareAsyncSLL2BdRegOpRaw(context, request, cq));
    }
    ::grpc::Status SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::service_layer::SLL2RouteMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> SLL2RouteOpStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(SLL2RouteOpStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpStreamRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> SLL2GetNotifStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(SLL2GetNotifStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> AsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(AsyncSLL2GetNotifStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> PrepareAsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(PrepareAsyncSLL2GetNotifStreamRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response, std::function<void(::grpc::Status)>) override;
      void SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response, std::function<void(::grpc::Status)>) override;
      void SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response, std::function<void(::grpc::Status)>) override;
      void SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response, std::function<void(::grpc::Status)>) override;
      void SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::service_layer::SLL2RouteMsg,::service_layer::SLL2RouteMsgRsp>* reactor) override;
      void SLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::service_layer::SLL2GetNotifMsg,::service_layer::SLL2Notif>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>* AsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>* PrepareAsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>* AsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>* PrepareAsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>* AsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>* PrepareAsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* SLL2RouteOpStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* SLL2GetNotifStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* AsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* PrepareAsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2GlobalsGet_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RegOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2BdRegOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RouteOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RouteOpStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2GetNotifStream_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Global L2 route operations
    //
    //
    // Used to retrieve global L2 info from the server.
    virtual ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response);
    //
    // L2 Registration Operations
    //
    //
    // SLL2RegMsg.Oper = SL_REGOP_REGISTER:
    //     Global L2 registration.
    //     A client Must Register BEFORE sending BD registration messages
    //     (to add/update/delete routes) or BEFORE requesting for L2 route
    //     notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
    //     Global L2 un-registration.
    //     This call is used to convey that the client is no longer
    //     interested in programming L2 routes and in receiving L2 route
    //     notifications. All programmed L2 routes will be deleted on the
    //     server and the server will stop sending L2 route notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_EOF:
    //     Global L2 End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known
    //     objects and to convey the end of requests for L2 route
    //     notifications.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2RegOp(::grpc::ServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response);
    //
    // L2 Bridge-Domain (BD) Registration Operations
    //
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
    //     BD registration: Sends a list of BD registration messages and
    //     expects a list of registration responses.
    //     A client Must Register a BD BEFORE L2 Routes can be added/modified
    //     in that BD.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
    //     BD un-registration: Sends a list of BD un-registration messages
    //     and expects a list of un-registration responses.
    //     This can be used to convey that the client is no longer
    //     interested in programming routes in this BD. All installed L2
    //     routes will be lost.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_EOF:
    //     BD End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known objects
    //     in that BD.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response);
    //
    // L2 Route Operations
    //
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_ADD:
    // Route add. Fails if the route already exists.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
    // Route update. Creates or updates the route.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
    // Route delete. The route path is not necessary to delete the route.
    //
    virtual ::grpc::Status SLL2RouteOp(::grpc::ServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response);
    //
    // L2 Stream Route Operations
    //
    //
    // Stream adds/updates/deletes of L2 Routes.
    virtual ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream);
    //
    // L2 Route Redistribution Operations
    //
    //
    // This call is used to get a stream of BD state and route notifications.
    // It can be used to get "push" notifications for route
    // adds/updates/deletes.
    // The caller must maintain the GRPC channel as long as there is
    // interest in route notifications.
    //
    // The call takes 3 types of notification requests:
    // 1. Request for BD state notifications only (pass only Oper and
    //    Correlator).
    // 2. Request for BD state and Route notifications in all BDs.
    // 3. Request for Route notifications per-BD.
    //    This should be sent after requesting for BD state notifications
    //    and after receiving BD-ready notification.
    //
    // The success/failure of the notification request is relayed in the
    // SLL2NotifStatusMsg followed by a Start marker, any routes if present,
    // and an End Marker.
    //
    // After all requests are sent, client should send GetNotifEof = TRUE.
    //
    virtual ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream);
    // @}
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GlobalsGet(::grpc::ServerContext* context, ::service_layer::SLL2GlobalsGetMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2GlobalsGetMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RegOp(::grpc::ServerContext* context, ::service_layer::SLL2RegMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2RegMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2BdRegOp(::grpc::ServerContext* context, ::service_layer::SLL2BdRegMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2BdRegMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOp(::grpc::ServerContext* context, ::service_layer::SLL2RouteMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2RouteMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(5, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SLL2GlobalsGet<WithAsyncMethod_SLL2RegOp<WithAsyncMethod_SLL2BdRegOp<WithAsyncMethod_SLL2RouteOp<WithAsyncMethod_SLL2RouteOpStream<WithAsyncMethod_SLL2GetNotifStream<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response) { return this->SLL2GlobalsGet(context, request, response); }));}
    void SetMessageAllocatorFor_SLL2GlobalsGet(
        ::grpc::MessageAllocator< ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2GlobalsGet(
      ::grpc::CallbackServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response) { return this->SLL2RegOp(context, request, response); }));}
    void SetMessageAllocatorFor_SLL2RegOp(
        ::grpc::MessageAllocator< ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2RegOp(
      ::grpc::CallbackServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response) { return this->SLL2BdRegOp(context, request, response); }));}
    void SetMessageAllocatorFor_SLL2BdRegOp(
        ::grpc::MessageAllocator< ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2BdRegOp(
      ::grpc::CallbackServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response) { return this->SLL2RouteOp(context, request, response); }));}
    void SetMessageAllocatorFor_SLL2RouteOp(
        ::grpc::MessageAllocator< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2RouteOp(
      ::grpc::CallbackServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackBidiHandler< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SLL2RouteOpStream(context); }));
    }
    ~WithCallbackMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* SLL2RouteOpStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackBidiHandler< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SLL2GetNotifStream(context); }));
    }
    ~WithCallbackMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* SLL2GetNotifStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_SLL2GlobalsGet<WithCallbackMethod_SLL2RegOp<WithCallbackMethod_SLL2BdRegOp<WithCallbackMethod_SLL2RouteOp<WithCallbackMethod_SLL2RouteOpStream<WithCallbackMethod_SLL2GetNotifStream<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GlobalsGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RegOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2BdRegOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(5, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SLL2GlobalsGet(context, request, response); }));
    }
    ~WithRawCallbackMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2GlobalsGet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SLL2RegOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2RegOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SLL2BdRegOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2BdRegOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SLL2RouteOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SLL2RouteOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SLL2RouteOpStream(context); }));
    }
    ~WithRawCallbackMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SLL2RouteOpStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->SLL2GetNotifStream(context); }));
    }
    ~WithRawCallbackMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SLL2GetNotifStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>* streamer) {
                       return this->StreamedSLL2GlobalsGet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2GlobalsGetMsg* /*request*/, ::service_layer::SLL2GlobalsGetMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2GlobalsGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2GlobalsGetMsg,::service_layer::SLL2GlobalsGetMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>* streamer) {
                       return this->StreamedSLL2RegOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RegMsg* /*request*/, ::service_layer::SLL2RegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2RegOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2RegMsg,::service_layer::SLL2RegMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>* streamer) {
                       return this->StreamedSLL2BdRegOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2BdRegMsg* /*request*/, ::service_layer::SLL2BdRegMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2BdRegOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2BdRegMsg,::service_layer::SLL2BdRegMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* streamer) {
                       return this->StreamedSLL2RouteOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* /*context*/, const ::service_layer::SLL2RouteMsg* /*request*/, ::service_layer::SLL2RouteMsgRsp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2RouteOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2RouteMsg,::service_layer::SLL2RouteMsgRsp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SLL2GlobalsGet<WithStreamedUnaryMethod_SLL2RegOp<WithStreamedUnaryMethod_SLL2BdRegOp<WithStreamedUnaryMethod_SLL2RouteOp<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SLL2GlobalsGet<WithStreamedUnaryMethod_SLL2RegOp<WithStreamedUnaryMethod_SLL2BdRegOp<WithStreamedUnaryMethod_SLL2RouteOp<Service > > > > StreamedService;
};
// @addtogroup SLRouteL2Oper
// @{
// ;

}  // namespace service_layer


#endif  // GRPC_sl_5fl2_5froute_2eproto__INCLUDED
