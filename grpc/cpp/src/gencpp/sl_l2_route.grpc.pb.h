// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sl_l2_route.proto
// Original file comments:
// @file
// @brief Server RPC proto file for L2 routes.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016 by cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//
//
#ifndef GRPC_sl_5fl2_5froute_2eproto__INCLUDED
#define GRPC_sl_5fl2_5froute_2eproto__INCLUDED

#include "sl_l2_route.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace service_layer {

// @defgroup SLRouteL2Oper
// @ingroup L2Route
// Defines RPC calls for L2 route changes and Bridge-Domain (BD) registration.
// This service declares calls for adding, deleting, updating and getting
// L2 routes.
// @{
class SLL2Oper final {
 public:
  static constexpr char const* service_full_name() {
    return "service_layer.SLL2Oper";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Global L2 route operations
    //
    //
    // Used to retrieve global L2 info from the server.
    virtual ::grpc::Status SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::service_layer::SLL2GlobalsGetMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>> AsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>>(AsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>> PrepareAsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>>(PrepareAsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    //
    // L2 Registration Operations
    //
    //
    // SLL2RegMsg.Oper = SL_REGOP_REGISTER:
    //     Global L2 registration.
    //     A client Must Register BEFORE sending BD registration messages
    //     (to add/update/delete routes) or BEFORE requesting for L2 route
    //     notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
    //     Global L2 un-registration.
    //     This call is used to convey that the client is no longer
    //     interested in programming L2 routes and in receiving L2 route
    //     notifications. All programmed L2 routes will be deleted on the
    //     server and the server will stop sending L2 route notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_EOF:
    //     Global L2 End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known
    //     objects and to convey the end of requests for L2 route
    //     notifications.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::service_layer::SLL2RegMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>> AsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>>(AsyncSLL2RegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>> PrepareAsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>>(PrepareAsyncSLL2RegOpRaw(context, request, cq));
    }
    //
    // L2 Bridge-Domain (BD) Registration Operations
    //
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
    //     BD registration: Sends a list of BD registration messages and
    //     expects a list of registration responses.
    //     A client Must Register a BD BEFORE L2 Routes can be added/modified
    //     in that BD.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
    //     BD un-registration: Sends a list of BD un-registration messages
    //     and expects a list of un-registration responses.
    //     This can be used to convey that the client is no longer
    //     interested in programming routes in this BD. All installed L2
    //     routes will be lost.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_EOF:
    //     BD End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known objects
    //     in that BD.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::service_layer::SLL2BdRegMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>> AsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>>(AsyncSLL2BdRegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>> PrepareAsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>>(PrepareAsyncSLL2BdRegOpRaw(context, request, cq));
    }
    //
    // L2 Route Operations
    //
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_ADD:
    // Route add. Fails if the route already exists.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
    // Route update. Creates or updates the route.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
    // Route delete. The route path is not necessary to delete the route.
    //
    virtual ::grpc::Status SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::service_layer::SLL2RouteMsgRsp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpRaw(context, request, cq));
    }
    //
    // L2 Stream Route Operations
    //
    //
    // Stream adds/updates/deletes of L2 Routes.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> SLL2RouteOpStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(SLL2RouteOpStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpStreamRaw(context, cq));
    }
    //
    // L2 Route Redistribution Operations
    //
    //
    // This call is used to get a stream of BD state and route notifications.
    // It can be used to get "push" notifications for route
    // adds/updates/deletes.
    // The caller must maintain the GRPC channel as long as there is
    // interest in route notifications.
    //
    // The call takes 3 types of notification requests:
    // 1. Request for BD state notifications only (pass only Oper and
    //    Correlator).
    // 2. Request for BD state and Route notifications in all BDs.
    // 3. Request for Route notifications per-BD.
    //    This should be sent after requesting for BD state notifications
    //    and after receiving BD-ready notification.
    //
    // The success/failure of the notification request is relayed in the
    // SLL2NotifStatusMsg followed by a Start marker, any routes if present,
    // and an End Marker.
    //
    // After all requests are sent, client should send GetNotifEof = TRUE.
    //
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> SLL2GetNotifStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(SLL2GetNotifStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> AsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(AsyncSLL2GetNotifStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> PrepareAsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(PrepareAsyncSLL2GetNotifStreamRaw(context, cq));
    }
    // @}
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>* AsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2GlobalsGetMsgRsp>* PrepareAsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>* AsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RegMsgRsp>* PrepareAsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>* AsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2BdRegMsgRsp>* PrepareAsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* SLL2RouteOpStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* SLL2GetNotifStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* AsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* PrepareAsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::service_layer::SLL2GlobalsGetMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>> AsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>>(AsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>> PrepareAsyncSLL2GlobalsGet(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>>(PrepareAsyncSLL2GlobalsGetRaw(context, request, cq));
    }
    ::grpc::Status SLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::service_layer::SLL2RegMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>> AsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>>(AsyncSLL2RegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>> PrepareAsyncSLL2RegOp(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>>(PrepareAsyncSLL2RegOpRaw(context, request, cq));
    }
    ::grpc::Status SLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::service_layer::SLL2BdRegMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>> AsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>>(AsyncSLL2BdRegOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>> PrepareAsyncSLL2BdRegOp(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>>(PrepareAsyncSLL2BdRegOpRaw(context, request, cq));
    }
    ::grpc::Status SLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::service_layer::SLL2RouteMsgRsp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOp(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> SLL2RouteOpStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(SLL2RouteOpStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> AsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(AsyncSLL2RouteOpStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>> PrepareAsyncSLL2RouteOpStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>>(PrepareAsyncSLL2RouteOpStreamRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> SLL2GetNotifStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(SLL2GetNotifStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> AsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(AsyncSLL2GetNotifStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>> PrepareAsyncSLL2GetNotifStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>>(PrepareAsyncSLL2GetNotifStreamRaw(context, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>* AsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2GlobalsGetMsgRsp>* PrepareAsyncSLL2GlobalsGetRaw(::grpc::ClientContext* context, const ::service_layer::SLL2GlobalsGetMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>* AsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RegMsgRsp>* PrepareAsyncSLL2RegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>* AsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2BdRegMsgRsp>* PrepareAsyncSLL2BdRegOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2BdRegMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpRaw(::grpc::ClientContext* context, const ::service_layer::SLL2RouteMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* SLL2RouteOpStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* AsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>* PrepareAsyncSLL2RouteOpStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* SLL2GetNotifStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* AsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::service_layer::SLL2GetNotifMsg, ::service_layer::SLL2Notif>* PrepareAsyncSLL2GetNotifStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2GlobalsGet_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RegOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2BdRegOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RouteOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2RouteOpStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SLL2GetNotifStream_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Global L2 route operations
    //
    //
    // Used to retrieve global L2 info from the server.
    virtual ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response);
    //
    // L2 Registration Operations
    //
    //
    // SLL2RegMsg.Oper = SL_REGOP_REGISTER:
    //     Global L2 registration.
    //     A client Must Register BEFORE sending BD registration messages
    //     (to add/update/delete routes) or BEFORE requesting for L2 route
    //     notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
    //     Global L2 un-registration.
    //     This call is used to convey that the client is no longer
    //     interested in programming L2 routes and in receiving L2 route
    //     notifications. All programmed L2 routes will be deleted on the
    //     server and the server will stop sending L2 route notifications.
    //
    // SLL2RegMsg.Oper = SL_REGOP_EOF:
    //     Global L2 End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known
    //     objects and to convey the end of requests for L2 route
    //     notifications.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2RegOp(::grpc::ServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response);
    //
    // L2 Bridge-Domain (BD) Registration Operations
    //
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
    //     BD registration: Sends a list of BD registration messages and
    //     expects a list of registration responses.
    //     A client Must Register a BD BEFORE L2 Routes can be added/modified
    //     in that BD.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
    //     BD un-registration: Sends a list of BD un-registration messages
    //     and expects a list of un-registration responses.
    //     This can be used to convey that the client is no longer
    //     interested in programming routes in this BD. All installed L2
    //     routes will be lost.
    //
    // SLL2BdRegMsg.Oper = SL_REGOP_EOF:
    //     BD End Of File message.
    //     After Registration, the client is expected to send an EOF
    //     message to convey the end of replay of the client's known objects
    //     in that BD.
    //     This is especially useful under certain restart scenarios when the
    //     client and the server are trying to synchronize their routes.
    //
    virtual ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response);
    //
    // L2 Route Operations
    //
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_ADD:
    // Route add. Fails if the route already exists.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
    // Route update. Creates or updates the route.
    //
    // SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
    // Route delete. The route path is not necessary to delete the route.
    //
    virtual ::grpc::Status SLL2RouteOp(::grpc::ServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response);
    //
    // L2 Stream Route Operations
    //
    //
    // Stream adds/updates/deletes of L2 Routes.
    virtual ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream);
    //
    // L2 Route Redistribution Operations
    //
    //
    // This call is used to get a stream of BD state and route notifications.
    // It can be used to get "push" notifications for route
    // adds/updates/deletes.
    // The caller must maintain the GRPC channel as long as there is
    // interest in route notifications.
    //
    // The call takes 3 types of notification requests:
    // 1. Request for BD state notifications only (pass only Oper and
    //    Correlator).
    // 2. Request for BD state and Route notifications in all BDs.
    // 3. Request for Route notifications per-BD.
    //    This should be sent after requesting for BD state notifications
    //    and after receiving BD-ready notification.
    //
    // The success/failure of the notification request is relayed in the
    // SLL2NotifStatusMsg followed by a Start marker, any routes if present,
    // and an End Marker.
    //
    // After all requests are sent, client should send GetNotifEof = TRUE.
    //
    virtual ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream);
    // @}
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GlobalsGet(::grpc::ServerContext* context, ::service_layer::SLL2GlobalsGetMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2GlobalsGetMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RegOp(::grpc::ServerContext* context, ::service_layer::SLL2RegMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2RegMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2BdRegOp(::grpc::ServerContext* context, ::service_layer::SLL2BdRegMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2BdRegMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOp(::grpc::ServerContext* context, ::service_layer::SLL2RouteMsg* request, ::grpc::ServerAsyncResponseWriter< ::service_layer::SLL2RouteMsgRsp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(5, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SLL2GlobalsGet<WithAsyncMethod_SLL2RegOp<WithAsyncMethod_SLL2BdRegOp<WithAsyncMethod_SLL2RouteOp<WithAsyncMethod_SLL2RouteOpStream<WithAsyncMethod_SLL2GetNotifStream<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2RouteOpStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2RouteOpStream() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SLL2RouteOpStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2RouteOpStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2RouteMsgRsp, ::service_layer::SLL2RouteMsg>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SLL2GetNotifStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SLL2GetNotifStream() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SLL2GetNotifStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SLL2GetNotifStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::service_layer::SLL2Notif, ::service_layer::SLL2GetNotifMsg>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2GlobalsGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SLL2GlobalsGet() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::service_layer::SLL2GlobalsGetMsg, ::service_layer::SLL2GlobalsGetMsgRsp>(std::bind(&WithStreamedUnaryMethod_SLL2GlobalsGet<BaseClass>::StreamedSLL2GlobalsGet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SLL2GlobalsGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2GlobalsGet(::grpc::ServerContext* context, const ::service_layer::SLL2GlobalsGetMsg* request, ::service_layer::SLL2GlobalsGetMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2GlobalsGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2GlobalsGetMsg,::service_layer::SLL2GlobalsGetMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2RegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SLL2RegOp() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::service_layer::SLL2RegMsg, ::service_layer::SLL2RegMsgRsp>(std::bind(&WithStreamedUnaryMethod_SLL2RegOp<BaseClass>::StreamedSLL2RegOp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SLL2RegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2RegOp(::grpc::ServerContext* context, const ::service_layer::SLL2RegMsg* request, ::service_layer::SLL2RegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2RegOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2RegMsg,::service_layer::SLL2RegMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2BdRegOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SLL2BdRegOp() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::service_layer::SLL2BdRegMsg, ::service_layer::SLL2BdRegMsgRsp>(std::bind(&WithStreamedUnaryMethod_SLL2BdRegOp<BaseClass>::StreamedSLL2BdRegOp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SLL2BdRegOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2BdRegOp(::grpc::ServerContext* context, const ::service_layer::SLL2BdRegMsg* request, ::service_layer::SLL2BdRegMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2BdRegOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2BdRegMsg,::service_layer::SLL2BdRegMsgRsp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SLL2RouteOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SLL2RouteOp() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::service_layer::SLL2RouteMsg, ::service_layer::SLL2RouteMsgRsp>(std::bind(&WithStreamedUnaryMethod_SLL2RouteOp<BaseClass>::StreamedSLL2RouteOp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SLL2RouteOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SLL2RouteOp(::grpc::ServerContext* context, const ::service_layer::SLL2RouteMsg* request, ::service_layer::SLL2RouteMsgRsp* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSLL2RouteOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::service_layer::SLL2RouteMsg,::service_layer::SLL2RouteMsgRsp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SLL2GlobalsGet<WithStreamedUnaryMethod_SLL2RegOp<WithStreamedUnaryMethod_SLL2BdRegOp<WithStreamedUnaryMethod_SLL2RouteOp<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SLL2GlobalsGet<WithStreamedUnaryMethod_SLL2RegOp<WithStreamedUnaryMethod_SLL2BdRegOp<WithStreamedUnaryMethod_SLL2RouteOp<Service > > > > StreamedService;
};
// @addtogroup SLRouteL2Oper
// @{
// ;

}  // namespace service_layer


#endif  // GRPC_sl_5fl2_5froute_2eproto__INCLUDED
