// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_l2_route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5fl2_5froute_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5fl2_5froute_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5fl2_5froute_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5fl2_5froute_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5fl2_5froute_2eproto;
namespace service_layer {
class SLL2BdRegMsg;
struct SLL2BdRegMsgDefaultTypeInternal;
extern SLL2BdRegMsgDefaultTypeInternal _SLL2BdRegMsg_default_instance_;
class SLL2BdRegMsgRsp;
struct SLL2BdRegMsgRspDefaultTypeInternal;
extern SLL2BdRegMsgRspDefaultTypeInternal _SLL2BdRegMsgRsp_default_instance_;
class SLL2BdRegRes;
struct SLL2BdRegResDefaultTypeInternal;
extern SLL2BdRegResDefaultTypeInternal _SLL2BdRegRes_default_instance_;
class SLL2BdStateInfo;
struct SLL2BdStateInfoDefaultTypeInternal;
extern SLL2BdStateInfoDefaultTypeInternal _SLL2BdStateInfo_default_instance_;
class SLL2GetNotifMsg;
struct SLL2GetNotifMsgDefaultTypeInternal;
extern SLL2GetNotifMsgDefaultTypeInternal _SLL2GetNotifMsg_default_instance_;
class SLL2GlobalsGetMsg;
struct SLL2GlobalsGetMsgDefaultTypeInternal;
extern SLL2GlobalsGetMsgDefaultTypeInternal _SLL2GlobalsGetMsg_default_instance_;
class SLL2GlobalsGetMsgRsp;
struct SLL2GlobalsGetMsgRspDefaultTypeInternal;
extern SLL2GlobalsGetMsgRspDefaultTypeInternal _SLL2GlobalsGetMsgRsp_default_instance_;
class SLL2ImetRoute;
struct SLL2ImetRouteDefaultTypeInternal;
extern SLL2ImetRouteDefaultTypeInternal _SLL2ImetRoute_default_instance_;
class SLL2ImetRouteKey;
struct SLL2ImetRouteKeyDefaultTypeInternal;
extern SLL2ImetRouteKeyDefaultTypeInternal _SLL2ImetRouteKey_default_instance_;
class SLL2MacRoute;
struct SLL2MacRouteDefaultTypeInternal;
extern SLL2MacRouteDefaultTypeInternal _SLL2MacRoute_default_instance_;
class SLL2MacRouteKey;
struct SLL2MacRouteKeyDefaultTypeInternal;
extern SLL2MacRouteKeyDefaultTypeInternal _SLL2MacRouteKey_default_instance_;
class SLL2Notif;
struct SLL2NotifDefaultTypeInternal;
extern SLL2NotifDefaultTypeInternal _SLL2Notif_default_instance_;
class SLL2NotifStatusMsg;
struct SLL2NotifStatusMsgDefaultTypeInternal;
extern SLL2NotifStatusMsgDefaultTypeInternal _SLL2NotifStatusMsg_default_instance_;
class SLL2OverlayNh;
struct SLL2OverlayNhDefaultTypeInternal;
extern SLL2OverlayNhDefaultTypeInternal _SLL2OverlayNh_default_instance_;
class SLL2RegMsg;
struct SLL2RegMsgDefaultTypeInternal;
extern SLL2RegMsgDefaultTypeInternal _SLL2RegMsg_default_instance_;
class SLL2RegMsgRsp;
struct SLL2RegMsgRspDefaultTypeInternal;
extern SLL2RegMsgRspDefaultTypeInternal _SLL2RegMsgRsp_default_instance_;
class SLL2Route;
struct SLL2RouteDefaultTypeInternal;
extern SLL2RouteDefaultTypeInternal _SLL2Route_default_instance_;
class SLL2RouteEsi;
struct SLL2RouteEsiDefaultTypeInternal;
extern SLL2RouteEsiDefaultTypeInternal _SLL2RouteEsi_default_instance_;
class SLL2RouteKey;
struct SLL2RouteKeyDefaultTypeInternal;
extern SLL2RouteKeyDefaultTypeInternal _SLL2RouteKey_default_instance_;
class SLL2RouteMsg;
struct SLL2RouteMsgDefaultTypeInternal;
extern SLL2RouteMsgDefaultTypeInternal _SLL2RouteMsg_default_instance_;
class SLL2RouteMsgRsp;
struct SLL2RouteMsgRspDefaultTypeInternal;
extern SLL2RouteMsgRspDefaultTypeInternal _SLL2RouteMsgRsp_default_instance_;
class SLL2RouteNh;
struct SLL2RouteNhDefaultTypeInternal;
extern SLL2RouteNhDefaultTypeInternal _SLL2RouteNh_default_instance_;
class SLL2RouteNotif;
struct SLL2RouteNotifDefaultTypeInternal;
extern SLL2RouteNotifDefaultTypeInternal _SLL2RouteNotif_default_instance_;
class SLL2RouteRes;
struct SLL2RouteResDefaultTypeInternal;
extern SLL2RouteResDefaultTypeInternal _SLL2RouteRes_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLL2BdRegMsg* Arena::CreateMaybeMessage<::service_layer::SLL2BdRegMsg>(Arena*);
template<> ::service_layer::SLL2BdRegMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLL2BdRegMsgRsp>(Arena*);
template<> ::service_layer::SLL2BdRegRes* Arena::CreateMaybeMessage<::service_layer::SLL2BdRegRes>(Arena*);
template<> ::service_layer::SLL2BdStateInfo* Arena::CreateMaybeMessage<::service_layer::SLL2BdStateInfo>(Arena*);
template<> ::service_layer::SLL2GetNotifMsg* Arena::CreateMaybeMessage<::service_layer::SLL2GetNotifMsg>(Arena*);
template<> ::service_layer::SLL2GlobalsGetMsg* Arena::CreateMaybeMessage<::service_layer::SLL2GlobalsGetMsg>(Arena*);
template<> ::service_layer::SLL2GlobalsGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLL2GlobalsGetMsgRsp>(Arena*);
template<> ::service_layer::SLL2ImetRoute* Arena::CreateMaybeMessage<::service_layer::SLL2ImetRoute>(Arena*);
template<> ::service_layer::SLL2ImetRouteKey* Arena::CreateMaybeMessage<::service_layer::SLL2ImetRouteKey>(Arena*);
template<> ::service_layer::SLL2MacRoute* Arena::CreateMaybeMessage<::service_layer::SLL2MacRoute>(Arena*);
template<> ::service_layer::SLL2MacRouteKey* Arena::CreateMaybeMessage<::service_layer::SLL2MacRouteKey>(Arena*);
template<> ::service_layer::SLL2Notif* Arena::CreateMaybeMessage<::service_layer::SLL2Notif>(Arena*);
template<> ::service_layer::SLL2NotifStatusMsg* Arena::CreateMaybeMessage<::service_layer::SLL2NotifStatusMsg>(Arena*);
template<> ::service_layer::SLL2OverlayNh* Arena::CreateMaybeMessage<::service_layer::SLL2OverlayNh>(Arena*);
template<> ::service_layer::SLL2RegMsg* Arena::CreateMaybeMessage<::service_layer::SLL2RegMsg>(Arena*);
template<> ::service_layer::SLL2RegMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLL2RegMsgRsp>(Arena*);
template<> ::service_layer::SLL2Route* Arena::CreateMaybeMessage<::service_layer::SLL2Route>(Arena*);
template<> ::service_layer::SLL2RouteEsi* Arena::CreateMaybeMessage<::service_layer::SLL2RouteEsi>(Arena*);
template<> ::service_layer::SLL2RouteKey* Arena::CreateMaybeMessage<::service_layer::SLL2RouteKey>(Arena*);
template<> ::service_layer::SLL2RouteMsg* Arena::CreateMaybeMessage<::service_layer::SLL2RouteMsg>(Arena*);
template<> ::service_layer::SLL2RouteMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLL2RouteMsgRsp>(Arena*);
template<> ::service_layer::SLL2RouteNh* Arena::CreateMaybeMessage<::service_layer::SLL2RouteNh>(Arena*);
template<> ::service_layer::SLL2RouteNotif* Arena::CreateMaybeMessage<::service_layer::SLL2RouteNotif>(Arena*);
template<> ::service_layer::SLL2RouteRes* Arena::CreateMaybeMessage<::service_layer::SLL2RouteRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

enum SLL2RouteNh_SLL2RouteNhType : int {
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED = 0,
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_INTERFACE = 1,
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY = 2,
  SLL2RouteNh_SLL2RouteNhType_SLL2RouteNh_SLL2RouteNhType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLL2RouteNh_SLL2RouteNhType_SLL2RouteNh_SLL2RouteNhType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLL2RouteNh_SLL2RouteNhType_IsValid(int value);
constexpr SLL2RouteNh_SLL2RouteNhType SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MIN = SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED;
constexpr SLL2RouteNh_SLL2RouteNhType SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX = SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY;
constexpr int SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_ARRAYSIZE = SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLL2RouteNh_SLL2RouteNhType_descriptor();
template<typename T>
inline const std::string& SLL2RouteNh_SLL2RouteNhType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLL2RouteNh_SLL2RouteNhType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLL2RouteNh_SLL2RouteNhType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLL2RouteNh_SLL2RouteNhType_descriptor(), enum_t_value);
}
inline bool SLL2RouteNh_SLL2RouteNhType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLL2RouteNh_SLL2RouteNhType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLL2RouteNh_SLL2RouteNhType>(
    SLL2RouteNh_SLL2RouteNhType_descriptor(), name, value);
}
enum SLL2ImetRoute_PMSITunnelType : int {
  SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL = 0,
  SLL2ImetRoute_PMSITunnelType_PMSI_RSVPP2MP_TUNNEL = 1,
  SLL2ImetRoute_PMSITunnelType_PMSI_MLDPP2MP_TUNNEL = 2,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMSSM_TUNNEL = 3,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMSM_TUNNEL = 4,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMBIDIR_TUNNEL = 5,
  SLL2ImetRoute_PMSITunnelType_PMSI_INGREP_TUNNEL = 6,
  SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL = 7,
  SLL2ImetRoute_PMSITunnelType_SLL2ImetRoute_PMSITunnelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLL2ImetRoute_PMSITunnelType_SLL2ImetRoute_PMSITunnelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLL2ImetRoute_PMSITunnelType_IsValid(int value);
constexpr SLL2ImetRoute_PMSITunnelType SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MIN = SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL;
constexpr SLL2ImetRoute_PMSITunnelType SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX = SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL;
constexpr int SLL2ImetRoute_PMSITunnelType_PMSITunnelType_ARRAYSIZE = SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLL2ImetRoute_PMSITunnelType_descriptor();
template<typename T>
inline const std::string& SLL2ImetRoute_PMSITunnelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLL2ImetRoute_PMSITunnelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLL2ImetRoute_PMSITunnelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLL2ImetRoute_PMSITunnelType_descriptor(), enum_t_value);
}
inline bool SLL2ImetRoute_PMSITunnelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLL2ImetRoute_PMSITunnelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLL2ImetRoute_PMSITunnelType>(
    SLL2ImetRoute_PMSITunnelType_descriptor(), name, value);
}
enum SLL2BdStateInfo_SLL2BdState : int {
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED = 0,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_ADDED = 1,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_DELETED = 2,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED = 3,
  SLL2BdStateInfo_SLL2BdState_SLL2BdStateInfo_SLL2BdState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLL2BdStateInfo_SLL2BdState_SLL2BdStateInfo_SLL2BdState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLL2BdStateInfo_SLL2BdState_IsValid(int value);
constexpr SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo_SLL2BdState_SLL2BdState_MIN = SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED;
constexpr SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX = SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED;
constexpr int SLL2BdStateInfo_SLL2BdState_SLL2BdState_ARRAYSIZE = SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLL2BdStateInfo_SLL2BdState_descriptor();
template<typename T>
inline const std::string& SLL2BdStateInfo_SLL2BdState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLL2BdStateInfo_SLL2BdState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLL2BdStateInfo_SLL2BdState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLL2BdStateInfo_SLL2BdState_descriptor(), enum_t_value);
}
inline bool SLL2BdStateInfo_SLL2BdState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLL2BdStateInfo_SLL2BdState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLL2BdStateInfo_SLL2BdState>(
    SLL2BdStateInfo_SLL2BdState_descriptor(), name, value);
}
enum SLL2RouteType : int {
  SL_L2_ROUTE_RESERVED = 0,
  SL_L2_ROUTE_MAC = 1,
  SL_L2_ROUTE_IMET = 2,
  SLL2RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLL2RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLL2RouteType_IsValid(int value);
constexpr SLL2RouteType SLL2RouteType_MIN = SL_L2_ROUTE_RESERVED;
constexpr SLL2RouteType SLL2RouteType_MAX = SL_L2_ROUTE_IMET;
constexpr int SLL2RouteType_ARRAYSIZE = SLL2RouteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLL2RouteType_descriptor();
template<typename T>
inline const std::string& SLL2RouteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLL2RouteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLL2RouteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLL2RouteType_descriptor(), enum_t_value);
}
inline bool SLL2RouteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLL2RouteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLL2RouteType>(
    SLL2RouteType_descriptor(), name, value);
}
enum SLL2NotifType : int {
  SL_L2_EVENT_TYPE_RESERVED = 0,
  SL_L2_EVENT_TYPE_ERROR = 1,
  SL_L2_EVENT_TYPE_STATUS = 2,
  SL_L2_EVENT_TYPE_START_MARKER = 3,
  SL_L2_EVENT_TYPE_BD_STATE = 4,
  SL_L2_EVENT_TYPE_BD_STATE_END_MARKER = 5,
  SL_L2_EVENT_TYPE_ROUTE = 6,
  SL_L2_EVENT_TYPE_ROUTE_END_MARKER = 7,
  SLL2NotifType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLL2NotifType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLL2NotifType_IsValid(int value);
constexpr SLL2NotifType SLL2NotifType_MIN = SL_L2_EVENT_TYPE_RESERVED;
constexpr SLL2NotifType SLL2NotifType_MAX = SL_L2_EVENT_TYPE_ROUTE_END_MARKER;
constexpr int SLL2NotifType_ARRAYSIZE = SLL2NotifType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLL2NotifType_descriptor();
template<typename T>
inline const std::string& SLL2NotifType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLL2NotifType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLL2NotifType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLL2NotifType_descriptor(), enum_t_value);
}
inline bool SLL2NotifType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLL2NotifType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLL2NotifType>(
    SLL2NotifType_descriptor(), name, value);
}
// ===================================================================

class SLL2GlobalsGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:service_layer.SLL2GlobalsGetMsg) */ {
 public:
  inline SLL2GlobalsGetMsg() : SLL2GlobalsGetMsg(nullptr) {}
  explicit constexpr SLL2GlobalsGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2GlobalsGetMsg(const SLL2GlobalsGetMsg& from);
  SLL2GlobalsGetMsg(SLL2GlobalsGetMsg&& from) noexcept
    : SLL2GlobalsGetMsg() {
    *this = ::std::move(from);
  }

  inline SLL2GlobalsGetMsg& operator=(const SLL2GlobalsGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2GlobalsGetMsg& operator=(SLL2GlobalsGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2GlobalsGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2GlobalsGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2GlobalsGetMsg*>(
               &_SLL2GlobalsGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLL2GlobalsGetMsg& a, SLL2GlobalsGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2GlobalsGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2GlobalsGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2GlobalsGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2GlobalsGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLL2GlobalsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLL2GlobalsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2GlobalsGetMsg";
  }
  protected:
  explicit SLL2GlobalsGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLL2GlobalsGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2GlobalsGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2GlobalsGetMsgRsp) */ {
 public:
  inline SLL2GlobalsGetMsgRsp() : SLL2GlobalsGetMsgRsp(nullptr) {}
  ~SLL2GlobalsGetMsgRsp() override;
  explicit constexpr SLL2GlobalsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2GlobalsGetMsgRsp(const SLL2GlobalsGetMsgRsp& from);
  SLL2GlobalsGetMsgRsp(SLL2GlobalsGetMsgRsp&& from) noexcept
    : SLL2GlobalsGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2GlobalsGetMsgRsp& operator=(const SLL2GlobalsGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2GlobalsGetMsgRsp& operator=(SLL2GlobalsGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2GlobalsGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2GlobalsGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2GlobalsGetMsgRsp*>(
               &_SLL2GlobalsGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLL2GlobalsGetMsgRsp& a, SLL2GlobalsGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2GlobalsGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2GlobalsGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2GlobalsGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2GlobalsGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2GlobalsGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2GlobalsGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2GlobalsGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2GlobalsGetMsgRsp";
  }
  protected:
  explicit SLL2GlobalsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kMaxBdRegPerBdRegmsgFieldNumber = 2,
    kMaxRoutePerRoutemsgFieldNumber = 3,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint32 MaxBdRegPerBdRegmsg = 2;
  void clear_maxbdregperbdregmsg();
  uint32_t maxbdregperbdregmsg() const;
  void set_maxbdregperbdregmsg(uint32_t value);
  private:
  uint32_t _internal_maxbdregperbdregmsg() const;
  void _internal_set_maxbdregperbdregmsg(uint32_t value);
  public:

  // uint32 MaxRoutePerRoutemsg = 3;
  void clear_maxrouteperroutemsg();
  uint32_t maxrouteperroutemsg() const;
  void set_maxrouteperroutemsg(uint32_t value);
  private:
  uint32_t _internal_maxrouteperroutemsg() const;
  void _internal_set_maxrouteperroutemsg(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2GlobalsGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint32_t maxbdregperbdregmsg_;
  uint32_t maxrouteperroutemsg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RegMsg) */ {
 public:
  inline SLL2RegMsg() : SLL2RegMsg(nullptr) {}
  ~SLL2RegMsg() override;
  explicit constexpr SLL2RegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RegMsg(const SLL2RegMsg& from);
  SLL2RegMsg(SLL2RegMsg&& from) noexcept
    : SLL2RegMsg() {
    *this = ::std::move(from);
  }

  inline SLL2RegMsg& operator=(const SLL2RegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RegMsg& operator=(SLL2RegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RegMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2RegMsg*>(
               &_SLL2RegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLL2RegMsg& a, SLL2RegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RegMsg";
  }
  protected:
  explicit SLL2RegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kPurgeIntervalSecondsFieldNumber = 3,
  };
  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);
  private:
  ::service_layer::SLRegOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLRegOp value);
  public:

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 PurgeIntervalSeconds = 3;
  void clear_purgeintervalseconds();
  uint32_t purgeintervalseconds() const;
  void set_purgeintervalseconds(uint32_t value);
  private:
  uint32_t _internal_purgeintervalseconds() const;
  void _internal_set_purgeintervalseconds(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int oper_;
  uint32_t admindistance_;
  uint32_t purgeintervalseconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RegMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RegMsgRsp) */ {
 public:
  inline SLL2RegMsgRsp() : SLL2RegMsgRsp(nullptr) {}
  ~SLL2RegMsgRsp() override;
  explicit constexpr SLL2RegMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RegMsgRsp(const SLL2RegMsgRsp& from);
  SLL2RegMsgRsp(SLL2RegMsgRsp&& from) noexcept
    : SLL2RegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2RegMsgRsp& operator=(const SLL2RegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RegMsgRsp& operator=(SLL2RegMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RegMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2RegMsgRsp*>(
               &_SLL2RegMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLL2RegMsgRsp& a, SLL2RegMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RegMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RegMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RegMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RegMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RegMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RegMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RegMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RegMsgRsp";
  }
  protected:
  explicit SLL2RegMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegStatusFieldNumber = 1,
  };
  // .service_layer.SLErrorStatus RegStatus = 1;
  bool has_regstatus() const;
  private:
  bool _internal_has_regstatus() const;
  public:
  void clear_regstatus();
  const ::service_layer::SLErrorStatus& regstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_regstatus();
  ::service_layer::SLErrorStatus* mutable_regstatus();
  void set_allocated_regstatus(::service_layer::SLErrorStatus* regstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_regstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_regstatus();
  public:
  void unsafe_arena_set_allocated_regstatus(
      ::service_layer::SLErrorStatus* regstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_regstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RegMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* regstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2BdRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegMsg) */ {
 public:
  inline SLL2BdRegMsg() : SLL2BdRegMsg(nullptr) {}
  ~SLL2BdRegMsg() override;
  explicit constexpr SLL2BdRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2BdRegMsg(const SLL2BdRegMsg& from);
  SLL2BdRegMsg(SLL2BdRegMsg&& from) noexcept
    : SLL2BdRegMsg() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegMsg& operator=(const SLL2BdRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2BdRegMsg& operator=(SLL2BdRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2BdRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2BdRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegMsg*>(
               &_SLL2BdRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLL2BdRegMsg& a, SLL2BdRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2BdRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2BdRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2BdRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2BdRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2BdRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2BdRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2BdRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2BdRegMsg";
  }
  protected:
  explicit SLL2BdRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBdRegNameFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated string BdRegName = 2;
  int bdregname_size() const;
  private:
  int _internal_bdregname_size() const;
  public:
  void clear_bdregname();
  const std::string& bdregname(int index) const;
  std::string* mutable_bdregname(int index);
  void set_bdregname(int index, const std::string& value);
  void set_bdregname(int index, std::string&& value);
  void set_bdregname(int index, const char* value);
  void set_bdregname(int index, const char* value, size_t size);
  std::string* add_bdregname();
  void add_bdregname(const std::string& value);
  void add_bdregname(std::string&& value);
  void add_bdregname(const char* value);
  void add_bdregname(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bdregname() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bdregname();
  private:
  const std::string& _internal_bdregname(int index) const;
  std::string* _internal_add_bdregname();
  public:

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);
  private:
  ::service_layer::SLRegOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLRegOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bdregname_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2BdRegRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegRes) */ {
 public:
  inline SLL2BdRegRes() : SLL2BdRegRes(nullptr) {}
  ~SLL2BdRegRes() override;
  explicit constexpr SLL2BdRegRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2BdRegRes(const SLL2BdRegRes& from);
  SLL2BdRegRes(SLL2BdRegRes&& from) noexcept
    : SLL2BdRegRes() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegRes& operator=(const SLL2BdRegRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2BdRegRes& operator=(SLL2BdRegRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2BdRegRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2BdRegRes* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegRes*>(
               &_SLL2BdRegRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLL2BdRegRes& a, SLL2BdRegRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2BdRegRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2BdRegRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2BdRegRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2BdRegRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2BdRegRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2BdRegRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2BdRegRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2BdRegRes";
  }
  protected:
  explicit SLL2BdRegRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBdNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
  };
  // string BdName = 2;
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  ::service_layer::SLErrorStatus* errstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2BdRegMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegMsgRsp) */ {
 public:
  inline SLL2BdRegMsgRsp() : SLL2BdRegMsgRsp(nullptr) {}
  ~SLL2BdRegMsgRsp() override;
  explicit constexpr SLL2BdRegMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2BdRegMsgRsp(const SLL2BdRegMsgRsp& from);
  SLL2BdRegMsgRsp(SLL2BdRegMsgRsp&& from) noexcept
    : SLL2BdRegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegMsgRsp& operator=(const SLL2BdRegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2BdRegMsgRsp& operator=(SLL2BdRegMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2BdRegMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2BdRegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegMsgRsp*>(
               &_SLL2BdRegMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLL2BdRegMsgRsp& a, SLL2BdRegMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2BdRegMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2BdRegMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2BdRegMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2BdRegMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2BdRegMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2BdRegMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2BdRegMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2BdRegMsgRsp";
  }
  protected:
  explicit SLL2BdRegMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kStatusSummaryFieldNumber = 1,
  };
  // repeated .service_layer.SLL2BdRegRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLL2BdRegRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2BdRegRes >*
      mutable_results();
  private:
  const ::service_layer::SLL2BdRegRes& _internal_results(int index) const;
  ::service_layer::SLL2BdRegRes* _internal_add_results();
  public:
  const ::service_layer::SLL2BdRegRes& results(int index) const;
  ::service_layer::SLL2BdRegRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2BdRegRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 1;
  bool has_statussummary() const;
  private:
  bool _internal_has_statussummary() const;
  public:
  void clear_statussummary();
  const ::service_layer::SLErrorStatus& statussummary() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);
  private:
  const ::service_layer::SLErrorStatus& _internal_statussummary() const;
  ::service_layer::SLErrorStatus* _internal_mutable_statussummary();
  public:
  void unsafe_arena_set_allocated_statussummary(
      ::service_layer::SLErrorStatus* statussummary);
  ::service_layer::SLErrorStatus* unsafe_arena_release_statussummary();

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2BdRegRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteEsi final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteEsi) */ {
 public:
  inline SLL2RouteEsi() : SLL2RouteEsi(nullptr) {}
  ~SLL2RouteEsi() override;
  explicit constexpr SLL2RouteEsi(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteEsi(const SLL2RouteEsi& from);
  SLL2RouteEsi(SLL2RouteEsi&& from) noexcept
    : SLL2RouteEsi() {
    *this = ::std::move(from);
  }

  inline SLL2RouteEsi& operator=(const SLL2RouteEsi& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteEsi& operator=(SLL2RouteEsi&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteEsi& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RouteEsi* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteEsi*>(
               &_SLL2RouteEsi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLL2RouteEsi& a, SLL2RouteEsi& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteEsi* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteEsi* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteEsi* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteEsi>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteEsi& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteEsi& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteEsi* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteEsi";
  }
  protected:
  explicit SLL2RouteEsi(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEsiFieldNumber = 1,
  };
  // bytes Esi = 1;
  void clear_esi();
  const std::string& esi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_esi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_esi();
  PROTOBUF_NODISCARD std::string* release_esi();
  void set_allocated_esi(std::string* esi);
  private:
  const std::string& _internal_esi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_esi(const std::string& value);
  std::string* _internal_mutable_esi();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteEsi)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr esi_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteNh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteNh) */ {
 public:
  inline SLL2RouteNh() : SLL2RouteNh(nullptr) {}
  ~SLL2RouteNh() override;
  explicit constexpr SLL2RouteNh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteNh(const SLL2RouteNh& from);
  SLL2RouteNh(SLL2RouteNh&& from) noexcept
    : SLL2RouteNh() {
    *this = ::std::move(from);
  }

  inline SLL2RouteNh& operator=(const SLL2RouteNh& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteNh& operator=(SLL2RouteNh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteNh& default_instance() {
    return *internal_default_instance();
  }
  enum NhDataCase {
    kNhInterface = 2,
    kNhOverlay = 3,
    NHDATA_NOT_SET = 0,
  };

  static inline const SLL2RouteNh* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteNh*>(
               &_SLL2RouteNh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLL2RouteNh& a, SLL2RouteNh& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteNh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteNh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteNh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteNh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteNh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteNh& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteNh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteNh";
  }
  protected:
  explicit SLL2RouteNh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLL2RouteNh_SLL2RouteNhType SLL2RouteNhType;
  static constexpr SLL2RouteNhType SL_L2_NH_RESERVED =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED;
  static constexpr SLL2RouteNhType SL_L2_NH_INTERFACE =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_INTERFACE;
  static constexpr SLL2RouteNhType SL_L2_NH_OVERLAY =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY;
  static inline bool SLL2RouteNhType_IsValid(int value) {
    return SLL2RouteNh_SLL2RouteNhType_IsValid(value);
  }
  static constexpr SLL2RouteNhType SLL2RouteNhType_MIN =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MIN;
  static constexpr SLL2RouteNhType SLL2RouteNhType_MAX =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX;
  static constexpr int SLL2RouteNhType_ARRAYSIZE =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SLL2RouteNhType_descriptor() {
    return SLL2RouteNh_SLL2RouteNhType_descriptor();
  }
  template<typename T>
  static inline const std::string& SLL2RouteNhType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SLL2RouteNhType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SLL2RouteNhType_Name.");
    return SLL2RouteNh_SLL2RouteNhType_Name(enum_t_value);
  }
  static inline bool SLL2RouteNhType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SLL2RouteNhType* value) {
    return SLL2RouteNh_SLL2RouteNhType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNhTypeFieldNumber = 1,
    kNhInterfaceFieldNumber = 2,
    kNhOverlayFieldNumber = 3,
  };
  // .service_layer.SLL2RouteNh.SLL2RouteNhType NhType = 1;
  void clear_nhtype();
  ::service_layer::SLL2RouteNh_SLL2RouteNhType nhtype() const;
  void set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value);
  private:
  ::service_layer::SLL2RouteNh_SLL2RouteNhType _internal_nhtype() const;
  void _internal_set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value);
  public:

  // .service_layer.SLInterface NhInterface = 2;
  bool has_nhinterface() const;
  private:
  bool _internal_has_nhinterface() const;
  public:
  void clear_nhinterface();
  const ::service_layer::SLInterface& nhinterface() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_nhinterface();
  ::service_layer::SLInterface* mutable_nhinterface();
  void set_allocated_nhinterface(::service_layer::SLInterface* nhinterface);
  private:
  const ::service_layer::SLInterface& _internal_nhinterface() const;
  ::service_layer::SLInterface* _internal_mutable_nhinterface();
  public:
  void unsafe_arena_set_allocated_nhinterface(
      ::service_layer::SLInterface* nhinterface);
  ::service_layer::SLInterface* unsafe_arena_release_nhinterface();

  // .service_layer.SLL2OverlayNh NhOverlay = 3;
  bool has_nhoverlay() const;
  private:
  bool _internal_has_nhoverlay() const;
  public:
  void clear_nhoverlay();
  const ::service_layer::SLL2OverlayNh& nhoverlay() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2OverlayNh* release_nhoverlay();
  ::service_layer::SLL2OverlayNh* mutable_nhoverlay();
  void set_allocated_nhoverlay(::service_layer::SLL2OverlayNh* nhoverlay);
  private:
  const ::service_layer::SLL2OverlayNh& _internal_nhoverlay() const;
  ::service_layer::SLL2OverlayNh* _internal_mutable_nhoverlay();
  public:
  void unsafe_arena_set_allocated_nhoverlay(
      ::service_layer::SLL2OverlayNh* nhoverlay);
  ::service_layer::SLL2OverlayNh* unsafe_arena_release_nhoverlay();

  void clear_NhData();
  NhDataCase NhData_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteNh)
 private:
  class _Internal;
  void set_has_nhinterface();
  void set_has_nhoverlay();

  inline bool has_NhData() const;
  inline void clear_has_NhData();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int nhtype_;
  union NhDataUnion {
    constexpr NhDataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLInterface* nhinterface_;
    ::service_layer::SLL2OverlayNh* nhoverlay_;
  } NhData_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2OverlayNh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2OverlayNh) */ {
 public:
  inline SLL2OverlayNh() : SLL2OverlayNh(nullptr) {}
  ~SLL2OverlayNh() override;
  explicit constexpr SLL2OverlayNh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2OverlayNh(const SLL2OverlayNh& from);
  SLL2OverlayNh(SLL2OverlayNh&& from) noexcept
    : SLL2OverlayNh() {
    *this = ::std::move(from);
  }

  inline SLL2OverlayNh& operator=(const SLL2OverlayNh& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2OverlayNh& operator=(SLL2OverlayNh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2OverlayNh& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2OverlayNh* internal_default_instance() {
    return reinterpret_cast<const SLL2OverlayNh*>(
               &_SLL2OverlayNh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLL2OverlayNh& a, SLL2OverlayNh& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2OverlayNh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2OverlayNh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2OverlayNh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2OverlayNh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2OverlayNh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2OverlayNh& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2OverlayNh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2OverlayNh";
  }
  protected:
  explicit SLL2OverlayNh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayNhL3LabelFieldNumber = 4,
    kOverlayNhRouterMacFieldNumber = 5,
    kOverlayNhIpFieldNumber = 1,
    kOverlayNhEncapFieldNumber = 2,
    kOverlayNhLabelFieldNumber = 3,
  };
  // repeated uint32 OverlayNhL3Label = 4;
  int overlaynhl3label_size() const;
  private:
  int _internal_overlaynhl3label_size() const;
  public:
  void clear_overlaynhl3label();
  private:
  uint32_t _internal_overlaynhl3label(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_overlaynhl3label() const;
  void _internal_add_overlaynhl3label(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_overlaynhl3label();
  public:
  uint32_t overlaynhl3label(int index) const;
  void set_overlaynhl3label(int index, uint32_t value);
  void add_overlaynhl3label(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      overlaynhl3label() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_overlaynhl3label();

  // bytes OverlayNhRouterMac = 5;
  void clear_overlaynhroutermac();
  const std::string& overlaynhroutermac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_overlaynhroutermac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_overlaynhroutermac();
  PROTOBUF_NODISCARD std::string* release_overlaynhroutermac();
  void set_allocated_overlaynhroutermac(std::string* overlaynhroutermac);
  private:
  const std::string& _internal_overlaynhroutermac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_overlaynhroutermac(const std::string& value);
  std::string* _internal_mutable_overlaynhroutermac();
  public:

  // .service_layer.SLIpAddress OverlayNhIp = 1;
  bool has_overlaynhip() const;
  private:
  bool _internal_has_overlaynhip() const;
  public:
  void clear_overlaynhip();
  const ::service_layer::SLIpAddress& overlaynhip() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_overlaynhip();
  ::service_layer::SLIpAddress* mutable_overlaynhip();
  void set_allocated_overlaynhip(::service_layer::SLIpAddress* overlaynhip);
  private:
  const ::service_layer::SLIpAddress& _internal_overlaynhip() const;
  ::service_layer::SLIpAddress* _internal_mutable_overlaynhip();
  public:
  void unsafe_arena_set_allocated_overlaynhip(
      ::service_layer::SLIpAddress* overlaynhip);
  ::service_layer::SLIpAddress* unsafe_arena_release_overlaynhip();

  // .service_layer.SLEncapType OverlayNhEncap = 2;
  void clear_overlaynhencap();
  ::service_layer::SLEncapType overlaynhencap() const;
  void set_overlaynhencap(::service_layer::SLEncapType value);
  private:
  ::service_layer::SLEncapType _internal_overlaynhencap() const;
  void _internal_set_overlaynhencap(::service_layer::SLEncapType value);
  public:

  // uint32 OverlayNhLabel = 3;
  void clear_overlaynhlabel();
  uint32_t overlaynhlabel() const;
  void set_overlaynhlabel(uint32_t value);
  private:
  uint32_t _internal_overlaynhlabel() const;
  void _internal_set_overlaynhlabel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2OverlayNh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > overlaynhl3label_;
  mutable std::atomic<int> _overlaynhl3label_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr overlaynhroutermac_;
  ::service_layer::SLIpAddress* overlaynhip_;
  int overlaynhencap_;
  uint32_t overlaynhlabel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2MacRouteKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2MacRouteKey) */ {
 public:
  inline SLL2MacRouteKey() : SLL2MacRouteKey(nullptr) {}
  ~SLL2MacRouteKey() override;
  explicit constexpr SLL2MacRouteKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2MacRouteKey(const SLL2MacRouteKey& from);
  SLL2MacRouteKey(SLL2MacRouteKey&& from) noexcept
    : SLL2MacRouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2MacRouteKey& operator=(const SLL2MacRouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2MacRouteKey& operator=(SLL2MacRouteKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2MacRouteKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2MacRouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2MacRouteKey*>(
               &_SLL2MacRouteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLL2MacRouteKey& a, SLL2MacRouteKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2MacRouteKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2MacRouteKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2MacRouteKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2MacRouteKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2MacRouteKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2MacRouteKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2MacRouteKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2MacRouteKey";
  }
  protected:
  explicit SLL2MacRouteKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 1,
    kIpAddressFieldNumber = 2,
  };
  // bytes MacAddress = 1;
  void clear_macaddress();
  const std::string& macaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_macaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_macaddress();
  PROTOBUF_NODISCARD std::string* release_macaddress();
  void set_allocated_macaddress(std::string* macaddress);
  private:
  const std::string& _internal_macaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddress(const std::string& value);
  std::string* _internal_mutable_macaddress();
  public:

  // .service_layer.SLIpAddress IpAddress = 2;
  bool has_ipaddress() const;
  private:
  bool _internal_has_ipaddress() const;
  public:
  void clear_ipaddress();
  const ::service_layer::SLIpAddress& ipaddress() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_ipaddress();
  ::service_layer::SLIpAddress* mutable_ipaddress();
  void set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress);
  private:
  const ::service_layer::SLIpAddress& _internal_ipaddress() const;
  ::service_layer::SLIpAddress* _internal_mutable_ipaddress();
  public:
  void unsafe_arena_set_allocated_ipaddress(
      ::service_layer::SLIpAddress* ipaddress);
  ::service_layer::SLIpAddress* unsafe_arena_release_ipaddress();

  // @@protoc_insertion_point(class_scope:service_layer.SLL2MacRouteKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macaddress_;
  ::service_layer::SLIpAddress* ipaddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2MacRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2MacRoute) */ {
 public:
  inline SLL2MacRoute() : SLL2MacRoute(nullptr) {}
  ~SLL2MacRoute() override;
  explicit constexpr SLL2MacRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2MacRoute(const SLL2MacRoute& from);
  SLL2MacRoute(SLL2MacRoute&& from) noexcept
    : SLL2MacRoute() {
    *this = ::std::move(from);
  }

  inline SLL2MacRoute& operator=(const SLL2MacRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2MacRoute& operator=(SLL2MacRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2MacRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2MacRoute* internal_default_instance() {
    return reinterpret_cast<const SLL2MacRoute*>(
               &_SLL2MacRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLL2MacRoute& a, SLL2MacRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2MacRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2MacRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2MacRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2MacRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2MacRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2MacRoute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2MacRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2MacRoute";
  }
  protected:
  explicit SLL2MacRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextHopListFieldNumber = 4,
    kRouteKeyFieldNumber = 1,
    kMacEsiFieldNumber = 3,
    kSequenceNumFieldNumber = 2,
  };
  // repeated .service_layer.SLL2RouteNh NextHopList = 4;
  int nexthoplist_size() const;
  private:
  int _internal_nexthoplist_size() const;
  public:
  void clear_nexthoplist();
  ::service_layer::SLL2RouteNh* mutable_nexthoplist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteNh >*
      mutable_nexthoplist();
  private:
  const ::service_layer::SLL2RouteNh& _internal_nexthoplist(int index) const;
  ::service_layer::SLL2RouteNh* _internal_add_nexthoplist();
  public:
  const ::service_layer::SLL2RouteNh& nexthoplist(int index) const;
  ::service_layer::SLL2RouteNh* add_nexthoplist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteNh >&
      nexthoplist() const;

  // .service_layer.SLL2MacRouteKey RouteKey = 1;
  bool has_routekey() const;
  private:
  bool _internal_has_routekey() const;
  public:
  void clear_routekey();
  const ::service_layer::SLL2MacRouteKey& routekey() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2MacRouteKey* release_routekey();
  ::service_layer::SLL2MacRouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2MacRouteKey* routekey);
  private:
  const ::service_layer::SLL2MacRouteKey& _internal_routekey() const;
  ::service_layer::SLL2MacRouteKey* _internal_mutable_routekey();
  public:
  void unsafe_arena_set_allocated_routekey(
      ::service_layer::SLL2MacRouteKey* routekey);
  ::service_layer::SLL2MacRouteKey* unsafe_arena_release_routekey();

  // .service_layer.SLL2RouteEsi MacEsi = 3;
  bool has_macesi() const;
  private:
  bool _internal_has_macesi() const;
  public:
  void clear_macesi();
  const ::service_layer::SLL2RouteEsi& macesi() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2RouteEsi* release_macesi();
  ::service_layer::SLL2RouteEsi* mutable_macesi();
  void set_allocated_macesi(::service_layer::SLL2RouteEsi* macesi);
  private:
  const ::service_layer::SLL2RouteEsi& _internal_macesi() const;
  ::service_layer::SLL2RouteEsi* _internal_mutable_macesi();
  public:
  void unsafe_arena_set_allocated_macesi(
      ::service_layer::SLL2RouteEsi* macesi);
  ::service_layer::SLL2RouteEsi* unsafe_arena_release_macesi();

  // uint32 SequenceNum = 2;
  void clear_sequencenum();
  uint32_t sequencenum() const;
  void set_sequencenum(uint32_t value);
  private:
  uint32_t _internal_sequencenum() const;
  void _internal_set_sequencenum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2MacRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteNh > nexthoplist_;
  ::service_layer::SLL2MacRouteKey* routekey_;
  ::service_layer::SLL2RouteEsi* macesi_;
  uint32_t sequencenum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2ImetRouteKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2ImetRouteKey) */ {
 public:
  inline SLL2ImetRouteKey() : SLL2ImetRouteKey(nullptr) {}
  ~SLL2ImetRouteKey() override;
  explicit constexpr SLL2ImetRouteKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2ImetRouteKey(const SLL2ImetRouteKey& from);
  SLL2ImetRouteKey(SLL2ImetRouteKey&& from) noexcept
    : SLL2ImetRouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2ImetRouteKey& operator=(const SLL2ImetRouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2ImetRouteKey& operator=(SLL2ImetRouteKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2ImetRouteKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2ImetRouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2ImetRouteKey*>(
               &_SLL2ImetRouteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLL2ImetRouteKey& a, SLL2ImetRouteKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2ImetRouteKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2ImetRouteKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2ImetRouteKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2ImetRouteKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2ImetRouteKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2ImetRouteKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2ImetRouteKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2ImetRouteKey";
  }
  protected:
  explicit SLL2ImetRouteKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 2,
    kEthTagIdFieldNumber = 1,
  };
  // .service_layer.SLIpAddress IpAddress = 2;
  bool has_ipaddress() const;
  private:
  bool _internal_has_ipaddress() const;
  public:
  void clear_ipaddress();
  const ::service_layer::SLIpAddress& ipaddress() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_ipaddress();
  ::service_layer::SLIpAddress* mutable_ipaddress();
  void set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress);
  private:
  const ::service_layer::SLIpAddress& _internal_ipaddress() const;
  ::service_layer::SLIpAddress* _internal_mutable_ipaddress();
  public:
  void unsafe_arena_set_allocated_ipaddress(
      ::service_layer::SLIpAddress* ipaddress);
  ::service_layer::SLIpAddress* unsafe_arena_release_ipaddress();

  // uint32 EthTagId = 1;
  void clear_ethtagid();
  uint32_t ethtagid() const;
  void set_ethtagid(uint32_t value);
  private:
  uint32_t _internal_ethtagid() const;
  void _internal_set_ethtagid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2ImetRouteKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLIpAddress* ipaddress_;
  uint32_t ethtagid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2ImetRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2ImetRoute) */ {
 public:
  inline SLL2ImetRoute() : SLL2ImetRoute(nullptr) {}
  ~SLL2ImetRoute() override;
  explicit constexpr SLL2ImetRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2ImetRoute(const SLL2ImetRoute& from);
  SLL2ImetRoute(SLL2ImetRoute&& from) noexcept
    : SLL2ImetRoute() {
    *this = ::std::move(from);
  }

  inline SLL2ImetRoute& operator=(const SLL2ImetRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2ImetRoute& operator=(SLL2ImetRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2ImetRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2ImetRoute* internal_default_instance() {
    return reinterpret_cast<const SLL2ImetRoute*>(
               &_SLL2ImetRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLL2ImetRoute& a, SLL2ImetRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2ImetRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2ImetRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2ImetRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2ImetRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2ImetRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2ImetRoute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2ImetRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2ImetRoute";
  }
  protected:
  explicit SLL2ImetRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLL2ImetRoute_PMSITunnelType PMSITunnelType;
  static constexpr PMSITunnelType PMSI_NO_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL;
  static constexpr PMSITunnelType PMSI_RSVPP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_RSVPP2MP_TUNNEL;
  static constexpr PMSITunnelType PMSI_MLDPP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_MLDPP2MP_TUNNEL;
  static constexpr PMSITunnelType PMSI_PIMSSM_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMSSM_TUNNEL;
  static constexpr PMSITunnelType PMSI_PIMSM_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMSM_TUNNEL;
  static constexpr PMSITunnelType PMSI_PIMBIDIR_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMBIDIR_TUNNEL;
  static constexpr PMSITunnelType PMSI_INGREP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_INGREP_TUNNEL;
  static constexpr PMSITunnelType PMSI_MLDPMP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL;
  static inline bool PMSITunnelType_IsValid(int value) {
    return SLL2ImetRoute_PMSITunnelType_IsValid(value);
  }
  static constexpr PMSITunnelType PMSITunnelType_MIN =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MIN;
  static constexpr PMSITunnelType PMSITunnelType_MAX =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX;
  static constexpr int PMSITunnelType_ARRAYSIZE =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PMSITunnelType_descriptor() {
    return SLL2ImetRoute_PMSITunnelType_descriptor();
  }
  template<typename T>
  static inline const std::string& PMSITunnelType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PMSITunnelType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PMSITunnelType_Name.");
    return SLL2ImetRoute_PMSITunnelType_Name(enum_t_value);
  }
  static inline bool PMSITunnelType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PMSITunnelType* value) {
    return SLL2ImetRoute_PMSITunnelType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelIdValueFieldNumber = 6,
    kRouteKeyFieldNumber = 1,
    kEncapTypeFieldNumber = 2,
    kLabelFieldNumber = 3,
    kTunnelTypeFieldNumber = 4,
    kTunnelIdLengthFieldNumber = 5,
  };
  // bytes TunnelIdValue = 6;
  void clear_tunnelidvalue();
  const std::string& tunnelidvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tunnelidvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tunnelidvalue();
  PROTOBUF_NODISCARD std::string* release_tunnelidvalue();
  void set_allocated_tunnelidvalue(std::string* tunnelidvalue);
  private:
  const std::string& _internal_tunnelidvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tunnelidvalue(const std::string& value);
  std::string* _internal_mutable_tunnelidvalue();
  public:

  // .service_layer.SLL2ImetRouteKey RouteKey = 1;
  bool has_routekey() const;
  private:
  bool _internal_has_routekey() const;
  public:
  void clear_routekey();
  const ::service_layer::SLL2ImetRouteKey& routekey() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2ImetRouteKey* release_routekey();
  ::service_layer::SLL2ImetRouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2ImetRouteKey* routekey);
  private:
  const ::service_layer::SLL2ImetRouteKey& _internal_routekey() const;
  ::service_layer::SLL2ImetRouteKey* _internal_mutable_routekey();
  public:
  void unsafe_arena_set_allocated_routekey(
      ::service_layer::SLL2ImetRouteKey* routekey);
  ::service_layer::SLL2ImetRouteKey* unsafe_arena_release_routekey();

  // .service_layer.SLEncapType EncapType = 2;
  void clear_encaptype();
  ::service_layer::SLEncapType encaptype() const;
  void set_encaptype(::service_layer::SLEncapType value);
  private:
  ::service_layer::SLEncapType _internal_encaptype() const;
  void _internal_set_encaptype(::service_layer::SLEncapType value);
  public:

  // uint32 Label = 3;
  void clear_label();
  uint32_t label() const;
  void set_label(uint32_t value);
  private:
  uint32_t _internal_label() const;
  void _internal_set_label(uint32_t value);
  public:

  // .service_layer.SLL2ImetRoute.PMSITunnelType TunnelType = 4;
  void clear_tunneltype();
  ::service_layer::SLL2ImetRoute_PMSITunnelType tunneltype() const;
  void set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value);
  private:
  ::service_layer::SLL2ImetRoute_PMSITunnelType _internal_tunneltype() const;
  void _internal_set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value);
  public:

  // uint32 TunnelIdLength = 5;
  void clear_tunnelidlength();
  uint32_t tunnelidlength() const;
  void set_tunnelidlength(uint32_t value);
  private:
  uint32_t _internal_tunnelidlength() const;
  void _internal_set_tunnelidlength(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2ImetRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tunnelidvalue_;
  ::service_layer::SLL2ImetRouteKey* routekey_;
  int encaptype_;
  uint32_t label_;
  int tunneltype_;
  uint32_t tunnelidlength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteKey) */ {
 public:
  inline SLL2RouteKey() : SLL2RouteKey(nullptr) {}
  ~SLL2RouteKey() override;
  explicit constexpr SLL2RouteKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteKey(const SLL2RouteKey& from);
  SLL2RouteKey(SLL2RouteKey&& from) noexcept
    : SLL2RouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2RouteKey& operator=(const SLL2RouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteKey& operator=(SLL2RouteKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteKey& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kMacKey = 3,
    kImetKey = 4,
    EVENT_NOT_SET = 0,
  };

  static inline const SLL2RouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteKey*>(
               &_SLL2RouteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLL2RouteKey& a, SLL2RouteKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteKey";
  }
  protected:
  explicit SLL2RouteKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBdNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMacKeyFieldNumber = 3,
    kImetKeyFieldNumber = 4,
  };
  // string BdName = 1;
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  // .service_layer.SLL2RouteType Type = 2;
  void clear_type();
  ::service_layer::SLL2RouteType type() const;
  void set_type(::service_layer::SLL2RouteType value);
  private:
  ::service_layer::SLL2RouteType _internal_type() const;
  void _internal_set_type(::service_layer::SLL2RouteType value);
  public:

  // .service_layer.SLL2MacRouteKey MacKey = 3;
  bool has_mackey() const;
  private:
  bool _internal_has_mackey() const;
  public:
  void clear_mackey();
  const ::service_layer::SLL2MacRouteKey& mackey() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2MacRouteKey* release_mackey();
  ::service_layer::SLL2MacRouteKey* mutable_mackey();
  void set_allocated_mackey(::service_layer::SLL2MacRouteKey* mackey);
  private:
  const ::service_layer::SLL2MacRouteKey& _internal_mackey() const;
  ::service_layer::SLL2MacRouteKey* _internal_mutable_mackey();
  public:
  void unsafe_arena_set_allocated_mackey(
      ::service_layer::SLL2MacRouteKey* mackey);
  ::service_layer::SLL2MacRouteKey* unsafe_arena_release_mackey();

  // .service_layer.SLL2ImetRouteKey ImetKey = 4;
  bool has_imetkey() const;
  private:
  bool _internal_has_imetkey() const;
  public:
  void clear_imetkey();
  const ::service_layer::SLL2ImetRouteKey& imetkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2ImetRouteKey* release_imetkey();
  ::service_layer::SLL2ImetRouteKey* mutable_imetkey();
  void set_allocated_imetkey(::service_layer::SLL2ImetRouteKey* imetkey);
  private:
  const ::service_layer::SLL2ImetRouteKey& _internal_imetkey() const;
  ::service_layer::SLL2ImetRouteKey* _internal_mutable_imetkey();
  public:
  void unsafe_arena_set_allocated_imetkey(
      ::service_layer::SLL2ImetRouteKey* imetkey);
  ::service_layer::SLL2ImetRouteKey* unsafe_arena_release_imetkey();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteKey)
 private:
  class _Internal;
  void set_has_mackey();
  void set_has_imetkey();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  int type_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLL2MacRouteKey* mackey_;
    ::service_layer::SLL2ImetRouteKey* imetkey_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2Route final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2Route) */ {
 public:
  inline SLL2Route() : SLL2Route(nullptr) {}
  ~SLL2Route() override;
  explicit constexpr SLL2Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2Route(const SLL2Route& from);
  SLL2Route(SLL2Route&& from) noexcept
    : SLL2Route() {
    *this = ::std::move(from);
  }

  inline SLL2Route& operator=(const SLL2Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2Route& operator=(SLL2Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2Route& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kMacRoute = 3,
    kImetRoute = 4,
    EVENT_NOT_SET = 0,
  };

  static inline const SLL2Route* internal_default_instance() {
    return reinterpret_cast<const SLL2Route*>(
               &_SLL2Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLL2Route& a, SLL2Route& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2Route>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2Route& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2Route& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2Route";
  }
  protected:
  explicit SLL2Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBdNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMacRouteFieldNumber = 3,
    kImetRouteFieldNumber = 4,
  };
  // string BdName = 1;
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  // .service_layer.SLL2RouteType Type = 2;
  void clear_type();
  ::service_layer::SLL2RouteType type() const;
  void set_type(::service_layer::SLL2RouteType value);
  private:
  ::service_layer::SLL2RouteType _internal_type() const;
  void _internal_set_type(::service_layer::SLL2RouteType value);
  public:

  // .service_layer.SLL2MacRoute MacRoute = 3;
  bool has_macroute() const;
  private:
  bool _internal_has_macroute() const;
  public:
  void clear_macroute();
  const ::service_layer::SLL2MacRoute& macroute() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2MacRoute* release_macroute();
  ::service_layer::SLL2MacRoute* mutable_macroute();
  void set_allocated_macroute(::service_layer::SLL2MacRoute* macroute);
  private:
  const ::service_layer::SLL2MacRoute& _internal_macroute() const;
  ::service_layer::SLL2MacRoute* _internal_mutable_macroute();
  public:
  void unsafe_arena_set_allocated_macroute(
      ::service_layer::SLL2MacRoute* macroute);
  ::service_layer::SLL2MacRoute* unsafe_arena_release_macroute();

  // .service_layer.SLL2ImetRoute ImetRoute = 4;
  bool has_imetroute() const;
  private:
  bool _internal_has_imetroute() const;
  public:
  void clear_imetroute();
  const ::service_layer::SLL2ImetRoute& imetroute() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2ImetRoute* release_imetroute();
  ::service_layer::SLL2ImetRoute* mutable_imetroute();
  void set_allocated_imetroute(::service_layer::SLL2ImetRoute* imetroute);
  private:
  const ::service_layer::SLL2ImetRoute& _internal_imetroute() const;
  ::service_layer::SLL2ImetRoute* _internal_mutable_imetroute();
  public:
  void unsafe_arena_set_allocated_imetroute(
      ::service_layer::SLL2ImetRoute* imetroute);
  ::service_layer::SLL2ImetRoute* unsafe_arena_release_imetroute();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2Route)
 private:
  class _Internal;
  void set_has_macroute();
  void set_has_imetroute();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  int type_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLL2MacRoute* macroute_;
    ::service_layer::SLL2ImetRoute* imetroute_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteMsg) */ {
 public:
  inline SLL2RouteMsg() : SLL2RouteMsg(nullptr) {}
  ~SLL2RouteMsg() override;
  explicit constexpr SLL2RouteMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteMsg(const SLL2RouteMsg& from);
  SLL2RouteMsg(SLL2RouteMsg&& from) noexcept
    : SLL2RouteMsg() {
    *this = ::std::move(from);
  }

  inline SLL2RouteMsg& operator=(const SLL2RouteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteMsg& operator=(SLL2RouteMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RouteMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteMsg*>(
               &_SLL2RouteMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLL2RouteMsg& a, SLL2RouteMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteMsg";
  }
  protected:
  explicit SLL2RouteMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kCorrelatorFieldNumber = 1,
    kOperFieldNumber = 2,
  };
  // repeated .service_layer.SLL2Route Routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::service_layer::SLL2Route* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2Route >*
      mutable_routes();
  private:
  const ::service_layer::SLL2Route& _internal_routes(int index) const;
  ::service_layer::SLL2Route* _internal_add_routes();
  public:
  const ::service_layer::SLL2Route& routes(int index) const;
  ::service_layer::SLL2Route* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2Route >&
      routes() const;

  // uint64 Correlator = 1;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // .service_layer.SLObjectOp Oper = 2;
  void clear_oper();
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);
  private:
  ::service_layer::SLObjectOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2Route > routes_;
  uint64_t correlator_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteRes) */ {
 public:
  inline SLL2RouteRes() : SLL2RouteRes(nullptr) {}
  ~SLL2RouteRes() override;
  explicit constexpr SLL2RouteRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteRes(const SLL2RouteRes& from);
  SLL2RouteRes(SLL2RouteRes&& from) noexcept
    : SLL2RouteRes() {
    *this = ::std::move(from);
  }

  inline SLL2RouteRes& operator=(const SLL2RouteRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteRes& operator=(SLL2RouteRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RouteRes* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteRes*>(
               &_SLL2RouteRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SLL2RouteRes& a, SLL2RouteRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteRes";
  }
  protected:
  explicit SLL2RouteRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kRouteKeyFieldNumber = 2,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLL2RouteKey RouteKey = 2;
  bool has_routekey() const;
  private:
  bool _internal_has_routekey() const;
  public:
  void clear_routekey();
  const ::service_layer::SLL2RouteKey& routekey() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2RouteKey* release_routekey();
  ::service_layer::SLL2RouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2RouteKey* routekey);
  private:
  const ::service_layer::SLL2RouteKey& _internal_routekey() const;
  ::service_layer::SLL2RouteKey* _internal_mutable_routekey();
  public:
  void unsafe_arena_set_allocated_routekey(
      ::service_layer::SLL2RouteKey* routekey);
  ::service_layer::SLL2RouteKey* unsafe_arena_release_routekey();

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  ::service_layer::SLL2RouteKey* routekey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteMsgRsp) */ {
 public:
  inline SLL2RouteMsgRsp() : SLL2RouteMsgRsp(nullptr) {}
  ~SLL2RouteMsgRsp() override;
  explicit constexpr SLL2RouteMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteMsgRsp(const SLL2RouteMsgRsp& from);
  SLL2RouteMsgRsp(SLL2RouteMsgRsp&& from) noexcept
    : SLL2RouteMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2RouteMsgRsp& operator=(const SLL2RouteMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteMsgRsp& operator=(SLL2RouteMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RouteMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteMsgRsp*>(
               &_SLL2RouteMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SLL2RouteMsgRsp& a, SLL2RouteMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteMsgRsp";
  }
  protected:
  explicit SLL2RouteMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 3,
    kStatusSummaryFieldNumber = 2,
    kCorrelatorFieldNumber = 1,
  };
  // repeated .service_layer.SLL2RouteRes Results = 3;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLL2RouteRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteRes >*
      mutable_results();
  private:
  const ::service_layer::SLL2RouteRes& _internal_results(int index) const;
  ::service_layer::SLL2RouteRes* _internal_add_results();
  public:
  const ::service_layer::SLL2RouteRes& results(int index) const;
  ::service_layer::SLL2RouteRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 2;
  bool has_statussummary() const;
  private:
  bool _internal_has_statussummary() const;
  public:
  void clear_statussummary();
  const ::service_layer::SLErrorStatus& statussummary() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);
  private:
  const ::service_layer::SLErrorStatus& _internal_statussummary() const;
  ::service_layer::SLErrorStatus* _internal_mutable_statussummary();
  public:
  void unsafe_arena_set_allocated_statussummary(
      ::service_layer::SLErrorStatus* statussummary);
  ::service_layer::SLErrorStatus* unsafe_arena_release_statussummary();

  // uint64 Correlator = 1;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  uint64_t correlator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2GetNotifMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2GetNotifMsg) */ {
 public:
  inline SLL2GetNotifMsg() : SLL2GetNotifMsg(nullptr) {}
  ~SLL2GetNotifMsg() override;
  explicit constexpr SLL2GetNotifMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2GetNotifMsg(const SLL2GetNotifMsg& from);
  SLL2GetNotifMsg(SLL2GetNotifMsg&& from) noexcept
    : SLL2GetNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLL2GetNotifMsg& operator=(const SLL2GetNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2GetNotifMsg& operator=(SLL2GetNotifMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2GetNotifMsg& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kBdAll = 4,
    kBdName = 5,
    REQUEST_NOT_SET = 0,
  };

  static inline const SLL2GetNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2GetNotifMsg*>(
               &_SLL2GetNotifMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SLL2GetNotifMsg& a, SLL2GetNotifMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2GetNotifMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2GetNotifMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2GetNotifMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2GetNotifMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2GetNotifMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2GetNotifMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2GetNotifMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2GetNotifMsg";
  }
  protected:
  explicit SLL2GetNotifMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorrelatorFieldNumber = 2,
    kOperFieldNumber = 1,
    kGetNotifEofFieldNumber = 3,
    kBdAllFieldNumber = 4,
    kBdNameFieldNumber = 5,
  };
  // uint64 Correlator = 2;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // bool GetNotifEof = 3;
  void clear_getnotifeof();
  bool getnotifeof() const;
  void set_getnotifeof(bool value);
  private:
  bool _internal_getnotifeof() const;
  void _internal_set_getnotifeof(bool value);
  public:

  // bool BdAll = 4;
  bool has_bdall() const;
  private:
  bool _internal_has_bdall() const;
  public:
  void clear_bdall();
  bool bdall() const;
  void set_bdall(bool value);
  private:
  bool _internal_bdall() const;
  void _internal_set_bdall(bool value);
  public:

  // string BdName = 5;
  bool has_bdname() const;
  private:
  bool _internal_has_bdname() const;
  public:
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  void clear_Request();
  RequestCase Request_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2GetNotifMsg)
 private:
  class _Internal;
  void set_has_bdall();
  void set_has_bdname();

  inline bool has_Request() const;
  inline void clear_has_Request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t correlator_;
  int oper_;
  bool getnotifeof_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool bdall_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  } Request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2RouteNotif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteNotif) */ {
 public:
  inline SLL2RouteNotif() : SLL2RouteNotif(nullptr) {}
  ~SLL2RouteNotif() override;
  explicit constexpr SLL2RouteNotif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2RouteNotif(const SLL2RouteNotif& from);
  SLL2RouteNotif(SLL2RouteNotif&& from) noexcept
    : SLL2RouteNotif() {
    *this = ::std::move(from);
  }

  inline SLL2RouteNotif& operator=(const SLL2RouteNotif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2RouteNotif& operator=(SLL2RouteNotif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2RouteNotif& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2RouteNotif* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteNotif*>(
               &_SLL2RouteNotif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SLL2RouteNotif& a, SLL2RouteNotif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2RouteNotif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2RouteNotif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2RouteNotif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2RouteNotif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2RouteNotif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2RouteNotif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2RouteNotif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2RouteNotif";
  }
  protected:
  explicit SLL2RouteNotif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // .service_layer.SLL2Route Routes = 2;
  bool has_routes() const;
  private:
  bool _internal_has_routes() const;
  public:
  void clear_routes();
  const ::service_layer::SLL2Route& routes() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2Route* release_routes();
  ::service_layer::SLL2Route* mutable_routes();
  void set_allocated_routes(::service_layer::SLL2Route* routes);
  private:
  const ::service_layer::SLL2Route& _internal_routes() const;
  ::service_layer::SLL2Route* _internal_mutable_routes();
  public:
  void unsafe_arena_set_allocated_routes(
      ::service_layer::SLL2Route* routes);
  ::service_layer::SLL2Route* unsafe_arena_release_routes();

  // .service_layer.SLObjectOp Oper = 1;
  void clear_oper();
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);
  private:
  ::service_layer::SLObjectOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteNotif)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLL2Route* routes_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2BdStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdStateInfo) */ {
 public:
  inline SLL2BdStateInfo() : SLL2BdStateInfo(nullptr) {}
  ~SLL2BdStateInfo() override;
  explicit constexpr SLL2BdStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2BdStateInfo(const SLL2BdStateInfo& from);
  SLL2BdStateInfo(SLL2BdStateInfo&& from) noexcept
    : SLL2BdStateInfo() {
    *this = ::std::move(from);
  }

  inline SLL2BdStateInfo& operator=(const SLL2BdStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2BdStateInfo& operator=(SLL2BdStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2BdStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2BdStateInfo* internal_default_instance() {
    return reinterpret_cast<const SLL2BdStateInfo*>(
               &_SLL2BdStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SLL2BdStateInfo& a, SLL2BdStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2BdStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2BdStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2BdStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2BdStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2BdStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2BdStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2BdStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2BdStateInfo";
  }
  protected:
  explicit SLL2BdStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SLL2BdStateInfo_SLL2BdState SLL2BdState;
  static constexpr SLL2BdState SL_L2_BD_STATE_RESERVED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED;
  static constexpr SLL2BdState SL_L2_BD_STATE_ADDED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_ADDED;
  static constexpr SLL2BdState SL_L2_BD_STATE_DELETED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_DELETED;
  static constexpr SLL2BdState SL_L2_BD_STATE_REPLAY_NEEDED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED;
  static inline bool SLL2BdState_IsValid(int value) {
    return SLL2BdStateInfo_SLL2BdState_IsValid(value);
  }
  static constexpr SLL2BdState SLL2BdState_MIN =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_MIN;
  static constexpr SLL2BdState SLL2BdState_MAX =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX;
  static constexpr int SLL2BdState_ARRAYSIZE =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SLL2BdState_descriptor() {
    return SLL2BdStateInfo_SLL2BdState_descriptor();
  }
  template<typename T>
  static inline const std::string& SLL2BdState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SLL2BdState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SLL2BdState_Name.");
    return SLL2BdStateInfo_SLL2BdState_Name(enum_t_value);
  }
  static inline bool SLL2BdState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SLL2BdState* value) {
    return SLL2BdStateInfo_SLL2BdState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBdNameFieldNumber = 1,
    kBdStateFieldNumber = 2,
  };
  // string BdName = 1;
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  // .service_layer.SLL2BdStateInfo.SLL2BdState BdState = 2;
  void clear_bdstate();
  ::service_layer::SLL2BdStateInfo_SLL2BdState bdstate() const;
  void set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value);
  private:
  ::service_layer::SLL2BdStateInfo_SLL2BdState _internal_bdstate() const;
  void _internal_set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  int bdstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2NotifStatusMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2NotifStatusMsg) */ {
 public:
  inline SLL2NotifStatusMsg() : SLL2NotifStatusMsg(nullptr) {}
  ~SLL2NotifStatusMsg() override;
  explicit constexpr SLL2NotifStatusMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2NotifStatusMsg(const SLL2NotifStatusMsg& from);
  SLL2NotifStatusMsg(SLL2NotifStatusMsg&& from) noexcept
    : SLL2NotifStatusMsg() {
    *this = ::std::move(from);
  }

  inline SLL2NotifStatusMsg& operator=(const SLL2NotifStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2NotifStatusMsg& operator=(SLL2NotifStatusMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2NotifStatusMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLL2NotifStatusMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2NotifStatusMsg*>(
               &_SLL2NotifStatusMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SLL2NotifStatusMsg& a, SLL2NotifStatusMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2NotifStatusMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2NotifStatusMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2NotifStatusMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2NotifStatusMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2NotifStatusMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2NotifStatusMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2NotifStatusMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2NotifStatusMsg";
  }
  protected:
  explicit SLL2NotifStatusMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBdNameFieldNumber = 3,
    kNotifStatusFieldNumber = 4,
    kCorrelatorFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // string BdName = 3;
  void clear_bdname();
  const std::string& bdname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bdname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bdname();
  PROTOBUF_NODISCARD std::string* release_bdname();
  void set_allocated_bdname(std::string* bdname);
  private:
  const std::string& _internal_bdname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bdname(const std::string& value);
  std::string* _internal_mutable_bdname();
  public:

  // .service_layer.SLErrorStatus NotifStatus = 4;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLErrorStatus& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_notifstatus();
  ::service_layer::SLErrorStatus* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_notifstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLErrorStatus* notifstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_notifstatus();

  // uint64 Correlator = 2;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLL2NotifStatusMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bdname_;
  ::service_layer::SLErrorStatus* notifstatus_;
  uint64_t correlator_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// -------------------------------------------------------------------

class SLL2Notif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2Notif) */ {
 public:
  inline SLL2Notif() : SLL2Notif(nullptr) {}
  ~SLL2Notif() override;
  explicit constexpr SLL2Notif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLL2Notif(const SLL2Notif& from);
  SLL2Notif(SLL2Notif&& from) noexcept
    : SLL2Notif() {
    *this = ::std::move(from);
  }

  inline SLL2Notif& operator=(const SLL2Notif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLL2Notif& operator=(SLL2Notif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLL2Notif& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kErrStatus = 2,
    kNotifStatus = 3,
    kBdStateInfo = 4,
    kRoute = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const SLL2Notif* internal_default_instance() {
    return reinterpret_cast<const SLL2Notif*>(
               &_SLL2Notif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SLL2Notif& a, SLL2Notif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLL2Notif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLL2Notif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLL2Notif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLL2Notif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLL2Notif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLL2Notif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLL2Notif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLL2Notif";
  }
  protected:
  explicit SLL2Notif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kErrStatusFieldNumber = 2,
    kNotifStatusFieldNumber = 3,
    kBdStateInfoFieldNumber = 4,
    kRouteFieldNumber = 5,
  };
  // .service_layer.SLL2NotifType EventType = 1;
  void clear_eventtype();
  ::service_layer::SLL2NotifType eventtype() const;
  void set_eventtype(::service_layer::SLL2NotifType value);
  private:
  ::service_layer::SLL2NotifType _internal_eventtype() const;
  void _internal_set_eventtype(::service_layer::SLL2NotifType value);
  public:

  // .service_layer.SLErrorStatus ErrStatus = 2;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // .service_layer.SLL2NotifStatusMsg NotifStatus = 3;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLL2NotifStatusMsg& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2NotifStatusMsg* release_notifstatus();
  ::service_layer::SLL2NotifStatusMsg* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLL2NotifStatusMsg* notifstatus);
  private:
  const ::service_layer::SLL2NotifStatusMsg& _internal_notifstatus() const;
  ::service_layer::SLL2NotifStatusMsg* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLL2NotifStatusMsg* notifstatus);
  ::service_layer::SLL2NotifStatusMsg* unsafe_arena_release_notifstatus();

  // .service_layer.SLL2BdStateInfo BdStateInfo = 4;
  bool has_bdstateinfo() const;
  private:
  bool _internal_has_bdstateinfo() const;
  public:
  void clear_bdstateinfo();
  const ::service_layer::SLL2BdStateInfo& bdstateinfo() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2BdStateInfo* release_bdstateinfo();
  ::service_layer::SLL2BdStateInfo* mutable_bdstateinfo();
  void set_allocated_bdstateinfo(::service_layer::SLL2BdStateInfo* bdstateinfo);
  private:
  const ::service_layer::SLL2BdStateInfo& _internal_bdstateinfo() const;
  ::service_layer::SLL2BdStateInfo* _internal_mutable_bdstateinfo();
  public:
  void unsafe_arena_set_allocated_bdstateinfo(
      ::service_layer::SLL2BdStateInfo* bdstateinfo);
  ::service_layer::SLL2BdStateInfo* unsafe_arena_release_bdstateinfo();

  // .service_layer.SLL2RouteNotif Route = 5;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::service_layer::SLL2RouteNotif& route() const;
  PROTOBUF_NODISCARD ::service_layer::SLL2RouteNotif* release_route();
  ::service_layer::SLL2RouteNotif* mutable_route();
  void set_allocated_route(::service_layer::SLL2RouteNotif* route);
  private:
  const ::service_layer::SLL2RouteNotif& _internal_route() const;
  ::service_layer::SLL2RouteNotif* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::service_layer::SLL2RouteNotif* route);
  ::service_layer::SLL2RouteNotif* unsafe_arena_release_route();

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2Notif)
 private:
  class _Internal;
  void set_has_errstatus();
  void set_has_notifstatus();
  void set_has_bdstateinfo();
  void set_has_route();

  inline bool has_Event() const;
  inline void clear_has_Event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int eventtype_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLErrorStatus* errstatus_;
    ::service_layer::SLL2NotifStatusMsg* notifstatus_;
    ::service_layer::SLL2BdStateInfo* bdstateinfo_;
    ::service_layer::SLL2RouteNotif* route_;
  } Event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fl2_5froute_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLL2GlobalsGetMsg

// -------------------------------------------------------------------

// SLL2GlobalsGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2GlobalsGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLL2GlobalsGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLL2GlobalsGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2GlobalsGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLL2GlobalsGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLL2GlobalsGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
}

// uint32 MaxBdRegPerBdRegmsg = 2;
inline void SLL2GlobalsGetMsgRsp::clear_maxbdregperbdregmsg() {
  maxbdregperbdregmsg_ = 0u;
}
inline uint32_t SLL2GlobalsGetMsgRsp::_internal_maxbdregperbdregmsg() const {
  return maxbdregperbdregmsg_;
}
inline uint32_t SLL2GlobalsGetMsgRsp::maxbdregperbdregmsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.MaxBdRegPerBdRegmsg)
  return _internal_maxbdregperbdregmsg();
}
inline void SLL2GlobalsGetMsgRsp::_internal_set_maxbdregperbdregmsg(uint32_t value) {
  
  maxbdregperbdregmsg_ = value;
}
inline void SLL2GlobalsGetMsgRsp::set_maxbdregperbdregmsg(uint32_t value) {
  _internal_set_maxbdregperbdregmsg(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GlobalsGetMsgRsp.MaxBdRegPerBdRegmsg)
}

// uint32 MaxRoutePerRoutemsg = 3;
inline void SLL2GlobalsGetMsgRsp::clear_maxrouteperroutemsg() {
  maxrouteperroutemsg_ = 0u;
}
inline uint32_t SLL2GlobalsGetMsgRsp::_internal_maxrouteperroutemsg() const {
  return maxrouteperroutemsg_;
}
inline uint32_t SLL2GlobalsGetMsgRsp::maxrouteperroutemsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.MaxRoutePerRoutemsg)
  return _internal_maxrouteperroutemsg();
}
inline void SLL2GlobalsGetMsgRsp::_internal_set_maxrouteperroutemsg(uint32_t value) {
  
  maxrouteperroutemsg_ = value;
}
inline void SLL2GlobalsGetMsgRsp::set_maxrouteperroutemsg(uint32_t value) {
  _internal_set_maxrouteperroutemsg(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GlobalsGetMsgRsp.MaxRoutePerRoutemsg)
}

// -------------------------------------------------------------------

// SLL2RegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLL2RegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLL2RegMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline ::service_layer::SLRegOp SLL2RegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.Oper)
  return _internal_oper();
}
inline void SLL2RegMsg::_internal_set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
}
inline void SLL2RegMsg::set_oper(::service_layer::SLRegOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.Oper)
}

// uint32 AdminDistance = 2;
inline void SLL2RegMsg::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLL2RegMsg::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLL2RegMsg::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.AdminDistance)
  return _internal_admindistance();
}
inline void SLL2RegMsg::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLL2RegMsg::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.AdminDistance)
}

// uint32 PurgeIntervalSeconds = 3;
inline void SLL2RegMsg::clear_purgeintervalseconds() {
  purgeintervalseconds_ = 0u;
}
inline uint32_t SLL2RegMsg::_internal_purgeintervalseconds() const {
  return purgeintervalseconds_;
}
inline uint32_t SLL2RegMsg::purgeintervalseconds() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.PurgeIntervalSeconds)
  return _internal_purgeintervalseconds();
}
inline void SLL2RegMsg::_internal_set_purgeintervalseconds(uint32_t value) {
  
  purgeintervalseconds_ = value;
}
inline void SLL2RegMsg::set_purgeintervalseconds(uint32_t value) {
  _internal_set_purgeintervalseconds(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.PurgeIntervalSeconds)
}

// -------------------------------------------------------------------

// SLL2RegMsgRsp

// .service_layer.SLErrorStatus RegStatus = 1;
inline bool SLL2RegMsgRsp::_internal_has_regstatus() const {
  return this != internal_default_instance() && regstatus_ != nullptr;
}
inline bool SLL2RegMsgRsp::has_regstatus() const {
  return _internal_has_regstatus();
}
inline const ::service_layer::SLErrorStatus& SLL2RegMsgRsp::_internal_regstatus() const {
  const ::service_layer::SLErrorStatus* p = regstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2RegMsgRsp::regstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsgRsp.RegStatus)
  return _internal_regstatus();
}
inline void SLL2RegMsgRsp::unsafe_arena_set_allocated_regstatus(
    ::service_layer::SLErrorStatus* regstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(regstatus_);
  }
  regstatus_ = regstatus;
  if (regstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RegMsgRsp.RegStatus)
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::release_regstatus() {
  
  ::service_layer::SLErrorStatus* temp = regstatus_;
  regstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::unsafe_arena_release_regstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RegMsgRsp.RegStatus)
  
  ::service_layer::SLErrorStatus* temp = regstatus_;
  regstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::_internal_mutable_regstatus() {
  
  if (regstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    regstatus_ = p;
  }
  return regstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::mutable_regstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_regstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RegMsgRsp.RegStatus)
  return _msg;
}
inline void SLL2RegMsgRsp::set_allocated_regstatus(::service_layer::SLErrorStatus* regstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(regstatus_);
  }
  if (regstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(regstatus));
    if (message_arena != submessage_arena) {
      regstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regstatus, submessage_arena);
    }
    
  } else {
    
  }
  regstatus_ = regstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RegMsgRsp.RegStatus)
}

// -------------------------------------------------------------------

// SLL2BdRegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLL2BdRegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLL2BdRegMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline ::service_layer::SLRegOp SLL2BdRegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsg.Oper)
  return _internal_oper();
}
inline void SLL2BdRegMsg::_internal_set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
}
inline void SLL2BdRegMsg::set_oper(::service_layer::SLRegOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.Oper)
}

// repeated string BdRegName = 2;
inline int SLL2BdRegMsg::_internal_bdregname_size() const {
  return bdregname_.size();
}
inline int SLL2BdRegMsg::bdregname_size() const {
  return _internal_bdregname_size();
}
inline void SLL2BdRegMsg::clear_bdregname() {
  bdregname_.Clear();
}
inline std::string* SLL2BdRegMsg::add_bdregname() {
  std::string* _s = _internal_add_bdregname();
  // @@protoc_insertion_point(field_add_mutable:service_layer.SLL2BdRegMsg.BdRegName)
  return _s;
}
inline const std::string& SLL2BdRegMsg::_internal_bdregname(int index) const {
  return bdregname_.Get(index);
}
inline const std::string& SLL2BdRegMsg::bdregname(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsg.BdRegName)
  return _internal_bdregname(index);
}
inline std::string* SLL2BdRegMsg::mutable_bdregname(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_.Mutable(index);
}
inline void SLL2BdRegMsg::set_bdregname(int index, const std::string& value) {
  bdregname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::set_bdregname(int index, std::string&& value) {
  bdregname_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::set_bdregname(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bdregname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::set_bdregname(int index, const char* value, size_t size) {
  bdregname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2BdRegMsg.BdRegName)
}
inline std::string* SLL2BdRegMsg::_internal_add_bdregname() {
  return bdregname_.Add();
}
inline void SLL2BdRegMsg::add_bdregname(const std::string& value) {
  bdregname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::add_bdregname(std::string&& value) {
  bdregname_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::add_bdregname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bdregname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::add_bdregname(const char* value, size_t size) {
  bdregname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service_layer.SLL2BdRegMsg.BdRegName)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SLL2BdRegMsg::bdregname() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SLL2BdRegMsg::mutable_bdregname() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2BdRegMsg.BdRegName)
  return &bdregname_;
}

// -------------------------------------------------------------------

// SLL2BdRegRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2BdRegRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLL2BdRegRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLL2BdRegRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2BdRegRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegRes.ErrStatus)
  return _msg;
}
inline void SLL2BdRegRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegRes.ErrStatus)
}

// string BdName = 2;
inline void SLL2BdRegRes::clear_bdname() {
  bdname_.ClearToEmpty();
}
inline const std::string& SLL2BdRegRes::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegRes.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2BdRegRes::set_bdname(ArgT0&& arg0, ArgT... args) {
 
 bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegRes.BdName)
}
inline std::string* SLL2BdRegRes::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegRes.BdName)
  return _s;
}
inline const std::string& SLL2BdRegRes::_internal_bdname() const {
  return bdname_.Get();
}
inline void SLL2BdRegRes::_internal_set_bdname(const std::string& value) {
  
  bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2BdRegRes::_internal_mutable_bdname() {
  
  return bdname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2BdRegRes::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegRes.BdName)
  return bdname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2BdRegRes::set_allocated_bdname(std::string* bdname) {
  if (bdname != nullptr) {
    
  } else {
    
  }
  bdname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bdname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bdname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegRes.BdName)
}

// -------------------------------------------------------------------

// SLL2BdRegMsgRsp

// .service_layer.SLErrorStatus StatusSummary = 1;
inline bool SLL2BdRegMsgRsp::_internal_has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != nullptr;
}
inline bool SLL2BdRegMsgRsp::has_statussummary() const {
  return _internal_has_statussummary();
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegMsgRsp::_internal_statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegMsgRsp::statussummary() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  return _internal_statussummary();
}
inline void SLL2BdRegMsgRsp::unsafe_arena_set_allocated_statussummary(
    ::service_layer::SLErrorStatus* statussummary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  statussummary_ = statussummary;
  if (statussummary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2BdRegMsgRsp.StatusSummary)
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::release_statussummary() {
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::unsafe_arena_release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::_internal_mutable_statussummary() {
  
  if (statussummary_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    statussummary_ = p;
  }
  return statussummary_;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::mutable_statussummary() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_statussummary();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  return _msg;
}
inline void SLL2BdRegMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary));
    if (message_arena != submessage_arena) {
      statussummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegMsgRsp.StatusSummary)
}

// repeated .service_layer.SLL2BdRegRes Results = 2;
inline int SLL2BdRegMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLL2BdRegMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLL2BdRegMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLL2BdRegRes* SLL2BdRegMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2BdRegRes >*
SLL2BdRegMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2BdRegMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLL2BdRegRes& SLL2BdRegMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLL2BdRegRes& SLL2BdRegMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLL2BdRegRes* SLL2BdRegMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLL2BdRegRes* SLL2BdRegMsgRsp::add_results() {
  ::service_layer::SLL2BdRegRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2BdRegRes >&
SLL2BdRegMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2BdRegMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLL2RouteEsi

// bytes Esi = 1;
inline void SLL2RouteEsi::clear_esi() {
  esi_.ClearToEmpty();
}
inline const std::string& SLL2RouteEsi::esi() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteEsi.Esi)
  return _internal_esi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2RouteEsi::set_esi(ArgT0&& arg0, ArgT... args) {
 
 esi_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteEsi.Esi)
}
inline std::string* SLL2RouteEsi::mutable_esi() {
  std::string* _s = _internal_mutable_esi();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteEsi.Esi)
  return _s;
}
inline const std::string& SLL2RouteEsi::_internal_esi() const {
  return esi_.Get();
}
inline void SLL2RouteEsi::_internal_set_esi(const std::string& value) {
  
  esi_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2RouteEsi::_internal_mutable_esi() {
  
  return esi_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2RouteEsi::release_esi() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteEsi.Esi)
  return esi_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2RouteEsi::set_allocated_esi(std::string* esi) {
  if (esi != nullptr) {
    
  } else {
    
  }
  esi_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), esi,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (esi_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    esi_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteEsi.Esi)
}

// -------------------------------------------------------------------

// SLL2RouteNh

// .service_layer.SLL2RouteNh.SLL2RouteNhType NhType = 1;
inline void SLL2RouteNh::clear_nhtype() {
  nhtype_ = 0;
}
inline ::service_layer::SLL2RouteNh_SLL2RouteNhType SLL2RouteNh::_internal_nhtype() const {
  return static_cast< ::service_layer::SLL2RouteNh_SLL2RouteNhType >(nhtype_);
}
inline ::service_layer::SLL2RouteNh_SLL2RouteNhType SLL2RouteNh::nhtype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhType)
  return _internal_nhtype();
}
inline void SLL2RouteNh::_internal_set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value) {
  
  nhtype_ = value;
}
inline void SLL2RouteNh::set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value) {
  _internal_set_nhtype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteNh.NhType)
}

// .service_layer.SLInterface NhInterface = 2;
inline bool SLL2RouteNh::_internal_has_nhinterface() const {
  return NhData_case() == kNhInterface;
}
inline bool SLL2RouteNh::has_nhinterface() const {
  return _internal_has_nhinterface();
}
inline void SLL2RouteNh::set_has_nhinterface() {
  _oneof_case_[0] = kNhInterface;
}
inline ::service_layer::SLInterface* SLL2RouteNh::release_nhinterface() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNh.NhInterface)
  if (_internal_has_nhinterface()) {
    clear_has_NhData();
      ::service_layer::SLInterface* temp = NhData_.nhinterface_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    NhData_.nhinterface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLInterface& SLL2RouteNh::_internal_nhinterface() const {
  return _internal_has_nhinterface()
      ? *NhData_.nhinterface_
      : reinterpret_cast< ::service_layer::SLInterface&>(::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLL2RouteNh::nhinterface() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhInterface)
  return _internal_nhinterface();
}
inline ::service_layer::SLInterface* SLL2RouteNh::unsafe_arena_release_nhinterface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2RouteNh.NhInterface)
  if (_internal_has_nhinterface()) {
    clear_has_NhData();
    ::service_layer::SLInterface* temp = NhData_.nhinterface_;
    NhData_.nhinterface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2RouteNh::unsafe_arena_set_allocated_nhinterface(::service_layer::SLInterface* nhinterface) {
  clear_NhData();
  if (nhinterface) {
    set_has_nhinterface();
    NhData_.nhinterface_ = nhinterface;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteNh.NhInterface)
}
inline ::service_layer::SLInterface* SLL2RouteNh::_internal_mutable_nhinterface() {
  if (!_internal_has_nhinterface()) {
    clear_NhData();
    set_has_nhinterface();
    NhData_.nhinterface_ = CreateMaybeMessage< ::service_layer::SLInterface >(GetArenaForAllocation());
  }
  return NhData_.nhinterface_;
}
inline ::service_layer::SLInterface* SLL2RouteNh::mutable_nhinterface() {
  ::service_layer::SLInterface* _msg = _internal_mutable_nhinterface();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNh.NhInterface)
  return _msg;
}

// .service_layer.SLL2OverlayNh NhOverlay = 3;
inline bool SLL2RouteNh::_internal_has_nhoverlay() const {
  return NhData_case() == kNhOverlay;
}
inline bool SLL2RouteNh::has_nhoverlay() const {
  return _internal_has_nhoverlay();
}
inline void SLL2RouteNh::set_has_nhoverlay() {
  _oneof_case_[0] = kNhOverlay;
}
inline void SLL2RouteNh::clear_nhoverlay() {
  if (_internal_has_nhoverlay()) {
    if (GetArenaForAllocation() == nullptr) {
      delete NhData_.nhoverlay_;
    }
    clear_has_NhData();
  }
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::release_nhoverlay() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNh.NhOverlay)
  if (_internal_has_nhoverlay()) {
    clear_has_NhData();
      ::service_layer::SLL2OverlayNh* temp = NhData_.nhoverlay_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    NhData_.nhoverlay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2OverlayNh& SLL2RouteNh::_internal_nhoverlay() const {
  return _internal_has_nhoverlay()
      ? *NhData_.nhoverlay_
      : reinterpret_cast< ::service_layer::SLL2OverlayNh&>(::service_layer::_SLL2OverlayNh_default_instance_);
}
inline const ::service_layer::SLL2OverlayNh& SLL2RouteNh::nhoverlay() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhOverlay)
  return _internal_nhoverlay();
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::unsafe_arena_release_nhoverlay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2RouteNh.NhOverlay)
  if (_internal_has_nhoverlay()) {
    clear_has_NhData();
    ::service_layer::SLL2OverlayNh* temp = NhData_.nhoverlay_;
    NhData_.nhoverlay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2RouteNh::unsafe_arena_set_allocated_nhoverlay(::service_layer::SLL2OverlayNh* nhoverlay) {
  clear_NhData();
  if (nhoverlay) {
    set_has_nhoverlay();
    NhData_.nhoverlay_ = nhoverlay;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteNh.NhOverlay)
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::_internal_mutable_nhoverlay() {
  if (!_internal_has_nhoverlay()) {
    clear_NhData();
    set_has_nhoverlay();
    NhData_.nhoverlay_ = CreateMaybeMessage< ::service_layer::SLL2OverlayNh >(GetArenaForAllocation());
  }
  return NhData_.nhoverlay_;
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::mutable_nhoverlay() {
  ::service_layer::SLL2OverlayNh* _msg = _internal_mutable_nhoverlay();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNh.NhOverlay)
  return _msg;
}

inline bool SLL2RouteNh::has_NhData() const {
  return NhData_case() != NHDATA_NOT_SET;
}
inline void SLL2RouteNh::clear_has_NhData() {
  _oneof_case_[0] = NHDATA_NOT_SET;
}
inline SLL2RouteNh::NhDataCase SLL2RouteNh::NhData_case() const {
  return SLL2RouteNh::NhDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2OverlayNh

// .service_layer.SLIpAddress OverlayNhIp = 1;
inline bool SLL2OverlayNh::_internal_has_overlaynhip() const {
  return this != internal_default_instance() && overlaynhip_ != nullptr;
}
inline bool SLL2OverlayNh::has_overlaynhip() const {
  return _internal_has_overlaynhip();
}
inline const ::service_layer::SLIpAddress& SLL2OverlayNh::_internal_overlaynhip() const {
  const ::service_layer::SLIpAddress* p = overlaynhip_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLL2OverlayNh::overlaynhip() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhIp)
  return _internal_overlaynhip();
}
inline void SLL2OverlayNh::unsafe_arena_set_allocated_overlaynhip(
    ::service_layer::SLIpAddress* overlaynhip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overlaynhip_);
  }
  overlaynhip_ = overlaynhip;
  if (overlaynhip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2OverlayNh.OverlayNhIp)
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::release_overlaynhip() {
  
  ::service_layer::SLIpAddress* temp = overlaynhip_;
  overlaynhip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::unsafe_arena_release_overlaynhip() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2OverlayNh.OverlayNhIp)
  
  ::service_layer::SLIpAddress* temp = overlaynhip_;
  overlaynhip_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::_internal_mutable_overlaynhip() {
  
  if (overlaynhip_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    overlaynhip_ = p;
  }
  return overlaynhip_;
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::mutable_overlaynhip() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_overlaynhip();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2OverlayNh.OverlayNhIp)
  return _msg;
}
inline void SLL2OverlayNh::set_allocated_overlaynhip(::service_layer::SLIpAddress* overlaynhip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(overlaynhip_);
  }
  if (overlaynhip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overlaynhip));
    if (message_arena != submessage_arena) {
      overlaynhip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overlaynhip, submessage_arena);
    }
    
  } else {
    
  }
  overlaynhip_ = overlaynhip;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2OverlayNh.OverlayNhIp)
}

// .service_layer.SLEncapType OverlayNhEncap = 2;
inline void SLL2OverlayNh::clear_overlaynhencap() {
  overlaynhencap_ = 0;
}
inline ::service_layer::SLEncapType SLL2OverlayNh::_internal_overlaynhencap() const {
  return static_cast< ::service_layer::SLEncapType >(overlaynhencap_);
}
inline ::service_layer::SLEncapType SLL2OverlayNh::overlaynhencap() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhEncap)
  return _internal_overlaynhencap();
}
inline void SLL2OverlayNh::_internal_set_overlaynhencap(::service_layer::SLEncapType value) {
  
  overlaynhencap_ = value;
}
inline void SLL2OverlayNh::set_overlaynhencap(::service_layer::SLEncapType value) {
  _internal_set_overlaynhencap(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhEncap)
}

// uint32 OverlayNhLabel = 3;
inline void SLL2OverlayNh::clear_overlaynhlabel() {
  overlaynhlabel_ = 0u;
}
inline uint32_t SLL2OverlayNh::_internal_overlaynhlabel() const {
  return overlaynhlabel_;
}
inline uint32_t SLL2OverlayNh::overlaynhlabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhLabel)
  return _internal_overlaynhlabel();
}
inline void SLL2OverlayNh::_internal_set_overlaynhlabel(uint32_t value) {
  
  overlaynhlabel_ = value;
}
inline void SLL2OverlayNh::set_overlaynhlabel(uint32_t value) {
  _internal_set_overlaynhlabel(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhLabel)
}

// repeated uint32 OverlayNhL3Label = 4;
inline int SLL2OverlayNh::_internal_overlaynhl3label_size() const {
  return overlaynhl3label_.size();
}
inline int SLL2OverlayNh::overlaynhl3label_size() const {
  return _internal_overlaynhl3label_size();
}
inline void SLL2OverlayNh::clear_overlaynhl3label() {
  overlaynhl3label_.Clear();
}
inline uint32_t SLL2OverlayNh::_internal_overlaynhl3label(int index) const {
  return overlaynhl3label_.Get(index);
}
inline uint32_t SLL2OverlayNh::overlaynhl3label(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return _internal_overlaynhl3label(index);
}
inline void SLL2OverlayNh::set_overlaynhl3label(int index, uint32_t value) {
  overlaynhl3label_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhL3Label)
}
inline void SLL2OverlayNh::_internal_add_overlaynhl3label(uint32_t value) {
  overlaynhl3label_.Add(value);
}
inline void SLL2OverlayNh::add_overlaynhl3label(uint32_t value) {
  _internal_add_overlaynhl3label(value);
  // @@protoc_insertion_point(field_add:service_layer.SLL2OverlayNh.OverlayNhL3Label)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SLL2OverlayNh::_internal_overlaynhl3label() const {
  return overlaynhl3label_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SLL2OverlayNh::overlaynhl3label() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return _internal_overlaynhl3label();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SLL2OverlayNh::_internal_mutable_overlaynhl3label() {
  return &overlaynhl3label_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SLL2OverlayNh::mutable_overlaynhl3label() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return _internal_mutable_overlaynhl3label();
}

// bytes OverlayNhRouterMac = 5;
inline void SLL2OverlayNh::clear_overlaynhroutermac() {
  overlaynhroutermac_.ClearToEmpty();
}
inline const std::string& SLL2OverlayNh::overlaynhroutermac() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  return _internal_overlaynhroutermac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2OverlayNh::set_overlaynhroutermac(ArgT0&& arg0, ArgT... args) {
 
 overlaynhroutermac_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}
inline std::string* SLL2OverlayNh::mutable_overlaynhroutermac() {
  std::string* _s = _internal_mutable_overlaynhroutermac();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  return _s;
}
inline const std::string& SLL2OverlayNh::_internal_overlaynhroutermac() const {
  return overlaynhroutermac_.Get();
}
inline void SLL2OverlayNh::_internal_set_overlaynhroutermac(const std::string& value) {
  
  overlaynhroutermac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2OverlayNh::_internal_mutable_overlaynhroutermac() {
  
  return overlaynhroutermac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2OverlayNh::release_overlaynhroutermac() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  return overlaynhroutermac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2OverlayNh::set_allocated_overlaynhroutermac(std::string* overlaynhroutermac) {
  if (overlaynhroutermac != nullptr) {
    
  } else {
    
  }
  overlaynhroutermac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), overlaynhroutermac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (overlaynhroutermac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    overlaynhroutermac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}

// -------------------------------------------------------------------

// SLL2MacRouteKey

// bytes MacAddress = 1;
inline void SLL2MacRouteKey::clear_macaddress() {
  macaddress_.ClearToEmpty();
}
inline const std::string& SLL2MacRouteKey::macaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRouteKey.MacAddress)
  return _internal_macaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2MacRouteKey::set_macaddress(ArgT0&& arg0, ArgT... args) {
 
 macaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2MacRouteKey.MacAddress)
}
inline std::string* SLL2MacRouteKey::mutable_macaddress() {
  std::string* _s = _internal_mutable_macaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRouteKey.MacAddress)
  return _s;
}
inline const std::string& SLL2MacRouteKey::_internal_macaddress() const {
  return macaddress_.Get();
}
inline void SLL2MacRouteKey::_internal_set_macaddress(const std::string& value) {
  
  macaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2MacRouteKey::_internal_mutable_macaddress() {
  
  return macaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2MacRouteKey::release_macaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRouteKey.MacAddress)
  return macaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2MacRouteKey::set_allocated_macaddress(std::string* macaddress) {
  if (macaddress != nullptr) {
    
  } else {
    
  }
  macaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (macaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    macaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRouteKey.MacAddress)
}

// .service_layer.SLIpAddress IpAddress = 2;
inline bool SLL2MacRouteKey::_internal_has_ipaddress() const {
  return this != internal_default_instance() && ipaddress_ != nullptr;
}
inline bool SLL2MacRouteKey::has_ipaddress() const {
  return _internal_has_ipaddress();
}
inline const ::service_layer::SLIpAddress& SLL2MacRouteKey::_internal_ipaddress() const {
  const ::service_layer::SLIpAddress* p = ipaddress_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLL2MacRouteKey::ipaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRouteKey.IpAddress)
  return _internal_ipaddress();
}
inline void SLL2MacRouteKey::unsafe_arena_set_allocated_ipaddress(
    ::service_layer::SLIpAddress* ipaddress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress_);
  }
  ipaddress_ = ipaddress;
  if (ipaddress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2MacRouteKey.IpAddress)
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::release_ipaddress() {
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::unsafe_arena_release_ipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRouteKey.IpAddress)
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::_internal_mutable_ipaddress() {
  
  if (ipaddress_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    ipaddress_ = p;
  }
  return ipaddress_;
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::mutable_ipaddress() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRouteKey.IpAddress)
  return _msg;
}
inline void SLL2MacRouteKey::set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress_);
  }
  if (ipaddress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress));
    if (message_arena != submessage_arena) {
      ipaddress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipaddress, submessage_arena);
    }
    
  } else {
    
  }
  ipaddress_ = ipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRouteKey.IpAddress)
}

// -------------------------------------------------------------------

// SLL2MacRoute

// .service_layer.SLL2MacRouteKey RouteKey = 1;
inline bool SLL2MacRoute::_internal_has_routekey() const {
  return this != internal_default_instance() && routekey_ != nullptr;
}
inline bool SLL2MacRoute::has_routekey() const {
  return _internal_has_routekey();
}
inline void SLL2MacRoute::clear_routekey() {
  if (GetArenaForAllocation() == nullptr && routekey_ != nullptr) {
    delete routekey_;
  }
  routekey_ = nullptr;
}
inline const ::service_layer::SLL2MacRouteKey& SLL2MacRoute::_internal_routekey() const {
  const ::service_layer::SLL2MacRouteKey* p = routekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLL2MacRouteKey&>(
      ::service_layer::_SLL2MacRouteKey_default_instance_);
}
inline const ::service_layer::SLL2MacRouteKey& SLL2MacRoute::routekey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.RouteKey)
  return _internal_routekey();
}
inline void SLL2MacRoute::unsafe_arena_set_allocated_routekey(
    ::service_layer::SLL2MacRouteKey* routekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routekey_);
  }
  routekey_ = routekey;
  if (routekey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2MacRoute.RouteKey)
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::release_routekey() {
  
  ::service_layer::SLL2MacRouteKey* temp = routekey_;
  routekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::unsafe_arena_release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRoute.RouteKey)
  
  ::service_layer::SLL2MacRouteKey* temp = routekey_;
  routekey_ = nullptr;
  return temp;
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::_internal_mutable_routekey() {
  
  if (routekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLL2MacRouteKey>(GetArenaForAllocation());
    routekey_ = p;
  }
  return routekey_;
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::mutable_routekey() {
  ::service_layer::SLL2MacRouteKey* _msg = _internal_mutable_routekey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.RouteKey)
  return _msg;
}
inline void SLL2MacRoute::set_allocated_routekey(::service_layer::SLL2MacRouteKey* routekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routekey_;
  }
  if (routekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLL2MacRouteKey>::GetOwningArena(routekey);
    if (message_arena != submessage_arena) {
      routekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRoute.RouteKey)
}

// uint32 SequenceNum = 2;
inline void SLL2MacRoute::clear_sequencenum() {
  sequencenum_ = 0u;
}
inline uint32_t SLL2MacRoute::_internal_sequencenum() const {
  return sequencenum_;
}
inline uint32_t SLL2MacRoute::sequencenum() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.SequenceNum)
  return _internal_sequencenum();
}
inline void SLL2MacRoute::_internal_set_sequencenum(uint32_t value) {
  
  sequencenum_ = value;
}
inline void SLL2MacRoute::set_sequencenum(uint32_t value) {
  _internal_set_sequencenum(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2MacRoute.SequenceNum)
}

// .service_layer.SLL2RouteEsi MacEsi = 3;
inline bool SLL2MacRoute::_internal_has_macesi() const {
  return this != internal_default_instance() && macesi_ != nullptr;
}
inline bool SLL2MacRoute::has_macesi() const {
  return _internal_has_macesi();
}
inline void SLL2MacRoute::clear_macesi() {
  if (GetArenaForAllocation() == nullptr && macesi_ != nullptr) {
    delete macesi_;
  }
  macesi_ = nullptr;
}
inline const ::service_layer::SLL2RouteEsi& SLL2MacRoute::_internal_macesi() const {
  const ::service_layer::SLL2RouteEsi* p = macesi_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLL2RouteEsi&>(
      ::service_layer::_SLL2RouteEsi_default_instance_);
}
inline const ::service_layer::SLL2RouteEsi& SLL2MacRoute::macesi() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.MacEsi)
  return _internal_macesi();
}
inline void SLL2MacRoute::unsafe_arena_set_allocated_macesi(
    ::service_layer::SLL2RouteEsi* macesi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(macesi_);
  }
  macesi_ = macesi;
  if (macesi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2MacRoute.MacEsi)
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::release_macesi() {
  
  ::service_layer::SLL2RouteEsi* temp = macesi_;
  macesi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::unsafe_arena_release_macesi() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRoute.MacEsi)
  
  ::service_layer::SLL2RouteEsi* temp = macesi_;
  macesi_ = nullptr;
  return temp;
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::_internal_mutable_macesi() {
  
  if (macesi_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLL2RouteEsi>(GetArenaForAllocation());
    macesi_ = p;
  }
  return macesi_;
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::mutable_macesi() {
  ::service_layer::SLL2RouteEsi* _msg = _internal_mutable_macesi();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.MacEsi)
  return _msg;
}
inline void SLL2MacRoute::set_allocated_macesi(::service_layer::SLL2RouteEsi* macesi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete macesi_;
  }
  if (macesi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLL2RouteEsi>::GetOwningArena(macesi);
    if (message_arena != submessage_arena) {
      macesi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, macesi, submessage_arena);
    }
    
  } else {
    
  }
  macesi_ = macesi;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRoute.MacEsi)
}

// repeated .service_layer.SLL2RouteNh NextHopList = 4;
inline int SLL2MacRoute::_internal_nexthoplist_size() const {
  return nexthoplist_.size();
}
inline int SLL2MacRoute::nexthoplist_size() const {
  return _internal_nexthoplist_size();
}
inline void SLL2MacRoute::clear_nexthoplist() {
  nexthoplist_.Clear();
}
inline ::service_layer::SLL2RouteNh* SLL2MacRoute::mutable_nexthoplist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteNh >*
SLL2MacRoute::mutable_nexthoplist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2MacRoute.NextHopList)
  return &nexthoplist_;
}
inline const ::service_layer::SLL2RouteNh& SLL2MacRoute::_internal_nexthoplist(int index) const {
  return nexthoplist_.Get(index);
}
inline const ::service_layer::SLL2RouteNh& SLL2MacRoute::nexthoplist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.NextHopList)
  return _internal_nexthoplist(index);
}
inline ::service_layer::SLL2RouteNh* SLL2MacRoute::_internal_add_nexthoplist() {
  return nexthoplist_.Add();
}
inline ::service_layer::SLL2RouteNh* SLL2MacRoute::add_nexthoplist() {
  ::service_layer::SLL2RouteNh* _add = _internal_add_nexthoplist();
  // @@protoc_insertion_point(field_add:service_layer.SLL2MacRoute.NextHopList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteNh >&
SLL2MacRoute::nexthoplist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_;
}

// -------------------------------------------------------------------

// SLL2ImetRouteKey

// uint32 EthTagId = 1;
inline void SLL2ImetRouteKey::clear_ethtagid() {
  ethtagid_ = 0u;
}
inline uint32_t SLL2ImetRouteKey::_internal_ethtagid() const {
  return ethtagid_;
}
inline uint32_t SLL2ImetRouteKey::ethtagid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRouteKey.EthTagId)
  return _internal_ethtagid();
}
inline void SLL2ImetRouteKey::_internal_set_ethtagid(uint32_t value) {
  
  ethtagid_ = value;
}
inline void SLL2ImetRouteKey::set_ethtagid(uint32_t value) {
  _internal_set_ethtagid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRouteKey.EthTagId)
}

// .service_layer.SLIpAddress IpAddress = 2;
inline bool SLL2ImetRouteKey::_internal_has_ipaddress() const {
  return this != internal_default_instance() && ipaddress_ != nullptr;
}
inline bool SLL2ImetRouteKey::has_ipaddress() const {
  return _internal_has_ipaddress();
}
inline const ::service_layer::SLIpAddress& SLL2ImetRouteKey::_internal_ipaddress() const {
  const ::service_layer::SLIpAddress* p = ipaddress_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLL2ImetRouteKey::ipaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRouteKey.IpAddress)
  return _internal_ipaddress();
}
inline void SLL2ImetRouteKey::unsafe_arena_set_allocated_ipaddress(
    ::service_layer::SLIpAddress* ipaddress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress_);
  }
  ipaddress_ = ipaddress;
  if (ipaddress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2ImetRouteKey.IpAddress)
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::release_ipaddress() {
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::unsafe_arena_release_ipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRouteKey.IpAddress)
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::_internal_mutable_ipaddress() {
  
  if (ipaddress_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    ipaddress_ = p;
  }
  return ipaddress_;
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::mutable_ipaddress() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRouteKey.IpAddress)
  return _msg;
}
inline void SLL2ImetRouteKey::set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress_);
  }
  if (ipaddress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipaddress));
    if (message_arena != submessage_arena) {
      ipaddress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipaddress, submessage_arena);
    }
    
  } else {
    
  }
  ipaddress_ = ipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRouteKey.IpAddress)
}

// -------------------------------------------------------------------

// SLL2ImetRoute

// .service_layer.SLL2ImetRouteKey RouteKey = 1;
inline bool SLL2ImetRoute::_internal_has_routekey() const {
  return this != internal_default_instance() && routekey_ != nullptr;
}
inline bool SLL2ImetRoute::has_routekey() const {
  return _internal_has_routekey();
}
inline void SLL2ImetRoute::clear_routekey() {
  if (GetArenaForAllocation() == nullptr && routekey_ != nullptr) {
    delete routekey_;
  }
  routekey_ = nullptr;
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2ImetRoute::_internal_routekey() const {
  const ::service_layer::SLL2ImetRouteKey* p = routekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLL2ImetRouteKey&>(
      ::service_layer::_SLL2ImetRouteKey_default_instance_);
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2ImetRoute::routekey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.RouteKey)
  return _internal_routekey();
}
inline void SLL2ImetRoute::unsafe_arena_set_allocated_routekey(
    ::service_layer::SLL2ImetRouteKey* routekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routekey_);
  }
  routekey_ = routekey;
  if (routekey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2ImetRoute.RouteKey)
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::release_routekey() {
  
  ::service_layer::SLL2ImetRouteKey* temp = routekey_;
  routekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::unsafe_arena_release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRoute.RouteKey)
  
  ::service_layer::SLL2ImetRouteKey* temp = routekey_;
  routekey_ = nullptr;
  return temp;
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::_internal_mutable_routekey() {
  
  if (routekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLL2ImetRouteKey>(GetArenaForAllocation());
    routekey_ = p;
  }
  return routekey_;
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::mutable_routekey() {
  ::service_layer::SLL2ImetRouteKey* _msg = _internal_mutable_routekey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRoute.RouteKey)
  return _msg;
}
inline void SLL2ImetRoute::set_allocated_routekey(::service_layer::SLL2ImetRouteKey* routekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routekey_;
  }
  if (routekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLL2ImetRouteKey>::GetOwningArena(routekey);
    if (message_arena != submessage_arena) {
      routekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRoute.RouteKey)
}

// .service_layer.SLEncapType EncapType = 2;
inline void SLL2ImetRoute::clear_encaptype() {
  encaptype_ = 0;
}
inline ::service_layer::SLEncapType SLL2ImetRoute::_internal_encaptype() const {
  return static_cast< ::service_layer::SLEncapType >(encaptype_);
}
inline ::service_layer::SLEncapType SLL2ImetRoute::encaptype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.EncapType)
  return _internal_encaptype();
}
inline void SLL2ImetRoute::_internal_set_encaptype(::service_layer::SLEncapType value) {
  
  encaptype_ = value;
}
inline void SLL2ImetRoute::set_encaptype(::service_layer::SLEncapType value) {
  _internal_set_encaptype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.EncapType)
}

// uint32 Label = 3;
inline void SLL2ImetRoute::clear_label() {
  label_ = 0u;
}
inline uint32_t SLL2ImetRoute::_internal_label() const {
  return label_;
}
inline uint32_t SLL2ImetRoute::label() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.Label)
  return _internal_label();
}
inline void SLL2ImetRoute::_internal_set_label(uint32_t value) {
  
  label_ = value;
}
inline void SLL2ImetRoute::set_label(uint32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.Label)
}

// .service_layer.SLL2ImetRoute.PMSITunnelType TunnelType = 4;
inline void SLL2ImetRoute::clear_tunneltype() {
  tunneltype_ = 0;
}
inline ::service_layer::SLL2ImetRoute_PMSITunnelType SLL2ImetRoute::_internal_tunneltype() const {
  return static_cast< ::service_layer::SLL2ImetRoute_PMSITunnelType >(tunneltype_);
}
inline ::service_layer::SLL2ImetRoute_PMSITunnelType SLL2ImetRoute::tunneltype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelType)
  return _internal_tunneltype();
}
inline void SLL2ImetRoute::_internal_set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value) {
  
  tunneltype_ = value;
}
inline void SLL2ImetRoute::set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value) {
  _internal_set_tunneltype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelType)
}

// uint32 TunnelIdLength = 5;
inline void SLL2ImetRoute::clear_tunnelidlength() {
  tunnelidlength_ = 0u;
}
inline uint32_t SLL2ImetRoute::_internal_tunnelidlength() const {
  return tunnelidlength_;
}
inline uint32_t SLL2ImetRoute::tunnelidlength() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelIdLength)
  return _internal_tunnelidlength();
}
inline void SLL2ImetRoute::_internal_set_tunnelidlength(uint32_t value) {
  
  tunnelidlength_ = value;
}
inline void SLL2ImetRoute::set_tunnelidlength(uint32_t value) {
  _internal_set_tunnelidlength(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelIdLength)
}

// bytes TunnelIdValue = 6;
inline void SLL2ImetRoute::clear_tunnelidvalue() {
  tunnelidvalue_.ClearToEmpty();
}
inline const std::string& SLL2ImetRoute::tunnelidvalue() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelIdValue)
  return _internal_tunnelidvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2ImetRoute::set_tunnelidvalue(ArgT0&& arg0, ArgT... args) {
 
 tunnelidvalue_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelIdValue)
}
inline std::string* SLL2ImetRoute::mutable_tunnelidvalue() {
  std::string* _s = _internal_mutable_tunnelidvalue();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRoute.TunnelIdValue)
  return _s;
}
inline const std::string& SLL2ImetRoute::_internal_tunnelidvalue() const {
  return tunnelidvalue_.Get();
}
inline void SLL2ImetRoute::_internal_set_tunnelidvalue(const std::string& value) {
  
  tunnelidvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2ImetRoute::_internal_mutable_tunnelidvalue() {
  
  return tunnelidvalue_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2ImetRoute::release_tunnelidvalue() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRoute.TunnelIdValue)
  return tunnelidvalue_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2ImetRoute::set_allocated_tunnelidvalue(std::string* tunnelidvalue) {
  if (tunnelidvalue != nullptr) {
    
  } else {
    
  }
  tunnelidvalue_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tunnelidvalue,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tunnelidvalue_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tunnelidvalue_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRoute.TunnelIdValue)
}

// -------------------------------------------------------------------

// SLL2RouteKey

// string BdName = 1;
inline void SLL2RouteKey::clear_bdname() {
  bdname_.ClearToEmpty();
}
inline const std::string& SLL2RouteKey::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2RouteKey::set_bdname(ArgT0&& arg0, ArgT... args) {
 
 bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteKey.BdName)
}
inline std::string* SLL2RouteKey::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.BdName)
  return _s;
}
inline const std::string& SLL2RouteKey::_internal_bdname() const {
  return bdname_.Get();
}
inline void SLL2RouteKey::_internal_set_bdname(const std::string& value) {
  
  bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2RouteKey::_internal_mutable_bdname() {
  
  return bdname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2RouteKey::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.BdName)
  return bdname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2RouteKey::set_allocated_bdname(std::string* bdname) {
  if (bdname != nullptr) {
    
  } else {
    
  }
  bdname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bdname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bdname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteKey.BdName)
}

// .service_layer.SLL2RouteType Type = 2;
inline void SLL2RouteKey::clear_type() {
  type_ = 0;
}
inline ::service_layer::SLL2RouteType SLL2RouteKey::_internal_type() const {
  return static_cast< ::service_layer::SLL2RouteType >(type_);
}
inline ::service_layer::SLL2RouteType SLL2RouteKey::type() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.Type)
  return _internal_type();
}
inline void SLL2RouteKey::_internal_set_type(::service_layer::SLL2RouteType value) {
  
  type_ = value;
}
inline void SLL2RouteKey::set_type(::service_layer::SLL2RouteType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteKey.Type)
}

// .service_layer.SLL2MacRouteKey MacKey = 3;
inline bool SLL2RouteKey::_internal_has_mackey() const {
  return Event_case() == kMacKey;
}
inline bool SLL2RouteKey::has_mackey() const {
  return _internal_has_mackey();
}
inline void SLL2RouteKey::set_has_mackey() {
  _oneof_case_[0] = kMacKey;
}
inline void SLL2RouteKey::clear_mackey() {
  if (_internal_has_mackey()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.mackey_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::release_mackey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.MacKey)
  if (_internal_has_mackey()) {
    clear_has_Event();
      ::service_layer::SLL2MacRouteKey* temp = Event_.mackey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.mackey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2MacRouteKey& SLL2RouteKey::_internal_mackey() const {
  return _internal_has_mackey()
      ? *Event_.mackey_
      : reinterpret_cast< ::service_layer::SLL2MacRouteKey&>(::service_layer::_SLL2MacRouteKey_default_instance_);
}
inline const ::service_layer::SLL2MacRouteKey& SLL2RouteKey::mackey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.MacKey)
  return _internal_mackey();
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::unsafe_arena_release_mackey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2RouteKey.MacKey)
  if (_internal_has_mackey()) {
    clear_has_Event();
    ::service_layer::SLL2MacRouteKey* temp = Event_.mackey_;
    Event_.mackey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2RouteKey::unsafe_arena_set_allocated_mackey(::service_layer::SLL2MacRouteKey* mackey) {
  clear_Event();
  if (mackey) {
    set_has_mackey();
    Event_.mackey_ = mackey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteKey.MacKey)
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::_internal_mutable_mackey() {
  if (!_internal_has_mackey()) {
    clear_Event();
    set_has_mackey();
    Event_.mackey_ = CreateMaybeMessage< ::service_layer::SLL2MacRouteKey >(GetArenaForAllocation());
  }
  return Event_.mackey_;
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::mutable_mackey() {
  ::service_layer::SLL2MacRouteKey* _msg = _internal_mutable_mackey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.MacKey)
  return _msg;
}

// .service_layer.SLL2ImetRouteKey ImetKey = 4;
inline bool SLL2RouteKey::_internal_has_imetkey() const {
  return Event_case() == kImetKey;
}
inline bool SLL2RouteKey::has_imetkey() const {
  return _internal_has_imetkey();
}
inline void SLL2RouteKey::set_has_imetkey() {
  _oneof_case_[0] = kImetKey;
}
inline void SLL2RouteKey::clear_imetkey() {
  if (_internal_has_imetkey()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.imetkey_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::release_imetkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.ImetKey)
  if (_internal_has_imetkey()) {
    clear_has_Event();
      ::service_layer::SLL2ImetRouteKey* temp = Event_.imetkey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.imetkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2RouteKey::_internal_imetkey() const {
  return _internal_has_imetkey()
      ? *Event_.imetkey_
      : reinterpret_cast< ::service_layer::SLL2ImetRouteKey&>(::service_layer::_SLL2ImetRouteKey_default_instance_);
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2RouteKey::imetkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.ImetKey)
  return _internal_imetkey();
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::unsafe_arena_release_imetkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2RouteKey.ImetKey)
  if (_internal_has_imetkey()) {
    clear_has_Event();
    ::service_layer::SLL2ImetRouteKey* temp = Event_.imetkey_;
    Event_.imetkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2RouteKey::unsafe_arena_set_allocated_imetkey(::service_layer::SLL2ImetRouteKey* imetkey) {
  clear_Event();
  if (imetkey) {
    set_has_imetkey();
    Event_.imetkey_ = imetkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteKey.ImetKey)
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::_internal_mutable_imetkey() {
  if (!_internal_has_imetkey()) {
    clear_Event();
    set_has_imetkey();
    Event_.imetkey_ = CreateMaybeMessage< ::service_layer::SLL2ImetRouteKey >(GetArenaForAllocation());
  }
  return Event_.imetkey_;
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::mutable_imetkey() {
  ::service_layer::SLL2ImetRouteKey* _msg = _internal_mutable_imetkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.ImetKey)
  return _msg;
}

inline bool SLL2RouteKey::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2RouteKey::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2RouteKey::EventCase SLL2RouteKey::Event_case() const {
  return SLL2RouteKey::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2Route

// string BdName = 1;
inline void SLL2Route::clear_bdname() {
  bdname_.ClearToEmpty();
}
inline const std::string& SLL2Route::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2Route::set_bdname(ArgT0&& arg0, ArgT... args) {
 
 bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2Route.BdName)
}
inline std::string* SLL2Route::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.BdName)
  return _s;
}
inline const std::string& SLL2Route::_internal_bdname() const {
  return bdname_.Get();
}
inline void SLL2Route::_internal_set_bdname(const std::string& value) {
  
  bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2Route::_internal_mutable_bdname() {
  
  return bdname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2Route::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.BdName)
  return bdname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2Route::set_allocated_bdname(std::string* bdname) {
  if (bdname != nullptr) {
    
  } else {
    
  }
  bdname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bdname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bdname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2Route.BdName)
}

// .service_layer.SLL2RouteType Type = 2;
inline void SLL2Route::clear_type() {
  type_ = 0;
}
inline ::service_layer::SLL2RouteType SLL2Route::_internal_type() const {
  return static_cast< ::service_layer::SLL2RouteType >(type_);
}
inline ::service_layer::SLL2RouteType SLL2Route::type() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.Type)
  return _internal_type();
}
inline void SLL2Route::_internal_set_type(::service_layer::SLL2RouteType value) {
  
  type_ = value;
}
inline void SLL2Route::set_type(::service_layer::SLL2RouteType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2Route.Type)
}

// .service_layer.SLL2MacRoute MacRoute = 3;
inline bool SLL2Route::_internal_has_macroute() const {
  return Event_case() == kMacRoute;
}
inline bool SLL2Route::has_macroute() const {
  return _internal_has_macroute();
}
inline void SLL2Route::set_has_macroute() {
  _oneof_case_[0] = kMacRoute;
}
inline void SLL2Route::clear_macroute() {
  if (_internal_has_macroute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.macroute_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2MacRoute* SLL2Route::release_macroute() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.MacRoute)
  if (_internal_has_macroute()) {
    clear_has_Event();
      ::service_layer::SLL2MacRoute* temp = Event_.macroute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.macroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2MacRoute& SLL2Route::_internal_macroute() const {
  return _internal_has_macroute()
      ? *Event_.macroute_
      : reinterpret_cast< ::service_layer::SLL2MacRoute&>(::service_layer::_SLL2MacRoute_default_instance_);
}
inline const ::service_layer::SLL2MacRoute& SLL2Route::macroute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.MacRoute)
  return _internal_macroute();
}
inline ::service_layer::SLL2MacRoute* SLL2Route::unsafe_arena_release_macroute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Route.MacRoute)
  if (_internal_has_macroute()) {
    clear_has_Event();
    ::service_layer::SLL2MacRoute* temp = Event_.macroute_;
    Event_.macroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Route::unsafe_arena_set_allocated_macroute(::service_layer::SLL2MacRoute* macroute) {
  clear_Event();
  if (macroute) {
    set_has_macroute();
    Event_.macroute_ = macroute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Route.MacRoute)
}
inline ::service_layer::SLL2MacRoute* SLL2Route::_internal_mutable_macroute() {
  if (!_internal_has_macroute()) {
    clear_Event();
    set_has_macroute();
    Event_.macroute_ = CreateMaybeMessage< ::service_layer::SLL2MacRoute >(GetArenaForAllocation());
  }
  return Event_.macroute_;
}
inline ::service_layer::SLL2MacRoute* SLL2Route::mutable_macroute() {
  ::service_layer::SLL2MacRoute* _msg = _internal_mutable_macroute();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.MacRoute)
  return _msg;
}

// .service_layer.SLL2ImetRoute ImetRoute = 4;
inline bool SLL2Route::_internal_has_imetroute() const {
  return Event_case() == kImetRoute;
}
inline bool SLL2Route::has_imetroute() const {
  return _internal_has_imetroute();
}
inline void SLL2Route::set_has_imetroute() {
  _oneof_case_[0] = kImetRoute;
}
inline void SLL2Route::clear_imetroute() {
  if (_internal_has_imetroute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.imetroute_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::release_imetroute() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.ImetRoute)
  if (_internal_has_imetroute()) {
    clear_has_Event();
      ::service_layer::SLL2ImetRoute* temp = Event_.imetroute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.imetroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2ImetRoute& SLL2Route::_internal_imetroute() const {
  return _internal_has_imetroute()
      ? *Event_.imetroute_
      : reinterpret_cast< ::service_layer::SLL2ImetRoute&>(::service_layer::_SLL2ImetRoute_default_instance_);
}
inline const ::service_layer::SLL2ImetRoute& SLL2Route::imetroute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.ImetRoute)
  return _internal_imetroute();
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::unsafe_arena_release_imetroute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Route.ImetRoute)
  if (_internal_has_imetroute()) {
    clear_has_Event();
    ::service_layer::SLL2ImetRoute* temp = Event_.imetroute_;
    Event_.imetroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Route::unsafe_arena_set_allocated_imetroute(::service_layer::SLL2ImetRoute* imetroute) {
  clear_Event();
  if (imetroute) {
    set_has_imetroute();
    Event_.imetroute_ = imetroute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Route.ImetRoute)
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::_internal_mutable_imetroute() {
  if (!_internal_has_imetroute()) {
    clear_Event();
    set_has_imetroute();
    Event_.imetroute_ = CreateMaybeMessage< ::service_layer::SLL2ImetRoute >(GetArenaForAllocation());
  }
  return Event_.imetroute_;
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::mutable_imetroute() {
  ::service_layer::SLL2ImetRoute* _msg = _internal_mutable_imetroute();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.ImetRoute)
  return _msg;
}

inline bool SLL2Route::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2Route::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2Route::EventCase SLL2Route::Event_case() const {
  return SLL2Route::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2RouteMsg

// uint64 Correlator = 1;
inline void SLL2RouteMsg::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLL2RouteMsg::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLL2RouteMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Correlator)
  return _internal_correlator();
}
inline void SLL2RouteMsg::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLL2RouteMsg::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsg.Correlator)
}

// .service_layer.SLObjectOp Oper = 2;
inline void SLL2RouteMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLL2RouteMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline ::service_layer::SLObjectOp SLL2RouteMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Oper)
  return _internal_oper();
}
inline void SLL2RouteMsg::_internal_set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
}
inline void SLL2RouteMsg::set_oper(::service_layer::SLObjectOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsg.Oper)
}

// repeated .service_layer.SLL2Route Routes = 3;
inline int SLL2RouteMsg::_internal_routes_size() const {
  return routes_.size();
}
inline int SLL2RouteMsg::routes_size() const {
  return _internal_routes_size();
}
inline void SLL2RouteMsg::clear_routes() {
  routes_.Clear();
}
inline ::service_layer::SLL2Route* SLL2RouteMsg::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsg.Routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2Route >*
SLL2RouteMsg::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2RouteMsg.Routes)
  return &routes_;
}
inline const ::service_layer::SLL2Route& SLL2RouteMsg::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::service_layer::SLL2Route& SLL2RouteMsg::routes(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Routes)
  return _internal_routes(index);
}
inline ::service_layer::SLL2Route* SLL2RouteMsg::_internal_add_routes() {
  return routes_.Add();
}
inline ::service_layer::SLL2Route* SLL2RouteMsg::add_routes() {
  ::service_layer::SLL2Route* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:service_layer.SLL2RouteMsg.Routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2Route >&
SLL2RouteMsg::routes() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2RouteMsg.Routes)
  return routes_;
}

// -------------------------------------------------------------------

// SLL2RouteRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2RouteRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLL2RouteRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLL2RouteRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2RouteRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLL2RouteRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteRes.ErrStatus)
  return _msg;
}
inline void SLL2RouteRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteRes.ErrStatus)
}

// .service_layer.SLL2RouteKey RouteKey = 2;
inline bool SLL2RouteRes::_internal_has_routekey() const {
  return this != internal_default_instance() && routekey_ != nullptr;
}
inline bool SLL2RouteRes::has_routekey() const {
  return _internal_has_routekey();
}
inline void SLL2RouteRes::clear_routekey() {
  if (GetArenaForAllocation() == nullptr && routekey_ != nullptr) {
    delete routekey_;
  }
  routekey_ = nullptr;
}
inline const ::service_layer::SLL2RouteKey& SLL2RouteRes::_internal_routekey() const {
  const ::service_layer::SLL2RouteKey* p = routekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLL2RouteKey&>(
      ::service_layer::_SLL2RouteKey_default_instance_);
}
inline const ::service_layer::SLL2RouteKey& SLL2RouteRes::routekey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteRes.RouteKey)
  return _internal_routekey();
}
inline void SLL2RouteRes::unsafe_arena_set_allocated_routekey(
    ::service_layer::SLL2RouteKey* routekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routekey_);
  }
  routekey_ = routekey;
  if (routekey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteRes.RouteKey)
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::release_routekey() {
  
  ::service_layer::SLL2RouteKey* temp = routekey_;
  routekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::unsafe_arena_release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteRes.RouteKey)
  
  ::service_layer::SLL2RouteKey* temp = routekey_;
  routekey_ = nullptr;
  return temp;
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::_internal_mutable_routekey() {
  
  if (routekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLL2RouteKey>(GetArenaForAllocation());
    routekey_ = p;
  }
  return routekey_;
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::mutable_routekey() {
  ::service_layer::SLL2RouteKey* _msg = _internal_mutable_routekey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteRes.RouteKey)
  return _msg;
}
inline void SLL2RouteRes::set_allocated_routekey(::service_layer::SLL2RouteKey* routekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routekey_;
  }
  if (routekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLL2RouteKey>::GetOwningArena(routekey);
    if (message_arena != submessage_arena) {
      routekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteRes.RouteKey)
}

// -------------------------------------------------------------------

// SLL2RouteMsgRsp

// uint64 Correlator = 1;
inline void SLL2RouteMsgRsp::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLL2RouteMsgRsp::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLL2RouteMsgRsp::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.Correlator)
  return _internal_correlator();
}
inline void SLL2RouteMsgRsp::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLL2RouteMsgRsp::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsgRsp.Correlator)
}

// .service_layer.SLErrorStatus StatusSummary = 2;
inline bool SLL2RouteMsgRsp::_internal_has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != nullptr;
}
inline bool SLL2RouteMsgRsp::has_statussummary() const {
  return _internal_has_statussummary();
}
inline const ::service_layer::SLErrorStatus& SLL2RouteMsgRsp::_internal_statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2RouteMsgRsp::statussummary() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.StatusSummary)
  return _internal_statussummary();
}
inline void SLL2RouteMsgRsp::unsafe_arena_set_allocated_statussummary(
    ::service_layer::SLErrorStatus* statussummary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  statussummary_ = statussummary;
  if (statussummary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteMsgRsp.StatusSummary)
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::release_statussummary() {
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::unsafe_arena_release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::_internal_mutable_statussummary() {
  
  if (statussummary_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    statussummary_ = p;
  }
  return statussummary_;
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::mutable_statussummary() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_statussummary();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsgRsp.StatusSummary)
  return _msg;
}
inline void SLL2RouteMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary));
    if (message_arena != submessage_arena) {
      statussummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteMsgRsp.StatusSummary)
}

// repeated .service_layer.SLL2RouteRes Results = 3;
inline int SLL2RouteMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLL2RouteMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLL2RouteMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLL2RouteRes* SLL2RouteMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteRes >*
SLL2RouteMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2RouteMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLL2RouteRes& SLL2RouteMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLL2RouteRes& SLL2RouteMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLL2RouteRes* SLL2RouteMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLL2RouteRes* SLL2RouteMsgRsp::add_results() {
  ::service_layer::SLL2RouteRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLL2RouteMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLL2RouteRes >&
SLL2RouteMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2RouteMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLL2GetNotifMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLL2GetNotifMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLL2GetNotifMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLL2GetNotifMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.Oper)
  return _internal_oper();
}
inline void SLL2GetNotifMsg::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLL2GetNotifMsg::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.Oper)
}

// uint64 Correlator = 2;
inline void SLL2GetNotifMsg::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLL2GetNotifMsg::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLL2GetNotifMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.Correlator)
  return _internal_correlator();
}
inline void SLL2GetNotifMsg::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLL2GetNotifMsg::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.Correlator)
}

// bool GetNotifEof = 3;
inline void SLL2GetNotifMsg::clear_getnotifeof() {
  getnotifeof_ = false;
}
inline bool SLL2GetNotifMsg::_internal_getnotifeof() const {
  return getnotifeof_;
}
inline bool SLL2GetNotifMsg::getnotifeof() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.GetNotifEof)
  return _internal_getnotifeof();
}
inline void SLL2GetNotifMsg::_internal_set_getnotifeof(bool value) {
  
  getnotifeof_ = value;
}
inline void SLL2GetNotifMsg::set_getnotifeof(bool value) {
  _internal_set_getnotifeof(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.GetNotifEof)
}

// bool BdAll = 4;
inline bool SLL2GetNotifMsg::_internal_has_bdall() const {
  return Request_case() == kBdAll;
}
inline bool SLL2GetNotifMsg::has_bdall() const {
  return _internal_has_bdall();
}
inline void SLL2GetNotifMsg::set_has_bdall() {
  _oneof_case_[0] = kBdAll;
}
inline void SLL2GetNotifMsg::clear_bdall() {
  if (_internal_has_bdall()) {
    Request_.bdall_ = false;
    clear_has_Request();
  }
}
inline bool SLL2GetNotifMsg::_internal_bdall() const {
  if (_internal_has_bdall()) {
    return Request_.bdall_;
  }
  return false;
}
inline void SLL2GetNotifMsg::_internal_set_bdall(bool value) {
  if (!_internal_has_bdall()) {
    clear_Request();
    set_has_bdall();
  }
  Request_.bdall_ = value;
}
inline bool SLL2GetNotifMsg::bdall() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.BdAll)
  return _internal_bdall();
}
inline void SLL2GetNotifMsg::set_bdall(bool value) {
  _internal_set_bdall(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdAll)
}

// string BdName = 5;
inline bool SLL2GetNotifMsg::_internal_has_bdname() const {
  return Request_case() == kBdName;
}
inline bool SLL2GetNotifMsg::has_bdname() const {
  return _internal_has_bdname();
}
inline void SLL2GetNotifMsg::set_has_bdname() {
  _oneof_case_[0] = kBdName;
}
inline void SLL2GetNotifMsg::clear_bdname() {
  if (_internal_has_bdname()) {
    Request_.bdname_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_Request();
  }
}
inline const std::string& SLL2GetNotifMsg::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline void SLL2GetNotifMsg::set_bdname(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdName)
}
inline std::string* SLL2GetNotifMsg::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2GetNotifMsg.BdName)
  return _s;
}
inline const std::string& SLL2GetNotifMsg::_internal_bdname() const {
  if (_internal_has_bdname()) {
    return Request_.bdname_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLL2GetNotifMsg::_internal_set_bdname(const std::string& value) {
  if (!_internal_has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2GetNotifMsg::_internal_mutable_bdname() {
  if (!_internal_has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Request_.bdname_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2GetNotifMsg::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2GetNotifMsg.BdName)
  if (_internal_has_bdname()) {
    clear_has_Request();
    return Request_.bdname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SLL2GetNotifMsg::set_allocated_bdname(std::string* bdname) {
  if (has_Request()) {
    clear_Request();
  }
  if (bdname != nullptr) {
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(bdname);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(bdname);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2GetNotifMsg.BdName)
}

inline bool SLL2GetNotifMsg::has_Request() const {
  return Request_case() != REQUEST_NOT_SET;
}
inline void SLL2GetNotifMsg::clear_has_Request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline SLL2GetNotifMsg::RequestCase SLL2GetNotifMsg::Request_case() const {
  return SLL2GetNotifMsg::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2RouteNotif

// .service_layer.SLObjectOp Oper = 1;
inline void SLL2RouteNotif::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLL2RouteNotif::_internal_oper() const {
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline ::service_layer::SLObjectOp SLL2RouteNotif::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNotif.Oper)
  return _internal_oper();
}
inline void SLL2RouteNotif::_internal_set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
}
inline void SLL2RouteNotif::set_oper(::service_layer::SLObjectOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteNotif.Oper)
}

// .service_layer.SLL2Route Routes = 2;
inline bool SLL2RouteNotif::_internal_has_routes() const {
  return this != internal_default_instance() && routes_ != nullptr;
}
inline bool SLL2RouteNotif::has_routes() const {
  return _internal_has_routes();
}
inline void SLL2RouteNotif::clear_routes() {
  if (GetArenaForAllocation() == nullptr && routes_ != nullptr) {
    delete routes_;
  }
  routes_ = nullptr;
}
inline const ::service_layer::SLL2Route& SLL2RouteNotif::_internal_routes() const {
  const ::service_layer::SLL2Route* p = routes_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLL2Route&>(
      ::service_layer::_SLL2Route_default_instance_);
}
inline const ::service_layer::SLL2Route& SLL2RouteNotif::routes() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNotif.Routes)
  return _internal_routes();
}
inline void SLL2RouteNotif::unsafe_arena_set_allocated_routes(
    ::service_layer::SLL2Route* routes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routes_);
  }
  routes_ = routes;
  if (routes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2RouteNotif.Routes)
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::release_routes() {
  
  ::service_layer::SLL2Route* temp = routes_;
  routes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::unsafe_arena_release_routes() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNotif.Routes)
  
  ::service_layer::SLL2Route* temp = routes_;
  routes_ = nullptr;
  return temp;
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::_internal_mutable_routes() {
  
  if (routes_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLL2Route>(GetArenaForAllocation());
    routes_ = p;
  }
  return routes_;
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::mutable_routes() {
  ::service_layer::SLL2Route* _msg = _internal_mutable_routes();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNotif.Routes)
  return _msg;
}
inline void SLL2RouteNotif::set_allocated_routes(::service_layer::SLL2Route* routes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routes_;
  }
  if (routes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLL2Route>::GetOwningArena(routes);
    if (message_arena != submessage_arena) {
      routes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    
  } else {
    
  }
  routes_ = routes;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteNotif.Routes)
}

// -------------------------------------------------------------------

// SLL2BdStateInfo

// string BdName = 1;
inline void SLL2BdStateInfo::clear_bdname() {
  bdname_.ClearToEmpty();
}
inline const std::string& SLL2BdStateInfo::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdStateInfo.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2BdStateInfo::set_bdname(ArgT0&& arg0, ArgT... args) {
 
 bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdStateInfo.BdName)
}
inline std::string* SLL2BdStateInfo::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdStateInfo.BdName)
  return _s;
}
inline const std::string& SLL2BdStateInfo::_internal_bdname() const {
  return bdname_.Get();
}
inline void SLL2BdStateInfo::_internal_set_bdname(const std::string& value) {
  
  bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2BdStateInfo::_internal_mutable_bdname() {
  
  return bdname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2BdStateInfo::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdStateInfo.BdName)
  return bdname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2BdStateInfo::set_allocated_bdname(std::string* bdname) {
  if (bdname != nullptr) {
    
  } else {
    
  }
  bdname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bdname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bdname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdStateInfo.BdName)
}

// .service_layer.SLL2BdStateInfo.SLL2BdState BdState = 2;
inline void SLL2BdStateInfo::clear_bdstate() {
  bdstate_ = 0;
}
inline ::service_layer::SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo::_internal_bdstate() const {
  return static_cast< ::service_layer::SLL2BdStateInfo_SLL2BdState >(bdstate_);
}
inline ::service_layer::SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo::bdstate() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdStateInfo.BdState)
  return _internal_bdstate();
}
inline void SLL2BdStateInfo::_internal_set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value) {
  
  bdstate_ = value;
}
inline void SLL2BdStateInfo::set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value) {
  _internal_set_bdstate(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdStateInfo.BdState)
}

// -------------------------------------------------------------------

// SLL2NotifStatusMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLL2NotifStatusMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLL2NotifStatusMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLL2NotifStatusMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.Oper)
  return _internal_oper();
}
inline void SLL2NotifStatusMsg::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLL2NotifStatusMsg::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.Oper)
}

// uint64 Correlator = 2;
inline void SLL2NotifStatusMsg::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLL2NotifStatusMsg::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLL2NotifStatusMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.Correlator)
  return _internal_correlator();
}
inline void SLL2NotifStatusMsg::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLL2NotifStatusMsg::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.Correlator)
}

// string BdName = 3;
inline void SLL2NotifStatusMsg::clear_bdname() {
  bdname_.ClearToEmpty();
}
inline const std::string& SLL2NotifStatusMsg::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.BdName)
  return _internal_bdname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLL2NotifStatusMsg::set_bdname(ArgT0&& arg0, ArgT... args) {
 
 bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.BdName)
}
inline std::string* SLL2NotifStatusMsg::mutable_bdname() {
  std::string* _s = _internal_mutable_bdname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2NotifStatusMsg.BdName)
  return _s;
}
inline const std::string& SLL2NotifStatusMsg::_internal_bdname() const {
  return bdname_.Get();
}
inline void SLL2NotifStatusMsg::_internal_set_bdname(const std::string& value) {
  
  bdname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLL2NotifStatusMsg::_internal_mutable_bdname() {
  
  return bdname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLL2NotifStatusMsg::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2NotifStatusMsg.BdName)
  return bdname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLL2NotifStatusMsg::set_allocated_bdname(std::string* bdname) {
  if (bdname != nullptr) {
    
  } else {
    
  }
  bdname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bdname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bdname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bdname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2NotifStatusMsg.BdName)
}

// .service_layer.SLErrorStatus NotifStatus = 4;
inline bool SLL2NotifStatusMsg::_internal_has_notifstatus() const {
  return this != internal_default_instance() && notifstatus_ != nullptr;
}
inline bool SLL2NotifStatusMsg::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline const ::service_layer::SLErrorStatus& SLL2NotifStatusMsg::_internal_notifstatus() const {
  const ::service_layer::SLErrorStatus* p = notifstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2NotifStatusMsg::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.NotifStatus)
  return _internal_notifstatus();
}
inline void SLL2NotifStatusMsg::unsafe_arena_set_allocated_notifstatus(
    ::service_layer::SLErrorStatus* notifstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  notifstatus_ = notifstatus;
  if (notifstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2NotifStatusMsg.NotifStatus)
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::release_notifstatus() {
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2NotifStatusMsg.NotifStatus)
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::_internal_mutable_notifstatus() {
  
  if (notifstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    notifstatus_ = p;
  }
  return notifstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::mutable_notifstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2NotifStatusMsg.NotifStatus)
  return _msg;
}
inline void SLL2NotifStatusMsg::set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  if (notifstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus));
    if (message_arena != submessage_arena) {
      notifstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifstatus, submessage_arena);
    }
    
  } else {
    
  }
  notifstatus_ = notifstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2NotifStatusMsg.NotifStatus)
}

// -------------------------------------------------------------------

// SLL2Notif

// .service_layer.SLL2NotifType EventType = 1;
inline void SLL2Notif::clear_eventtype() {
  eventtype_ = 0;
}
inline ::service_layer::SLL2NotifType SLL2Notif::_internal_eventtype() const {
  return static_cast< ::service_layer::SLL2NotifType >(eventtype_);
}
inline ::service_layer::SLL2NotifType SLL2Notif::eventtype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.EventType)
  return _internal_eventtype();
}
inline void SLL2Notif::_internal_set_eventtype(::service_layer::SLL2NotifType value) {
  
  eventtype_ = value;
}
inline void SLL2Notif::set_eventtype(::service_layer::SLL2NotifType value) {
  _internal_set_eventtype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2Notif.EventType)
}

// .service_layer.SLErrorStatus ErrStatus = 2;
inline bool SLL2Notif::_internal_has_errstatus() const {
  return Event_case() == kErrStatus;
}
inline bool SLL2Notif::has_errstatus() const {
  return _internal_has_errstatus();
}
inline void SLL2Notif::set_has_errstatus() {
  _oneof_case_[0] = kErrStatus;
}
inline ::service_layer::SLErrorStatus* SLL2Notif::release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.ErrStatus)
  if (_internal_has_errstatus()) {
    clear_has_Event();
      ::service_layer::SLErrorStatus* temp = Event_.errstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.errstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLErrorStatus& SLL2Notif::_internal_errstatus() const {
  return _internal_has_errstatus()
      ? *Event_.errstatus_
      : reinterpret_cast< ::service_layer::SLErrorStatus&>(::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLL2Notif::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.ErrStatus)
  return _internal_errstatus();
}
inline ::service_layer::SLErrorStatus* SLL2Notif::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Notif.ErrStatus)
  if (_internal_has_errstatus()) {
    clear_has_Event();
    ::service_layer::SLErrorStatus* temp = Event_.errstatus_;
    Event_.errstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Notif::unsafe_arena_set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  clear_Event();
  if (errstatus) {
    set_has_errstatus();
    Event_.errstatus_ = errstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Notif.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLL2Notif::_internal_mutable_errstatus() {
  if (!_internal_has_errstatus()) {
    clear_Event();
    set_has_errstatus();
    Event_.errstatus_ = CreateMaybeMessage< ::service_layer::SLErrorStatus >(GetArenaForAllocation());
  }
  return Event_.errstatus_;
}
inline ::service_layer::SLErrorStatus* SLL2Notif::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.ErrStatus)
  return _msg;
}

// .service_layer.SLL2NotifStatusMsg NotifStatus = 3;
inline bool SLL2Notif::_internal_has_notifstatus() const {
  return Event_case() == kNotifStatus;
}
inline bool SLL2Notif::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline void SLL2Notif::set_has_notifstatus() {
  _oneof_case_[0] = kNotifStatus;
}
inline void SLL2Notif::clear_notifstatus() {
  if (_internal_has_notifstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.notifstatus_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
      ::service_layer::SLL2NotifStatusMsg* temp = Event_.notifstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2NotifStatusMsg& SLL2Notif::_internal_notifstatus() const {
  return _internal_has_notifstatus()
      ? *Event_.notifstatus_
      : reinterpret_cast< ::service_layer::SLL2NotifStatusMsg&>(::service_layer::_SLL2NotifStatusMsg_default_instance_);
}
inline const ::service_layer::SLL2NotifStatusMsg& SLL2Notif::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.NotifStatus)
  return _internal_notifstatus();
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Notif.NotifStatus)
  if (_internal_has_notifstatus()) {
    clear_has_Event();
    ::service_layer::SLL2NotifStatusMsg* temp = Event_.notifstatus_;
    Event_.notifstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Notif::unsafe_arena_set_allocated_notifstatus(::service_layer::SLL2NotifStatusMsg* notifstatus) {
  clear_Event();
  if (notifstatus) {
    set_has_notifstatus();
    Event_.notifstatus_ = notifstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Notif.NotifStatus)
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::_internal_mutable_notifstatus() {
  if (!_internal_has_notifstatus()) {
    clear_Event();
    set_has_notifstatus();
    Event_.notifstatus_ = CreateMaybeMessage< ::service_layer::SLL2NotifStatusMsg >(GetArenaForAllocation());
  }
  return Event_.notifstatus_;
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::mutable_notifstatus() {
  ::service_layer::SLL2NotifStatusMsg* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.NotifStatus)
  return _msg;
}

// .service_layer.SLL2BdStateInfo BdStateInfo = 4;
inline bool SLL2Notif::_internal_has_bdstateinfo() const {
  return Event_case() == kBdStateInfo;
}
inline bool SLL2Notif::has_bdstateinfo() const {
  return _internal_has_bdstateinfo();
}
inline void SLL2Notif::set_has_bdstateinfo() {
  _oneof_case_[0] = kBdStateInfo;
}
inline void SLL2Notif::clear_bdstateinfo() {
  if (_internal_has_bdstateinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.bdstateinfo_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::release_bdstateinfo() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.BdStateInfo)
  if (_internal_has_bdstateinfo()) {
    clear_has_Event();
      ::service_layer::SLL2BdStateInfo* temp = Event_.bdstateinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.bdstateinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2BdStateInfo& SLL2Notif::_internal_bdstateinfo() const {
  return _internal_has_bdstateinfo()
      ? *Event_.bdstateinfo_
      : reinterpret_cast< ::service_layer::SLL2BdStateInfo&>(::service_layer::_SLL2BdStateInfo_default_instance_);
}
inline const ::service_layer::SLL2BdStateInfo& SLL2Notif::bdstateinfo() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.BdStateInfo)
  return _internal_bdstateinfo();
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::unsafe_arena_release_bdstateinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Notif.BdStateInfo)
  if (_internal_has_bdstateinfo()) {
    clear_has_Event();
    ::service_layer::SLL2BdStateInfo* temp = Event_.bdstateinfo_;
    Event_.bdstateinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Notif::unsafe_arena_set_allocated_bdstateinfo(::service_layer::SLL2BdStateInfo* bdstateinfo) {
  clear_Event();
  if (bdstateinfo) {
    set_has_bdstateinfo();
    Event_.bdstateinfo_ = bdstateinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Notif.BdStateInfo)
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::_internal_mutable_bdstateinfo() {
  if (!_internal_has_bdstateinfo()) {
    clear_Event();
    set_has_bdstateinfo();
    Event_.bdstateinfo_ = CreateMaybeMessage< ::service_layer::SLL2BdStateInfo >(GetArenaForAllocation());
  }
  return Event_.bdstateinfo_;
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::mutable_bdstateinfo() {
  ::service_layer::SLL2BdStateInfo* _msg = _internal_mutable_bdstateinfo();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.BdStateInfo)
  return _msg;
}

// .service_layer.SLL2RouteNotif Route = 5;
inline bool SLL2Notif::_internal_has_route() const {
  return Event_case() == kRoute;
}
inline bool SLL2Notif::has_route() const {
  return _internal_has_route();
}
inline void SLL2Notif::set_has_route() {
  _oneof_case_[0] = kRoute;
}
inline void SLL2Notif::clear_route() {
  if (_internal_has_route()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Event_.route_;
    }
    clear_has_Event();
  }
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::release_route() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.Route)
  if (_internal_has_route()) {
    clear_has_Event();
      ::service_layer::SLL2RouteNotif* temp = Event_.route_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Event_.route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLL2RouteNotif& SLL2Notif::_internal_route() const {
  return _internal_has_route()
      ? *Event_.route_
      : reinterpret_cast< ::service_layer::SLL2RouteNotif&>(::service_layer::_SLL2RouteNotif_default_instance_);
}
inline const ::service_layer::SLL2RouteNotif& SLL2Notif::route() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.Route)
  return _internal_route();
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLL2Notif.Route)
  if (_internal_has_route()) {
    clear_has_Event();
    ::service_layer::SLL2RouteNotif* temp = Event_.route_;
    Event_.route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLL2Notif::unsafe_arena_set_allocated_route(::service_layer::SLL2RouteNotif* route) {
  clear_Event();
  if (route) {
    set_has_route();
    Event_.route_ = route;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLL2Notif.Route)
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::_internal_mutable_route() {
  if (!_internal_has_route()) {
    clear_Event();
    set_has_route();
    Event_.route_ = CreateMaybeMessage< ::service_layer::SLL2RouteNotif >(GetArenaForAllocation());
  }
  return Event_.route_;
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::mutable_route() {
  ::service_layer::SLL2RouteNotif* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.Route)
  return _msg;
}

inline bool SLL2Notif::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2Notif::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2Notif::EventCase SLL2Notif::Event_case() const {
  return SLL2Notif::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service_layer::SLL2RouteNh_SLL2RouteNhType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2RouteNh_SLL2RouteNhType>() {
  return ::service_layer::SLL2RouteNh_SLL2RouteNhType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2ImetRoute_PMSITunnelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2ImetRoute_PMSITunnelType>() {
  return ::service_layer::SLL2ImetRoute_PMSITunnelType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2BdStateInfo_SLL2BdState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2BdStateInfo_SLL2BdState>() {
  return ::service_layer::SLL2BdStateInfo_SLL2BdState_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2RouteType>() {
  return ::service_layer::SLL2RouteType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2NotifType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2NotifType>() {
  return ::service_layer::SLL2NotifType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5fl2_5froute_2eproto
