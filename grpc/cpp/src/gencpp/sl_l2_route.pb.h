// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_l2_route.proto

#ifndef PROTOBUF_sl_5fl2_5froute_2eproto__INCLUDED
#define PROTOBUF_sl_5fl2_5froute_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_sl_5fl2_5froute_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[24];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSLL2GlobalsGetMsgImpl();
void InitDefaultsSLL2GlobalsGetMsg();
void InitDefaultsSLL2GlobalsGetMsgRspImpl();
void InitDefaultsSLL2GlobalsGetMsgRsp();
void InitDefaultsSLL2RegMsgImpl();
void InitDefaultsSLL2RegMsg();
void InitDefaultsSLL2RegMsgRspImpl();
void InitDefaultsSLL2RegMsgRsp();
void InitDefaultsSLL2BdRegMsgImpl();
void InitDefaultsSLL2BdRegMsg();
void InitDefaultsSLL2BdRegResImpl();
void InitDefaultsSLL2BdRegRes();
void InitDefaultsSLL2BdRegMsgRspImpl();
void InitDefaultsSLL2BdRegMsgRsp();
void InitDefaultsSLL2RouteEsiImpl();
void InitDefaultsSLL2RouteEsi();
void InitDefaultsSLL2RouteNhImpl();
void InitDefaultsSLL2RouteNh();
void InitDefaultsSLL2OverlayNhImpl();
void InitDefaultsSLL2OverlayNh();
void InitDefaultsSLL2MacRouteKeyImpl();
void InitDefaultsSLL2MacRouteKey();
void InitDefaultsSLL2MacRouteImpl();
void InitDefaultsSLL2MacRoute();
void InitDefaultsSLL2ImetRouteKeyImpl();
void InitDefaultsSLL2ImetRouteKey();
void InitDefaultsSLL2ImetRouteImpl();
void InitDefaultsSLL2ImetRoute();
void InitDefaultsSLL2RouteKeyImpl();
void InitDefaultsSLL2RouteKey();
void InitDefaultsSLL2RouteImpl();
void InitDefaultsSLL2Route();
void InitDefaultsSLL2RouteMsgImpl();
void InitDefaultsSLL2RouteMsg();
void InitDefaultsSLL2RouteResImpl();
void InitDefaultsSLL2RouteRes();
void InitDefaultsSLL2RouteMsgRspImpl();
void InitDefaultsSLL2RouteMsgRsp();
void InitDefaultsSLL2GetNotifMsgImpl();
void InitDefaultsSLL2GetNotifMsg();
void InitDefaultsSLL2RouteNotifImpl();
void InitDefaultsSLL2RouteNotif();
void InitDefaultsSLL2BdStateInfoImpl();
void InitDefaultsSLL2BdStateInfo();
void InitDefaultsSLL2NotifStatusMsgImpl();
void InitDefaultsSLL2NotifStatusMsg();
void InitDefaultsSLL2NotifImpl();
void InitDefaultsSLL2Notif();
inline void InitDefaults() {
  InitDefaultsSLL2GlobalsGetMsg();
  InitDefaultsSLL2GlobalsGetMsgRsp();
  InitDefaultsSLL2RegMsg();
  InitDefaultsSLL2RegMsgRsp();
  InitDefaultsSLL2BdRegMsg();
  InitDefaultsSLL2BdRegRes();
  InitDefaultsSLL2BdRegMsgRsp();
  InitDefaultsSLL2RouteEsi();
  InitDefaultsSLL2RouteNh();
  InitDefaultsSLL2OverlayNh();
  InitDefaultsSLL2MacRouteKey();
  InitDefaultsSLL2MacRoute();
  InitDefaultsSLL2ImetRouteKey();
  InitDefaultsSLL2ImetRoute();
  InitDefaultsSLL2RouteKey();
  InitDefaultsSLL2Route();
  InitDefaultsSLL2RouteMsg();
  InitDefaultsSLL2RouteRes();
  InitDefaultsSLL2RouteMsgRsp();
  InitDefaultsSLL2GetNotifMsg();
  InitDefaultsSLL2RouteNotif();
  InitDefaultsSLL2BdStateInfo();
  InitDefaultsSLL2NotifStatusMsg();
  InitDefaultsSLL2Notif();
}
}  // namespace protobuf_sl_5fl2_5froute_2eproto
namespace service_layer {
class SLL2BdRegMsg;
class SLL2BdRegMsgDefaultTypeInternal;
extern SLL2BdRegMsgDefaultTypeInternal _SLL2BdRegMsg_default_instance_;
class SLL2BdRegMsgRsp;
class SLL2BdRegMsgRspDefaultTypeInternal;
extern SLL2BdRegMsgRspDefaultTypeInternal _SLL2BdRegMsgRsp_default_instance_;
class SLL2BdRegRes;
class SLL2BdRegResDefaultTypeInternal;
extern SLL2BdRegResDefaultTypeInternal _SLL2BdRegRes_default_instance_;
class SLL2BdStateInfo;
class SLL2BdStateInfoDefaultTypeInternal;
extern SLL2BdStateInfoDefaultTypeInternal _SLL2BdStateInfo_default_instance_;
class SLL2GetNotifMsg;
class SLL2GetNotifMsgDefaultTypeInternal;
extern SLL2GetNotifMsgDefaultTypeInternal _SLL2GetNotifMsg_default_instance_;
class SLL2GlobalsGetMsg;
class SLL2GlobalsGetMsgDefaultTypeInternal;
extern SLL2GlobalsGetMsgDefaultTypeInternal _SLL2GlobalsGetMsg_default_instance_;
class SLL2GlobalsGetMsgRsp;
class SLL2GlobalsGetMsgRspDefaultTypeInternal;
extern SLL2GlobalsGetMsgRspDefaultTypeInternal _SLL2GlobalsGetMsgRsp_default_instance_;
class SLL2ImetRoute;
class SLL2ImetRouteDefaultTypeInternal;
extern SLL2ImetRouteDefaultTypeInternal _SLL2ImetRoute_default_instance_;
class SLL2ImetRouteKey;
class SLL2ImetRouteKeyDefaultTypeInternal;
extern SLL2ImetRouteKeyDefaultTypeInternal _SLL2ImetRouteKey_default_instance_;
class SLL2MacRoute;
class SLL2MacRouteDefaultTypeInternal;
extern SLL2MacRouteDefaultTypeInternal _SLL2MacRoute_default_instance_;
class SLL2MacRouteKey;
class SLL2MacRouteKeyDefaultTypeInternal;
extern SLL2MacRouteKeyDefaultTypeInternal _SLL2MacRouteKey_default_instance_;
class SLL2Notif;
class SLL2NotifDefaultTypeInternal;
extern SLL2NotifDefaultTypeInternal _SLL2Notif_default_instance_;
class SLL2NotifStatusMsg;
class SLL2NotifStatusMsgDefaultTypeInternal;
extern SLL2NotifStatusMsgDefaultTypeInternal _SLL2NotifStatusMsg_default_instance_;
class SLL2OverlayNh;
class SLL2OverlayNhDefaultTypeInternal;
extern SLL2OverlayNhDefaultTypeInternal _SLL2OverlayNh_default_instance_;
class SLL2RegMsg;
class SLL2RegMsgDefaultTypeInternal;
extern SLL2RegMsgDefaultTypeInternal _SLL2RegMsg_default_instance_;
class SLL2RegMsgRsp;
class SLL2RegMsgRspDefaultTypeInternal;
extern SLL2RegMsgRspDefaultTypeInternal _SLL2RegMsgRsp_default_instance_;
class SLL2Route;
class SLL2RouteDefaultTypeInternal;
extern SLL2RouteDefaultTypeInternal _SLL2Route_default_instance_;
class SLL2RouteEsi;
class SLL2RouteEsiDefaultTypeInternal;
extern SLL2RouteEsiDefaultTypeInternal _SLL2RouteEsi_default_instance_;
class SLL2RouteKey;
class SLL2RouteKeyDefaultTypeInternal;
extern SLL2RouteKeyDefaultTypeInternal _SLL2RouteKey_default_instance_;
class SLL2RouteMsg;
class SLL2RouteMsgDefaultTypeInternal;
extern SLL2RouteMsgDefaultTypeInternal _SLL2RouteMsg_default_instance_;
class SLL2RouteMsgRsp;
class SLL2RouteMsgRspDefaultTypeInternal;
extern SLL2RouteMsgRspDefaultTypeInternal _SLL2RouteMsgRsp_default_instance_;
class SLL2RouteNh;
class SLL2RouteNhDefaultTypeInternal;
extern SLL2RouteNhDefaultTypeInternal _SLL2RouteNh_default_instance_;
class SLL2RouteNotif;
class SLL2RouteNotifDefaultTypeInternal;
extern SLL2RouteNotifDefaultTypeInternal _SLL2RouteNotif_default_instance_;
class SLL2RouteRes;
class SLL2RouteResDefaultTypeInternal;
extern SLL2RouteResDefaultTypeInternal _SLL2RouteRes_default_instance_;
}  // namespace service_layer
namespace service_layer {

enum SLL2RouteNh_SLL2RouteNhType {
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED = 0,
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_INTERFACE = 1,
  SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY = 2,
  SLL2RouteNh_SLL2RouteNhType_SLL2RouteNh_SLL2RouteNhType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLL2RouteNh_SLL2RouteNhType_SLL2RouteNh_SLL2RouteNhType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLL2RouteNh_SLL2RouteNhType_IsValid(int value);
const SLL2RouteNh_SLL2RouteNhType SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MIN = SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED;
const SLL2RouteNh_SLL2RouteNhType SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX = SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY;
const int SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_ARRAYSIZE = SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLL2RouteNh_SLL2RouteNhType_descriptor();
inline const ::std::string& SLL2RouteNh_SLL2RouteNhType_Name(SLL2RouteNh_SLL2RouteNhType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLL2RouteNh_SLL2RouteNhType_descriptor(), value);
}
inline bool SLL2RouteNh_SLL2RouteNhType_Parse(
    const ::std::string& name, SLL2RouteNh_SLL2RouteNhType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLL2RouteNh_SLL2RouteNhType>(
    SLL2RouteNh_SLL2RouteNhType_descriptor(), name, value);
}
enum SLL2ImetRoute_PMSITunnelType {
  SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL = 0,
  SLL2ImetRoute_PMSITunnelType_PMSI_RSVPP2MP_TUNNEL = 1,
  SLL2ImetRoute_PMSITunnelType_PMSI_MLDPP2MP_TUNNEL = 2,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMSSM_TUNNEL = 3,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMSM_TUNNEL = 4,
  SLL2ImetRoute_PMSITunnelType_PMSI_PIMBIDIR_TUNNEL = 5,
  SLL2ImetRoute_PMSITunnelType_PMSI_INGREP_TUNNEL = 6,
  SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL = 7,
  SLL2ImetRoute_PMSITunnelType_SLL2ImetRoute_PMSITunnelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLL2ImetRoute_PMSITunnelType_SLL2ImetRoute_PMSITunnelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLL2ImetRoute_PMSITunnelType_IsValid(int value);
const SLL2ImetRoute_PMSITunnelType SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MIN = SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL;
const SLL2ImetRoute_PMSITunnelType SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX = SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL;
const int SLL2ImetRoute_PMSITunnelType_PMSITunnelType_ARRAYSIZE = SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLL2ImetRoute_PMSITunnelType_descriptor();
inline const ::std::string& SLL2ImetRoute_PMSITunnelType_Name(SLL2ImetRoute_PMSITunnelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLL2ImetRoute_PMSITunnelType_descriptor(), value);
}
inline bool SLL2ImetRoute_PMSITunnelType_Parse(
    const ::std::string& name, SLL2ImetRoute_PMSITunnelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLL2ImetRoute_PMSITunnelType>(
    SLL2ImetRoute_PMSITunnelType_descriptor(), name, value);
}
enum SLL2BdStateInfo_SLL2BdState {
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED = 0,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_ADDED = 1,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_DELETED = 2,
  SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED = 3,
  SLL2BdStateInfo_SLL2BdState_SLL2BdStateInfo_SLL2BdState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLL2BdStateInfo_SLL2BdState_SLL2BdStateInfo_SLL2BdState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLL2BdStateInfo_SLL2BdState_IsValid(int value);
const SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo_SLL2BdState_SLL2BdState_MIN = SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED;
const SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX = SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED;
const int SLL2BdStateInfo_SLL2BdState_SLL2BdState_ARRAYSIZE = SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLL2BdStateInfo_SLL2BdState_descriptor();
inline const ::std::string& SLL2BdStateInfo_SLL2BdState_Name(SLL2BdStateInfo_SLL2BdState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLL2BdStateInfo_SLL2BdState_descriptor(), value);
}
inline bool SLL2BdStateInfo_SLL2BdState_Parse(
    const ::std::string& name, SLL2BdStateInfo_SLL2BdState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLL2BdStateInfo_SLL2BdState>(
    SLL2BdStateInfo_SLL2BdState_descriptor(), name, value);
}
enum SLL2RouteType {
  SL_L2_ROUTE_RESERVED = 0,
  SL_L2_ROUTE_MAC = 1,
  SL_L2_ROUTE_IMET = 2,
  SLL2RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLL2RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLL2RouteType_IsValid(int value);
const SLL2RouteType SLL2RouteType_MIN = SL_L2_ROUTE_RESERVED;
const SLL2RouteType SLL2RouteType_MAX = SL_L2_ROUTE_IMET;
const int SLL2RouteType_ARRAYSIZE = SLL2RouteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLL2RouteType_descriptor();
inline const ::std::string& SLL2RouteType_Name(SLL2RouteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLL2RouteType_descriptor(), value);
}
inline bool SLL2RouteType_Parse(
    const ::std::string& name, SLL2RouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLL2RouteType>(
    SLL2RouteType_descriptor(), name, value);
}
enum SLL2NotifType {
  SL_L2_EVENT_TYPE_RESERVED = 0,
  SL_L2_EVENT_TYPE_ERROR = 1,
  SL_L2_EVENT_TYPE_STATUS = 2,
  SL_L2_EVENT_TYPE_START_MARKER = 3,
  SL_L2_EVENT_TYPE_BD_STATE = 4,
  SL_L2_EVENT_TYPE_BD_STATE_END_MARKER = 5,
  SL_L2_EVENT_TYPE_ROUTE = 6,
  SL_L2_EVENT_TYPE_ROUTE_END_MARKER = 7,
  SLL2NotifType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLL2NotifType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLL2NotifType_IsValid(int value);
const SLL2NotifType SLL2NotifType_MIN = SL_L2_EVENT_TYPE_RESERVED;
const SLL2NotifType SLL2NotifType_MAX = SL_L2_EVENT_TYPE_ROUTE_END_MARKER;
const int SLL2NotifType_ARRAYSIZE = SLL2NotifType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLL2NotifType_descriptor();
inline const ::std::string& SLL2NotifType_Name(SLL2NotifType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLL2NotifType_descriptor(), value);
}
inline bool SLL2NotifType_Parse(
    const ::std::string& name, SLL2NotifType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLL2NotifType>(
    SLL2NotifType_descriptor(), name, value);
}
// ===================================================================

class SLL2GlobalsGetMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2GlobalsGetMsg) */ {
 public:
  SLL2GlobalsGetMsg();
  virtual ~SLL2GlobalsGetMsg();

  SLL2GlobalsGetMsg(const SLL2GlobalsGetMsg& from);

  inline SLL2GlobalsGetMsg& operator=(const SLL2GlobalsGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2GlobalsGetMsg(SLL2GlobalsGetMsg&& from) noexcept
    : SLL2GlobalsGetMsg() {
    *this = ::std::move(from);
  }

  inline SLL2GlobalsGetMsg& operator=(SLL2GlobalsGetMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2GlobalsGetMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2GlobalsGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2GlobalsGetMsg*>(
               &_SLL2GlobalsGetMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SLL2GlobalsGetMsg* other);
  friend void swap(SLL2GlobalsGetMsg& a, SLL2GlobalsGetMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2GlobalsGetMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2GlobalsGetMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2GlobalsGetMsg& from);
  void MergeFrom(const SLL2GlobalsGetMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2GlobalsGetMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLL2GlobalsGetMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2GlobalsGetMsgImpl();
};
// -------------------------------------------------------------------

class SLL2GlobalsGetMsgRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2GlobalsGetMsgRsp) */ {
 public:
  SLL2GlobalsGetMsgRsp();
  virtual ~SLL2GlobalsGetMsgRsp();

  SLL2GlobalsGetMsgRsp(const SLL2GlobalsGetMsgRsp& from);

  inline SLL2GlobalsGetMsgRsp& operator=(const SLL2GlobalsGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2GlobalsGetMsgRsp(SLL2GlobalsGetMsgRsp&& from) noexcept
    : SLL2GlobalsGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2GlobalsGetMsgRsp& operator=(SLL2GlobalsGetMsgRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2GlobalsGetMsgRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2GlobalsGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2GlobalsGetMsgRsp*>(
               &_SLL2GlobalsGetMsgRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SLL2GlobalsGetMsgRsp* other);
  friend void swap(SLL2GlobalsGetMsgRsp& a, SLL2GlobalsGetMsgRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2GlobalsGetMsgRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2GlobalsGetMsgRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2GlobalsGetMsgRsp& from);
  void MergeFrom(const SLL2GlobalsGetMsgRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2GlobalsGetMsgRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  void clear_errstatus();
  static const int kErrStatusFieldNumber = 1;
  const ::service_layer::SLErrorStatus& errstatus() const;
  ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);

  // uint32 MaxBdRegPerBdRegmsg = 2;
  void clear_maxbdregperbdregmsg();
  static const int kMaxBdRegPerBdRegmsgFieldNumber = 2;
  ::google::protobuf::uint32 maxbdregperbdregmsg() const;
  void set_maxbdregperbdregmsg(::google::protobuf::uint32 value);

  // uint32 MaxRoutePerRoutemsg = 3;
  void clear_maxrouteperroutemsg();
  static const int kMaxRoutePerRoutemsgFieldNumber = 3;
  ::google::protobuf::uint32 maxrouteperroutemsg() const;
  void set_maxrouteperroutemsg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2GlobalsGetMsgRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::service_layer::SLErrorStatus* errstatus_;
  ::google::protobuf::uint32 maxbdregperbdregmsg_;
  ::google::protobuf::uint32 maxrouteperroutemsg_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2GlobalsGetMsgRspImpl();
};
// -------------------------------------------------------------------

class SLL2RegMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RegMsg) */ {
 public:
  SLL2RegMsg();
  virtual ~SLL2RegMsg();

  SLL2RegMsg(const SLL2RegMsg& from);

  inline SLL2RegMsg& operator=(const SLL2RegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RegMsg(SLL2RegMsg&& from) noexcept
    : SLL2RegMsg() {
    *this = ::std::move(from);
  }

  inline SLL2RegMsg& operator=(SLL2RegMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RegMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RegMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2RegMsg*>(
               &_SLL2RegMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SLL2RegMsg* other);
  friend void swap(SLL2RegMsg& a, SLL2RegMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RegMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RegMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RegMsg& from);
  void MergeFrom(const SLL2RegMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RegMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  static const int kAdminDistanceFieldNumber = 2;
  ::google::protobuf::uint32 admindistance() const;
  void set_admindistance(::google::protobuf::uint32 value);

  // uint32 PurgeIntervalSeconds = 3;
  void clear_purgeintervalseconds();
  static const int kPurgeIntervalSecondsFieldNumber = 3;
  ::google::protobuf::uint32 purgeintervalseconds() const;
  void set_purgeintervalseconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RegMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int oper_;
  ::google::protobuf::uint32 admindistance_;
  ::google::protobuf::uint32 purgeintervalseconds_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RegMsgImpl();
};
// -------------------------------------------------------------------

class SLL2RegMsgRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RegMsgRsp) */ {
 public:
  SLL2RegMsgRsp();
  virtual ~SLL2RegMsgRsp();

  SLL2RegMsgRsp(const SLL2RegMsgRsp& from);

  inline SLL2RegMsgRsp& operator=(const SLL2RegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RegMsgRsp(SLL2RegMsgRsp&& from) noexcept
    : SLL2RegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2RegMsgRsp& operator=(SLL2RegMsgRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RegMsgRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2RegMsgRsp*>(
               &_SLL2RegMsgRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SLL2RegMsgRsp* other);
  friend void swap(SLL2RegMsgRsp& a, SLL2RegMsgRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RegMsgRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RegMsgRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RegMsgRsp& from);
  void MergeFrom(const SLL2RegMsgRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RegMsgRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLErrorStatus RegStatus = 1;
  bool has_regstatus() const;
  void clear_regstatus();
  static const int kRegStatusFieldNumber = 1;
  const ::service_layer::SLErrorStatus& regstatus() const;
  ::service_layer::SLErrorStatus* release_regstatus();
  ::service_layer::SLErrorStatus* mutable_regstatus();
  void set_allocated_regstatus(::service_layer::SLErrorStatus* regstatus);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RegMsgRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::service_layer::SLErrorStatus* regstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RegMsgRspImpl();
};
// -------------------------------------------------------------------

class SLL2BdRegMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegMsg) */ {
 public:
  SLL2BdRegMsg();
  virtual ~SLL2BdRegMsg();

  SLL2BdRegMsg(const SLL2BdRegMsg& from);

  inline SLL2BdRegMsg& operator=(const SLL2BdRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2BdRegMsg(SLL2BdRegMsg&& from) noexcept
    : SLL2BdRegMsg() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegMsg& operator=(SLL2BdRegMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2BdRegMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2BdRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegMsg*>(
               &_SLL2BdRegMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SLL2BdRegMsg* other);
  friend void swap(SLL2BdRegMsg& a, SLL2BdRegMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2BdRegMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2BdRegMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2BdRegMsg& from);
  void MergeFrom(const SLL2BdRegMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2BdRegMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string BdRegName = 2;
  int bdregname_size() const;
  void clear_bdregname();
  static const int kBdRegNameFieldNumber = 2;
  const ::std::string& bdregname(int index) const;
  ::std::string* mutable_bdregname(int index);
  void set_bdregname(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_bdregname(int index, ::std::string&& value);
  #endif
  void set_bdregname(int index, const char* value);
  void set_bdregname(int index, const char* value, size_t size);
  ::std::string* add_bdregname();
  void add_bdregname(const ::std::string& value);
  #if LANG_CXX11
  void add_bdregname(::std::string&& value);
  #endif
  void add_bdregname(const char* value);
  void add_bdregname(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& bdregname() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bdregname();

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bdregname_;
  int oper_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2BdRegMsgImpl();
};
// -------------------------------------------------------------------

class SLL2BdRegRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegRes) */ {
 public:
  SLL2BdRegRes();
  virtual ~SLL2BdRegRes();

  SLL2BdRegRes(const SLL2BdRegRes& from);

  inline SLL2BdRegRes& operator=(const SLL2BdRegRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2BdRegRes(SLL2BdRegRes&& from) noexcept
    : SLL2BdRegRes() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegRes& operator=(SLL2BdRegRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2BdRegRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2BdRegRes* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegRes*>(
               &_SLL2BdRegRes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SLL2BdRegRes* other);
  friend void swap(SLL2BdRegRes& a, SLL2BdRegRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2BdRegRes* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2BdRegRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2BdRegRes& from);
  void MergeFrom(const SLL2BdRegRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2BdRegRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string BdName = 2;
  void clear_bdname();
  static const int kBdNameFieldNumber = 2;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  void clear_errstatus();
  static const int kErrStatusFieldNumber = 1;
  const ::service_layer::SLErrorStatus& errstatus() const;
  ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bdname_;
  ::service_layer::SLErrorStatus* errstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2BdRegResImpl();
};
// -------------------------------------------------------------------

class SLL2BdRegMsgRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdRegMsgRsp) */ {
 public:
  SLL2BdRegMsgRsp();
  virtual ~SLL2BdRegMsgRsp();

  SLL2BdRegMsgRsp(const SLL2BdRegMsgRsp& from);

  inline SLL2BdRegMsgRsp& operator=(const SLL2BdRegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2BdRegMsgRsp(SLL2BdRegMsgRsp&& from) noexcept
    : SLL2BdRegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2BdRegMsgRsp& operator=(SLL2BdRegMsgRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2BdRegMsgRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2BdRegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2BdRegMsgRsp*>(
               &_SLL2BdRegMsgRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SLL2BdRegMsgRsp* other);
  friend void swap(SLL2BdRegMsgRsp& a, SLL2BdRegMsgRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2BdRegMsgRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2BdRegMsgRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2BdRegMsgRsp& from);
  void MergeFrom(const SLL2BdRegMsgRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2BdRegMsgRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .service_layer.SLL2BdRegRes Results = 2;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 2;
  const ::service_layer::SLL2BdRegRes& results(int index) const;
  ::service_layer::SLL2BdRegRes* mutable_results(int index);
  ::service_layer::SLL2BdRegRes* add_results();
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2BdRegRes >*
      mutable_results();
  const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2BdRegRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 1;
  bool has_statussummary() const;
  void clear_statussummary();
  static const int kStatusSummaryFieldNumber = 1;
  const ::service_layer::SLErrorStatus& statussummary() const;
  ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdRegMsgRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2BdRegRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2BdRegMsgRspImpl();
};
// -------------------------------------------------------------------

class SLL2RouteEsi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteEsi) */ {
 public:
  SLL2RouteEsi();
  virtual ~SLL2RouteEsi();

  SLL2RouteEsi(const SLL2RouteEsi& from);

  inline SLL2RouteEsi& operator=(const SLL2RouteEsi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteEsi(SLL2RouteEsi&& from) noexcept
    : SLL2RouteEsi() {
    *this = ::std::move(from);
  }

  inline SLL2RouteEsi& operator=(SLL2RouteEsi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteEsi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteEsi* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteEsi*>(
               &_SLL2RouteEsi_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SLL2RouteEsi* other);
  friend void swap(SLL2RouteEsi& a, SLL2RouteEsi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteEsi* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteEsi* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteEsi& from);
  void MergeFrom(const SLL2RouteEsi& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteEsi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Esi = 1;
  void clear_esi();
  static const int kEsiFieldNumber = 1;
  const ::std::string& esi() const;
  void set_esi(const ::std::string& value);
  #if LANG_CXX11
  void set_esi(::std::string&& value);
  #endif
  void set_esi(const char* value);
  void set_esi(const void* value, size_t size);
  ::std::string* mutable_esi();
  ::std::string* release_esi();
  void set_allocated_esi(::std::string* esi);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteEsi)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr esi_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteEsiImpl();
};
// -------------------------------------------------------------------

class SLL2RouteNh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteNh) */ {
 public:
  SLL2RouteNh();
  virtual ~SLL2RouteNh();

  SLL2RouteNh(const SLL2RouteNh& from);

  inline SLL2RouteNh& operator=(const SLL2RouteNh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteNh(SLL2RouteNh&& from) noexcept
    : SLL2RouteNh() {
    *this = ::std::move(from);
  }

  inline SLL2RouteNh& operator=(SLL2RouteNh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteNh& default_instance();

  enum NhDataCase {
    kNhInterface = 2,
    kNhOverlay = 3,
    NHDATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteNh* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteNh*>(
               &_SLL2RouteNh_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SLL2RouteNh* other);
  friend void swap(SLL2RouteNh& a, SLL2RouteNh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteNh* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteNh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteNh& from);
  void MergeFrom(const SLL2RouteNh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteNh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SLL2RouteNh_SLL2RouteNhType SLL2RouteNhType;
  static const SLL2RouteNhType SL_L2_NH_RESERVED =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_RESERVED;
  static const SLL2RouteNhType SL_L2_NH_INTERFACE =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_INTERFACE;
  static const SLL2RouteNhType SL_L2_NH_OVERLAY =
    SLL2RouteNh_SLL2RouteNhType_SL_L2_NH_OVERLAY;
  static inline bool SLL2RouteNhType_IsValid(int value) {
    return SLL2RouteNh_SLL2RouteNhType_IsValid(value);
  }
  static const SLL2RouteNhType SLL2RouteNhType_MIN =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MIN;
  static const SLL2RouteNhType SLL2RouteNhType_MAX =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_MAX;
  static const int SLL2RouteNhType_ARRAYSIZE =
    SLL2RouteNh_SLL2RouteNhType_SLL2RouteNhType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SLL2RouteNhType_descriptor() {
    return SLL2RouteNh_SLL2RouteNhType_descriptor();
  }
  static inline const ::std::string& SLL2RouteNhType_Name(SLL2RouteNhType value) {
    return SLL2RouteNh_SLL2RouteNhType_Name(value);
  }
  static inline bool SLL2RouteNhType_Parse(const ::std::string& name,
      SLL2RouteNhType* value) {
    return SLL2RouteNh_SLL2RouteNhType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .service_layer.SLL2RouteNh.SLL2RouteNhType NhType = 1;
  void clear_nhtype();
  static const int kNhTypeFieldNumber = 1;
  ::service_layer::SLL2RouteNh_SLL2RouteNhType nhtype() const;
  void set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value);

  // .service_layer.SLInterface NhInterface = 2;
  bool has_nhinterface() const;
  void clear_nhinterface();
  static const int kNhInterfaceFieldNumber = 2;
  const ::service_layer::SLInterface& nhinterface() const;
  ::service_layer::SLInterface* release_nhinterface();
  ::service_layer::SLInterface* mutable_nhinterface();
  void set_allocated_nhinterface(::service_layer::SLInterface* nhinterface);

  // .service_layer.SLL2OverlayNh NhOverlay = 3;
  bool has_nhoverlay() const;
  void clear_nhoverlay();
  static const int kNhOverlayFieldNumber = 3;
  const ::service_layer::SLL2OverlayNh& nhoverlay() const;
  ::service_layer::SLL2OverlayNh* release_nhoverlay();
  ::service_layer::SLL2OverlayNh* mutable_nhoverlay();
  void set_allocated_nhoverlay(::service_layer::SLL2OverlayNh* nhoverlay);

  NhDataCase NhData_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteNh)
 private:
  void set_has_nhinterface();
  void set_has_nhoverlay();

  inline bool has_NhData() const;
  void clear_NhData();
  inline void clear_has_NhData();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int nhtype_;
  union NhDataUnion {
    NhDataUnion() {}
    ::service_layer::SLInterface* nhinterface_;
    ::service_layer::SLL2OverlayNh* nhoverlay_;
  } NhData_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteNhImpl();
};
// -------------------------------------------------------------------

class SLL2OverlayNh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2OverlayNh) */ {
 public:
  SLL2OverlayNh();
  virtual ~SLL2OverlayNh();

  SLL2OverlayNh(const SLL2OverlayNh& from);

  inline SLL2OverlayNh& operator=(const SLL2OverlayNh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2OverlayNh(SLL2OverlayNh&& from) noexcept
    : SLL2OverlayNh() {
    *this = ::std::move(from);
  }

  inline SLL2OverlayNh& operator=(SLL2OverlayNh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2OverlayNh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2OverlayNh* internal_default_instance() {
    return reinterpret_cast<const SLL2OverlayNh*>(
               &_SLL2OverlayNh_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SLL2OverlayNh* other);
  friend void swap(SLL2OverlayNh& a, SLL2OverlayNh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2OverlayNh* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2OverlayNh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2OverlayNh& from);
  void MergeFrom(const SLL2OverlayNh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2OverlayNh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 OverlayNhL3Label = 4;
  int overlaynhl3label_size() const;
  void clear_overlaynhl3label();
  static const int kOverlayNhL3LabelFieldNumber = 4;
  ::google::protobuf::uint32 overlaynhl3label(int index) const;
  void set_overlaynhl3label(int index, ::google::protobuf::uint32 value);
  void add_overlaynhl3label(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      overlaynhl3label() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_overlaynhl3label();

  // bytes OverlayNhRouterMac = 5;
  void clear_overlaynhroutermac();
  static const int kOverlayNhRouterMacFieldNumber = 5;
  const ::std::string& overlaynhroutermac() const;
  void set_overlaynhroutermac(const ::std::string& value);
  #if LANG_CXX11
  void set_overlaynhroutermac(::std::string&& value);
  #endif
  void set_overlaynhroutermac(const char* value);
  void set_overlaynhroutermac(const void* value, size_t size);
  ::std::string* mutable_overlaynhroutermac();
  ::std::string* release_overlaynhroutermac();
  void set_allocated_overlaynhroutermac(::std::string* overlaynhroutermac);

  // .service_layer.SLIpAddress OverlayNhIp = 1;
  bool has_overlaynhip() const;
  void clear_overlaynhip();
  static const int kOverlayNhIpFieldNumber = 1;
  const ::service_layer::SLIpAddress& overlaynhip() const;
  ::service_layer::SLIpAddress* release_overlaynhip();
  ::service_layer::SLIpAddress* mutable_overlaynhip();
  void set_allocated_overlaynhip(::service_layer::SLIpAddress* overlaynhip);

  // .service_layer.SLEncapType OverlayNhEncap = 2;
  void clear_overlaynhencap();
  static const int kOverlayNhEncapFieldNumber = 2;
  ::service_layer::SLEncapType overlaynhencap() const;
  void set_overlaynhencap(::service_layer::SLEncapType value);

  // uint32 OverlayNhLabel = 3;
  void clear_overlaynhlabel();
  static const int kOverlayNhLabelFieldNumber = 3;
  ::google::protobuf::uint32 overlaynhlabel() const;
  void set_overlaynhlabel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2OverlayNh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > overlaynhl3label_;
  mutable int _overlaynhl3label_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr overlaynhroutermac_;
  ::service_layer::SLIpAddress* overlaynhip_;
  int overlaynhencap_;
  ::google::protobuf::uint32 overlaynhlabel_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2OverlayNhImpl();
};
// -------------------------------------------------------------------

class SLL2MacRouteKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2MacRouteKey) */ {
 public:
  SLL2MacRouteKey();
  virtual ~SLL2MacRouteKey();

  SLL2MacRouteKey(const SLL2MacRouteKey& from);

  inline SLL2MacRouteKey& operator=(const SLL2MacRouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2MacRouteKey(SLL2MacRouteKey&& from) noexcept
    : SLL2MacRouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2MacRouteKey& operator=(SLL2MacRouteKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2MacRouteKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2MacRouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2MacRouteKey*>(
               &_SLL2MacRouteKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SLL2MacRouteKey* other);
  friend void swap(SLL2MacRouteKey& a, SLL2MacRouteKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2MacRouteKey* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2MacRouteKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2MacRouteKey& from);
  void MergeFrom(const SLL2MacRouteKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2MacRouteKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes MacAddress = 1;
  void clear_macaddress();
  static const int kMacAddressFieldNumber = 1;
  const ::std::string& macaddress() const;
  void set_macaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_macaddress(::std::string&& value);
  #endif
  void set_macaddress(const char* value);
  void set_macaddress(const void* value, size_t size);
  ::std::string* mutable_macaddress();
  ::std::string* release_macaddress();
  void set_allocated_macaddress(::std::string* macaddress);

  // .service_layer.SLIpAddress IpAddress = 2;
  bool has_ipaddress() const;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 2;
  const ::service_layer::SLIpAddress& ipaddress() const;
  ::service_layer::SLIpAddress* release_ipaddress();
  ::service_layer::SLIpAddress* mutable_ipaddress();
  void set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2MacRouteKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr macaddress_;
  ::service_layer::SLIpAddress* ipaddress_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2MacRouteKeyImpl();
};
// -------------------------------------------------------------------

class SLL2MacRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2MacRoute) */ {
 public:
  SLL2MacRoute();
  virtual ~SLL2MacRoute();

  SLL2MacRoute(const SLL2MacRoute& from);

  inline SLL2MacRoute& operator=(const SLL2MacRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2MacRoute(SLL2MacRoute&& from) noexcept
    : SLL2MacRoute() {
    *this = ::std::move(from);
  }

  inline SLL2MacRoute& operator=(SLL2MacRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2MacRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2MacRoute* internal_default_instance() {
    return reinterpret_cast<const SLL2MacRoute*>(
               &_SLL2MacRoute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SLL2MacRoute* other);
  friend void swap(SLL2MacRoute& a, SLL2MacRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2MacRoute* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2MacRoute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2MacRoute& from);
  void MergeFrom(const SLL2MacRoute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2MacRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .service_layer.SLL2RouteNh NextHopList = 4;
  int nexthoplist_size() const;
  void clear_nexthoplist();
  static const int kNextHopListFieldNumber = 4;
  const ::service_layer::SLL2RouteNh& nexthoplist(int index) const;
  ::service_layer::SLL2RouteNh* mutable_nexthoplist(int index);
  ::service_layer::SLL2RouteNh* add_nexthoplist();
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteNh >*
      mutable_nexthoplist();
  const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteNh >&
      nexthoplist() const;

  // .service_layer.SLL2MacRouteKey RouteKey = 1;
  bool has_routekey() const;
  void clear_routekey();
  static const int kRouteKeyFieldNumber = 1;
  const ::service_layer::SLL2MacRouteKey& routekey() const;
  ::service_layer::SLL2MacRouteKey* release_routekey();
  ::service_layer::SLL2MacRouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2MacRouteKey* routekey);

  // .service_layer.SLL2RouteEsi MacEsi = 3;
  bool has_macesi() const;
  void clear_macesi();
  static const int kMacEsiFieldNumber = 3;
  const ::service_layer::SLL2RouteEsi& macesi() const;
  ::service_layer::SLL2RouteEsi* release_macesi();
  ::service_layer::SLL2RouteEsi* mutable_macesi();
  void set_allocated_macesi(::service_layer::SLL2RouteEsi* macesi);

  // uint32 SequenceNum = 2;
  void clear_sequencenum();
  static const int kSequenceNumFieldNumber = 2;
  ::google::protobuf::uint32 sequencenum() const;
  void set_sequencenum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2MacRoute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteNh > nexthoplist_;
  ::service_layer::SLL2MacRouteKey* routekey_;
  ::service_layer::SLL2RouteEsi* macesi_;
  ::google::protobuf::uint32 sequencenum_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2MacRouteImpl();
};
// -------------------------------------------------------------------

class SLL2ImetRouteKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2ImetRouteKey) */ {
 public:
  SLL2ImetRouteKey();
  virtual ~SLL2ImetRouteKey();

  SLL2ImetRouteKey(const SLL2ImetRouteKey& from);

  inline SLL2ImetRouteKey& operator=(const SLL2ImetRouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2ImetRouteKey(SLL2ImetRouteKey&& from) noexcept
    : SLL2ImetRouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2ImetRouteKey& operator=(SLL2ImetRouteKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2ImetRouteKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2ImetRouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2ImetRouteKey*>(
               &_SLL2ImetRouteKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SLL2ImetRouteKey* other);
  friend void swap(SLL2ImetRouteKey& a, SLL2ImetRouteKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2ImetRouteKey* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2ImetRouteKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2ImetRouteKey& from);
  void MergeFrom(const SLL2ImetRouteKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2ImetRouteKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLIpAddress IpAddress = 2;
  bool has_ipaddress() const;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 2;
  const ::service_layer::SLIpAddress& ipaddress() const;
  ::service_layer::SLIpAddress* release_ipaddress();
  ::service_layer::SLIpAddress* mutable_ipaddress();
  void set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress);

  // uint32 EthTagId = 1;
  void clear_ethtagid();
  static const int kEthTagIdFieldNumber = 1;
  ::google::protobuf::uint32 ethtagid() const;
  void set_ethtagid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2ImetRouteKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::service_layer::SLIpAddress* ipaddress_;
  ::google::protobuf::uint32 ethtagid_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2ImetRouteKeyImpl();
};
// -------------------------------------------------------------------

class SLL2ImetRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2ImetRoute) */ {
 public:
  SLL2ImetRoute();
  virtual ~SLL2ImetRoute();

  SLL2ImetRoute(const SLL2ImetRoute& from);

  inline SLL2ImetRoute& operator=(const SLL2ImetRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2ImetRoute(SLL2ImetRoute&& from) noexcept
    : SLL2ImetRoute() {
    *this = ::std::move(from);
  }

  inline SLL2ImetRoute& operator=(SLL2ImetRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2ImetRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2ImetRoute* internal_default_instance() {
    return reinterpret_cast<const SLL2ImetRoute*>(
               &_SLL2ImetRoute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SLL2ImetRoute* other);
  friend void swap(SLL2ImetRoute& a, SLL2ImetRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2ImetRoute* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2ImetRoute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2ImetRoute& from);
  void MergeFrom(const SLL2ImetRoute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2ImetRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SLL2ImetRoute_PMSITunnelType PMSITunnelType;
  static const PMSITunnelType PMSI_NO_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_NO_TUNNEL;
  static const PMSITunnelType PMSI_RSVPP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_RSVPP2MP_TUNNEL;
  static const PMSITunnelType PMSI_MLDPP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_MLDPP2MP_TUNNEL;
  static const PMSITunnelType PMSI_PIMSSM_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMSSM_TUNNEL;
  static const PMSITunnelType PMSI_PIMSM_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMSM_TUNNEL;
  static const PMSITunnelType PMSI_PIMBIDIR_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_PIMBIDIR_TUNNEL;
  static const PMSITunnelType PMSI_INGREP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_INGREP_TUNNEL;
  static const PMSITunnelType PMSI_MLDPMP2MP_TUNNEL =
    SLL2ImetRoute_PMSITunnelType_PMSI_MLDPMP2MP_TUNNEL;
  static inline bool PMSITunnelType_IsValid(int value) {
    return SLL2ImetRoute_PMSITunnelType_IsValid(value);
  }
  static const PMSITunnelType PMSITunnelType_MIN =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MIN;
  static const PMSITunnelType PMSITunnelType_MAX =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_MAX;
  static const int PMSITunnelType_ARRAYSIZE =
    SLL2ImetRoute_PMSITunnelType_PMSITunnelType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PMSITunnelType_descriptor() {
    return SLL2ImetRoute_PMSITunnelType_descriptor();
  }
  static inline const ::std::string& PMSITunnelType_Name(PMSITunnelType value) {
    return SLL2ImetRoute_PMSITunnelType_Name(value);
  }
  static inline bool PMSITunnelType_Parse(const ::std::string& name,
      PMSITunnelType* value) {
    return SLL2ImetRoute_PMSITunnelType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes TunnelIdValue = 6;
  void clear_tunnelidvalue();
  static const int kTunnelIdValueFieldNumber = 6;
  const ::std::string& tunnelidvalue() const;
  void set_tunnelidvalue(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnelidvalue(::std::string&& value);
  #endif
  void set_tunnelidvalue(const char* value);
  void set_tunnelidvalue(const void* value, size_t size);
  ::std::string* mutable_tunnelidvalue();
  ::std::string* release_tunnelidvalue();
  void set_allocated_tunnelidvalue(::std::string* tunnelidvalue);

  // .service_layer.SLL2ImetRouteKey RouteKey = 1;
  bool has_routekey() const;
  void clear_routekey();
  static const int kRouteKeyFieldNumber = 1;
  const ::service_layer::SLL2ImetRouteKey& routekey() const;
  ::service_layer::SLL2ImetRouteKey* release_routekey();
  ::service_layer::SLL2ImetRouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2ImetRouteKey* routekey);

  // .service_layer.SLEncapType EncapType = 2;
  void clear_encaptype();
  static const int kEncapTypeFieldNumber = 2;
  ::service_layer::SLEncapType encaptype() const;
  void set_encaptype(::service_layer::SLEncapType value);

  // uint32 Label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  ::google::protobuf::uint32 label() const;
  void set_label(::google::protobuf::uint32 value);

  // .service_layer.SLL2ImetRoute.PMSITunnelType TunnelType = 4;
  void clear_tunneltype();
  static const int kTunnelTypeFieldNumber = 4;
  ::service_layer::SLL2ImetRoute_PMSITunnelType tunneltype() const;
  void set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value);

  // uint32 TunnelIdLength = 5;
  void clear_tunnelidlength();
  static const int kTunnelIdLengthFieldNumber = 5;
  ::google::protobuf::uint32 tunnelidlength() const;
  void set_tunnelidlength(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2ImetRoute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tunnelidvalue_;
  ::service_layer::SLL2ImetRouteKey* routekey_;
  int encaptype_;
  ::google::protobuf::uint32 label_;
  int tunneltype_;
  ::google::protobuf::uint32 tunnelidlength_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2ImetRouteImpl();
};
// -------------------------------------------------------------------

class SLL2RouteKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteKey) */ {
 public:
  SLL2RouteKey();
  virtual ~SLL2RouteKey();

  SLL2RouteKey(const SLL2RouteKey& from);

  inline SLL2RouteKey& operator=(const SLL2RouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteKey(SLL2RouteKey&& from) noexcept
    : SLL2RouteKey() {
    *this = ::std::move(from);
  }

  inline SLL2RouteKey& operator=(SLL2RouteKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteKey& default_instance();

  enum EventCase {
    kMacKey = 3,
    kImetKey = 4,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteKey* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteKey*>(
               &_SLL2RouteKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SLL2RouteKey* other);
  friend void swap(SLL2RouteKey& a, SLL2RouteKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteKey* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteKey& from);
  void MergeFrom(const SLL2RouteKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string BdName = 1;
  void clear_bdname();
  static const int kBdNameFieldNumber = 1;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  // .service_layer.SLL2RouteType Type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::service_layer::SLL2RouteType type() const;
  void set_type(::service_layer::SLL2RouteType value);

  // .service_layer.SLL2MacRouteKey MacKey = 3;
  bool has_mackey() const;
  void clear_mackey();
  static const int kMacKeyFieldNumber = 3;
  const ::service_layer::SLL2MacRouteKey& mackey() const;
  ::service_layer::SLL2MacRouteKey* release_mackey();
  ::service_layer::SLL2MacRouteKey* mutable_mackey();
  void set_allocated_mackey(::service_layer::SLL2MacRouteKey* mackey);

  // .service_layer.SLL2ImetRouteKey ImetKey = 4;
  bool has_imetkey() const;
  void clear_imetkey();
  static const int kImetKeyFieldNumber = 4;
  const ::service_layer::SLL2ImetRouteKey& imetkey() const;
  ::service_layer::SLL2ImetRouteKey* release_imetkey();
  ::service_layer::SLL2ImetRouteKey* mutable_imetkey();
  void set_allocated_imetkey(::service_layer::SLL2ImetRouteKey* imetkey);

  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteKey)
 private:
  void set_has_mackey();
  void set_has_imetkey();

  inline bool has_Event() const;
  void clear_Event();
  inline void clear_has_Event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bdname_;
  int type_;
  union EventUnion {
    EventUnion() {}
    ::service_layer::SLL2MacRouteKey* mackey_;
    ::service_layer::SLL2ImetRouteKey* imetkey_;
  } Event_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteKeyImpl();
};
// -------------------------------------------------------------------

class SLL2Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2Route) */ {
 public:
  SLL2Route();
  virtual ~SLL2Route();

  SLL2Route(const SLL2Route& from);

  inline SLL2Route& operator=(const SLL2Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2Route(SLL2Route&& from) noexcept
    : SLL2Route() {
    *this = ::std::move(from);
  }

  inline SLL2Route& operator=(SLL2Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2Route& default_instance();

  enum EventCase {
    kMacRoute = 3,
    kImetRoute = 4,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2Route* internal_default_instance() {
    return reinterpret_cast<const SLL2Route*>(
               &_SLL2Route_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SLL2Route* other);
  friend void swap(SLL2Route& a, SLL2Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2Route* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2Route* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2Route& from);
  void MergeFrom(const SLL2Route& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string BdName = 1;
  void clear_bdname();
  static const int kBdNameFieldNumber = 1;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  // .service_layer.SLL2RouteType Type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::service_layer::SLL2RouteType type() const;
  void set_type(::service_layer::SLL2RouteType value);

  // .service_layer.SLL2MacRoute MacRoute = 3;
  bool has_macroute() const;
  void clear_macroute();
  static const int kMacRouteFieldNumber = 3;
  const ::service_layer::SLL2MacRoute& macroute() const;
  ::service_layer::SLL2MacRoute* release_macroute();
  ::service_layer::SLL2MacRoute* mutable_macroute();
  void set_allocated_macroute(::service_layer::SLL2MacRoute* macroute);

  // .service_layer.SLL2ImetRoute ImetRoute = 4;
  bool has_imetroute() const;
  void clear_imetroute();
  static const int kImetRouteFieldNumber = 4;
  const ::service_layer::SLL2ImetRoute& imetroute() const;
  ::service_layer::SLL2ImetRoute* release_imetroute();
  ::service_layer::SLL2ImetRoute* mutable_imetroute();
  void set_allocated_imetroute(::service_layer::SLL2ImetRoute* imetroute);

  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2Route)
 private:
  void set_has_macroute();
  void set_has_imetroute();

  inline bool has_Event() const;
  void clear_Event();
  inline void clear_has_Event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bdname_;
  int type_;
  union EventUnion {
    EventUnion() {}
    ::service_layer::SLL2MacRoute* macroute_;
    ::service_layer::SLL2ImetRoute* imetroute_;
  } Event_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteImpl();
};
// -------------------------------------------------------------------

class SLL2RouteMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteMsg) */ {
 public:
  SLL2RouteMsg();
  virtual ~SLL2RouteMsg();

  SLL2RouteMsg(const SLL2RouteMsg& from);

  inline SLL2RouteMsg& operator=(const SLL2RouteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteMsg(SLL2RouteMsg&& from) noexcept
    : SLL2RouteMsg() {
    *this = ::std::move(from);
  }

  inline SLL2RouteMsg& operator=(SLL2RouteMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteMsg*>(
               &_SLL2RouteMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SLL2RouteMsg* other);
  friend void swap(SLL2RouteMsg& a, SLL2RouteMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteMsg& from);
  void MergeFrom(const SLL2RouteMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .service_layer.SLL2Route Routes = 3;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 3;
  const ::service_layer::SLL2Route& routes(int index) const;
  ::service_layer::SLL2Route* mutable_routes(int index);
  ::service_layer::SLL2Route* add_routes();
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2Route >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2Route >&
      routes() const;

  // uint64 Correlator = 1;
  void clear_correlator();
  static const int kCorrelatorFieldNumber = 1;
  ::google::protobuf::uint64 correlator() const;
  void set_correlator(::google::protobuf::uint64 value);

  // .service_layer.SLObjectOp Oper = 2;
  void clear_oper();
  static const int kOperFieldNumber = 2;
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2Route > routes_;
  ::google::protobuf::uint64 correlator_;
  int oper_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteMsgImpl();
};
// -------------------------------------------------------------------

class SLL2RouteRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteRes) */ {
 public:
  SLL2RouteRes();
  virtual ~SLL2RouteRes();

  SLL2RouteRes(const SLL2RouteRes& from);

  inline SLL2RouteRes& operator=(const SLL2RouteRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteRes(SLL2RouteRes&& from) noexcept
    : SLL2RouteRes() {
    *this = ::std::move(from);
  }

  inline SLL2RouteRes& operator=(SLL2RouteRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteRes* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteRes*>(
               &_SLL2RouteRes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(SLL2RouteRes* other);
  friend void swap(SLL2RouteRes& a, SLL2RouteRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteRes* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteRes& from);
  void MergeFrom(const SLL2RouteRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  void clear_errstatus();
  static const int kErrStatusFieldNumber = 1;
  const ::service_layer::SLErrorStatus& errstatus() const;
  ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);

  // .service_layer.SLL2RouteKey RouteKey = 2;
  bool has_routekey() const;
  void clear_routekey();
  static const int kRouteKeyFieldNumber = 2;
  const ::service_layer::SLL2RouteKey& routekey() const;
  ::service_layer::SLL2RouteKey* release_routekey();
  ::service_layer::SLL2RouteKey* mutable_routekey();
  void set_allocated_routekey(::service_layer::SLL2RouteKey* routekey);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::service_layer::SLErrorStatus* errstatus_;
  ::service_layer::SLL2RouteKey* routekey_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteResImpl();
};
// -------------------------------------------------------------------

class SLL2RouteMsgRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteMsgRsp) */ {
 public:
  SLL2RouteMsgRsp();
  virtual ~SLL2RouteMsgRsp();

  SLL2RouteMsgRsp(const SLL2RouteMsgRsp& from);

  inline SLL2RouteMsgRsp& operator=(const SLL2RouteMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteMsgRsp(SLL2RouteMsgRsp&& from) noexcept
    : SLL2RouteMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLL2RouteMsgRsp& operator=(SLL2RouteMsgRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteMsgRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteMsgRsp*>(
               &_SLL2RouteMsgRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(SLL2RouteMsgRsp* other);
  friend void swap(SLL2RouteMsgRsp& a, SLL2RouteMsgRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteMsgRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteMsgRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteMsgRsp& from);
  void MergeFrom(const SLL2RouteMsgRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteMsgRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .service_layer.SLL2RouteRes Results = 3;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 3;
  const ::service_layer::SLL2RouteRes& results(int index) const;
  ::service_layer::SLL2RouteRes* mutable_results(int index);
  ::service_layer::SLL2RouteRes* add_results();
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteRes >*
      mutable_results();
  const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 2;
  bool has_statussummary() const;
  void clear_statussummary();
  static const int kStatusSummaryFieldNumber = 2;
  const ::service_layer::SLErrorStatus& statussummary() const;
  ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);

  // uint64 Correlator = 1;
  void clear_correlator();
  static const int kCorrelatorFieldNumber = 1;
  ::google::protobuf::uint64 correlator() const;
  void set_correlator(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteMsgRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  ::google::protobuf::uint64 correlator_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteMsgRspImpl();
};
// -------------------------------------------------------------------

class SLL2GetNotifMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2GetNotifMsg) */ {
 public:
  SLL2GetNotifMsg();
  virtual ~SLL2GetNotifMsg();

  SLL2GetNotifMsg(const SLL2GetNotifMsg& from);

  inline SLL2GetNotifMsg& operator=(const SLL2GetNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2GetNotifMsg(SLL2GetNotifMsg&& from) noexcept
    : SLL2GetNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLL2GetNotifMsg& operator=(SLL2GetNotifMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2GetNotifMsg& default_instance();

  enum RequestCase {
    kBdAll = 4,
    kBdName = 5,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2GetNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2GetNotifMsg*>(
               &_SLL2GetNotifMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(SLL2GetNotifMsg* other);
  friend void swap(SLL2GetNotifMsg& a, SLL2GetNotifMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2GetNotifMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2GetNotifMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2GetNotifMsg& from);
  void MergeFrom(const SLL2GetNotifMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2GetNotifMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 Correlator = 2;
  void clear_correlator();
  static const int kCorrelatorFieldNumber = 2;
  ::google::protobuf::uint64 correlator() const;
  void set_correlator(::google::protobuf::uint64 value);

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);

  // bool GetNotifEof = 3;
  void clear_getnotifeof();
  static const int kGetNotifEofFieldNumber = 3;
  bool getnotifeof() const;
  void set_getnotifeof(bool value);

  // bool BdAll = 4;
  private:
  bool has_bdall() const;
  public:
  void clear_bdall();
  static const int kBdAllFieldNumber = 4;
  bool bdall() const;
  void set_bdall(bool value);

  // string BdName = 5;
  private:
  bool has_bdname() const;
  public:
  void clear_bdname();
  static const int kBdNameFieldNumber = 5;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  RequestCase Request_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2GetNotifMsg)
 private:
  void set_has_bdall();
  void set_has_bdname();

  inline bool has_Request() const;
  void clear_Request();
  inline void clear_has_Request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 correlator_;
  int oper_;
  bool getnotifeof_;
  union RequestUnion {
    RequestUnion() {}
    bool bdall_;
    ::google::protobuf::internal::ArenaStringPtr bdname_;
  } Request_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2GetNotifMsgImpl();
};
// -------------------------------------------------------------------

class SLL2RouteNotif : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2RouteNotif) */ {
 public:
  SLL2RouteNotif();
  virtual ~SLL2RouteNotif();

  SLL2RouteNotif(const SLL2RouteNotif& from);

  inline SLL2RouteNotif& operator=(const SLL2RouteNotif& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2RouteNotif(SLL2RouteNotif&& from) noexcept
    : SLL2RouteNotif() {
    *this = ::std::move(from);
  }

  inline SLL2RouteNotif& operator=(SLL2RouteNotif&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2RouteNotif& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2RouteNotif* internal_default_instance() {
    return reinterpret_cast<const SLL2RouteNotif*>(
               &_SLL2RouteNotif_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(SLL2RouteNotif* other);
  friend void swap(SLL2RouteNotif& a, SLL2RouteNotif& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2RouteNotif* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2RouteNotif* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2RouteNotif& from);
  void MergeFrom(const SLL2RouteNotif& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2RouteNotif* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLL2Route Routes = 2;
  bool has_routes() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 2;
  const ::service_layer::SLL2Route& routes() const;
  ::service_layer::SLL2Route* release_routes();
  ::service_layer::SLL2Route* mutable_routes();
  void set_allocated_routes(::service_layer::SLL2Route* routes);

  // .service_layer.SLObjectOp Oper = 1;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::service_layer::SLObjectOp oper() const;
  void set_oper(::service_layer::SLObjectOp value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2RouteNotif)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::service_layer::SLL2Route* routes_;
  int oper_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2RouteNotifImpl();
};
// -------------------------------------------------------------------

class SLL2BdStateInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2BdStateInfo) */ {
 public:
  SLL2BdStateInfo();
  virtual ~SLL2BdStateInfo();

  SLL2BdStateInfo(const SLL2BdStateInfo& from);

  inline SLL2BdStateInfo& operator=(const SLL2BdStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2BdStateInfo(SLL2BdStateInfo&& from) noexcept
    : SLL2BdStateInfo() {
    *this = ::std::move(from);
  }

  inline SLL2BdStateInfo& operator=(SLL2BdStateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2BdStateInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2BdStateInfo* internal_default_instance() {
    return reinterpret_cast<const SLL2BdStateInfo*>(
               &_SLL2BdStateInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SLL2BdStateInfo* other);
  friend void swap(SLL2BdStateInfo& a, SLL2BdStateInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2BdStateInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2BdStateInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2BdStateInfo& from);
  void MergeFrom(const SLL2BdStateInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2BdStateInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SLL2BdStateInfo_SLL2BdState SLL2BdState;
  static const SLL2BdState SL_L2_BD_STATE_RESERVED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_RESERVED;
  static const SLL2BdState SL_L2_BD_STATE_ADDED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_ADDED;
  static const SLL2BdState SL_L2_BD_STATE_DELETED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_DELETED;
  static const SLL2BdState SL_L2_BD_STATE_REPLAY_NEEDED =
    SLL2BdStateInfo_SLL2BdState_SL_L2_BD_STATE_REPLAY_NEEDED;
  static inline bool SLL2BdState_IsValid(int value) {
    return SLL2BdStateInfo_SLL2BdState_IsValid(value);
  }
  static const SLL2BdState SLL2BdState_MIN =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_MIN;
  static const SLL2BdState SLL2BdState_MAX =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_MAX;
  static const int SLL2BdState_ARRAYSIZE =
    SLL2BdStateInfo_SLL2BdState_SLL2BdState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SLL2BdState_descriptor() {
    return SLL2BdStateInfo_SLL2BdState_descriptor();
  }
  static inline const ::std::string& SLL2BdState_Name(SLL2BdState value) {
    return SLL2BdStateInfo_SLL2BdState_Name(value);
  }
  static inline bool SLL2BdState_Parse(const ::std::string& name,
      SLL2BdState* value) {
    return SLL2BdStateInfo_SLL2BdState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string BdName = 1;
  void clear_bdname();
  static const int kBdNameFieldNumber = 1;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  // .service_layer.SLL2BdStateInfo.SLL2BdState BdState = 2;
  void clear_bdstate();
  static const int kBdStateFieldNumber = 2;
  ::service_layer::SLL2BdStateInfo_SLL2BdState bdstate() const;
  void set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2BdStateInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bdname_;
  int bdstate_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2BdStateInfoImpl();
};
// -------------------------------------------------------------------

class SLL2NotifStatusMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2NotifStatusMsg) */ {
 public:
  SLL2NotifStatusMsg();
  virtual ~SLL2NotifStatusMsg();

  SLL2NotifStatusMsg(const SLL2NotifStatusMsg& from);

  inline SLL2NotifStatusMsg& operator=(const SLL2NotifStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2NotifStatusMsg(SLL2NotifStatusMsg&& from) noexcept
    : SLL2NotifStatusMsg() {
    *this = ::std::move(from);
  }

  inline SLL2NotifStatusMsg& operator=(SLL2NotifStatusMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2NotifStatusMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2NotifStatusMsg* internal_default_instance() {
    return reinterpret_cast<const SLL2NotifStatusMsg*>(
               &_SLL2NotifStatusMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(SLL2NotifStatusMsg* other);
  friend void swap(SLL2NotifStatusMsg& a, SLL2NotifStatusMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2NotifStatusMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2NotifStatusMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2NotifStatusMsg& from);
  void MergeFrom(const SLL2NotifStatusMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2NotifStatusMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string BdName = 3;
  void clear_bdname();
  static const int kBdNameFieldNumber = 3;
  const ::std::string& bdname() const;
  void set_bdname(const ::std::string& value);
  #if LANG_CXX11
  void set_bdname(::std::string&& value);
  #endif
  void set_bdname(const char* value);
  void set_bdname(const char* value, size_t size);
  ::std::string* mutable_bdname();
  ::std::string* release_bdname();
  void set_allocated_bdname(::std::string* bdname);

  // .service_layer.SLErrorStatus NotifStatus = 4;
  bool has_notifstatus() const;
  void clear_notifstatus();
  static const int kNotifStatusFieldNumber = 4;
  const ::service_layer::SLErrorStatus& notifstatus() const;
  ::service_layer::SLErrorStatus* release_notifstatus();
  ::service_layer::SLErrorStatus* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus);

  // uint64 Correlator = 2;
  void clear_correlator();
  static const int kCorrelatorFieldNumber = 2;
  ::google::protobuf::uint64 correlator() const;
  void set_correlator(::google::protobuf::uint64 value);

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);

  // @@protoc_insertion_point(class_scope:service_layer.SLL2NotifStatusMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bdname_;
  ::service_layer::SLErrorStatus* notifstatus_;
  ::google::protobuf::uint64 correlator_;
  int oper_;
  mutable int _cached_size_;
  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2NotifStatusMsgImpl();
};
// -------------------------------------------------------------------

class SLL2Notif : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:service_layer.SLL2Notif) */ {
 public:
  SLL2Notif();
  virtual ~SLL2Notif();

  SLL2Notif(const SLL2Notif& from);

  inline SLL2Notif& operator=(const SLL2Notif& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SLL2Notif(SLL2Notif&& from) noexcept
    : SLL2Notif() {
    *this = ::std::move(from);
  }

  inline SLL2Notif& operator=(SLL2Notif&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLL2Notif& default_instance();

  enum EventCase {
    kErrStatus = 2,
    kNotifStatus = 3,
    kBdStateInfo = 4,
    kRoute = 5,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLL2Notif* internal_default_instance() {
    return reinterpret_cast<const SLL2Notif*>(
               &_SLL2Notif_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(SLL2Notif* other);
  friend void swap(SLL2Notif& a, SLL2Notif& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLL2Notif* New() const PROTOBUF_FINAL { return New(NULL); }

  SLL2Notif* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SLL2Notif& from);
  void MergeFrom(const SLL2Notif& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SLL2Notif* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .service_layer.SLL2NotifType EventType = 1;
  void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  ::service_layer::SLL2NotifType eventtype() const;
  void set_eventtype(::service_layer::SLL2NotifType value);

  // .service_layer.SLErrorStatus ErrStatus = 2;
  bool has_errstatus() const;
  void clear_errstatus();
  static const int kErrStatusFieldNumber = 2;
  const ::service_layer::SLErrorStatus& errstatus() const;
  ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);

  // .service_layer.SLL2NotifStatusMsg NotifStatus = 3;
  bool has_notifstatus() const;
  void clear_notifstatus();
  static const int kNotifStatusFieldNumber = 3;
  const ::service_layer::SLL2NotifStatusMsg& notifstatus() const;
  ::service_layer::SLL2NotifStatusMsg* release_notifstatus();
  ::service_layer::SLL2NotifStatusMsg* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLL2NotifStatusMsg* notifstatus);

  // .service_layer.SLL2BdStateInfo BdStateInfo = 4;
  bool has_bdstateinfo() const;
  void clear_bdstateinfo();
  static const int kBdStateInfoFieldNumber = 4;
  const ::service_layer::SLL2BdStateInfo& bdstateinfo() const;
  ::service_layer::SLL2BdStateInfo* release_bdstateinfo();
  ::service_layer::SLL2BdStateInfo* mutable_bdstateinfo();
  void set_allocated_bdstateinfo(::service_layer::SLL2BdStateInfo* bdstateinfo);

  // .service_layer.SLL2RouteNotif Route = 5;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 5;
  const ::service_layer::SLL2RouteNotif& route() const;
  ::service_layer::SLL2RouteNotif* release_route();
  ::service_layer::SLL2RouteNotif* mutable_route();
  void set_allocated_route(::service_layer::SLL2RouteNotif* route);

  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLL2Notif)
 private:
  void set_has_errstatus();
  void set_has_notifstatus();
  void set_has_bdstateinfo();
  void set_has_route();

  inline bool has_Event() const;
  void clear_Event();
  inline void clear_has_Event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int eventtype_;
  union EventUnion {
    EventUnion() {}
    ::service_layer::SLErrorStatus* errstatus_;
    ::service_layer::SLL2NotifStatusMsg* notifstatus_;
    ::service_layer::SLL2BdStateInfo* bdstateinfo_;
    ::service_layer::SLL2RouteNotif* route_;
  } Event_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sl_5fl2_5froute_2eproto::TableStruct;
  friend void ::protobuf_sl_5fl2_5froute_2eproto::InitDefaultsSLL2NotifImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLL2GlobalsGetMsg

// -------------------------------------------------------------------

// SLL2GlobalsGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2GlobalsGetMsgRsp::has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2GlobalsGetMsgRsp::errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2GlobalsGetMsgRsp::mutable_errstatus() {
  
  if (errstatus_ == NULL) {
    errstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
  return errstatus_;
}
inline void SLL2GlobalsGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2GlobalsGetMsgRsp.ErrStatus)
}

// uint32 MaxBdRegPerBdRegmsg = 2;
inline void SLL2GlobalsGetMsgRsp::clear_maxbdregperbdregmsg() {
  maxbdregperbdregmsg_ = 0u;
}
inline ::google::protobuf::uint32 SLL2GlobalsGetMsgRsp::maxbdregperbdregmsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.MaxBdRegPerBdRegmsg)
  return maxbdregperbdregmsg_;
}
inline void SLL2GlobalsGetMsgRsp::set_maxbdregperbdregmsg(::google::protobuf::uint32 value) {
  
  maxbdregperbdregmsg_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GlobalsGetMsgRsp.MaxBdRegPerBdRegmsg)
}

// uint32 MaxRoutePerRoutemsg = 3;
inline void SLL2GlobalsGetMsgRsp::clear_maxrouteperroutemsg() {
  maxrouteperroutemsg_ = 0u;
}
inline ::google::protobuf::uint32 SLL2GlobalsGetMsgRsp::maxrouteperroutemsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GlobalsGetMsgRsp.MaxRoutePerRoutemsg)
  return maxrouteperroutemsg_;
}
inline void SLL2GlobalsGetMsgRsp::set_maxrouteperroutemsg(::google::protobuf::uint32 value) {
  
  maxrouteperroutemsg_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GlobalsGetMsgRsp.MaxRoutePerRoutemsg)
}

// -------------------------------------------------------------------

// SLL2RegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLL2RegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLL2RegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.Oper)
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline void SLL2RegMsg::set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.Oper)
}

// uint32 AdminDistance = 2;
inline void SLL2RegMsg::clear_admindistance() {
  admindistance_ = 0u;
}
inline ::google::protobuf::uint32 SLL2RegMsg::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.AdminDistance)
  return admindistance_;
}
inline void SLL2RegMsg::set_admindistance(::google::protobuf::uint32 value) {
  
  admindistance_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.AdminDistance)
}

// uint32 PurgeIntervalSeconds = 3;
inline void SLL2RegMsg::clear_purgeintervalseconds() {
  purgeintervalseconds_ = 0u;
}
inline ::google::protobuf::uint32 SLL2RegMsg::purgeintervalseconds() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsg.PurgeIntervalSeconds)
  return purgeintervalseconds_;
}
inline void SLL2RegMsg::set_purgeintervalseconds(::google::protobuf::uint32 value) {
  
  purgeintervalseconds_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RegMsg.PurgeIntervalSeconds)
}

// -------------------------------------------------------------------

// SLL2RegMsgRsp

// .service_layer.SLErrorStatus RegStatus = 1;
inline bool SLL2RegMsgRsp::has_regstatus() const {
  return this != internal_default_instance() && regstatus_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2RegMsgRsp::regstatus() const {
  const ::service_layer::SLErrorStatus* p = regstatus_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2RegMsgRsp.RegStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::release_regstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RegMsgRsp.RegStatus)
  
  ::service_layer::SLErrorStatus* temp = regstatus_;
  regstatus_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RegMsgRsp::mutable_regstatus() {
  
  if (regstatus_ == NULL) {
    regstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RegMsgRsp.RegStatus)
  return regstatus_;
}
inline void SLL2RegMsgRsp::set_allocated_regstatus(::service_layer::SLErrorStatus* regstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(regstatus_);
  }
  if (regstatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      regstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regstatus, submessage_arena);
    }
    
  } else {
    
  }
  regstatus_ = regstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RegMsgRsp.RegStatus)
}

// -------------------------------------------------------------------

// SLL2BdRegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLL2BdRegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLL2BdRegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsg.Oper)
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline void SLL2BdRegMsg::set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.Oper)
}

// repeated string BdRegName = 2;
inline int SLL2BdRegMsg::bdregname_size() const {
  return bdregname_.size();
}
inline void SLL2BdRegMsg::clear_bdregname() {
  bdregname_.Clear();
}
inline const ::std::string& SLL2BdRegMsg::bdregname(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_.Get(index);
}
inline ::std::string* SLL2BdRegMsg::mutable_bdregname(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_.Mutable(index);
}
inline void SLL2BdRegMsg::set_bdregname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.BdRegName)
  bdregname_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SLL2BdRegMsg::set_bdregname(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegMsg.BdRegName)
  bdregname_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SLL2BdRegMsg::set_bdregname(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  bdregname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::set_bdregname(int index, const char* value, size_t size) {
  bdregname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2BdRegMsg.BdRegName)
}
inline ::std::string* SLL2BdRegMsg::add_bdregname() {
  // @@protoc_insertion_point(field_add_mutable:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_.Add();
}
inline void SLL2BdRegMsg::add_bdregname(const ::std::string& value) {
  bdregname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsg.BdRegName)
}
#if LANG_CXX11
inline void SLL2BdRegMsg::add_bdregname(::std::string&& value) {
  bdregname_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsg.BdRegName)
}
#endif
inline void SLL2BdRegMsg::add_bdregname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  bdregname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service_layer.SLL2BdRegMsg.BdRegName)
}
inline void SLL2BdRegMsg::add_bdregname(const char* value, size_t size) {
  bdregname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service_layer.SLL2BdRegMsg.BdRegName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SLL2BdRegMsg::bdregname() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2BdRegMsg.BdRegName)
  return bdregname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SLL2BdRegMsg::mutable_bdregname() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2BdRegMsg.BdRegName)
  return &bdregname_;
}

// -------------------------------------------------------------------

// SLL2BdRegRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2BdRegRes::has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegRes::errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegRes.ErrStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegRes::mutable_errstatus() {
  
  if (errstatus_ == NULL) {
    errstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegRes.ErrStatus)
  return errstatus_;
}
inline void SLL2BdRegRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegRes.ErrStatus)
}

// string BdName = 2;
inline void SLL2BdRegRes::clear_bdname() {
  bdname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2BdRegRes::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegRes.BdName)
  return bdname_.GetNoArena();
}
inline void SLL2BdRegRes::set_bdname(const ::std::string& value) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdRegRes.BdName)
}
#if LANG_CXX11
inline void SLL2BdRegRes::set_bdname(::std::string&& value) {
  
  bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2BdRegRes.BdName)
}
#endif
inline void SLL2BdRegRes::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2BdRegRes.BdName)
}
inline void SLL2BdRegRes::set_bdname(const char* value, size_t size) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2BdRegRes.BdName)
}
inline ::std::string* SLL2BdRegRes::mutable_bdname() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegRes.BdName)
  return bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2BdRegRes::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegRes.BdName)
  
  return bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2BdRegRes::set_allocated_bdname(::std::string* bdname) {
  if (bdname != NULL) {
    
  } else {
    
  }
  bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bdname);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegRes.BdName)
}

// -------------------------------------------------------------------

// SLL2BdRegMsgRsp

// .service_layer.SLErrorStatus StatusSummary = 1;
inline bool SLL2BdRegMsgRsp::has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2BdRegMsgRsp::statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2BdRegMsgRsp::mutable_statussummary() {
  
  if (statussummary_ == NULL) {
    statussummary_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsgRsp.StatusSummary)
  return statussummary_;
}
inline void SLL2BdRegMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      statussummary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdRegMsgRsp.StatusSummary)
}

// repeated .service_layer.SLL2BdRegRes Results = 2;
inline int SLL2BdRegMsgRsp::results_size() const {
  return results_.size();
}
inline void SLL2BdRegMsgRsp::clear_results() {
  results_.Clear();
}
inline const ::service_layer::SLL2BdRegRes& SLL2BdRegMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdRegMsgRsp.Results)
  return results_.Get(index);
}
inline ::service_layer::SLL2BdRegRes* SLL2BdRegMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdRegMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::service_layer::SLL2BdRegRes* SLL2BdRegMsgRsp::add_results() {
  // @@protoc_insertion_point(field_add:service_layer.SLL2BdRegMsgRsp.Results)
  return results_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2BdRegRes >*
SLL2BdRegMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2BdRegMsgRsp.Results)
  return &results_;
}
inline const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2BdRegRes >&
SLL2BdRegMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2BdRegMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLL2RouteEsi

// bytes Esi = 1;
inline void SLL2RouteEsi::clear_esi() {
  esi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2RouteEsi::esi() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteEsi.Esi)
  return esi_.GetNoArena();
}
inline void SLL2RouteEsi::set_esi(const ::std::string& value) {
  
  esi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteEsi.Esi)
}
#if LANG_CXX11
inline void SLL2RouteEsi::set_esi(::std::string&& value) {
  
  esi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2RouteEsi.Esi)
}
#endif
inline void SLL2RouteEsi::set_esi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  esi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2RouteEsi.Esi)
}
inline void SLL2RouteEsi::set_esi(const void* value, size_t size) {
  
  esi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2RouteEsi.Esi)
}
inline ::std::string* SLL2RouteEsi::mutable_esi() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteEsi.Esi)
  return esi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2RouteEsi::release_esi() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteEsi.Esi)
  
  return esi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2RouteEsi::set_allocated_esi(::std::string* esi) {
  if (esi != NULL) {
    
  } else {
    
  }
  esi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), esi);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteEsi.Esi)
}

// -------------------------------------------------------------------

// SLL2RouteNh

// .service_layer.SLL2RouteNh.SLL2RouteNhType NhType = 1;
inline void SLL2RouteNh::clear_nhtype() {
  nhtype_ = 0;
}
inline ::service_layer::SLL2RouteNh_SLL2RouteNhType SLL2RouteNh::nhtype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhType)
  return static_cast< ::service_layer::SLL2RouteNh_SLL2RouteNhType >(nhtype_);
}
inline void SLL2RouteNh::set_nhtype(::service_layer::SLL2RouteNh_SLL2RouteNhType value) {
  
  nhtype_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteNh.NhType)
}

// .service_layer.SLInterface NhInterface = 2;
inline bool SLL2RouteNh::has_nhinterface() const {
  return NhData_case() == kNhInterface;
}
inline void SLL2RouteNh::set_has_nhinterface() {
  _oneof_case_[0] = kNhInterface;
}
inline ::service_layer::SLInterface* SLL2RouteNh::release_nhinterface() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNh.NhInterface)
  if (has_nhinterface()) {
    clear_has_NhData();
      ::service_layer::SLInterface* temp = NhData_.nhinterface_;
    NhData_.nhinterface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLInterface& SLL2RouteNh::nhinterface() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhInterface)
  return has_nhinterface()
      ? *NhData_.nhinterface_
      : *reinterpret_cast< ::service_layer::SLInterface*>(&::service_layer::_SLInterface_default_instance_);
}
inline ::service_layer::SLInterface* SLL2RouteNh::mutable_nhinterface() {
  if (!has_nhinterface()) {
    clear_NhData();
    set_has_nhinterface();
    NhData_.nhinterface_ = new ::service_layer::SLInterface;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNh.NhInterface)
  return NhData_.nhinterface_;
}

// .service_layer.SLL2OverlayNh NhOverlay = 3;
inline bool SLL2RouteNh::has_nhoverlay() const {
  return NhData_case() == kNhOverlay;
}
inline void SLL2RouteNh::set_has_nhoverlay() {
  _oneof_case_[0] = kNhOverlay;
}
inline void SLL2RouteNh::clear_nhoverlay() {
  if (has_nhoverlay()) {
    delete NhData_.nhoverlay_;
    clear_has_NhData();
  }
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::release_nhoverlay() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNh.NhOverlay)
  if (has_nhoverlay()) {
    clear_has_NhData();
      ::service_layer::SLL2OverlayNh* temp = NhData_.nhoverlay_;
    NhData_.nhoverlay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2OverlayNh& SLL2RouteNh::nhoverlay() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNh.NhOverlay)
  return has_nhoverlay()
      ? *NhData_.nhoverlay_
      : *reinterpret_cast< ::service_layer::SLL2OverlayNh*>(&::service_layer::_SLL2OverlayNh_default_instance_);
}
inline ::service_layer::SLL2OverlayNh* SLL2RouteNh::mutable_nhoverlay() {
  if (!has_nhoverlay()) {
    clear_NhData();
    set_has_nhoverlay();
    NhData_.nhoverlay_ = new ::service_layer::SLL2OverlayNh;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNh.NhOverlay)
  return NhData_.nhoverlay_;
}

inline bool SLL2RouteNh::has_NhData() const {
  return NhData_case() != NHDATA_NOT_SET;
}
inline void SLL2RouteNh::clear_has_NhData() {
  _oneof_case_[0] = NHDATA_NOT_SET;
}
inline SLL2RouteNh::NhDataCase SLL2RouteNh::NhData_case() const {
  return SLL2RouteNh::NhDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2OverlayNh

// .service_layer.SLIpAddress OverlayNhIp = 1;
inline bool SLL2OverlayNh::has_overlaynhip() const {
  return this != internal_default_instance() && overlaynhip_ != NULL;
}
inline const ::service_layer::SLIpAddress& SLL2OverlayNh::overlaynhip() const {
  const ::service_layer::SLIpAddress* p = overlaynhip_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhIp)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLIpAddress*>(
      &::service_layer::_SLIpAddress_default_instance_);
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::release_overlaynhip() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2OverlayNh.OverlayNhIp)
  
  ::service_layer::SLIpAddress* temp = overlaynhip_;
  overlaynhip_ = NULL;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2OverlayNh::mutable_overlaynhip() {
  
  if (overlaynhip_ == NULL) {
    overlaynhip_ = new ::service_layer::SLIpAddress;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2OverlayNh.OverlayNhIp)
  return overlaynhip_;
}
inline void SLL2OverlayNh::set_allocated_overlaynhip(::service_layer::SLIpAddress* overlaynhip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(overlaynhip_);
  }
  if (overlaynhip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      overlaynhip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overlaynhip, submessage_arena);
    }
    
  } else {
    
  }
  overlaynhip_ = overlaynhip;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2OverlayNh.OverlayNhIp)
}

// .service_layer.SLEncapType OverlayNhEncap = 2;
inline void SLL2OverlayNh::clear_overlaynhencap() {
  overlaynhencap_ = 0;
}
inline ::service_layer::SLEncapType SLL2OverlayNh::overlaynhencap() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhEncap)
  return static_cast< ::service_layer::SLEncapType >(overlaynhencap_);
}
inline void SLL2OverlayNh::set_overlaynhencap(::service_layer::SLEncapType value) {
  
  overlaynhencap_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhEncap)
}

// uint32 OverlayNhLabel = 3;
inline void SLL2OverlayNh::clear_overlaynhlabel() {
  overlaynhlabel_ = 0u;
}
inline ::google::protobuf::uint32 SLL2OverlayNh::overlaynhlabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhLabel)
  return overlaynhlabel_;
}
inline void SLL2OverlayNh::set_overlaynhlabel(::google::protobuf::uint32 value) {
  
  overlaynhlabel_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhLabel)
}

// repeated uint32 OverlayNhL3Label = 4;
inline int SLL2OverlayNh::overlaynhl3label_size() const {
  return overlaynhl3label_.size();
}
inline void SLL2OverlayNh::clear_overlaynhl3label() {
  overlaynhl3label_.Clear();
}
inline ::google::protobuf::uint32 SLL2OverlayNh::overlaynhl3label(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return overlaynhl3label_.Get(index);
}
inline void SLL2OverlayNh::set_overlaynhl3label(int index, ::google::protobuf::uint32 value) {
  overlaynhl3label_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhL3Label)
}
inline void SLL2OverlayNh::add_overlaynhl3label(::google::protobuf::uint32 value) {
  overlaynhl3label_.Add(value);
  // @@protoc_insertion_point(field_add:service_layer.SLL2OverlayNh.OverlayNhL3Label)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SLL2OverlayNh::overlaynhl3label() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return overlaynhl3label_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SLL2OverlayNh::mutable_overlaynhl3label() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2OverlayNh.OverlayNhL3Label)
  return &overlaynhl3label_;
}

// bytes OverlayNhRouterMac = 5;
inline void SLL2OverlayNh::clear_overlaynhroutermac() {
  overlaynhroutermac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2OverlayNh::overlaynhroutermac() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  return overlaynhroutermac_.GetNoArena();
}
inline void SLL2OverlayNh::set_overlaynhroutermac(const ::std::string& value) {
  
  overlaynhroutermac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}
#if LANG_CXX11
inline void SLL2OverlayNh::set_overlaynhroutermac(::std::string&& value) {
  
  overlaynhroutermac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}
#endif
inline void SLL2OverlayNh::set_overlaynhroutermac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  overlaynhroutermac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}
inline void SLL2OverlayNh::set_overlaynhroutermac(const void* value, size_t size) {
  
  overlaynhroutermac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}
inline ::std::string* SLL2OverlayNh::mutable_overlaynhroutermac() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  return overlaynhroutermac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2OverlayNh::release_overlaynhroutermac() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
  
  return overlaynhroutermac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2OverlayNh::set_allocated_overlaynhroutermac(::std::string* overlaynhroutermac) {
  if (overlaynhroutermac != NULL) {
    
  } else {
    
  }
  overlaynhroutermac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), overlaynhroutermac);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2OverlayNh.OverlayNhRouterMac)
}

// -------------------------------------------------------------------

// SLL2MacRouteKey

// bytes MacAddress = 1;
inline void SLL2MacRouteKey::clear_macaddress() {
  macaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2MacRouteKey::macaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRouteKey.MacAddress)
  return macaddress_.GetNoArena();
}
inline void SLL2MacRouteKey::set_macaddress(const ::std::string& value) {
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2MacRouteKey.MacAddress)
}
#if LANG_CXX11
inline void SLL2MacRouteKey::set_macaddress(::std::string&& value) {
  
  macaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2MacRouteKey.MacAddress)
}
#endif
inline void SLL2MacRouteKey::set_macaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2MacRouteKey.MacAddress)
}
inline void SLL2MacRouteKey::set_macaddress(const void* value, size_t size) {
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2MacRouteKey.MacAddress)
}
inline ::std::string* SLL2MacRouteKey::mutable_macaddress() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRouteKey.MacAddress)
  return macaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2MacRouteKey::release_macaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRouteKey.MacAddress)
  
  return macaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2MacRouteKey::set_allocated_macaddress(::std::string* macaddress) {
  if (macaddress != NULL) {
    
  } else {
    
  }
  macaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macaddress);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRouteKey.MacAddress)
}

// .service_layer.SLIpAddress IpAddress = 2;
inline bool SLL2MacRouteKey::has_ipaddress() const {
  return this != internal_default_instance() && ipaddress_ != NULL;
}
inline const ::service_layer::SLIpAddress& SLL2MacRouteKey::ipaddress() const {
  const ::service_layer::SLIpAddress* p = ipaddress_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRouteKey.IpAddress)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLIpAddress*>(
      &::service_layer::_SLIpAddress_default_instance_);
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::release_ipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRouteKey.IpAddress)
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = NULL;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2MacRouteKey::mutable_ipaddress() {
  
  if (ipaddress_ == NULL) {
    ipaddress_ = new ::service_layer::SLIpAddress;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRouteKey.IpAddress)
  return ipaddress_;
}
inline void SLL2MacRouteKey::set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ipaddress_);
  }
  if (ipaddress) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ipaddress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ipaddress, submessage_arena);
    }
    
  } else {
    
  }
  ipaddress_ = ipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRouteKey.IpAddress)
}

// -------------------------------------------------------------------

// SLL2MacRoute

// .service_layer.SLL2MacRouteKey RouteKey = 1;
inline bool SLL2MacRoute::has_routekey() const {
  return this != internal_default_instance() && routekey_ != NULL;
}
inline void SLL2MacRoute::clear_routekey() {
  if (GetArenaNoVirtual() == NULL && routekey_ != NULL) {
    delete routekey_;
  }
  routekey_ = NULL;
}
inline const ::service_layer::SLL2MacRouteKey& SLL2MacRoute::routekey() const {
  const ::service_layer::SLL2MacRouteKey* p = routekey_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.RouteKey)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLL2MacRouteKey*>(
      &::service_layer::_SLL2MacRouteKey_default_instance_);
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRoute.RouteKey)
  
  ::service_layer::SLL2MacRouteKey* temp = routekey_;
  routekey_ = NULL;
  return temp;
}
inline ::service_layer::SLL2MacRouteKey* SLL2MacRoute::mutable_routekey() {
  
  if (routekey_ == NULL) {
    routekey_ = new ::service_layer::SLL2MacRouteKey;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.RouteKey)
  return routekey_;
}
inline void SLL2MacRoute::set_allocated_routekey(::service_layer::SLL2MacRouteKey* routekey) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routekey_;
  }
  if (routekey) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routekey = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRoute.RouteKey)
}

// uint32 SequenceNum = 2;
inline void SLL2MacRoute::clear_sequencenum() {
  sequencenum_ = 0u;
}
inline ::google::protobuf::uint32 SLL2MacRoute::sequencenum() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.SequenceNum)
  return sequencenum_;
}
inline void SLL2MacRoute::set_sequencenum(::google::protobuf::uint32 value) {
  
  sequencenum_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2MacRoute.SequenceNum)
}

// .service_layer.SLL2RouteEsi MacEsi = 3;
inline bool SLL2MacRoute::has_macesi() const {
  return this != internal_default_instance() && macesi_ != NULL;
}
inline void SLL2MacRoute::clear_macesi() {
  if (GetArenaNoVirtual() == NULL && macesi_ != NULL) {
    delete macesi_;
  }
  macesi_ = NULL;
}
inline const ::service_layer::SLL2RouteEsi& SLL2MacRoute::macesi() const {
  const ::service_layer::SLL2RouteEsi* p = macesi_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.MacEsi)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLL2RouteEsi*>(
      &::service_layer::_SLL2RouteEsi_default_instance_);
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::release_macesi() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2MacRoute.MacEsi)
  
  ::service_layer::SLL2RouteEsi* temp = macesi_;
  macesi_ = NULL;
  return temp;
}
inline ::service_layer::SLL2RouteEsi* SLL2MacRoute::mutable_macesi() {
  
  if (macesi_ == NULL) {
    macesi_ = new ::service_layer::SLL2RouteEsi;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.MacEsi)
  return macesi_;
}
inline void SLL2MacRoute::set_allocated_macesi(::service_layer::SLL2RouteEsi* macesi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete macesi_;
  }
  if (macesi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      macesi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, macesi, submessage_arena);
    }
    
  } else {
    
  }
  macesi_ = macesi;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2MacRoute.MacEsi)
}

// repeated .service_layer.SLL2RouteNh NextHopList = 4;
inline int SLL2MacRoute::nexthoplist_size() const {
  return nexthoplist_.size();
}
inline void SLL2MacRoute::clear_nexthoplist() {
  nexthoplist_.Clear();
}
inline const ::service_layer::SLL2RouteNh& SLL2MacRoute::nexthoplist(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_.Get(index);
}
inline ::service_layer::SLL2RouteNh* SLL2MacRoute::mutable_nexthoplist(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_.Mutable(index);
}
inline ::service_layer::SLL2RouteNh* SLL2MacRoute::add_nexthoplist() {
  // @@protoc_insertion_point(field_add:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteNh >*
SLL2MacRoute::mutable_nexthoplist() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2MacRoute.NextHopList)
  return &nexthoplist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteNh >&
SLL2MacRoute::nexthoplist() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2MacRoute.NextHopList)
  return nexthoplist_;
}

// -------------------------------------------------------------------

// SLL2ImetRouteKey

// uint32 EthTagId = 1;
inline void SLL2ImetRouteKey::clear_ethtagid() {
  ethtagid_ = 0u;
}
inline ::google::protobuf::uint32 SLL2ImetRouteKey::ethtagid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRouteKey.EthTagId)
  return ethtagid_;
}
inline void SLL2ImetRouteKey::set_ethtagid(::google::protobuf::uint32 value) {
  
  ethtagid_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRouteKey.EthTagId)
}

// .service_layer.SLIpAddress IpAddress = 2;
inline bool SLL2ImetRouteKey::has_ipaddress() const {
  return this != internal_default_instance() && ipaddress_ != NULL;
}
inline const ::service_layer::SLIpAddress& SLL2ImetRouteKey::ipaddress() const {
  const ::service_layer::SLIpAddress* p = ipaddress_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRouteKey.IpAddress)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLIpAddress*>(
      &::service_layer::_SLIpAddress_default_instance_);
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::release_ipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRouteKey.IpAddress)
  
  ::service_layer::SLIpAddress* temp = ipaddress_;
  ipaddress_ = NULL;
  return temp;
}
inline ::service_layer::SLIpAddress* SLL2ImetRouteKey::mutable_ipaddress() {
  
  if (ipaddress_ == NULL) {
    ipaddress_ = new ::service_layer::SLIpAddress;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRouteKey.IpAddress)
  return ipaddress_;
}
inline void SLL2ImetRouteKey::set_allocated_ipaddress(::service_layer::SLIpAddress* ipaddress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ipaddress_);
  }
  if (ipaddress) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ipaddress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ipaddress, submessage_arena);
    }
    
  } else {
    
  }
  ipaddress_ = ipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRouteKey.IpAddress)
}

// -------------------------------------------------------------------

// SLL2ImetRoute

// .service_layer.SLL2ImetRouteKey RouteKey = 1;
inline bool SLL2ImetRoute::has_routekey() const {
  return this != internal_default_instance() && routekey_ != NULL;
}
inline void SLL2ImetRoute::clear_routekey() {
  if (GetArenaNoVirtual() == NULL && routekey_ != NULL) {
    delete routekey_;
  }
  routekey_ = NULL;
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2ImetRoute::routekey() const {
  const ::service_layer::SLL2ImetRouteKey* p = routekey_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.RouteKey)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLL2ImetRouteKey*>(
      &::service_layer::_SLL2ImetRouteKey_default_instance_);
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRoute.RouteKey)
  
  ::service_layer::SLL2ImetRouteKey* temp = routekey_;
  routekey_ = NULL;
  return temp;
}
inline ::service_layer::SLL2ImetRouteKey* SLL2ImetRoute::mutable_routekey() {
  
  if (routekey_ == NULL) {
    routekey_ = new ::service_layer::SLL2ImetRouteKey;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRoute.RouteKey)
  return routekey_;
}
inline void SLL2ImetRoute::set_allocated_routekey(::service_layer::SLL2ImetRouteKey* routekey) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routekey_;
  }
  if (routekey) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routekey = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRoute.RouteKey)
}

// .service_layer.SLEncapType EncapType = 2;
inline void SLL2ImetRoute::clear_encaptype() {
  encaptype_ = 0;
}
inline ::service_layer::SLEncapType SLL2ImetRoute::encaptype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.EncapType)
  return static_cast< ::service_layer::SLEncapType >(encaptype_);
}
inline void SLL2ImetRoute::set_encaptype(::service_layer::SLEncapType value) {
  
  encaptype_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.EncapType)
}

// uint32 Label = 3;
inline void SLL2ImetRoute::clear_label() {
  label_ = 0u;
}
inline ::google::protobuf::uint32 SLL2ImetRoute::label() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.Label)
  return label_;
}
inline void SLL2ImetRoute::set_label(::google::protobuf::uint32 value) {
  
  label_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.Label)
}

// .service_layer.SLL2ImetRoute.PMSITunnelType TunnelType = 4;
inline void SLL2ImetRoute::clear_tunneltype() {
  tunneltype_ = 0;
}
inline ::service_layer::SLL2ImetRoute_PMSITunnelType SLL2ImetRoute::tunneltype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelType)
  return static_cast< ::service_layer::SLL2ImetRoute_PMSITunnelType >(tunneltype_);
}
inline void SLL2ImetRoute::set_tunneltype(::service_layer::SLL2ImetRoute_PMSITunnelType value) {
  
  tunneltype_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelType)
}

// uint32 TunnelIdLength = 5;
inline void SLL2ImetRoute::clear_tunnelidlength() {
  tunnelidlength_ = 0u;
}
inline ::google::protobuf::uint32 SLL2ImetRoute::tunnelidlength() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelIdLength)
  return tunnelidlength_;
}
inline void SLL2ImetRoute::set_tunnelidlength(::google::protobuf::uint32 value) {
  
  tunnelidlength_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelIdLength)
}

// bytes TunnelIdValue = 6;
inline void SLL2ImetRoute::clear_tunnelidvalue() {
  tunnelidvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2ImetRoute::tunnelidvalue() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2ImetRoute.TunnelIdValue)
  return tunnelidvalue_.GetNoArena();
}
inline void SLL2ImetRoute::set_tunnelidvalue(const ::std::string& value) {
  
  tunnelidvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2ImetRoute.TunnelIdValue)
}
#if LANG_CXX11
inline void SLL2ImetRoute::set_tunnelidvalue(::std::string&& value) {
  
  tunnelidvalue_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2ImetRoute.TunnelIdValue)
}
#endif
inline void SLL2ImetRoute::set_tunnelidvalue(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tunnelidvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2ImetRoute.TunnelIdValue)
}
inline void SLL2ImetRoute::set_tunnelidvalue(const void* value, size_t size) {
  
  tunnelidvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2ImetRoute.TunnelIdValue)
}
inline ::std::string* SLL2ImetRoute::mutable_tunnelidvalue() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2ImetRoute.TunnelIdValue)
  return tunnelidvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2ImetRoute::release_tunnelidvalue() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2ImetRoute.TunnelIdValue)
  
  return tunnelidvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2ImetRoute::set_allocated_tunnelidvalue(::std::string* tunnelidvalue) {
  if (tunnelidvalue != NULL) {
    
  } else {
    
  }
  tunnelidvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnelidvalue);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2ImetRoute.TunnelIdValue)
}

// -------------------------------------------------------------------

// SLL2RouteKey

// string BdName = 1;
inline void SLL2RouteKey::clear_bdname() {
  bdname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2RouteKey::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.BdName)
  return bdname_.GetNoArena();
}
inline void SLL2RouteKey::set_bdname(const ::std::string& value) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteKey.BdName)
}
#if LANG_CXX11
inline void SLL2RouteKey::set_bdname(::std::string&& value) {
  
  bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2RouteKey.BdName)
}
#endif
inline void SLL2RouteKey::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2RouteKey.BdName)
}
inline void SLL2RouteKey::set_bdname(const char* value, size_t size) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2RouteKey.BdName)
}
inline ::std::string* SLL2RouteKey::mutable_bdname() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.BdName)
  return bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2RouteKey::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.BdName)
  
  return bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2RouteKey::set_allocated_bdname(::std::string* bdname) {
  if (bdname != NULL) {
    
  } else {
    
  }
  bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bdname);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteKey.BdName)
}

// .service_layer.SLL2RouteType Type = 2;
inline void SLL2RouteKey::clear_type() {
  type_ = 0;
}
inline ::service_layer::SLL2RouteType SLL2RouteKey::type() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.Type)
  return static_cast< ::service_layer::SLL2RouteType >(type_);
}
inline void SLL2RouteKey::set_type(::service_layer::SLL2RouteType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteKey.Type)
}

// .service_layer.SLL2MacRouteKey MacKey = 3;
inline bool SLL2RouteKey::has_mackey() const {
  return Event_case() == kMacKey;
}
inline void SLL2RouteKey::set_has_mackey() {
  _oneof_case_[0] = kMacKey;
}
inline void SLL2RouteKey::clear_mackey() {
  if (has_mackey()) {
    delete Event_.mackey_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::release_mackey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.MacKey)
  if (has_mackey()) {
    clear_has_Event();
      ::service_layer::SLL2MacRouteKey* temp = Event_.mackey_;
    Event_.mackey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2MacRouteKey& SLL2RouteKey::mackey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.MacKey)
  return has_mackey()
      ? *Event_.mackey_
      : *reinterpret_cast< ::service_layer::SLL2MacRouteKey*>(&::service_layer::_SLL2MacRouteKey_default_instance_);
}
inline ::service_layer::SLL2MacRouteKey* SLL2RouteKey::mutable_mackey() {
  if (!has_mackey()) {
    clear_Event();
    set_has_mackey();
    Event_.mackey_ = new ::service_layer::SLL2MacRouteKey;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.MacKey)
  return Event_.mackey_;
}

// .service_layer.SLL2ImetRouteKey ImetKey = 4;
inline bool SLL2RouteKey::has_imetkey() const {
  return Event_case() == kImetKey;
}
inline void SLL2RouteKey::set_has_imetkey() {
  _oneof_case_[0] = kImetKey;
}
inline void SLL2RouteKey::clear_imetkey() {
  if (has_imetkey()) {
    delete Event_.imetkey_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::release_imetkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteKey.ImetKey)
  if (has_imetkey()) {
    clear_has_Event();
      ::service_layer::SLL2ImetRouteKey* temp = Event_.imetkey_;
    Event_.imetkey_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2ImetRouteKey& SLL2RouteKey::imetkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteKey.ImetKey)
  return has_imetkey()
      ? *Event_.imetkey_
      : *reinterpret_cast< ::service_layer::SLL2ImetRouteKey*>(&::service_layer::_SLL2ImetRouteKey_default_instance_);
}
inline ::service_layer::SLL2ImetRouteKey* SLL2RouteKey::mutable_imetkey() {
  if (!has_imetkey()) {
    clear_Event();
    set_has_imetkey();
    Event_.imetkey_ = new ::service_layer::SLL2ImetRouteKey;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteKey.ImetKey)
  return Event_.imetkey_;
}

inline bool SLL2RouteKey::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2RouteKey::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2RouteKey::EventCase SLL2RouteKey::Event_case() const {
  return SLL2RouteKey::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2Route

// string BdName = 1;
inline void SLL2Route::clear_bdname() {
  bdname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2Route::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.BdName)
  return bdname_.GetNoArena();
}
inline void SLL2Route::set_bdname(const ::std::string& value) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2Route.BdName)
}
#if LANG_CXX11
inline void SLL2Route::set_bdname(::std::string&& value) {
  
  bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2Route.BdName)
}
#endif
inline void SLL2Route::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2Route.BdName)
}
inline void SLL2Route::set_bdname(const char* value, size_t size) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2Route.BdName)
}
inline ::std::string* SLL2Route::mutable_bdname() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.BdName)
  return bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2Route::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.BdName)
  
  return bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2Route::set_allocated_bdname(::std::string* bdname) {
  if (bdname != NULL) {
    
  } else {
    
  }
  bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bdname);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2Route.BdName)
}

// .service_layer.SLL2RouteType Type = 2;
inline void SLL2Route::clear_type() {
  type_ = 0;
}
inline ::service_layer::SLL2RouteType SLL2Route::type() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.Type)
  return static_cast< ::service_layer::SLL2RouteType >(type_);
}
inline void SLL2Route::set_type(::service_layer::SLL2RouteType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2Route.Type)
}

// .service_layer.SLL2MacRoute MacRoute = 3;
inline bool SLL2Route::has_macroute() const {
  return Event_case() == kMacRoute;
}
inline void SLL2Route::set_has_macroute() {
  _oneof_case_[0] = kMacRoute;
}
inline void SLL2Route::clear_macroute() {
  if (has_macroute()) {
    delete Event_.macroute_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2MacRoute* SLL2Route::release_macroute() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.MacRoute)
  if (has_macroute()) {
    clear_has_Event();
      ::service_layer::SLL2MacRoute* temp = Event_.macroute_;
    Event_.macroute_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2MacRoute& SLL2Route::macroute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.MacRoute)
  return has_macroute()
      ? *Event_.macroute_
      : *reinterpret_cast< ::service_layer::SLL2MacRoute*>(&::service_layer::_SLL2MacRoute_default_instance_);
}
inline ::service_layer::SLL2MacRoute* SLL2Route::mutable_macroute() {
  if (!has_macroute()) {
    clear_Event();
    set_has_macroute();
    Event_.macroute_ = new ::service_layer::SLL2MacRoute;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.MacRoute)
  return Event_.macroute_;
}

// .service_layer.SLL2ImetRoute ImetRoute = 4;
inline bool SLL2Route::has_imetroute() const {
  return Event_case() == kImetRoute;
}
inline void SLL2Route::set_has_imetroute() {
  _oneof_case_[0] = kImetRoute;
}
inline void SLL2Route::clear_imetroute() {
  if (has_imetroute()) {
    delete Event_.imetroute_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::release_imetroute() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Route.ImetRoute)
  if (has_imetroute()) {
    clear_has_Event();
      ::service_layer::SLL2ImetRoute* temp = Event_.imetroute_;
    Event_.imetroute_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2ImetRoute& SLL2Route::imetroute() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Route.ImetRoute)
  return has_imetroute()
      ? *Event_.imetroute_
      : *reinterpret_cast< ::service_layer::SLL2ImetRoute*>(&::service_layer::_SLL2ImetRoute_default_instance_);
}
inline ::service_layer::SLL2ImetRoute* SLL2Route::mutable_imetroute() {
  if (!has_imetroute()) {
    clear_Event();
    set_has_imetroute();
    Event_.imetroute_ = new ::service_layer::SLL2ImetRoute;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Route.ImetRoute)
  return Event_.imetroute_;
}

inline bool SLL2Route::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2Route::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2Route::EventCase SLL2Route::Event_case() const {
  return SLL2Route::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2RouteMsg

// uint64 Correlator = 1;
inline void SLL2RouteMsg::clear_correlator() {
  correlator_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SLL2RouteMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Correlator)
  return correlator_;
}
inline void SLL2RouteMsg::set_correlator(::google::protobuf::uint64 value) {
  
  correlator_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsg.Correlator)
}

// .service_layer.SLObjectOp Oper = 2;
inline void SLL2RouteMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLL2RouteMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Oper)
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline void SLL2RouteMsg::set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsg.Oper)
}

// repeated .service_layer.SLL2Route Routes = 3;
inline int SLL2RouteMsg::routes_size() const {
  return routes_.size();
}
inline void SLL2RouteMsg::clear_routes() {
  routes_.Clear();
}
inline const ::service_layer::SLL2Route& SLL2RouteMsg::routes(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsg.Routes)
  return routes_.Get(index);
}
inline ::service_layer::SLL2Route* SLL2RouteMsg::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsg.Routes)
  return routes_.Mutable(index);
}
inline ::service_layer::SLL2Route* SLL2RouteMsg::add_routes() {
  // @@protoc_insertion_point(field_add:service_layer.SLL2RouteMsg.Routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2Route >*
SLL2RouteMsg::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2RouteMsg.Routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2Route >&
SLL2RouteMsg::routes() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2RouteMsg.Routes)
  return routes_;
}

// -------------------------------------------------------------------

// SLL2RouteRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLL2RouteRes::has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2RouteRes::errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteRes.ErrStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteRes::mutable_errstatus() {
  
  if (errstatus_ == NULL) {
    errstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteRes.ErrStatus)
  return errstatus_;
}
inline void SLL2RouteRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteRes.ErrStatus)
}

// .service_layer.SLL2RouteKey RouteKey = 2;
inline bool SLL2RouteRes::has_routekey() const {
  return this != internal_default_instance() && routekey_ != NULL;
}
inline void SLL2RouteRes::clear_routekey() {
  if (GetArenaNoVirtual() == NULL && routekey_ != NULL) {
    delete routekey_;
  }
  routekey_ = NULL;
}
inline const ::service_layer::SLL2RouteKey& SLL2RouteRes::routekey() const {
  const ::service_layer::SLL2RouteKey* p = routekey_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteRes.RouteKey)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLL2RouteKey*>(
      &::service_layer::_SLL2RouteKey_default_instance_);
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::release_routekey() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteRes.RouteKey)
  
  ::service_layer::SLL2RouteKey* temp = routekey_;
  routekey_ = NULL;
  return temp;
}
inline ::service_layer::SLL2RouteKey* SLL2RouteRes::mutable_routekey() {
  
  if (routekey_ == NULL) {
    routekey_ = new ::service_layer::SLL2RouteKey;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteRes.RouteKey)
  return routekey_;
}
inline void SLL2RouteRes::set_allocated_routekey(::service_layer::SLL2RouteKey* routekey) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routekey_;
  }
  if (routekey) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routekey = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routekey, submessage_arena);
    }
    
  } else {
    
  }
  routekey_ = routekey;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteRes.RouteKey)
}

// -------------------------------------------------------------------

// SLL2RouteMsgRsp

// uint64 Correlator = 1;
inline void SLL2RouteMsgRsp::clear_correlator() {
  correlator_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SLL2RouteMsgRsp::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.Correlator)
  return correlator_;
}
inline void SLL2RouteMsgRsp::set_correlator(::google::protobuf::uint64 value) {
  
  correlator_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteMsgRsp.Correlator)
}

// .service_layer.SLErrorStatus StatusSummary = 2;
inline bool SLL2RouteMsgRsp::has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2RouteMsgRsp::statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.StatusSummary)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2RouteMsgRsp::mutable_statussummary() {
  
  if (statussummary_ == NULL) {
    statussummary_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsgRsp.StatusSummary)
  return statussummary_;
}
inline void SLL2RouteMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      statussummary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteMsgRsp.StatusSummary)
}

// repeated .service_layer.SLL2RouteRes Results = 3;
inline int SLL2RouteMsgRsp::results_size() const {
  return results_.size();
}
inline void SLL2RouteMsgRsp::clear_results() {
  results_.Clear();
}
inline const ::service_layer::SLL2RouteRes& SLL2RouteMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteMsgRsp.Results)
  return results_.Get(index);
}
inline ::service_layer::SLL2RouteRes* SLL2RouteMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::service_layer::SLL2RouteRes* SLL2RouteMsgRsp::add_results() {
  // @@protoc_insertion_point(field_add:service_layer.SLL2RouteMsgRsp.Results)
  return results_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteRes >*
SLL2RouteMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLL2RouteMsgRsp.Results)
  return &results_;
}
inline const ::google::protobuf::RepeatedPtrField< ::service_layer::SLL2RouteRes >&
SLL2RouteMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLL2RouteMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLL2GetNotifMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLL2GetNotifMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLL2GetNotifMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.Oper)
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline void SLL2GetNotifMsg::set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.Oper)
}

// uint64 Correlator = 2;
inline void SLL2GetNotifMsg::clear_correlator() {
  correlator_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SLL2GetNotifMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.Correlator)
  return correlator_;
}
inline void SLL2GetNotifMsg::set_correlator(::google::protobuf::uint64 value) {
  
  correlator_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.Correlator)
}

// bool GetNotifEof = 3;
inline void SLL2GetNotifMsg::clear_getnotifeof() {
  getnotifeof_ = false;
}
inline bool SLL2GetNotifMsg::getnotifeof() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.GetNotifEof)
  return getnotifeof_;
}
inline void SLL2GetNotifMsg::set_getnotifeof(bool value) {
  
  getnotifeof_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.GetNotifEof)
}

// bool BdAll = 4;
inline bool SLL2GetNotifMsg::has_bdall() const {
  return Request_case() == kBdAll;
}
inline void SLL2GetNotifMsg::set_has_bdall() {
  _oneof_case_[0] = kBdAll;
}
inline void SLL2GetNotifMsg::clear_bdall() {
  if (has_bdall()) {
    Request_.bdall_ = false;
    clear_has_Request();
  }
}
inline bool SLL2GetNotifMsg::bdall() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.BdAll)
  if (has_bdall()) {
    return Request_.bdall_;
  }
  return false;
}
inline void SLL2GetNotifMsg::set_bdall(bool value) {
  if (!has_bdall()) {
    clear_Request();
    set_has_bdall();
  }
  Request_.bdall_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdAll)
}

// string BdName = 5;
inline bool SLL2GetNotifMsg::has_bdname() const {
  return Request_case() == kBdName;
}
inline void SLL2GetNotifMsg::set_has_bdname() {
  _oneof_case_[0] = kBdName;
}
inline void SLL2GetNotifMsg::clear_bdname() {
  if (has_bdname()) {
    Request_.bdname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Request();
  }
}
inline const ::std::string& SLL2GetNotifMsg::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2GetNotifMsg.BdName)
  if (has_bdname()) {
    return Request_.bdname_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SLL2GetNotifMsg::set_bdname(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdName)
  if (!has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdName)
}
#if LANG_CXX11
inline void SLL2GetNotifMsg::set_bdname(::std::string&& value) {
  // @@protoc_insertion_point(field_set:service_layer.SLL2GetNotifMsg.BdName)
  if (!has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2GetNotifMsg.BdName)
}
#endif
inline void SLL2GetNotifMsg::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2GetNotifMsg.BdName)
}
inline void SLL2GetNotifMsg::set_bdname(const char* value, size_t size) {
  if (!has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Request_.bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2GetNotifMsg.BdName)
}
inline ::std::string* SLL2GetNotifMsg::mutable_bdname() {
  if (!has_bdname()) {
    clear_Request();
    set_has_bdname();
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2GetNotifMsg.BdName)
  return Request_.bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2GetNotifMsg::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2GetNotifMsg.BdName)
  if (has_bdname()) {
    clear_has_Request();
    return Request_.bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void SLL2GetNotifMsg::set_allocated_bdname(::std::string* bdname) {
  if (!has_bdname()) {
    Request_.bdname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Request();
  if (bdname != NULL) {
    set_has_bdname();
    Request_.bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        bdname);
  }
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2GetNotifMsg.BdName)
}

inline bool SLL2GetNotifMsg::has_Request() const {
  return Request_case() != REQUEST_NOT_SET;
}
inline void SLL2GetNotifMsg::clear_has_Request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline SLL2GetNotifMsg::RequestCase SLL2GetNotifMsg::Request_case() const {
  return SLL2GetNotifMsg::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLL2RouteNotif

// .service_layer.SLObjectOp Oper = 1;
inline void SLL2RouteNotif::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLObjectOp SLL2RouteNotif::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNotif.Oper)
  return static_cast< ::service_layer::SLObjectOp >(oper_);
}
inline void SLL2RouteNotif::set_oper(::service_layer::SLObjectOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2RouteNotif.Oper)
}

// .service_layer.SLL2Route Routes = 2;
inline bool SLL2RouteNotif::has_routes() const {
  return this != internal_default_instance() && routes_ != NULL;
}
inline void SLL2RouteNotif::clear_routes() {
  if (GetArenaNoVirtual() == NULL && routes_ != NULL) {
    delete routes_;
  }
  routes_ = NULL;
}
inline const ::service_layer::SLL2Route& SLL2RouteNotif::routes() const {
  const ::service_layer::SLL2Route* p = routes_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2RouteNotif.Routes)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLL2Route*>(
      &::service_layer::_SLL2Route_default_instance_);
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::release_routes() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2RouteNotif.Routes)
  
  ::service_layer::SLL2Route* temp = routes_;
  routes_ = NULL;
  return temp;
}
inline ::service_layer::SLL2Route* SLL2RouteNotif::mutable_routes() {
  
  if (routes_ == NULL) {
    routes_ = new ::service_layer::SLL2Route;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2RouteNotif.Routes)
  return routes_;
}
inline void SLL2RouteNotif::set_allocated_routes(::service_layer::SLL2Route* routes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routes_;
  }
  if (routes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    
  } else {
    
  }
  routes_ = routes;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2RouteNotif.Routes)
}

// -------------------------------------------------------------------

// SLL2BdStateInfo

// string BdName = 1;
inline void SLL2BdStateInfo::clear_bdname() {
  bdname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2BdStateInfo::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdStateInfo.BdName)
  return bdname_.GetNoArena();
}
inline void SLL2BdStateInfo::set_bdname(const ::std::string& value) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdStateInfo.BdName)
}
#if LANG_CXX11
inline void SLL2BdStateInfo::set_bdname(::std::string&& value) {
  
  bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2BdStateInfo.BdName)
}
#endif
inline void SLL2BdStateInfo::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2BdStateInfo.BdName)
}
inline void SLL2BdStateInfo::set_bdname(const char* value, size_t size) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2BdStateInfo.BdName)
}
inline ::std::string* SLL2BdStateInfo::mutable_bdname() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2BdStateInfo.BdName)
  return bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2BdStateInfo::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2BdStateInfo.BdName)
  
  return bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2BdStateInfo::set_allocated_bdname(::std::string* bdname) {
  if (bdname != NULL) {
    
  } else {
    
  }
  bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bdname);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2BdStateInfo.BdName)
}

// .service_layer.SLL2BdStateInfo.SLL2BdState BdState = 2;
inline void SLL2BdStateInfo::clear_bdstate() {
  bdstate_ = 0;
}
inline ::service_layer::SLL2BdStateInfo_SLL2BdState SLL2BdStateInfo::bdstate() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2BdStateInfo.BdState)
  return static_cast< ::service_layer::SLL2BdStateInfo_SLL2BdState >(bdstate_);
}
inline void SLL2BdStateInfo::set_bdstate(::service_layer::SLL2BdStateInfo_SLL2BdState value) {
  
  bdstate_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2BdStateInfo.BdState)
}

// -------------------------------------------------------------------

// SLL2NotifStatusMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLL2NotifStatusMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLL2NotifStatusMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.Oper)
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline void SLL2NotifStatusMsg::set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.Oper)
}

// uint64 Correlator = 2;
inline void SLL2NotifStatusMsg::clear_correlator() {
  correlator_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SLL2NotifStatusMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.Correlator)
  return correlator_;
}
inline void SLL2NotifStatusMsg::set_correlator(::google::protobuf::uint64 value) {
  
  correlator_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.Correlator)
}

// string BdName = 3;
inline void SLL2NotifStatusMsg::clear_bdname() {
  bdname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SLL2NotifStatusMsg::bdname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.BdName)
  return bdname_.GetNoArena();
}
inline void SLL2NotifStatusMsg::set_bdname(const ::std::string& value) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:service_layer.SLL2NotifStatusMsg.BdName)
}
#if LANG_CXX11
inline void SLL2NotifStatusMsg::set_bdname(::std::string&& value) {
  
  bdname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:service_layer.SLL2NotifStatusMsg.BdName)
}
#endif
inline void SLL2NotifStatusMsg::set_bdname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:service_layer.SLL2NotifStatusMsg.BdName)
}
inline void SLL2NotifStatusMsg::set_bdname(const char* value, size_t size) {
  
  bdname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:service_layer.SLL2NotifStatusMsg.BdName)
}
inline ::std::string* SLL2NotifStatusMsg::mutable_bdname() {
  
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2NotifStatusMsg.BdName)
  return bdname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SLL2NotifStatusMsg::release_bdname() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2NotifStatusMsg.BdName)
  
  return bdname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SLL2NotifStatusMsg::set_allocated_bdname(::std::string* bdname) {
  if (bdname != NULL) {
    
  } else {
    
  }
  bdname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bdname);
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2NotifStatusMsg.BdName)
}

// .service_layer.SLErrorStatus NotifStatus = 4;
inline bool SLL2NotifStatusMsg::has_notifstatus() const {
  return this != internal_default_instance() && notifstatus_ != NULL;
}
inline const ::service_layer::SLErrorStatus& SLL2NotifStatusMsg::notifstatus() const {
  const ::service_layer::SLErrorStatus* p = notifstatus_;
  // @@protoc_insertion_point(field_get:service_layer.SLL2NotifStatusMsg.NotifStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::service_layer::SLErrorStatus*>(
      &::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2NotifStatusMsg.NotifStatus)
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = NULL;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLL2NotifStatusMsg::mutable_notifstatus() {
  
  if (notifstatus_ == NULL) {
    notifstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2NotifStatusMsg.NotifStatus)
  return notifstatus_;
}
inline void SLL2NotifStatusMsg::set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(notifstatus_);
  }
  if (notifstatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      notifstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, notifstatus, submessage_arena);
    }
    
  } else {
    
  }
  notifstatus_ = notifstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLL2NotifStatusMsg.NotifStatus)
}

// -------------------------------------------------------------------

// SLL2Notif

// .service_layer.SLL2NotifType EventType = 1;
inline void SLL2Notif::clear_eventtype() {
  eventtype_ = 0;
}
inline ::service_layer::SLL2NotifType SLL2Notif::eventtype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.EventType)
  return static_cast< ::service_layer::SLL2NotifType >(eventtype_);
}
inline void SLL2Notif::set_eventtype(::service_layer::SLL2NotifType value) {
  
  eventtype_ = value;
  // @@protoc_insertion_point(field_set:service_layer.SLL2Notif.EventType)
}

// .service_layer.SLErrorStatus ErrStatus = 2;
inline bool SLL2Notif::has_errstatus() const {
  return Event_case() == kErrStatus;
}
inline void SLL2Notif::set_has_errstatus() {
  _oneof_case_[0] = kErrStatus;
}
inline ::service_layer::SLErrorStatus* SLL2Notif::release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.ErrStatus)
  if (has_errstatus()) {
    clear_has_Event();
      ::service_layer::SLErrorStatus* temp = Event_.errstatus_;
    Event_.errstatus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLErrorStatus& SLL2Notif::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.ErrStatus)
  return has_errstatus()
      ? *Event_.errstatus_
      : *reinterpret_cast< ::service_layer::SLErrorStatus*>(&::service_layer::_SLErrorStatus_default_instance_);
}
inline ::service_layer::SLErrorStatus* SLL2Notif::mutable_errstatus() {
  if (!has_errstatus()) {
    clear_Event();
    set_has_errstatus();
    Event_.errstatus_ = new ::service_layer::SLErrorStatus;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.ErrStatus)
  return Event_.errstatus_;
}

// .service_layer.SLL2NotifStatusMsg NotifStatus = 3;
inline bool SLL2Notif::has_notifstatus() const {
  return Event_case() == kNotifStatus;
}
inline void SLL2Notif::set_has_notifstatus() {
  _oneof_case_[0] = kNotifStatus;
}
inline void SLL2Notif::clear_notifstatus() {
  if (has_notifstatus()) {
    delete Event_.notifstatus_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.NotifStatus)
  if (has_notifstatus()) {
    clear_has_Event();
      ::service_layer::SLL2NotifStatusMsg* temp = Event_.notifstatus_;
    Event_.notifstatus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2NotifStatusMsg& SLL2Notif::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.NotifStatus)
  return has_notifstatus()
      ? *Event_.notifstatus_
      : *reinterpret_cast< ::service_layer::SLL2NotifStatusMsg*>(&::service_layer::_SLL2NotifStatusMsg_default_instance_);
}
inline ::service_layer::SLL2NotifStatusMsg* SLL2Notif::mutable_notifstatus() {
  if (!has_notifstatus()) {
    clear_Event();
    set_has_notifstatus();
    Event_.notifstatus_ = new ::service_layer::SLL2NotifStatusMsg;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.NotifStatus)
  return Event_.notifstatus_;
}

// .service_layer.SLL2BdStateInfo BdStateInfo = 4;
inline bool SLL2Notif::has_bdstateinfo() const {
  return Event_case() == kBdStateInfo;
}
inline void SLL2Notif::set_has_bdstateinfo() {
  _oneof_case_[0] = kBdStateInfo;
}
inline void SLL2Notif::clear_bdstateinfo() {
  if (has_bdstateinfo()) {
    delete Event_.bdstateinfo_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::release_bdstateinfo() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.BdStateInfo)
  if (has_bdstateinfo()) {
    clear_has_Event();
      ::service_layer::SLL2BdStateInfo* temp = Event_.bdstateinfo_;
    Event_.bdstateinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2BdStateInfo& SLL2Notif::bdstateinfo() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.BdStateInfo)
  return has_bdstateinfo()
      ? *Event_.bdstateinfo_
      : *reinterpret_cast< ::service_layer::SLL2BdStateInfo*>(&::service_layer::_SLL2BdStateInfo_default_instance_);
}
inline ::service_layer::SLL2BdStateInfo* SLL2Notif::mutable_bdstateinfo() {
  if (!has_bdstateinfo()) {
    clear_Event();
    set_has_bdstateinfo();
    Event_.bdstateinfo_ = new ::service_layer::SLL2BdStateInfo;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.BdStateInfo)
  return Event_.bdstateinfo_;
}

// .service_layer.SLL2RouteNotif Route = 5;
inline bool SLL2Notif::has_route() const {
  return Event_case() == kRoute;
}
inline void SLL2Notif::set_has_route() {
  _oneof_case_[0] = kRoute;
}
inline void SLL2Notif::clear_route() {
  if (has_route()) {
    delete Event_.route_;
    clear_has_Event();
  }
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::release_route() {
  // @@protoc_insertion_point(field_release:service_layer.SLL2Notif.Route)
  if (has_route()) {
    clear_has_Event();
      ::service_layer::SLL2RouteNotif* temp = Event_.route_;
    Event_.route_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::service_layer::SLL2RouteNotif& SLL2Notif::route() const {
  // @@protoc_insertion_point(field_get:service_layer.SLL2Notif.Route)
  return has_route()
      ? *Event_.route_
      : *reinterpret_cast< ::service_layer::SLL2RouteNotif*>(&::service_layer::_SLL2RouteNotif_default_instance_);
}
inline ::service_layer::SLL2RouteNotif* SLL2Notif::mutable_route() {
  if (!has_route()) {
    clear_Event();
    set_has_route();
    Event_.route_ = new ::service_layer::SLL2RouteNotif;
  }
  // @@protoc_insertion_point(field_mutable:service_layer.SLL2Notif.Route)
  return Event_.route_;
}

inline bool SLL2Notif::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void SLL2Notif::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline SLL2Notif::EventCase SLL2Notif::Event_case() const {
  return SLL2Notif::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::service_layer::SLL2RouteNh_SLL2RouteNhType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2RouteNh_SLL2RouteNhType>() {
  return ::service_layer::SLL2RouteNh_SLL2RouteNhType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2ImetRoute_PMSITunnelType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2ImetRoute_PMSITunnelType>() {
  return ::service_layer::SLL2ImetRoute_PMSITunnelType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2BdStateInfo_SLL2BdState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2BdStateInfo_SLL2BdState>() {
  return ::service_layer::SLL2BdStateInfo_SLL2BdState_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2RouteType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2RouteType>() {
  return ::service_layer::SLL2RouteType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLL2NotifType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLL2NotifType>() {
  return ::service_layer::SLL2NotifType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sl_5fl2_5froute_2eproto__INCLUDED
