// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_policy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5fpolicy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5fpolicy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5fpolicy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5fpolicy_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5fpolicy_2eproto;
namespace service_layer {
class PolicyIntfList;
struct PolicyIntfListDefaultTypeInternal;
extern PolicyIntfListDefaultTypeInternal _PolicyIntfList_default_instance_;
class PolicyRuleList;
struct PolicyRuleListDefaultTypeInternal;
extern PolicyRuleListDefaultTypeInternal _PolicyRuleList_default_instance_;
class SLDscpMatch;
struct SLDscpMatchDefaultTypeInternal;
extern SLDscpMatchDefaultTypeInternal _SLDscpMatch_default_instance_;
class SLPolicyEntry;
struct SLPolicyEntryDefaultTypeInternal;
extern SLPolicyEntryDefaultTypeInternal _SLPolicyEntry_default_instance_;
class SLPolicyGetMsg;
struct SLPolicyGetMsgDefaultTypeInternal;
extern SLPolicyGetMsgDefaultTypeInternal _SLPolicyGetMsg_default_instance_;
class SLPolicyGetMsgRsp;
struct SLPolicyGetMsgRspDefaultTypeInternal;
extern SLPolicyGetMsgRspDefaultTypeInternal _SLPolicyGetMsgRsp_default_instance_;
class SLPolicyGlobalGetMsg;
struct SLPolicyGlobalGetMsgDefaultTypeInternal;
extern SLPolicyGlobalGetMsgDefaultTypeInternal _SLPolicyGlobalGetMsg_default_instance_;
class SLPolicyGlobalGetMsgRsp;
struct SLPolicyGlobalGetMsgRspDefaultTypeInternal;
extern SLPolicyGlobalGetMsgRspDefaultTypeInternal _SLPolicyGlobalGetMsgRsp_default_instance_;
class SLPolicyInfo;
struct SLPolicyInfoDefaultTypeInternal;
extern SLPolicyInfoDefaultTypeInternal _SLPolicyInfo_default_instance_;
class SLPolicyIntf;
struct SLPolicyIntfDefaultTypeInternal;
extern SLPolicyIntfDefaultTypeInternal _SLPolicyIntf_default_instance_;
class SLPolicyIntfStatus;
struct SLPolicyIntfStatusDefaultTypeInternal;
extern SLPolicyIntfStatusDefaultTypeInternal _SLPolicyIntfStatus_default_instance_;
class SLPolicyIntfStatusList;
struct SLPolicyIntfStatusListDefaultTypeInternal;
extern SLPolicyIntfStatusListDefaultTypeInternal _SLPolicyIntfStatusList_default_instance_;
class SLPolicyKey;
struct SLPolicyKeyDefaultTypeInternal;
extern SLPolicyKeyDefaultTypeInternal _SLPolicyKey_default_instance_;
class SLPolicyOpMsg;
struct SLPolicyOpMsgDefaultTypeInternal;
extern SLPolicyOpMsgDefaultTypeInternal _SLPolicyOpMsg_default_instance_;
class SLPolicyOpRsp;
struct SLPolicyOpRspDefaultTypeInternal;
extern SLPolicyOpRspDefaultTypeInternal _SLPolicyOpRsp_default_instance_;
class SLPolicyRes;
struct SLPolicyResDefaultTypeInternal;
extern SLPolicyResDefaultTypeInternal _SLPolicyRes_default_instance_;
class SLPolicyRule;
struct SLPolicyRuleDefaultTypeInternal;
extern SLPolicyRuleDefaultTypeInternal _SLPolicyRule_default_instance_;
class SLPolicyRuleStatus;
struct SLPolicyRuleStatusDefaultTypeInternal;
extern SLPolicyRuleStatusDefaultTypeInternal _SLPolicyRuleStatus_default_instance_;
class SLPolicyRuleStatusList;
struct SLPolicyRuleStatusListDefaultTypeInternal;
extern SLPolicyRuleStatusListDefaultTypeInternal _SLPolicyRuleStatusList_default_instance_;
class SLRuleAction;
struct SLRuleActionDefaultTypeInternal;
extern SLRuleActionDefaultTypeInternal _SLRuleAction_default_instance_;
class SLRuleMatch;
struct SLRuleMatchDefaultTypeInternal;
extern SLRuleMatchDefaultTypeInternal _SLRuleMatch_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::PolicyIntfList* Arena::CreateMaybeMessage<::service_layer::PolicyIntfList>(Arena*);
template<> ::service_layer::PolicyRuleList* Arena::CreateMaybeMessage<::service_layer::PolicyRuleList>(Arena*);
template<> ::service_layer::SLDscpMatch* Arena::CreateMaybeMessage<::service_layer::SLDscpMatch>(Arena*);
template<> ::service_layer::SLPolicyEntry* Arena::CreateMaybeMessage<::service_layer::SLPolicyEntry>(Arena*);
template<> ::service_layer::SLPolicyGetMsg* Arena::CreateMaybeMessage<::service_layer::SLPolicyGetMsg>(Arena*);
template<> ::service_layer::SLPolicyGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLPolicyGetMsgRsp>(Arena*);
template<> ::service_layer::SLPolicyGlobalGetMsg* Arena::CreateMaybeMessage<::service_layer::SLPolicyGlobalGetMsg>(Arena*);
template<> ::service_layer::SLPolicyGlobalGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLPolicyGlobalGetMsgRsp>(Arena*);
template<> ::service_layer::SLPolicyInfo* Arena::CreateMaybeMessage<::service_layer::SLPolicyInfo>(Arena*);
template<> ::service_layer::SLPolicyIntf* Arena::CreateMaybeMessage<::service_layer::SLPolicyIntf>(Arena*);
template<> ::service_layer::SLPolicyIntfStatus* Arena::CreateMaybeMessage<::service_layer::SLPolicyIntfStatus>(Arena*);
template<> ::service_layer::SLPolicyIntfStatusList* Arena::CreateMaybeMessage<::service_layer::SLPolicyIntfStatusList>(Arena*);
template<> ::service_layer::SLPolicyKey* Arena::CreateMaybeMessage<::service_layer::SLPolicyKey>(Arena*);
template<> ::service_layer::SLPolicyOpMsg* Arena::CreateMaybeMessage<::service_layer::SLPolicyOpMsg>(Arena*);
template<> ::service_layer::SLPolicyOpRsp* Arena::CreateMaybeMessage<::service_layer::SLPolicyOpRsp>(Arena*);
template<> ::service_layer::SLPolicyRes* Arena::CreateMaybeMessage<::service_layer::SLPolicyRes>(Arena*);
template<> ::service_layer::SLPolicyRule* Arena::CreateMaybeMessage<::service_layer::SLPolicyRule>(Arena*);
template<> ::service_layer::SLPolicyRuleStatus* Arena::CreateMaybeMessage<::service_layer::SLPolicyRuleStatus>(Arena*);
template<> ::service_layer::SLPolicyRuleStatusList* Arena::CreateMaybeMessage<::service_layer::SLPolicyRuleStatusList>(Arena*);
template<> ::service_layer::SLRuleAction* Arena::CreateMaybeMessage<::service_layer::SLRuleAction>(Arena*);
template<> ::service_layer::SLRuleMatch* Arena::CreateMaybeMessage<::service_layer::SLRuleMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

enum SLPolicyObjectOp : int {
  SL_OBJOP_POLICY_RESERVED = 0,
  SL_OBJOP_POLICY_ADD = 1,
  SL_OBJOP_POLICY_DELETE = 2,
  SL_OBJOP_RULE_ADD = 3,
  SL_OBJOP_RULE_DELETE = 4,
  SL_OBJOP_POLICY_APPLY = 5,
  SL_OBJOP_POLICY_UNAPPLY = 6,
  SLPolicyObjectOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLPolicyObjectOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLPolicyObjectOp_IsValid(int value);
constexpr SLPolicyObjectOp SLPolicyObjectOp_MIN = SL_OBJOP_POLICY_RESERVED;
constexpr SLPolicyObjectOp SLPolicyObjectOp_MAX = SL_OBJOP_POLICY_UNAPPLY;
constexpr int SLPolicyObjectOp_ARRAYSIZE = SLPolicyObjectOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLPolicyObjectOp_descriptor();
template<typename T>
inline const std::string& SLPolicyObjectOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLPolicyObjectOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLPolicyObjectOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLPolicyObjectOp_descriptor(), enum_t_value);
}
inline bool SLPolicyObjectOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLPolicyObjectOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLPolicyObjectOp>(
    SLPolicyObjectOp_descriptor(), name, value);
}
enum SLPolicyType : int {
  SL_PM_PTYPE_RESERVED = 0,
  SL_PM_PTYPE_PBR = 1,
  SLPolicyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLPolicyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLPolicyType_IsValid(int value);
constexpr SLPolicyType SLPolicyType_MIN = SL_PM_PTYPE_RESERVED;
constexpr SLPolicyType SLPolicyType_MAX = SL_PM_PTYPE_PBR;
constexpr int SLPolicyType_ARRAYSIZE = SLPolicyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLPolicyType_descriptor();
template<typename T>
inline const std::string& SLPolicyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLPolicyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLPolicyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLPolicyType_descriptor(), enum_t_value);
}
inline bool SLPolicyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLPolicyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLPolicyType>(
    SLPolicyType_descriptor(), name, value);
}
enum SLApplyDirection : int {
  SL_APPLY_TYPE_RESERVED = 0,
  SL_APPLY_DIRECTION_INGRESS = 1,
  SLApplyDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLApplyDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLApplyDirection_IsValid(int value);
constexpr SLApplyDirection SLApplyDirection_MIN = SL_APPLY_TYPE_RESERVED;
constexpr SLApplyDirection SLApplyDirection_MAX = SL_APPLY_DIRECTION_INGRESS;
constexpr int SLApplyDirection_ARRAYSIZE = SLApplyDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLApplyDirection_descriptor();
template<typename T>
inline const std::string& SLApplyDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLApplyDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLApplyDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLApplyDirection_descriptor(), enum_t_value);
}
inline bool SLApplyDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLApplyDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLApplyDirection>(
    SLApplyDirection_descriptor(), name, value);
}
// ===================================================================

class SLPolicyOpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyOpMsg) */ {
 public:
  inline SLPolicyOpMsg() : SLPolicyOpMsg(nullptr) {}
  ~SLPolicyOpMsg() override;
  explicit constexpr SLPolicyOpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyOpMsg(const SLPolicyOpMsg& from);
  SLPolicyOpMsg(SLPolicyOpMsg&& from) noexcept
    : SLPolicyOpMsg() {
    *this = ::std::move(from);
  }

  inline SLPolicyOpMsg& operator=(const SLPolicyOpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyOpMsg& operator=(SLPolicyOpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyOpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyOpMsg* internal_default_instance() {
    return reinterpret_cast<const SLPolicyOpMsg*>(
               &_SLPolicyOpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLPolicyOpMsg& a, SLPolicyOpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyOpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyOpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyOpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyOpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyOpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyOpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyOpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyOpMsg";
  }
  protected:
  explicit SLPolicyOpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoliciesFieldNumber = 3,
    kOperationIDFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyEntry Policies = 3;
  int policies_size() const;
  private:
  int _internal_policies_size() const;
  public:
  void clear_policies();
  ::service_layer::SLPolicyEntry* mutable_policies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyEntry >*
      mutable_policies();
  private:
  const ::service_layer::SLPolicyEntry& _internal_policies(int index) const;
  ::service_layer::SLPolicyEntry* _internal_add_policies();
  public:
  const ::service_layer::SLPolicyEntry& policies(int index) const;
  ::service_layer::SLPolicyEntry* add_policies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyEntry >&
      policies() const;

  // uint64 OperationID = 2;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // .service_layer.SLPolicyObjectOp Oper = 1;
  void clear_oper();
  ::service_layer::SLPolicyObjectOp oper() const;
  void set_oper(::service_layer::SLPolicyObjectOp value);
  private:
  ::service_layer::SLPolicyObjectOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLPolicyObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyOpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyEntry > policies_;
  uint64_t operationid_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyEntry) */ {
 public:
  inline SLPolicyEntry() : SLPolicyEntry(nullptr) {}
  ~SLPolicyEntry() override;
  explicit constexpr SLPolicyEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyEntry(const SLPolicyEntry& from);
  SLPolicyEntry(SLPolicyEntry&& from) noexcept
    : SLPolicyEntry() {
    *this = ::std::move(from);
  }

  inline SLPolicyEntry& operator=(const SLPolicyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyEntry& operator=(SLPolicyEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyEntry& default_instance() {
    return *internal_default_instance();
  }
  enum SLPolicyObjectListCase {
    kRules = 2,
    kIntfs = 3,
    SLPOLICYOBJECTLIST_NOT_SET = 0,
  };

  static inline const SLPolicyEntry* internal_default_instance() {
    return reinterpret_cast<const SLPolicyEntry*>(
               &_SLPolicyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLPolicyEntry& a, SLPolicyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyEntry";
  }
  protected:
  explicit SLPolicyEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kRulesFieldNumber = 2,
    kIntfsFieldNumber = 3,
  };
  // .service_layer.SLPolicyKey Key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLPolicyKey& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLPolicyKey* release_key();
  ::service_layer::SLPolicyKey* mutable_key();
  void set_allocated_key(::service_layer::SLPolicyKey* key);
  private:
  const ::service_layer::SLPolicyKey& _internal_key() const;
  ::service_layer::SLPolicyKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLPolicyKey* key);
  ::service_layer::SLPolicyKey* unsafe_arena_release_key();

  // .service_layer.PolicyRuleList Rules = 2;
  bool has_rules() const;
  private:
  bool _internal_has_rules() const;
  public:
  void clear_rules();
  const ::service_layer::PolicyRuleList& rules() const;
  PROTOBUF_NODISCARD ::service_layer::PolicyRuleList* release_rules();
  ::service_layer::PolicyRuleList* mutable_rules();
  void set_allocated_rules(::service_layer::PolicyRuleList* rules);
  private:
  const ::service_layer::PolicyRuleList& _internal_rules() const;
  ::service_layer::PolicyRuleList* _internal_mutable_rules();
  public:
  void unsafe_arena_set_allocated_rules(
      ::service_layer::PolicyRuleList* rules);
  ::service_layer::PolicyRuleList* unsafe_arena_release_rules();

  // .service_layer.PolicyIntfList Intfs = 3;
  bool has_intfs() const;
  private:
  bool _internal_has_intfs() const;
  public:
  void clear_intfs();
  const ::service_layer::PolicyIntfList& intfs() const;
  PROTOBUF_NODISCARD ::service_layer::PolicyIntfList* release_intfs();
  ::service_layer::PolicyIntfList* mutable_intfs();
  void set_allocated_intfs(::service_layer::PolicyIntfList* intfs);
  private:
  const ::service_layer::PolicyIntfList& _internal_intfs() const;
  ::service_layer::PolicyIntfList* _internal_mutable_intfs();
  public:
  void unsafe_arena_set_allocated_intfs(
      ::service_layer::PolicyIntfList* intfs);
  ::service_layer::PolicyIntfList* unsafe_arena_release_intfs();

  void clear_SLPolicyObjectList();
  SLPolicyObjectListCase SLPolicyObjectList_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyEntry)
 private:
  class _Internal;
  void set_has_rules();
  void set_has_intfs();

  inline bool has_SLPolicyObjectList() const;
  inline void clear_has_SLPolicyObjectList();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLPolicyKey* key_;
  union SLPolicyObjectListUnion {
    constexpr SLPolicyObjectListUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::PolicyRuleList* rules_;
    ::service_layer::PolicyIntfList* intfs_;
  } SLPolicyObjectList_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class PolicyRuleList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.PolicyRuleList) */ {
 public:
  inline PolicyRuleList() : PolicyRuleList(nullptr) {}
  ~PolicyRuleList() override;
  explicit constexpr PolicyRuleList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyRuleList(const PolicyRuleList& from);
  PolicyRuleList(PolicyRuleList&& from) noexcept
    : PolicyRuleList() {
    *this = ::std::move(from);
  }

  inline PolicyRuleList& operator=(const PolicyRuleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyRuleList& operator=(PolicyRuleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyRuleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyRuleList* internal_default_instance() {
    return reinterpret_cast<const PolicyRuleList*>(
               &_PolicyRuleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PolicyRuleList& a, PolicyRuleList& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyRuleList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyRuleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyRuleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyRuleList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolicyRuleList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolicyRuleList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolicyRuleList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.PolicyRuleList";
  }
  protected:
  explicit PolicyRuleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyRulesFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyRule PolicyRules = 1;
  int policyrules_size() const;
  private:
  int _internal_policyrules_size() const;
  public:
  void clear_policyrules();
  ::service_layer::SLPolicyRule* mutable_policyrules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >*
      mutable_policyrules();
  private:
  const ::service_layer::SLPolicyRule& _internal_policyrules(int index) const;
  ::service_layer::SLPolicyRule* _internal_add_policyrules();
  public:
  const ::service_layer::SLPolicyRule& policyrules(int index) const;
  ::service_layer::SLPolicyRule* add_policyrules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >&
      policyrules() const;

  // @@protoc_insertion_point(class_scope:service_layer.PolicyRuleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule > policyrules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class PolicyIntfList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.PolicyIntfList) */ {
 public:
  inline PolicyIntfList() : PolicyIntfList(nullptr) {}
  ~PolicyIntfList() override;
  explicit constexpr PolicyIntfList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyIntfList(const PolicyIntfList& from);
  PolicyIntfList(PolicyIntfList&& from) noexcept
    : PolicyIntfList() {
    *this = ::std::move(from);
  }

  inline PolicyIntfList& operator=(const PolicyIntfList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyIntfList& operator=(PolicyIntfList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyIntfList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyIntfList* internal_default_instance() {
    return reinterpret_cast<const PolicyIntfList*>(
               &_PolicyIntfList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PolicyIntfList& a, PolicyIntfList& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyIntfList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyIntfList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyIntfList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyIntfList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolicyIntfList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolicyIntfList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolicyIntfList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.PolicyIntfList";
  }
  protected:
  explicit PolicyIntfList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyIntfsFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyIntf PolicyIntfs = 1;
  int policyintfs_size() const;
  private:
  int _internal_policyintfs_size() const;
  public:
  void clear_policyintfs();
  ::service_layer::SLPolicyIntf* mutable_policyintfs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >*
      mutable_policyintfs();
  private:
  const ::service_layer::SLPolicyIntf& _internal_policyintfs(int index) const;
  ::service_layer::SLPolicyIntf* _internal_add_policyintfs();
  public:
  const ::service_layer::SLPolicyIntf& policyintfs(int index) const;
  ::service_layer::SLPolicyIntf* add_policyintfs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >&
      policyintfs() const;

  // @@protoc_insertion_point(class_scope:service_layer.PolicyIntfList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf > policyintfs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyKey) */ {
 public:
  inline SLPolicyKey() : SLPolicyKey(nullptr) {}
  ~SLPolicyKey() override;
  explicit constexpr SLPolicyKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyKey(const SLPolicyKey& from);
  SLPolicyKey(SLPolicyKey&& from) noexcept
    : SLPolicyKey() {
    *this = ::std::move(from);
  }

  inline SLPolicyKey& operator=(const SLPolicyKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyKey& operator=(SLPolicyKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyKey* internal_default_instance() {
    return reinterpret_cast<const SLPolicyKey*>(
               &_SLPolicyKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLPolicyKey& a, SLPolicyKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyKey";
  }
  protected:
  explicit SLPolicyKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string PolicyName = 1;
  void clear_policyname();
  const std::string& policyname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policyname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policyname();
  PROTOBUF_NODISCARD std::string* release_policyname();
  void set_allocated_policyname(std::string* policyname);
  private:
  const std::string& _internal_policyname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policyname(const std::string& value);
  std::string* _internal_mutable_policyname();
  public:

  // .service_layer.SLPolicyType Type = 2;
  void clear_type();
  ::service_layer::SLPolicyType type() const;
  void set_type(::service_layer::SLPolicyType value);
  private:
  ::service_layer::SLPolicyType _internal_type() const;
  void _internal_set_type(::service_layer::SLPolicyType value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policyname_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyRule) */ {
 public:
  inline SLPolicyRule() : SLPolicyRule(nullptr) {}
  ~SLPolicyRule() override;
  explicit constexpr SLPolicyRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyRule(const SLPolicyRule& from);
  SLPolicyRule(SLPolicyRule&& from) noexcept
    : SLPolicyRule() {
    *this = ::std::move(from);
  }

  inline SLPolicyRule& operator=(const SLPolicyRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyRule& operator=(SLPolicyRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyRule* internal_default_instance() {
    return reinterpret_cast<const SLPolicyRule*>(
               &_SLPolicyRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLPolicyRule& a, SLPolicyRule& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyRule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyRule";
  }
  protected:
  explicit SLPolicyRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleNameFieldNumber = 1,
    kPriorityStrFieldNumber = 2,
    kMatchFieldNumber = 3,
    kActionFieldNumber = 4,
  };
  // string RuleName = 1;
  void clear_rulename();
  const std::string& rulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rulename();
  PROTOBUF_NODISCARD std::string* release_rulename();
  void set_allocated_rulename(std::string* rulename);
  private:
  const std::string& _internal_rulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rulename(const std::string& value);
  std::string* _internal_mutable_rulename();
  public:

  // string PriorityStr = 2;
  void clear_prioritystr();
  const std::string& prioritystr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prioritystr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prioritystr();
  PROTOBUF_NODISCARD std::string* release_prioritystr();
  void set_allocated_prioritystr(std::string* prioritystr);
  private:
  const std::string& _internal_prioritystr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prioritystr(const std::string& value);
  std::string* _internal_mutable_prioritystr();
  public:

  // .service_layer.SLRuleMatch Match = 3;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::service_layer::SLRuleMatch& match() const;
  PROTOBUF_NODISCARD ::service_layer::SLRuleMatch* release_match();
  ::service_layer::SLRuleMatch* mutable_match();
  void set_allocated_match(::service_layer::SLRuleMatch* match);
  private:
  const ::service_layer::SLRuleMatch& _internal_match() const;
  ::service_layer::SLRuleMatch* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::service_layer::SLRuleMatch* match);
  ::service_layer::SLRuleMatch* unsafe_arena_release_match();

  // .service_layer.SLRuleAction Action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::service_layer::SLRuleAction& action() const;
  PROTOBUF_NODISCARD ::service_layer::SLRuleAction* release_action();
  ::service_layer::SLRuleAction* mutable_action();
  void set_allocated_action(::service_layer::SLRuleAction* action);
  private:
  const ::service_layer::SLRuleAction& _internal_action() const;
  ::service_layer::SLRuleAction* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::service_layer::SLRuleAction* action);
  ::service_layer::SLRuleAction* unsafe_arena_release_action();

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rulename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prioritystr_;
  ::service_layer::SLRuleMatch* match_;
  ::service_layer::SLRuleAction* action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLRuleMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRuleMatch) */ {
 public:
  inline SLRuleMatch() : SLRuleMatch(nullptr) {}
  ~SLRuleMatch() override;
  explicit constexpr SLRuleMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRuleMatch(const SLRuleMatch& from);
  SLRuleMatch(SLRuleMatch&& from) noexcept
    : SLRuleMatch() {
    *this = ::std::move(from);
  }

  inline SLRuleMatch& operator=(const SLRuleMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRuleMatch& operator=(SLRuleMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRuleMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRuleMatch* internal_default_instance() {
    return reinterpret_cast<const SLRuleMatch*>(
               &_SLRuleMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLRuleMatch& a, SLRuleMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRuleMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRuleMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRuleMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRuleMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRuleMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRuleMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRuleMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRuleMatch";
  }
  protected:
  explicit SLRuleMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDscpFieldNumber = 1,
    kPathGroupFieldNumber = 2,
  };
  // .service_layer.SLDscpMatch Dscp = 1;
  bool has_dscp() const;
  private:
  bool _internal_has_dscp() const;
  public:
  void clear_dscp();
  const ::service_layer::SLDscpMatch& dscp() const;
  PROTOBUF_NODISCARD ::service_layer::SLDscpMatch* release_dscp();
  ::service_layer::SLDscpMatch* mutable_dscp();
  void set_allocated_dscp(::service_layer::SLDscpMatch* dscp);
  private:
  const ::service_layer::SLDscpMatch& _internal_dscp() const;
  ::service_layer::SLDscpMatch* _internal_mutable_dscp();
  public:
  void unsafe_arena_set_allocated_dscp(
      ::service_layer::SLDscpMatch* dscp);
  ::service_layer::SLDscpMatch* unsafe_arena_release_dscp();

  // .service_layer.SLPathGroupRefKey PathGroup = 2;
  bool has_pathgroup() const;
  private:
  bool _internal_has_pathgroup() const;
  public:
  void clear_pathgroup();
  const ::service_layer::SLPathGroupRefKey& pathgroup() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroupRefKey* release_pathgroup();
  ::service_layer::SLPathGroupRefKey* mutable_pathgroup();
  void set_allocated_pathgroup(::service_layer::SLPathGroupRefKey* pathgroup);
  private:
  const ::service_layer::SLPathGroupRefKey& _internal_pathgroup() const;
  ::service_layer::SLPathGroupRefKey* _internal_mutable_pathgroup();
  public:
  void unsafe_arena_set_allocated_pathgroup(
      ::service_layer::SLPathGroupRefKey* pathgroup);
  ::service_layer::SLPathGroupRefKey* unsafe_arena_release_pathgroup();

  // @@protoc_insertion_point(class_scope:service_layer.SLRuleMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLDscpMatch* dscp_;
  ::service_layer::SLPathGroupRefKey* pathgroup_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLDscpMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLDscpMatch) */ {
 public:
  inline SLDscpMatch() : SLDscpMatch(nullptr) {}
  ~SLDscpMatch() override;
  explicit constexpr SLDscpMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLDscpMatch(const SLDscpMatch& from);
  SLDscpMatch(SLDscpMatch&& from) noexcept
    : SLDscpMatch() {
    *this = ::std::move(from);
  }

  inline SLDscpMatch& operator=(const SLDscpMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLDscpMatch& operator=(SLDscpMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLDscpMatch& default_instance() {
    return *internal_default_instance();
  }
  enum DscpCase {
    kDscpValue = 1,
    DSCP_NOT_SET = 0,
  };

  static inline const SLDscpMatch* internal_default_instance() {
    return reinterpret_cast<const SLDscpMatch*>(
               &_SLDscpMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLDscpMatch& a, SLDscpMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(SLDscpMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLDscpMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLDscpMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLDscpMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLDscpMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLDscpMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLDscpMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLDscpMatch";
  }
  protected:
  explicit SLDscpMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDscpValueFieldNumber = 1,
  };
  // uint32 DscpValue = 1;
  bool has_dscpvalue() const;
  private:
  bool _internal_has_dscpvalue() const;
  public:
  void clear_dscpvalue();
  uint32_t dscpvalue() const;
  void set_dscpvalue(uint32_t value);
  private:
  uint32_t _internal_dscpvalue() const;
  void _internal_set_dscpvalue(uint32_t value);
  public:

  void clear_Dscp();
  DscpCase Dscp_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLDscpMatch)
 private:
  class _Internal;
  void set_has_dscpvalue();

  inline bool has_Dscp() const;
  inline void clear_has_Dscp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DscpUnion {
    constexpr DscpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t dscpvalue_;
  } Dscp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLRuleAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRuleAction) */ {
 public:
  inline SLRuleAction() : SLRuleAction(nullptr) {}
  ~SLRuleAction() override;
  explicit constexpr SLRuleAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRuleAction(const SLRuleAction& from);
  SLRuleAction(SLRuleAction&& from) noexcept
    : SLRuleAction() {
    *this = ::std::move(from);
  }

  inline SLRuleAction& operator=(const SLRuleAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRuleAction& operator=(SLRuleAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRuleAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRuleAction* internal_default_instance() {
    return reinterpret_cast<const SLRuleAction*>(
               &_SLRuleAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLRuleAction& a, SLRuleAction& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRuleAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRuleAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRuleAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRuleAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRuleAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRuleAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRuleAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRuleAction";
  }
  protected:
  explicit SLRuleAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathGroupFieldNumber = 1,
    kEnableStatsCounterFieldNumber = 2,
  };
  // .service_layer.SLPathGroupRefKey PathGroup = 1;
  bool has_pathgroup() const;
  private:
  bool _internal_has_pathgroup() const;
  public:
  void clear_pathgroup();
  const ::service_layer::SLPathGroupRefKey& pathgroup() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroupRefKey* release_pathgroup();
  ::service_layer::SLPathGroupRefKey* mutable_pathgroup();
  void set_allocated_pathgroup(::service_layer::SLPathGroupRefKey* pathgroup);
  private:
  const ::service_layer::SLPathGroupRefKey& _internal_pathgroup() const;
  ::service_layer::SLPathGroupRefKey* _internal_mutable_pathgroup();
  public:
  void unsafe_arena_set_allocated_pathgroup(
      ::service_layer::SLPathGroupRefKey* pathgroup);
  ::service_layer::SLPathGroupRefKey* unsafe_arena_release_pathgroup();

  // bool EnableStatsCounter = 2;
  void clear_enablestatscounter();
  bool enablestatscounter() const;
  void set_enablestatscounter(bool value);
  private:
  bool _internal_enablestatscounter() const;
  void _internal_set_enablestatscounter(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRuleAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLPathGroupRefKey* pathgroup_;
  bool enablestatscounter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyIntf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyIntf) */ {
 public:
  inline SLPolicyIntf() : SLPolicyIntf(nullptr) {}
  ~SLPolicyIntf() override;
  explicit constexpr SLPolicyIntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyIntf(const SLPolicyIntf& from);
  SLPolicyIntf(SLPolicyIntf&& from) noexcept
    : SLPolicyIntf() {
    *this = ::std::move(from);
  }

  inline SLPolicyIntf& operator=(const SLPolicyIntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyIntf& operator=(SLPolicyIntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyIntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyIntf* internal_default_instance() {
    return reinterpret_cast<const SLPolicyIntf*>(
               &_SLPolicyIntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLPolicyIntf& a, SLPolicyIntf& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyIntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyIntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyIntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyIntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyIntf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyIntf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyIntf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyIntf";
  }
  protected:
  explicit SLPolicyIntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIntfDirFieldNumber = 2,
  };
  // .service_layer.SLInterface Key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLInterface& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_key();
  ::service_layer::SLInterface* mutable_key();
  void set_allocated_key(::service_layer::SLInterface* key);
  private:
  const ::service_layer::SLInterface& _internal_key() const;
  ::service_layer::SLInterface* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLInterface* key);
  ::service_layer::SLInterface* unsafe_arena_release_key();

  // .service_layer.SLApplyDirection IntfDir = 2;
  void clear_intfdir();
  ::service_layer::SLApplyDirection intfdir() const;
  void set_intfdir(::service_layer::SLApplyDirection value);
  private:
  ::service_layer::SLApplyDirection _internal_intfdir() const;
  void _internal_set_intfdir(::service_layer::SLApplyDirection value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyIntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLInterface* key_;
  int intfdir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyOpRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyOpRsp) */ {
 public:
  inline SLPolicyOpRsp() : SLPolicyOpRsp(nullptr) {}
  ~SLPolicyOpRsp() override;
  explicit constexpr SLPolicyOpRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyOpRsp(const SLPolicyOpRsp& from);
  SLPolicyOpRsp(SLPolicyOpRsp&& from) noexcept
    : SLPolicyOpRsp() {
    *this = ::std::move(from);
  }

  inline SLPolicyOpRsp& operator=(const SLPolicyOpRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyOpRsp& operator=(SLPolicyOpRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyOpRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyOpRsp* internal_default_instance() {
    return reinterpret_cast<const SLPolicyOpRsp*>(
               &_SLPolicyOpRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLPolicyOpRsp& a, SLPolicyOpRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyOpRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyOpRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyOpRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyOpRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyOpRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyOpRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyOpRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyOpRsp";
  }
  protected:
  explicit SLPolicyOpRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kOperationIDFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLPolicyRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRes >*
      mutable_results();
  private:
  const ::service_layer::SLPolicyRes& _internal_results(int index) const;
  ::service_layer::SLPolicyRes* _internal_add_results();
  public:
  const ::service_layer::SLPolicyRes& results(int index) const;
  ::service_layer::SLPolicyRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRes >&
      results() const;

  // uint64 OperationID = 1;
  void clear_operationid();
  uint64_t operationid() const;
  void set_operationid(uint64_t value);
  private:
  uint64_t _internal_operationid() const;
  void _internal_set_operationid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyOpRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRes > results_;
  uint64_t operationid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyRes) */ {
 public:
  inline SLPolicyRes() : SLPolicyRes(nullptr) {}
  ~SLPolicyRes() override;
  explicit constexpr SLPolicyRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyRes(const SLPolicyRes& from);
  SLPolicyRes(SLPolicyRes&& from) noexcept
    : SLPolicyRes() {
    *this = ::std::move(from);
  }

  inline SLPolicyRes& operator=(const SLPolicyRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyRes& operator=(SLPolicyRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyRes& default_instance() {
    return *internal_default_instance();
  }
  enum SLPolicyOpStatusCase {
    kPolicyStatus = 2,
    kRulesStatus = 3,
    kIntfStatus = 4,
    SLPOLICYOPSTATUS_NOT_SET = 0,
  };

  static inline const SLPolicyRes* internal_default_instance() {
    return reinterpret_cast<const SLPolicyRes*>(
               &_SLPolicyRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLPolicyRes& a, SLPolicyRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyRes";
  }
  protected:
  explicit SLPolicyRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kPolicyStatusFieldNumber = 2,
    kRulesStatusFieldNumber = 3,
    kIntfStatusFieldNumber = 4,
  };
  // .service_layer.SLPolicyKey Key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLPolicyKey& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLPolicyKey* release_key();
  ::service_layer::SLPolicyKey* mutable_key();
  void set_allocated_key(::service_layer::SLPolicyKey* key);
  private:
  const ::service_layer::SLPolicyKey& _internal_key() const;
  ::service_layer::SLPolicyKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLPolicyKey* key);
  ::service_layer::SLPolicyKey* unsafe_arena_release_key();

  // .service_layer.SLErrorStatus PolicyStatus = 2;
  bool has_policystatus() const;
  private:
  bool _internal_has_policystatus() const;
  public:
  void clear_policystatus();
  const ::service_layer::SLErrorStatus& policystatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_policystatus();
  ::service_layer::SLErrorStatus* mutable_policystatus();
  void set_allocated_policystatus(::service_layer::SLErrorStatus* policystatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_policystatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_policystatus();
  public:
  void unsafe_arena_set_allocated_policystatus(
      ::service_layer::SLErrorStatus* policystatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_policystatus();

  // .service_layer.SLPolicyRuleStatusList RulesStatus = 3;
  bool has_rulesstatus() const;
  private:
  bool _internal_has_rulesstatus() const;
  public:
  void clear_rulesstatus();
  const ::service_layer::SLPolicyRuleStatusList& rulesstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLPolicyRuleStatusList* release_rulesstatus();
  ::service_layer::SLPolicyRuleStatusList* mutable_rulesstatus();
  void set_allocated_rulesstatus(::service_layer::SLPolicyRuleStatusList* rulesstatus);
  private:
  const ::service_layer::SLPolicyRuleStatusList& _internal_rulesstatus() const;
  ::service_layer::SLPolicyRuleStatusList* _internal_mutable_rulesstatus();
  public:
  void unsafe_arena_set_allocated_rulesstatus(
      ::service_layer::SLPolicyRuleStatusList* rulesstatus);
  ::service_layer::SLPolicyRuleStatusList* unsafe_arena_release_rulesstatus();

  // .service_layer.SLPolicyIntfStatusList IntfStatus = 4;
  bool has_intfstatus() const;
  private:
  bool _internal_has_intfstatus() const;
  public:
  void clear_intfstatus();
  const ::service_layer::SLPolicyIntfStatusList& intfstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLPolicyIntfStatusList* release_intfstatus();
  ::service_layer::SLPolicyIntfStatusList* mutable_intfstatus();
  void set_allocated_intfstatus(::service_layer::SLPolicyIntfStatusList* intfstatus);
  private:
  const ::service_layer::SLPolicyIntfStatusList& _internal_intfstatus() const;
  ::service_layer::SLPolicyIntfStatusList* _internal_mutable_intfstatus();
  public:
  void unsafe_arena_set_allocated_intfstatus(
      ::service_layer::SLPolicyIntfStatusList* intfstatus);
  ::service_layer::SLPolicyIntfStatusList* unsafe_arena_release_intfstatus();

  void clear_SLPolicyOpStatus();
  SLPolicyOpStatusCase SLPolicyOpStatus_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyRes)
 private:
  class _Internal;
  void set_has_policystatus();
  void set_has_rulesstatus();
  void set_has_intfstatus();

  inline bool has_SLPolicyOpStatus() const;
  inline void clear_has_SLPolicyOpStatus();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLPolicyKey* key_;
  union SLPolicyOpStatusUnion {
    constexpr SLPolicyOpStatusUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLErrorStatus* policystatus_;
    ::service_layer::SLPolicyRuleStatusList* rulesstatus_;
    ::service_layer::SLPolicyIntfStatusList* intfstatus_;
  } SLPolicyOpStatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyRuleStatusList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyRuleStatusList) */ {
 public:
  inline SLPolicyRuleStatusList() : SLPolicyRuleStatusList(nullptr) {}
  ~SLPolicyRuleStatusList() override;
  explicit constexpr SLPolicyRuleStatusList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyRuleStatusList(const SLPolicyRuleStatusList& from);
  SLPolicyRuleStatusList(SLPolicyRuleStatusList&& from) noexcept
    : SLPolicyRuleStatusList() {
    *this = ::std::move(from);
  }

  inline SLPolicyRuleStatusList& operator=(const SLPolicyRuleStatusList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyRuleStatusList& operator=(SLPolicyRuleStatusList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyRuleStatusList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyRuleStatusList* internal_default_instance() {
    return reinterpret_cast<const SLPolicyRuleStatusList*>(
               &_SLPolicyRuleStatusList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLPolicyRuleStatusList& a, SLPolicyRuleStatusList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyRuleStatusList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyRuleStatusList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyRuleStatusList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyRuleStatusList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyRuleStatusList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyRuleStatusList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyRuleStatusList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyRuleStatusList";
  }
  protected:
  explicit SLPolicyRuleStatusList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRulesStatusFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyRuleStatus RulesStatus = 1;
  int rulesstatus_size() const;
  private:
  int _internal_rulesstatus_size() const;
  public:
  void clear_rulesstatus();
  ::service_layer::SLPolicyRuleStatus* mutable_rulesstatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRuleStatus >*
      mutable_rulesstatus();
  private:
  const ::service_layer::SLPolicyRuleStatus& _internal_rulesstatus(int index) const;
  ::service_layer::SLPolicyRuleStatus* _internal_add_rulesstatus();
  public:
  const ::service_layer::SLPolicyRuleStatus& rulesstatus(int index) const;
  ::service_layer::SLPolicyRuleStatus* add_rulesstatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRuleStatus >&
      rulesstatus() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyRuleStatusList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRuleStatus > rulesstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyIntfStatusList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyIntfStatusList) */ {
 public:
  inline SLPolicyIntfStatusList() : SLPolicyIntfStatusList(nullptr) {}
  ~SLPolicyIntfStatusList() override;
  explicit constexpr SLPolicyIntfStatusList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyIntfStatusList(const SLPolicyIntfStatusList& from);
  SLPolicyIntfStatusList(SLPolicyIntfStatusList&& from) noexcept
    : SLPolicyIntfStatusList() {
    *this = ::std::move(from);
  }

  inline SLPolicyIntfStatusList& operator=(const SLPolicyIntfStatusList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyIntfStatusList& operator=(SLPolicyIntfStatusList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyIntfStatusList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyIntfStatusList* internal_default_instance() {
    return reinterpret_cast<const SLPolicyIntfStatusList*>(
               &_SLPolicyIntfStatusList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLPolicyIntfStatusList& a, SLPolicyIntfStatusList& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyIntfStatusList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyIntfStatusList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyIntfStatusList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyIntfStatusList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyIntfStatusList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyIntfStatusList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyIntfStatusList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyIntfStatusList";
  }
  protected:
  explicit SLPolicyIntfStatusList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntfsStatusFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyIntfStatus IntfsStatus = 1;
  int intfsstatus_size() const;
  private:
  int _internal_intfsstatus_size() const;
  public:
  void clear_intfsstatus();
  ::service_layer::SLPolicyIntfStatus* mutable_intfsstatus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntfStatus >*
      mutable_intfsstatus();
  private:
  const ::service_layer::SLPolicyIntfStatus& _internal_intfsstatus(int index) const;
  ::service_layer::SLPolicyIntfStatus* _internal_add_intfsstatus();
  public:
  const ::service_layer::SLPolicyIntfStatus& intfsstatus(int index) const;
  ::service_layer::SLPolicyIntfStatus* add_intfsstatus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntfStatus >&
      intfsstatus() const;

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyIntfStatusList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntfStatus > intfsstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyRuleStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyRuleStatus) */ {
 public:
  inline SLPolicyRuleStatus() : SLPolicyRuleStatus(nullptr) {}
  ~SLPolicyRuleStatus() override;
  explicit constexpr SLPolicyRuleStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyRuleStatus(const SLPolicyRuleStatus& from);
  SLPolicyRuleStatus(SLPolicyRuleStatus&& from) noexcept
    : SLPolicyRuleStatus() {
    *this = ::std::move(from);
  }

  inline SLPolicyRuleStatus& operator=(const SLPolicyRuleStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyRuleStatus& operator=(SLPolicyRuleStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyRuleStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyRuleStatus* internal_default_instance() {
    return reinterpret_cast<const SLPolicyRuleStatus*>(
               &_SLPolicyRuleStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLPolicyRuleStatus& a, SLPolicyRuleStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyRuleStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyRuleStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyRuleStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyRuleStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyRuleStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyRuleStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyRuleStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyRuleStatus";
  }
  protected:
  explicit SLPolicyRuleStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string RuleName = 1;
  void clear_rulename();
  const std::string& rulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rulename();
  PROTOBUF_NODISCARD std::string* release_rulename();
  void set_allocated_rulename(std::string* rulename);
  private:
  const std::string& _internal_rulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rulename(const std::string& value);
  std::string* _internal_mutable_rulename();
  public:

  // .service_layer.SLErrorStatus Status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::service_layer::SLErrorStatus& status() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_status();
  ::service_layer::SLErrorStatus* mutable_status();
  void set_allocated_status(::service_layer::SLErrorStatus* status);
  private:
  const ::service_layer::SLErrorStatus& _internal_status() const;
  ::service_layer::SLErrorStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::service_layer::SLErrorStatus* status);
  ::service_layer::SLErrorStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyRuleStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rulename_;
  ::service_layer::SLErrorStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyIntfStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyIntfStatus) */ {
 public:
  inline SLPolicyIntfStatus() : SLPolicyIntfStatus(nullptr) {}
  ~SLPolicyIntfStatus() override;
  explicit constexpr SLPolicyIntfStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyIntfStatus(const SLPolicyIntfStatus& from);
  SLPolicyIntfStatus(SLPolicyIntfStatus&& from) noexcept
    : SLPolicyIntfStatus() {
    *this = ::std::move(from);
  }

  inline SLPolicyIntfStatus& operator=(const SLPolicyIntfStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyIntfStatus& operator=(SLPolicyIntfStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyIntfStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyIntfStatus* internal_default_instance() {
    return reinterpret_cast<const SLPolicyIntfStatus*>(
               &_SLPolicyIntfStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLPolicyIntfStatus& a, SLPolicyIntfStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyIntfStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyIntfStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyIntfStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyIntfStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyIntfStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyIntfStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyIntfStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyIntfStatus";
  }
  protected:
  explicit SLPolicyIntfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntfFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .service_layer.SLInterface Intf = 1;
  bool has_intf() const;
  private:
  bool _internal_has_intf() const;
  public:
  void clear_intf();
  const ::service_layer::SLInterface& intf() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_intf();
  ::service_layer::SLInterface* mutable_intf();
  void set_allocated_intf(::service_layer::SLInterface* intf);
  private:
  const ::service_layer::SLInterface& _internal_intf() const;
  ::service_layer::SLInterface* _internal_mutable_intf();
  public:
  void unsafe_arena_set_allocated_intf(
      ::service_layer::SLInterface* intf);
  ::service_layer::SLInterface* unsafe_arena_release_intf();

  // .service_layer.SLErrorStatus Status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::service_layer::SLErrorStatus& status() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_status();
  ::service_layer::SLErrorStatus* mutable_status();
  void set_allocated_status(::service_layer::SLErrorStatus* status);
  private:
  const ::service_layer::SLErrorStatus& _internal_status() const;
  ::service_layer::SLErrorStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::service_layer::SLErrorStatus* status);
  ::service_layer::SLErrorStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyIntfStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLInterface* intf_;
  ::service_layer::SLErrorStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyGetMsg) */ {
 public:
  inline SLPolicyGetMsg() : SLPolicyGetMsg(nullptr) {}
  explicit constexpr SLPolicyGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyGetMsg(const SLPolicyGetMsg& from);
  SLPolicyGetMsg(SLPolicyGetMsg&& from) noexcept
    : SLPolicyGetMsg() {
    *this = ::std::move(from);
  }

  inline SLPolicyGetMsg& operator=(const SLPolicyGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyGetMsg& operator=(SLPolicyGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLPolicyGetMsg*>(
               &_SLPolicyGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLPolicyGetMsg& a, SLPolicyGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLPolicyGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLPolicyGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyGetMsg";
  }
  protected:
  explicit SLPolicyGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyInfo) */ {
 public:
  inline SLPolicyInfo() : SLPolicyInfo(nullptr) {}
  ~SLPolicyInfo() override;
  explicit constexpr SLPolicyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyInfo(const SLPolicyInfo& from);
  SLPolicyInfo(SLPolicyInfo&& from) noexcept
    : SLPolicyInfo() {
    *this = ::std::move(from);
  }

  inline SLPolicyInfo& operator=(const SLPolicyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyInfo& operator=(SLPolicyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyInfo* internal_default_instance() {
    return reinterpret_cast<const SLPolicyInfo*>(
               &_SLPolicyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SLPolicyInfo& a, SLPolicyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyInfo";
  }
  protected:
  explicit SLPolicyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyRulesFieldNumber = 2,
    kPolicyIntfsFieldNumber = 3,
    kKeyFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyRule PolicyRules = 2;
  int policyrules_size() const;
  private:
  int _internal_policyrules_size() const;
  public:
  void clear_policyrules();
  ::service_layer::SLPolicyRule* mutable_policyrules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >*
      mutable_policyrules();
  private:
  const ::service_layer::SLPolicyRule& _internal_policyrules(int index) const;
  ::service_layer::SLPolicyRule* _internal_add_policyrules();
  public:
  const ::service_layer::SLPolicyRule& policyrules(int index) const;
  ::service_layer::SLPolicyRule* add_policyrules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >&
      policyrules() const;

  // repeated .service_layer.SLPolicyIntf PolicyIntfs = 3;
  int policyintfs_size() const;
  private:
  int _internal_policyintfs_size() const;
  public:
  void clear_policyintfs();
  ::service_layer::SLPolicyIntf* mutable_policyintfs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >*
      mutable_policyintfs();
  private:
  const ::service_layer::SLPolicyIntf& _internal_policyintfs(int index) const;
  ::service_layer::SLPolicyIntf* _internal_add_policyintfs();
  public:
  const ::service_layer::SLPolicyIntf& policyintfs(int index) const;
  ::service_layer::SLPolicyIntf* add_policyintfs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >&
      policyintfs() const;

  // .service_layer.SLPolicyKey Key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::service_layer::SLPolicyKey& key() const;
  PROTOBUF_NODISCARD ::service_layer::SLPolicyKey* release_key();
  ::service_layer::SLPolicyKey* mutable_key();
  void set_allocated_key(::service_layer::SLPolicyKey* key);
  private:
  const ::service_layer::SLPolicyKey& _internal_key() const;
  ::service_layer::SLPolicyKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::service_layer::SLPolicyKey* key);
  ::service_layer::SLPolicyKey* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule > policyrules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf > policyintfs_;
  ::service_layer::SLPolicyKey* key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyGetMsgRsp) */ {
 public:
  inline SLPolicyGetMsgRsp() : SLPolicyGetMsgRsp(nullptr) {}
  ~SLPolicyGetMsgRsp() override;
  explicit constexpr SLPolicyGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyGetMsgRsp(const SLPolicyGetMsgRsp& from);
  SLPolicyGetMsgRsp(SLPolicyGetMsgRsp&& from) noexcept
    : SLPolicyGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLPolicyGetMsgRsp& operator=(const SLPolicyGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyGetMsgRsp& operator=(SLPolicyGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLPolicyGetMsgRsp*>(
               &_SLPolicyGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SLPolicyGetMsgRsp& a, SLPolicyGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyGetMsgRsp";
  }
  protected:
  explicit SLPolicyGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyObjsFieldNumber = 2,
    kPolicyCfgOpStatusFieldNumber = 1,
  };
  // repeated .service_layer.SLPolicyInfo PolicyObjs = 2;
  int policyobjs_size() const;
  private:
  int _internal_policyobjs_size() const;
  public:
  void clear_policyobjs();
  ::service_layer::SLPolicyInfo* mutable_policyobjs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyInfo >*
      mutable_policyobjs();
  private:
  const ::service_layer::SLPolicyInfo& _internal_policyobjs(int index) const;
  ::service_layer::SLPolicyInfo* _internal_add_policyobjs();
  public:
  const ::service_layer::SLPolicyInfo& policyobjs(int index) const;
  ::service_layer::SLPolicyInfo* add_policyobjs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyInfo >&
      policyobjs() const;

  // .service_layer.SLErrorStatus PolicyCfgOpStatus = 1;
  bool has_policycfgopstatus() const;
  private:
  bool _internal_has_policycfgopstatus() const;
  public:
  void clear_policycfgopstatus();
  const ::service_layer::SLErrorStatus& policycfgopstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_policycfgopstatus();
  ::service_layer::SLErrorStatus* mutable_policycfgopstatus();
  void set_allocated_policycfgopstatus(::service_layer::SLErrorStatus* policycfgopstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_policycfgopstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_policycfgopstatus();
  public:
  void unsafe_arena_set_allocated_policycfgopstatus(
      ::service_layer::SLErrorStatus* policycfgopstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_policycfgopstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyInfo > policyobjs_;
  ::service_layer::SLErrorStatus* policycfgopstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyGlobalGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyGlobalGetMsg) */ {
 public:
  inline SLPolicyGlobalGetMsg() : SLPolicyGlobalGetMsg(nullptr) {}
  explicit constexpr SLPolicyGlobalGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyGlobalGetMsg(const SLPolicyGlobalGetMsg& from);
  SLPolicyGlobalGetMsg(SLPolicyGlobalGetMsg&& from) noexcept
    : SLPolicyGlobalGetMsg() {
    *this = ::std::move(from);
  }

  inline SLPolicyGlobalGetMsg& operator=(const SLPolicyGlobalGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyGlobalGetMsg& operator=(SLPolicyGlobalGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyGlobalGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyGlobalGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLPolicyGlobalGetMsg*>(
               &_SLPolicyGlobalGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SLPolicyGlobalGetMsg& a, SLPolicyGlobalGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyGlobalGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyGlobalGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyGlobalGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyGlobalGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLPolicyGlobalGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLPolicyGlobalGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyGlobalGetMsg";
  }
  protected:
  explicit SLPolicyGlobalGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyGlobalGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SLPolicyGlobalGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLPolicyGlobalGetMsgRsp) */ {
 public:
  inline SLPolicyGlobalGetMsgRsp() : SLPolicyGlobalGetMsgRsp(nullptr) {}
  ~SLPolicyGlobalGetMsgRsp() override;
  explicit constexpr SLPolicyGlobalGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLPolicyGlobalGetMsgRsp(const SLPolicyGlobalGetMsgRsp& from);
  SLPolicyGlobalGetMsgRsp(SLPolicyGlobalGetMsgRsp&& from) noexcept
    : SLPolicyGlobalGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLPolicyGlobalGetMsgRsp& operator=(const SLPolicyGlobalGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLPolicyGlobalGetMsgRsp& operator=(SLPolicyGlobalGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLPolicyGlobalGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLPolicyGlobalGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLPolicyGlobalGetMsgRsp*>(
               &_SLPolicyGlobalGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SLPolicyGlobalGetMsgRsp& a, SLPolicyGlobalGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLPolicyGlobalGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLPolicyGlobalGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLPolicyGlobalGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLPolicyGlobalGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLPolicyGlobalGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLPolicyGlobalGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLPolicyGlobalGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLPolicyGlobalGetMsgRsp";
  }
  protected:
  explicit SLPolicyGlobalGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kMaxPoliciesFieldNumber = 2,
    kMaxRulesFieldNumber = 3,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint32 MaxPolicies = 2;
  void clear_maxpolicies();
  uint32_t maxpolicies() const;
  void set_maxpolicies(uint32_t value);
  private:
  uint32_t _internal_maxpolicies() const;
  void _internal_set_maxpolicies(uint32_t value);
  public:

  // uint32 MaxRules = 3;
  void clear_maxrules();
  uint32_t maxrules() const;
  void set_maxrules(uint32_t value);
  private:
  uint32_t _internal_maxrules() const;
  void _internal_set_maxrules(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLPolicyGlobalGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint32_t maxpolicies_;
  uint32_t maxrules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5fpolicy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLPolicyOpMsg

// .service_layer.SLPolicyObjectOp Oper = 1;
inline void SLPolicyOpMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLPolicyObjectOp SLPolicyOpMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLPolicyObjectOp >(oper_);
}
inline ::service_layer::SLPolicyObjectOp SLPolicyOpMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyOpMsg.Oper)
  return _internal_oper();
}
inline void SLPolicyOpMsg::_internal_set_oper(::service_layer::SLPolicyObjectOp value) {
  
  oper_ = value;
}
inline void SLPolicyOpMsg::set_oper(::service_layer::SLPolicyObjectOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyOpMsg.Oper)
}

// uint64 OperationID = 2;
inline void SLPolicyOpMsg::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLPolicyOpMsg::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLPolicyOpMsg::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyOpMsg.OperationID)
  return _internal_operationid();
}
inline void SLPolicyOpMsg::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLPolicyOpMsg::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyOpMsg.OperationID)
}

// repeated .service_layer.SLPolicyEntry Policies = 3;
inline int SLPolicyOpMsg::_internal_policies_size() const {
  return policies_.size();
}
inline int SLPolicyOpMsg::policies_size() const {
  return _internal_policies_size();
}
inline void SLPolicyOpMsg::clear_policies() {
  policies_.Clear();
}
inline ::service_layer::SLPolicyEntry* SLPolicyOpMsg::mutable_policies(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyOpMsg.Policies)
  return policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyEntry >*
SLPolicyOpMsg::mutable_policies() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyOpMsg.Policies)
  return &policies_;
}
inline const ::service_layer::SLPolicyEntry& SLPolicyOpMsg::_internal_policies(int index) const {
  return policies_.Get(index);
}
inline const ::service_layer::SLPolicyEntry& SLPolicyOpMsg::policies(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyOpMsg.Policies)
  return _internal_policies(index);
}
inline ::service_layer::SLPolicyEntry* SLPolicyOpMsg::_internal_add_policies() {
  return policies_.Add();
}
inline ::service_layer::SLPolicyEntry* SLPolicyOpMsg::add_policies() {
  ::service_layer::SLPolicyEntry* _add = _internal_add_policies();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyOpMsg.Policies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyEntry >&
SLPolicyOpMsg::policies() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyOpMsg.Policies)
  return policies_;
}

// -------------------------------------------------------------------

// SLPolicyEntry

// .service_layer.SLPolicyKey Key = 1;
inline bool SLPolicyEntry::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLPolicyEntry::has_key() const {
  return _internal_has_key();
}
inline void SLPolicyEntry::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::service_layer::SLPolicyKey& SLPolicyEntry::_internal_key() const {
  const ::service_layer::SLPolicyKey* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLPolicyKey&>(
      ::service_layer::_SLPolicyKey_default_instance_);
}
inline const ::service_layer::SLPolicyKey& SLPolicyEntry::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyEntry.Key)
  return _internal_key();
}
inline void SLPolicyEntry::unsafe_arena_set_allocated_key(
    ::service_layer::SLPolicyKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyEntry.Key)
}
inline ::service_layer::SLPolicyKey* SLPolicyEntry::release_key() {
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyEntry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyEntry.Key)
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyEntry::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLPolicyKey>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLPolicyKey* SLPolicyEntry::mutable_key() {
  ::service_layer::SLPolicyKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyEntry.Key)
  return _msg;
}
inline void SLPolicyEntry::set_allocated_key(::service_layer::SLPolicyKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLPolicyKey>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyEntry.Key)
}

// .service_layer.PolicyRuleList Rules = 2;
inline bool SLPolicyEntry::_internal_has_rules() const {
  return SLPolicyObjectList_case() == kRules;
}
inline bool SLPolicyEntry::has_rules() const {
  return _internal_has_rules();
}
inline void SLPolicyEntry::set_has_rules() {
  _oneof_case_[0] = kRules;
}
inline void SLPolicyEntry::clear_rules() {
  if (_internal_has_rules()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SLPolicyObjectList_.rules_;
    }
    clear_has_SLPolicyObjectList();
  }
}
inline ::service_layer::PolicyRuleList* SLPolicyEntry::release_rules() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyEntry.Rules)
  if (_internal_has_rules()) {
    clear_has_SLPolicyObjectList();
      ::service_layer::PolicyRuleList* temp = SLPolicyObjectList_.rules_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SLPolicyObjectList_.rules_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::PolicyRuleList& SLPolicyEntry::_internal_rules() const {
  return _internal_has_rules()
      ? *SLPolicyObjectList_.rules_
      : reinterpret_cast< ::service_layer::PolicyRuleList&>(::service_layer::_PolicyRuleList_default_instance_);
}
inline const ::service_layer::PolicyRuleList& SLPolicyEntry::rules() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyEntry.Rules)
  return _internal_rules();
}
inline ::service_layer::PolicyRuleList* SLPolicyEntry::unsafe_arena_release_rules() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPolicyEntry.Rules)
  if (_internal_has_rules()) {
    clear_has_SLPolicyObjectList();
    ::service_layer::PolicyRuleList* temp = SLPolicyObjectList_.rules_;
    SLPolicyObjectList_.rules_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPolicyEntry::unsafe_arena_set_allocated_rules(::service_layer::PolicyRuleList* rules) {
  clear_SLPolicyObjectList();
  if (rules) {
    set_has_rules();
    SLPolicyObjectList_.rules_ = rules;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyEntry.Rules)
}
inline ::service_layer::PolicyRuleList* SLPolicyEntry::_internal_mutable_rules() {
  if (!_internal_has_rules()) {
    clear_SLPolicyObjectList();
    set_has_rules();
    SLPolicyObjectList_.rules_ = CreateMaybeMessage< ::service_layer::PolicyRuleList >(GetArenaForAllocation());
  }
  return SLPolicyObjectList_.rules_;
}
inline ::service_layer::PolicyRuleList* SLPolicyEntry::mutable_rules() {
  ::service_layer::PolicyRuleList* _msg = _internal_mutable_rules();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyEntry.Rules)
  return _msg;
}

// .service_layer.PolicyIntfList Intfs = 3;
inline bool SLPolicyEntry::_internal_has_intfs() const {
  return SLPolicyObjectList_case() == kIntfs;
}
inline bool SLPolicyEntry::has_intfs() const {
  return _internal_has_intfs();
}
inline void SLPolicyEntry::set_has_intfs() {
  _oneof_case_[0] = kIntfs;
}
inline void SLPolicyEntry::clear_intfs() {
  if (_internal_has_intfs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SLPolicyObjectList_.intfs_;
    }
    clear_has_SLPolicyObjectList();
  }
}
inline ::service_layer::PolicyIntfList* SLPolicyEntry::release_intfs() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyEntry.Intfs)
  if (_internal_has_intfs()) {
    clear_has_SLPolicyObjectList();
      ::service_layer::PolicyIntfList* temp = SLPolicyObjectList_.intfs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SLPolicyObjectList_.intfs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::PolicyIntfList& SLPolicyEntry::_internal_intfs() const {
  return _internal_has_intfs()
      ? *SLPolicyObjectList_.intfs_
      : reinterpret_cast< ::service_layer::PolicyIntfList&>(::service_layer::_PolicyIntfList_default_instance_);
}
inline const ::service_layer::PolicyIntfList& SLPolicyEntry::intfs() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyEntry.Intfs)
  return _internal_intfs();
}
inline ::service_layer::PolicyIntfList* SLPolicyEntry::unsafe_arena_release_intfs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPolicyEntry.Intfs)
  if (_internal_has_intfs()) {
    clear_has_SLPolicyObjectList();
    ::service_layer::PolicyIntfList* temp = SLPolicyObjectList_.intfs_;
    SLPolicyObjectList_.intfs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPolicyEntry::unsafe_arena_set_allocated_intfs(::service_layer::PolicyIntfList* intfs) {
  clear_SLPolicyObjectList();
  if (intfs) {
    set_has_intfs();
    SLPolicyObjectList_.intfs_ = intfs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyEntry.Intfs)
}
inline ::service_layer::PolicyIntfList* SLPolicyEntry::_internal_mutable_intfs() {
  if (!_internal_has_intfs()) {
    clear_SLPolicyObjectList();
    set_has_intfs();
    SLPolicyObjectList_.intfs_ = CreateMaybeMessage< ::service_layer::PolicyIntfList >(GetArenaForAllocation());
  }
  return SLPolicyObjectList_.intfs_;
}
inline ::service_layer::PolicyIntfList* SLPolicyEntry::mutable_intfs() {
  ::service_layer::PolicyIntfList* _msg = _internal_mutable_intfs();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyEntry.Intfs)
  return _msg;
}

inline bool SLPolicyEntry::has_SLPolicyObjectList() const {
  return SLPolicyObjectList_case() != SLPOLICYOBJECTLIST_NOT_SET;
}
inline void SLPolicyEntry::clear_has_SLPolicyObjectList() {
  _oneof_case_[0] = SLPOLICYOBJECTLIST_NOT_SET;
}
inline SLPolicyEntry::SLPolicyObjectListCase SLPolicyEntry::SLPolicyObjectList_case() const {
  return SLPolicyEntry::SLPolicyObjectListCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PolicyRuleList

// repeated .service_layer.SLPolicyRule PolicyRules = 1;
inline int PolicyRuleList::_internal_policyrules_size() const {
  return policyrules_.size();
}
inline int PolicyRuleList::policyrules_size() const {
  return _internal_policyrules_size();
}
inline void PolicyRuleList::clear_policyrules() {
  policyrules_.Clear();
}
inline ::service_layer::SLPolicyRule* PolicyRuleList::mutable_policyrules(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.PolicyRuleList.PolicyRules)
  return policyrules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >*
PolicyRuleList::mutable_policyrules() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.PolicyRuleList.PolicyRules)
  return &policyrules_;
}
inline const ::service_layer::SLPolicyRule& PolicyRuleList::_internal_policyrules(int index) const {
  return policyrules_.Get(index);
}
inline const ::service_layer::SLPolicyRule& PolicyRuleList::policyrules(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.PolicyRuleList.PolicyRules)
  return _internal_policyrules(index);
}
inline ::service_layer::SLPolicyRule* PolicyRuleList::_internal_add_policyrules() {
  return policyrules_.Add();
}
inline ::service_layer::SLPolicyRule* PolicyRuleList::add_policyrules() {
  ::service_layer::SLPolicyRule* _add = _internal_add_policyrules();
  // @@protoc_insertion_point(field_add:service_layer.PolicyRuleList.PolicyRules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >&
PolicyRuleList::policyrules() const {
  // @@protoc_insertion_point(field_list:service_layer.PolicyRuleList.PolicyRules)
  return policyrules_;
}

// -------------------------------------------------------------------

// PolicyIntfList

// repeated .service_layer.SLPolicyIntf PolicyIntfs = 1;
inline int PolicyIntfList::_internal_policyintfs_size() const {
  return policyintfs_.size();
}
inline int PolicyIntfList::policyintfs_size() const {
  return _internal_policyintfs_size();
}
inline void PolicyIntfList::clear_policyintfs() {
  policyintfs_.Clear();
}
inline ::service_layer::SLPolicyIntf* PolicyIntfList::mutable_policyintfs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.PolicyIntfList.PolicyIntfs)
  return policyintfs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >*
PolicyIntfList::mutable_policyintfs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.PolicyIntfList.PolicyIntfs)
  return &policyintfs_;
}
inline const ::service_layer::SLPolicyIntf& PolicyIntfList::_internal_policyintfs(int index) const {
  return policyintfs_.Get(index);
}
inline const ::service_layer::SLPolicyIntf& PolicyIntfList::policyintfs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.PolicyIntfList.PolicyIntfs)
  return _internal_policyintfs(index);
}
inline ::service_layer::SLPolicyIntf* PolicyIntfList::_internal_add_policyintfs() {
  return policyintfs_.Add();
}
inline ::service_layer::SLPolicyIntf* PolicyIntfList::add_policyintfs() {
  ::service_layer::SLPolicyIntf* _add = _internal_add_policyintfs();
  // @@protoc_insertion_point(field_add:service_layer.PolicyIntfList.PolicyIntfs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >&
PolicyIntfList::policyintfs() const {
  // @@protoc_insertion_point(field_list:service_layer.PolicyIntfList.PolicyIntfs)
  return policyintfs_;
}

// -------------------------------------------------------------------

// SLPolicyKey

// string PolicyName = 1;
inline void SLPolicyKey::clear_policyname() {
  policyname_.ClearToEmpty();
}
inline const std::string& SLPolicyKey::policyname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyKey.PolicyName)
  return _internal_policyname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLPolicyKey::set_policyname(ArgT0&& arg0, ArgT... args) {
 
 policyname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyKey.PolicyName)
}
inline std::string* SLPolicyKey::mutable_policyname() {
  std::string* _s = _internal_mutable_policyname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyKey.PolicyName)
  return _s;
}
inline const std::string& SLPolicyKey::_internal_policyname() const {
  return policyname_.Get();
}
inline void SLPolicyKey::_internal_set_policyname(const std::string& value) {
  
  policyname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLPolicyKey::_internal_mutable_policyname() {
  
  return policyname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLPolicyKey::release_policyname() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyKey.PolicyName)
  return policyname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLPolicyKey::set_allocated_policyname(std::string* policyname) {
  if (policyname != nullptr) {
    
  } else {
    
  }
  policyname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), policyname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (policyname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    policyname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyKey.PolicyName)
}

// .service_layer.SLPolicyType Type = 2;
inline void SLPolicyKey::clear_type() {
  type_ = 0;
}
inline ::service_layer::SLPolicyType SLPolicyKey::_internal_type() const {
  return static_cast< ::service_layer::SLPolicyType >(type_);
}
inline ::service_layer::SLPolicyType SLPolicyKey::type() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyKey.Type)
  return _internal_type();
}
inline void SLPolicyKey::_internal_set_type(::service_layer::SLPolicyType value) {
  
  type_ = value;
}
inline void SLPolicyKey::set_type(::service_layer::SLPolicyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyKey.Type)
}

// -------------------------------------------------------------------

// SLPolicyRule

// string RuleName = 1;
inline void SLPolicyRule::clear_rulename() {
  rulename_.ClearToEmpty();
}
inline const std::string& SLPolicyRule::rulename() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRule.RuleName)
  return _internal_rulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLPolicyRule::set_rulename(ArgT0&& arg0, ArgT... args) {
 
 rulename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyRule.RuleName)
}
inline std::string* SLPolicyRule::mutable_rulename() {
  std::string* _s = _internal_mutable_rulename();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRule.RuleName)
  return _s;
}
inline const std::string& SLPolicyRule::_internal_rulename() const {
  return rulename_.Get();
}
inline void SLPolicyRule::_internal_set_rulename(const std::string& value) {
  
  rulename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLPolicyRule::_internal_mutable_rulename() {
  
  return rulename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLPolicyRule::release_rulename() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRule.RuleName)
  return rulename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLPolicyRule::set_allocated_rulename(std::string* rulename) {
  if (rulename != nullptr) {
    
  } else {
    
  }
  rulename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rulename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rulename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rulename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRule.RuleName)
}

// string PriorityStr = 2;
inline void SLPolicyRule::clear_prioritystr() {
  prioritystr_.ClearToEmpty();
}
inline const std::string& SLPolicyRule::prioritystr() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRule.PriorityStr)
  return _internal_prioritystr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLPolicyRule::set_prioritystr(ArgT0&& arg0, ArgT... args) {
 
 prioritystr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyRule.PriorityStr)
}
inline std::string* SLPolicyRule::mutable_prioritystr() {
  std::string* _s = _internal_mutable_prioritystr();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRule.PriorityStr)
  return _s;
}
inline const std::string& SLPolicyRule::_internal_prioritystr() const {
  return prioritystr_.Get();
}
inline void SLPolicyRule::_internal_set_prioritystr(const std::string& value) {
  
  prioritystr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLPolicyRule::_internal_mutable_prioritystr() {
  
  return prioritystr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLPolicyRule::release_prioritystr() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRule.PriorityStr)
  return prioritystr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLPolicyRule::set_allocated_prioritystr(std::string* prioritystr) {
  if (prioritystr != nullptr) {
    
  } else {
    
  }
  prioritystr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prioritystr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prioritystr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prioritystr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRule.PriorityStr)
}

// .service_layer.SLRuleMatch Match = 3;
inline bool SLPolicyRule::_internal_has_match() const {
  return this != internal_default_instance() && match_ != nullptr;
}
inline bool SLPolicyRule::has_match() const {
  return _internal_has_match();
}
inline void SLPolicyRule::clear_match() {
  if (GetArenaForAllocation() == nullptr && match_ != nullptr) {
    delete match_;
  }
  match_ = nullptr;
}
inline const ::service_layer::SLRuleMatch& SLPolicyRule::_internal_match() const {
  const ::service_layer::SLRuleMatch* p = match_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRuleMatch&>(
      ::service_layer::_SLRuleMatch_default_instance_);
}
inline const ::service_layer::SLRuleMatch& SLPolicyRule::match() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRule.Match)
  return _internal_match();
}
inline void SLPolicyRule::unsafe_arena_set_allocated_match(
    ::service_layer::SLRuleMatch* match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_);
  }
  match_ = match;
  if (match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRule.Match)
}
inline ::service_layer::SLRuleMatch* SLPolicyRule::release_match() {
  
  ::service_layer::SLRuleMatch* temp = match_;
  match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRuleMatch* SLPolicyRule::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRule.Match)
  
  ::service_layer::SLRuleMatch* temp = match_;
  match_ = nullptr;
  return temp;
}
inline ::service_layer::SLRuleMatch* SLPolicyRule::_internal_mutable_match() {
  
  if (match_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRuleMatch>(GetArenaForAllocation());
    match_ = p;
  }
  return match_;
}
inline ::service_layer::SLRuleMatch* SLPolicyRule::mutable_match() {
  ::service_layer::SLRuleMatch* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRule.Match)
  return _msg;
}
inline void SLPolicyRule::set_allocated_match(::service_layer::SLRuleMatch* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_;
  }
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLRuleMatch>::GetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRule.Match)
}

// .service_layer.SLRuleAction Action = 4;
inline bool SLPolicyRule::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool SLPolicyRule::has_action() const {
  return _internal_has_action();
}
inline void SLPolicyRule::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::service_layer::SLRuleAction& SLPolicyRule::_internal_action() const {
  const ::service_layer::SLRuleAction* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLRuleAction&>(
      ::service_layer::_SLRuleAction_default_instance_);
}
inline const ::service_layer::SLRuleAction& SLPolicyRule::action() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRule.Action)
  return _internal_action();
}
inline void SLPolicyRule::unsafe_arena_set_allocated_action(
    ::service_layer::SLRuleAction* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRule.Action)
}
inline ::service_layer::SLRuleAction* SLPolicyRule::release_action() {
  
  ::service_layer::SLRuleAction* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLRuleAction* SLPolicyRule::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRule.Action)
  
  ::service_layer::SLRuleAction* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::service_layer::SLRuleAction* SLPolicyRule::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLRuleAction>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::service_layer::SLRuleAction* SLPolicyRule::mutable_action() {
  ::service_layer::SLRuleAction* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRule.Action)
  return _msg;
}
inline void SLPolicyRule::set_allocated_action(::service_layer::SLRuleAction* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLRuleAction>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRule.Action)
}

// -------------------------------------------------------------------

// SLRuleMatch

// .service_layer.SLDscpMatch Dscp = 1;
inline bool SLRuleMatch::_internal_has_dscp() const {
  return this != internal_default_instance() && dscp_ != nullptr;
}
inline bool SLRuleMatch::has_dscp() const {
  return _internal_has_dscp();
}
inline void SLRuleMatch::clear_dscp() {
  if (GetArenaForAllocation() == nullptr && dscp_ != nullptr) {
    delete dscp_;
  }
  dscp_ = nullptr;
}
inline const ::service_layer::SLDscpMatch& SLRuleMatch::_internal_dscp() const {
  const ::service_layer::SLDscpMatch* p = dscp_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLDscpMatch&>(
      ::service_layer::_SLDscpMatch_default_instance_);
}
inline const ::service_layer::SLDscpMatch& SLRuleMatch::dscp() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRuleMatch.Dscp)
  return _internal_dscp();
}
inline void SLRuleMatch::unsafe_arena_set_allocated_dscp(
    ::service_layer::SLDscpMatch* dscp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dscp_);
  }
  dscp_ = dscp;
  if (dscp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRuleMatch.Dscp)
}
inline ::service_layer::SLDscpMatch* SLRuleMatch::release_dscp() {
  
  ::service_layer::SLDscpMatch* temp = dscp_;
  dscp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLDscpMatch* SLRuleMatch::unsafe_arena_release_dscp() {
  // @@protoc_insertion_point(field_release:service_layer.SLRuleMatch.Dscp)
  
  ::service_layer::SLDscpMatch* temp = dscp_;
  dscp_ = nullptr;
  return temp;
}
inline ::service_layer::SLDscpMatch* SLRuleMatch::_internal_mutable_dscp() {
  
  if (dscp_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLDscpMatch>(GetArenaForAllocation());
    dscp_ = p;
  }
  return dscp_;
}
inline ::service_layer::SLDscpMatch* SLRuleMatch::mutable_dscp() {
  ::service_layer::SLDscpMatch* _msg = _internal_mutable_dscp();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRuleMatch.Dscp)
  return _msg;
}
inline void SLRuleMatch::set_allocated_dscp(::service_layer::SLDscpMatch* dscp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dscp_;
  }
  if (dscp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLDscpMatch>::GetOwningArena(dscp);
    if (message_arena != submessage_arena) {
      dscp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dscp, submessage_arena);
    }
    
  } else {
    
  }
  dscp_ = dscp;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRuleMatch.Dscp)
}

// .service_layer.SLPathGroupRefKey PathGroup = 2;
inline bool SLRuleMatch::_internal_has_pathgroup() const {
  return this != internal_default_instance() && pathgroup_ != nullptr;
}
inline bool SLRuleMatch::has_pathgroup() const {
  return _internal_has_pathgroup();
}
inline const ::service_layer::SLPathGroupRefKey& SLRuleMatch::_internal_pathgroup() const {
  const ::service_layer::SLPathGroupRefKey* p = pathgroup_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLPathGroupRefKey&>(
      ::service_layer::_SLPathGroupRefKey_default_instance_);
}
inline const ::service_layer::SLPathGroupRefKey& SLRuleMatch::pathgroup() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRuleMatch.PathGroup)
  return _internal_pathgroup();
}
inline void SLRuleMatch::unsafe_arena_set_allocated_pathgroup(
    ::service_layer::SLPathGroupRefKey* pathgroup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup_);
  }
  pathgroup_ = pathgroup;
  if (pathgroup) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRuleMatch.PathGroup)
}
inline ::service_layer::SLPathGroupRefKey* SLRuleMatch::release_pathgroup() {
  
  ::service_layer::SLPathGroupRefKey* temp = pathgroup_;
  pathgroup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleMatch::unsafe_arena_release_pathgroup() {
  // @@protoc_insertion_point(field_release:service_layer.SLRuleMatch.PathGroup)
  
  ::service_layer::SLPathGroupRefKey* temp = pathgroup_;
  pathgroup_ = nullptr;
  return temp;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleMatch::_internal_mutable_pathgroup() {
  
  if (pathgroup_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLPathGroupRefKey>(GetArenaForAllocation());
    pathgroup_ = p;
  }
  return pathgroup_;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleMatch::mutable_pathgroup() {
  ::service_layer::SLPathGroupRefKey* _msg = _internal_mutable_pathgroup();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRuleMatch.PathGroup)
  return _msg;
}
inline void SLRuleMatch::set_allocated_pathgroup(::service_layer::SLPathGroupRefKey* pathgroup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup_);
  }
  if (pathgroup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup));
    if (message_arena != submessage_arena) {
      pathgroup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathgroup, submessage_arena);
    }
    
  } else {
    
  }
  pathgroup_ = pathgroup;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRuleMatch.PathGroup)
}

// -------------------------------------------------------------------

// SLDscpMatch

// uint32 DscpValue = 1;
inline bool SLDscpMatch::_internal_has_dscpvalue() const {
  return Dscp_case() == kDscpValue;
}
inline bool SLDscpMatch::has_dscpvalue() const {
  return _internal_has_dscpvalue();
}
inline void SLDscpMatch::set_has_dscpvalue() {
  _oneof_case_[0] = kDscpValue;
}
inline void SLDscpMatch::clear_dscpvalue() {
  if (_internal_has_dscpvalue()) {
    Dscp_.dscpvalue_ = 0u;
    clear_has_Dscp();
  }
}
inline uint32_t SLDscpMatch::_internal_dscpvalue() const {
  if (_internal_has_dscpvalue()) {
    return Dscp_.dscpvalue_;
  }
  return 0u;
}
inline void SLDscpMatch::_internal_set_dscpvalue(uint32_t value) {
  if (!_internal_has_dscpvalue()) {
    clear_Dscp();
    set_has_dscpvalue();
  }
  Dscp_.dscpvalue_ = value;
}
inline uint32_t SLDscpMatch::dscpvalue() const {
  // @@protoc_insertion_point(field_get:service_layer.SLDscpMatch.DscpValue)
  return _internal_dscpvalue();
}
inline void SLDscpMatch::set_dscpvalue(uint32_t value) {
  _internal_set_dscpvalue(value);
  // @@protoc_insertion_point(field_set:service_layer.SLDscpMatch.DscpValue)
}

inline bool SLDscpMatch::has_Dscp() const {
  return Dscp_case() != DSCP_NOT_SET;
}
inline void SLDscpMatch::clear_has_Dscp() {
  _oneof_case_[0] = DSCP_NOT_SET;
}
inline SLDscpMatch::DscpCase SLDscpMatch::Dscp_case() const {
  return SLDscpMatch::DscpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLRuleAction

// .service_layer.SLPathGroupRefKey PathGroup = 1;
inline bool SLRuleAction::_internal_has_pathgroup() const {
  return this != internal_default_instance() && pathgroup_ != nullptr;
}
inline bool SLRuleAction::has_pathgroup() const {
  return _internal_has_pathgroup();
}
inline const ::service_layer::SLPathGroupRefKey& SLRuleAction::_internal_pathgroup() const {
  const ::service_layer::SLPathGroupRefKey* p = pathgroup_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLPathGroupRefKey&>(
      ::service_layer::_SLPathGroupRefKey_default_instance_);
}
inline const ::service_layer::SLPathGroupRefKey& SLRuleAction::pathgroup() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRuleAction.PathGroup)
  return _internal_pathgroup();
}
inline void SLRuleAction::unsafe_arena_set_allocated_pathgroup(
    ::service_layer::SLPathGroupRefKey* pathgroup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup_);
  }
  pathgroup_ = pathgroup;
  if (pathgroup) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRuleAction.PathGroup)
}
inline ::service_layer::SLPathGroupRefKey* SLRuleAction::release_pathgroup() {
  
  ::service_layer::SLPathGroupRefKey* temp = pathgroup_;
  pathgroup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleAction::unsafe_arena_release_pathgroup() {
  // @@protoc_insertion_point(field_release:service_layer.SLRuleAction.PathGroup)
  
  ::service_layer::SLPathGroupRefKey* temp = pathgroup_;
  pathgroup_ = nullptr;
  return temp;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleAction::_internal_mutable_pathgroup() {
  
  if (pathgroup_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLPathGroupRefKey>(GetArenaForAllocation());
    pathgroup_ = p;
  }
  return pathgroup_;
}
inline ::service_layer::SLPathGroupRefKey* SLRuleAction::mutable_pathgroup() {
  ::service_layer::SLPathGroupRefKey* _msg = _internal_mutable_pathgroup();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRuleAction.PathGroup)
  return _msg;
}
inline void SLRuleAction::set_allocated_pathgroup(::service_layer::SLPathGroupRefKey* pathgroup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup_);
  }
  if (pathgroup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathgroup));
    if (message_arena != submessage_arena) {
      pathgroup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathgroup, submessage_arena);
    }
    
  } else {
    
  }
  pathgroup_ = pathgroup;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRuleAction.PathGroup)
}

// bool EnableStatsCounter = 2;
inline void SLRuleAction::clear_enablestatscounter() {
  enablestatscounter_ = false;
}
inline bool SLRuleAction::_internal_enablestatscounter() const {
  return enablestatscounter_;
}
inline bool SLRuleAction::enablestatscounter() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRuleAction.EnableStatsCounter)
  return _internal_enablestatscounter();
}
inline void SLRuleAction::_internal_set_enablestatscounter(bool value) {
  
  enablestatscounter_ = value;
}
inline void SLRuleAction::set_enablestatscounter(bool value) {
  _internal_set_enablestatscounter(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRuleAction.EnableStatsCounter)
}

// -------------------------------------------------------------------

// SLPolicyIntf

// .service_layer.SLInterface Key = 1;
inline bool SLPolicyIntf::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLPolicyIntf::has_key() const {
  return _internal_has_key();
}
inline const ::service_layer::SLInterface& SLPolicyIntf::_internal_key() const {
  const ::service_layer::SLInterface* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLPolicyIntf::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyIntf.Key)
  return _internal_key();
}
inline void SLPolicyIntf::unsafe_arena_set_allocated_key(
    ::service_layer::SLInterface* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyIntf.Key)
}
inline ::service_layer::SLInterface* SLPolicyIntf::release_key() {
  
  ::service_layer::SLInterface* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLPolicyIntf::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyIntf.Key)
  
  ::service_layer::SLInterface* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLPolicyIntf::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLInterface* SLPolicyIntf::mutable_key() {
  ::service_layer::SLInterface* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyIntf.Key)
  return _msg;
}
inline void SLPolicyIntf::set_allocated_key(::service_layer::SLInterface* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key));
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyIntf.Key)
}

// .service_layer.SLApplyDirection IntfDir = 2;
inline void SLPolicyIntf::clear_intfdir() {
  intfdir_ = 0;
}
inline ::service_layer::SLApplyDirection SLPolicyIntf::_internal_intfdir() const {
  return static_cast< ::service_layer::SLApplyDirection >(intfdir_);
}
inline ::service_layer::SLApplyDirection SLPolicyIntf::intfdir() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyIntf.IntfDir)
  return _internal_intfdir();
}
inline void SLPolicyIntf::_internal_set_intfdir(::service_layer::SLApplyDirection value) {
  
  intfdir_ = value;
}
inline void SLPolicyIntf::set_intfdir(::service_layer::SLApplyDirection value) {
  _internal_set_intfdir(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyIntf.IntfDir)
}

// -------------------------------------------------------------------

// SLPolicyOpRsp

// uint64 OperationID = 1;
inline void SLPolicyOpRsp::clear_operationid() {
  operationid_ = uint64_t{0u};
}
inline uint64_t SLPolicyOpRsp::_internal_operationid() const {
  return operationid_;
}
inline uint64_t SLPolicyOpRsp::operationid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyOpRsp.OperationID)
  return _internal_operationid();
}
inline void SLPolicyOpRsp::_internal_set_operationid(uint64_t value) {
  
  operationid_ = value;
}
inline void SLPolicyOpRsp::set_operationid(uint64_t value) {
  _internal_set_operationid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyOpRsp.OperationID)
}

// repeated .service_layer.SLPolicyRes Results = 2;
inline int SLPolicyOpRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLPolicyOpRsp::results_size() const {
  return _internal_results_size();
}
inline void SLPolicyOpRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLPolicyRes* SLPolicyOpRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyOpRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRes >*
SLPolicyOpRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyOpRsp.Results)
  return &results_;
}
inline const ::service_layer::SLPolicyRes& SLPolicyOpRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLPolicyRes& SLPolicyOpRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyOpRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLPolicyRes* SLPolicyOpRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLPolicyRes* SLPolicyOpRsp::add_results() {
  ::service_layer::SLPolicyRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyOpRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRes >&
SLPolicyOpRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyOpRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLPolicyRes

// .service_layer.SLPolicyKey Key = 1;
inline bool SLPolicyRes::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLPolicyRes::has_key() const {
  return _internal_has_key();
}
inline void SLPolicyRes::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::service_layer::SLPolicyKey& SLPolicyRes::_internal_key() const {
  const ::service_layer::SLPolicyKey* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLPolicyKey&>(
      ::service_layer::_SLPolicyKey_default_instance_);
}
inline const ::service_layer::SLPolicyKey& SLPolicyRes::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRes.Key)
  return _internal_key();
}
inline void SLPolicyRes::unsafe_arena_set_allocated_key(
    ::service_layer::SLPolicyKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRes.Key)
}
inline ::service_layer::SLPolicyKey* SLPolicyRes::release_key() {
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyRes::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRes.Key)
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyRes::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLPolicyKey>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLPolicyKey* SLPolicyRes::mutable_key() {
  ::service_layer::SLPolicyKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRes.Key)
  return _msg;
}
inline void SLPolicyRes::set_allocated_key(::service_layer::SLPolicyKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLPolicyKey>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRes.Key)
}

// .service_layer.SLErrorStatus PolicyStatus = 2;
inline bool SLPolicyRes::_internal_has_policystatus() const {
  return SLPolicyOpStatus_case() == kPolicyStatus;
}
inline bool SLPolicyRes::has_policystatus() const {
  return _internal_has_policystatus();
}
inline void SLPolicyRes::set_has_policystatus() {
  _oneof_case_[0] = kPolicyStatus;
}
inline ::service_layer::SLErrorStatus* SLPolicyRes::release_policystatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRes.PolicyStatus)
  if (_internal_has_policystatus()) {
    clear_has_SLPolicyOpStatus();
      ::service_layer::SLErrorStatus* temp = SLPolicyOpStatus_.policystatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SLPolicyOpStatus_.policystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLErrorStatus& SLPolicyRes::_internal_policystatus() const {
  return _internal_has_policystatus()
      ? *SLPolicyOpStatus_.policystatus_
      : reinterpret_cast< ::service_layer::SLErrorStatus&>(::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLPolicyRes::policystatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRes.PolicyStatus)
  return _internal_policystatus();
}
inline ::service_layer::SLErrorStatus* SLPolicyRes::unsafe_arena_release_policystatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPolicyRes.PolicyStatus)
  if (_internal_has_policystatus()) {
    clear_has_SLPolicyOpStatus();
    ::service_layer::SLErrorStatus* temp = SLPolicyOpStatus_.policystatus_;
    SLPolicyOpStatus_.policystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPolicyRes::unsafe_arena_set_allocated_policystatus(::service_layer::SLErrorStatus* policystatus) {
  clear_SLPolicyOpStatus();
  if (policystatus) {
    set_has_policystatus();
    SLPolicyOpStatus_.policystatus_ = policystatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRes.PolicyStatus)
}
inline ::service_layer::SLErrorStatus* SLPolicyRes::_internal_mutable_policystatus() {
  if (!_internal_has_policystatus()) {
    clear_SLPolicyOpStatus();
    set_has_policystatus();
    SLPolicyOpStatus_.policystatus_ = CreateMaybeMessage< ::service_layer::SLErrorStatus >(GetArenaForAllocation());
  }
  return SLPolicyOpStatus_.policystatus_;
}
inline ::service_layer::SLErrorStatus* SLPolicyRes::mutable_policystatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_policystatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRes.PolicyStatus)
  return _msg;
}

// .service_layer.SLPolicyRuleStatusList RulesStatus = 3;
inline bool SLPolicyRes::_internal_has_rulesstatus() const {
  return SLPolicyOpStatus_case() == kRulesStatus;
}
inline bool SLPolicyRes::has_rulesstatus() const {
  return _internal_has_rulesstatus();
}
inline void SLPolicyRes::set_has_rulesstatus() {
  _oneof_case_[0] = kRulesStatus;
}
inline void SLPolicyRes::clear_rulesstatus() {
  if (_internal_has_rulesstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SLPolicyOpStatus_.rulesstatus_;
    }
    clear_has_SLPolicyOpStatus();
  }
}
inline ::service_layer::SLPolicyRuleStatusList* SLPolicyRes::release_rulesstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRes.RulesStatus)
  if (_internal_has_rulesstatus()) {
    clear_has_SLPolicyOpStatus();
      ::service_layer::SLPolicyRuleStatusList* temp = SLPolicyOpStatus_.rulesstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SLPolicyOpStatus_.rulesstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPolicyRuleStatusList& SLPolicyRes::_internal_rulesstatus() const {
  return _internal_has_rulesstatus()
      ? *SLPolicyOpStatus_.rulesstatus_
      : reinterpret_cast< ::service_layer::SLPolicyRuleStatusList&>(::service_layer::_SLPolicyRuleStatusList_default_instance_);
}
inline const ::service_layer::SLPolicyRuleStatusList& SLPolicyRes::rulesstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRes.RulesStatus)
  return _internal_rulesstatus();
}
inline ::service_layer::SLPolicyRuleStatusList* SLPolicyRes::unsafe_arena_release_rulesstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPolicyRes.RulesStatus)
  if (_internal_has_rulesstatus()) {
    clear_has_SLPolicyOpStatus();
    ::service_layer::SLPolicyRuleStatusList* temp = SLPolicyOpStatus_.rulesstatus_;
    SLPolicyOpStatus_.rulesstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPolicyRes::unsafe_arena_set_allocated_rulesstatus(::service_layer::SLPolicyRuleStatusList* rulesstatus) {
  clear_SLPolicyOpStatus();
  if (rulesstatus) {
    set_has_rulesstatus();
    SLPolicyOpStatus_.rulesstatus_ = rulesstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRes.RulesStatus)
}
inline ::service_layer::SLPolicyRuleStatusList* SLPolicyRes::_internal_mutable_rulesstatus() {
  if (!_internal_has_rulesstatus()) {
    clear_SLPolicyOpStatus();
    set_has_rulesstatus();
    SLPolicyOpStatus_.rulesstatus_ = CreateMaybeMessage< ::service_layer::SLPolicyRuleStatusList >(GetArenaForAllocation());
  }
  return SLPolicyOpStatus_.rulesstatus_;
}
inline ::service_layer::SLPolicyRuleStatusList* SLPolicyRes::mutable_rulesstatus() {
  ::service_layer::SLPolicyRuleStatusList* _msg = _internal_mutable_rulesstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRes.RulesStatus)
  return _msg;
}

// .service_layer.SLPolicyIntfStatusList IntfStatus = 4;
inline bool SLPolicyRes::_internal_has_intfstatus() const {
  return SLPolicyOpStatus_case() == kIntfStatus;
}
inline bool SLPolicyRes::has_intfstatus() const {
  return _internal_has_intfstatus();
}
inline void SLPolicyRes::set_has_intfstatus() {
  _oneof_case_[0] = kIntfStatus;
}
inline void SLPolicyRes::clear_intfstatus() {
  if (_internal_has_intfstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete SLPolicyOpStatus_.intfstatus_;
    }
    clear_has_SLPolicyOpStatus();
  }
}
inline ::service_layer::SLPolicyIntfStatusList* SLPolicyRes::release_intfstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRes.IntfStatus)
  if (_internal_has_intfstatus()) {
    clear_has_SLPolicyOpStatus();
      ::service_layer::SLPolicyIntfStatusList* temp = SLPolicyOpStatus_.intfstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    SLPolicyOpStatus_.intfstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPolicyIntfStatusList& SLPolicyRes::_internal_intfstatus() const {
  return _internal_has_intfstatus()
      ? *SLPolicyOpStatus_.intfstatus_
      : reinterpret_cast< ::service_layer::SLPolicyIntfStatusList&>(::service_layer::_SLPolicyIntfStatusList_default_instance_);
}
inline const ::service_layer::SLPolicyIntfStatusList& SLPolicyRes::intfstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRes.IntfStatus)
  return _internal_intfstatus();
}
inline ::service_layer::SLPolicyIntfStatusList* SLPolicyRes::unsafe_arena_release_intfstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLPolicyRes.IntfStatus)
  if (_internal_has_intfstatus()) {
    clear_has_SLPolicyOpStatus();
    ::service_layer::SLPolicyIntfStatusList* temp = SLPolicyOpStatus_.intfstatus_;
    SLPolicyOpStatus_.intfstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLPolicyRes::unsafe_arena_set_allocated_intfstatus(::service_layer::SLPolicyIntfStatusList* intfstatus) {
  clear_SLPolicyOpStatus();
  if (intfstatus) {
    set_has_intfstatus();
    SLPolicyOpStatus_.intfstatus_ = intfstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRes.IntfStatus)
}
inline ::service_layer::SLPolicyIntfStatusList* SLPolicyRes::_internal_mutable_intfstatus() {
  if (!_internal_has_intfstatus()) {
    clear_SLPolicyOpStatus();
    set_has_intfstatus();
    SLPolicyOpStatus_.intfstatus_ = CreateMaybeMessage< ::service_layer::SLPolicyIntfStatusList >(GetArenaForAllocation());
  }
  return SLPolicyOpStatus_.intfstatus_;
}
inline ::service_layer::SLPolicyIntfStatusList* SLPolicyRes::mutable_intfstatus() {
  ::service_layer::SLPolicyIntfStatusList* _msg = _internal_mutable_intfstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRes.IntfStatus)
  return _msg;
}

inline bool SLPolicyRes::has_SLPolicyOpStatus() const {
  return SLPolicyOpStatus_case() != SLPOLICYOPSTATUS_NOT_SET;
}
inline void SLPolicyRes::clear_has_SLPolicyOpStatus() {
  _oneof_case_[0] = SLPOLICYOPSTATUS_NOT_SET;
}
inline SLPolicyRes::SLPolicyOpStatusCase SLPolicyRes::SLPolicyOpStatus_case() const {
  return SLPolicyRes::SLPolicyOpStatusCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLPolicyRuleStatusList

// repeated .service_layer.SLPolicyRuleStatus RulesStatus = 1;
inline int SLPolicyRuleStatusList::_internal_rulesstatus_size() const {
  return rulesstatus_.size();
}
inline int SLPolicyRuleStatusList::rulesstatus_size() const {
  return _internal_rulesstatus_size();
}
inline void SLPolicyRuleStatusList::clear_rulesstatus() {
  rulesstatus_.Clear();
}
inline ::service_layer::SLPolicyRuleStatus* SLPolicyRuleStatusList::mutable_rulesstatus(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRuleStatusList.RulesStatus)
  return rulesstatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRuleStatus >*
SLPolicyRuleStatusList::mutable_rulesstatus() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyRuleStatusList.RulesStatus)
  return &rulesstatus_;
}
inline const ::service_layer::SLPolicyRuleStatus& SLPolicyRuleStatusList::_internal_rulesstatus(int index) const {
  return rulesstatus_.Get(index);
}
inline const ::service_layer::SLPolicyRuleStatus& SLPolicyRuleStatusList::rulesstatus(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRuleStatusList.RulesStatus)
  return _internal_rulesstatus(index);
}
inline ::service_layer::SLPolicyRuleStatus* SLPolicyRuleStatusList::_internal_add_rulesstatus() {
  return rulesstatus_.Add();
}
inline ::service_layer::SLPolicyRuleStatus* SLPolicyRuleStatusList::add_rulesstatus() {
  ::service_layer::SLPolicyRuleStatus* _add = _internal_add_rulesstatus();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyRuleStatusList.RulesStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRuleStatus >&
SLPolicyRuleStatusList::rulesstatus() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyRuleStatusList.RulesStatus)
  return rulesstatus_;
}

// -------------------------------------------------------------------

// SLPolicyIntfStatusList

// repeated .service_layer.SLPolicyIntfStatus IntfsStatus = 1;
inline int SLPolicyIntfStatusList::_internal_intfsstatus_size() const {
  return intfsstatus_.size();
}
inline int SLPolicyIntfStatusList::intfsstatus_size() const {
  return _internal_intfsstatus_size();
}
inline void SLPolicyIntfStatusList::clear_intfsstatus() {
  intfsstatus_.Clear();
}
inline ::service_layer::SLPolicyIntfStatus* SLPolicyIntfStatusList::mutable_intfsstatus(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyIntfStatusList.IntfsStatus)
  return intfsstatus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntfStatus >*
SLPolicyIntfStatusList::mutable_intfsstatus() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyIntfStatusList.IntfsStatus)
  return &intfsstatus_;
}
inline const ::service_layer::SLPolicyIntfStatus& SLPolicyIntfStatusList::_internal_intfsstatus(int index) const {
  return intfsstatus_.Get(index);
}
inline const ::service_layer::SLPolicyIntfStatus& SLPolicyIntfStatusList::intfsstatus(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyIntfStatusList.IntfsStatus)
  return _internal_intfsstatus(index);
}
inline ::service_layer::SLPolicyIntfStatus* SLPolicyIntfStatusList::_internal_add_intfsstatus() {
  return intfsstatus_.Add();
}
inline ::service_layer::SLPolicyIntfStatus* SLPolicyIntfStatusList::add_intfsstatus() {
  ::service_layer::SLPolicyIntfStatus* _add = _internal_add_intfsstatus();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyIntfStatusList.IntfsStatus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntfStatus >&
SLPolicyIntfStatusList::intfsstatus() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyIntfStatusList.IntfsStatus)
  return intfsstatus_;
}

// -------------------------------------------------------------------

// SLPolicyRuleStatus

// string RuleName = 1;
inline void SLPolicyRuleStatus::clear_rulename() {
  rulename_.ClearToEmpty();
}
inline const std::string& SLPolicyRuleStatus::rulename() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRuleStatus.RuleName)
  return _internal_rulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLPolicyRuleStatus::set_rulename(ArgT0&& arg0, ArgT... args) {
 
 rulename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyRuleStatus.RuleName)
}
inline std::string* SLPolicyRuleStatus::mutable_rulename() {
  std::string* _s = _internal_mutable_rulename();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRuleStatus.RuleName)
  return _s;
}
inline const std::string& SLPolicyRuleStatus::_internal_rulename() const {
  return rulename_.Get();
}
inline void SLPolicyRuleStatus::_internal_set_rulename(const std::string& value) {
  
  rulename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLPolicyRuleStatus::_internal_mutable_rulename() {
  
  return rulename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLPolicyRuleStatus::release_rulename() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRuleStatus.RuleName)
  return rulename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLPolicyRuleStatus::set_allocated_rulename(std::string* rulename) {
  if (rulename != nullptr) {
    
  } else {
    
  }
  rulename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rulename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rulename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rulename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRuleStatus.RuleName)
}

// .service_layer.SLErrorStatus Status = 2;
inline bool SLPolicyRuleStatus::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SLPolicyRuleStatus::has_status() const {
  return _internal_has_status();
}
inline const ::service_layer::SLErrorStatus& SLPolicyRuleStatus::_internal_status() const {
  const ::service_layer::SLErrorStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLPolicyRuleStatus::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyRuleStatus.Status)
  return _internal_status();
}
inline void SLPolicyRuleStatus::unsafe_arena_set_allocated_status(
    ::service_layer::SLErrorStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyRuleStatus.Status)
}
inline ::service_layer::SLErrorStatus* SLPolicyRuleStatus::release_status() {
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyRuleStatus::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyRuleStatus.Status)
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyRuleStatus::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::service_layer::SLErrorStatus* SLPolicyRuleStatus::mutable_status() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyRuleStatus.Status)
  return _msg;
}
inline void SLPolicyRuleStatus::set_allocated_status(::service_layer::SLErrorStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyRuleStatus.Status)
}

// -------------------------------------------------------------------

// SLPolicyIntfStatus

// .service_layer.SLInterface Intf = 1;
inline bool SLPolicyIntfStatus::_internal_has_intf() const {
  return this != internal_default_instance() && intf_ != nullptr;
}
inline bool SLPolicyIntfStatus::has_intf() const {
  return _internal_has_intf();
}
inline const ::service_layer::SLInterface& SLPolicyIntfStatus::_internal_intf() const {
  const ::service_layer::SLInterface* p = intf_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLPolicyIntfStatus::intf() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyIntfStatus.Intf)
  return _internal_intf();
}
inline void SLPolicyIntfStatus::unsafe_arena_set_allocated_intf(
    ::service_layer::SLInterface* intf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intf_);
  }
  intf_ = intf;
  if (intf) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyIntfStatus.Intf)
}
inline ::service_layer::SLInterface* SLPolicyIntfStatus::release_intf() {
  
  ::service_layer::SLInterface* temp = intf_;
  intf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLPolicyIntfStatus::unsafe_arena_release_intf() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyIntfStatus.Intf)
  
  ::service_layer::SLInterface* temp = intf_;
  intf_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLPolicyIntfStatus::_internal_mutable_intf() {
  
  if (intf_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    intf_ = p;
  }
  return intf_;
}
inline ::service_layer::SLInterface* SLPolicyIntfStatus::mutable_intf() {
  ::service_layer::SLInterface* _msg = _internal_mutable_intf();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyIntfStatus.Intf)
  return _msg;
}
inline void SLPolicyIntfStatus::set_allocated_intf(::service_layer::SLInterface* intf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(intf_);
  }
  if (intf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intf));
    if (message_arena != submessage_arena) {
      intf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intf, submessage_arena);
    }
    
  } else {
    
  }
  intf_ = intf;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyIntfStatus.Intf)
}

// .service_layer.SLErrorStatus Status = 2;
inline bool SLPolicyIntfStatus::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SLPolicyIntfStatus::has_status() const {
  return _internal_has_status();
}
inline const ::service_layer::SLErrorStatus& SLPolicyIntfStatus::_internal_status() const {
  const ::service_layer::SLErrorStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLPolicyIntfStatus::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyIntfStatus.Status)
  return _internal_status();
}
inline void SLPolicyIntfStatus::unsafe_arena_set_allocated_status(
    ::service_layer::SLErrorStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyIntfStatus.Status)
}
inline ::service_layer::SLErrorStatus* SLPolicyIntfStatus::release_status() {
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyIntfStatus::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyIntfStatus.Status)
  
  ::service_layer::SLErrorStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyIntfStatus::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::service_layer::SLErrorStatus* SLPolicyIntfStatus::mutable_status() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyIntfStatus.Status)
  return _msg;
}
inline void SLPolicyIntfStatus::set_allocated_status(::service_layer::SLErrorStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyIntfStatus.Status)
}

// -------------------------------------------------------------------

// SLPolicyGetMsg

// -------------------------------------------------------------------

// SLPolicyInfo

// .service_layer.SLPolicyKey Key = 1;
inline bool SLPolicyInfo::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool SLPolicyInfo::has_key() const {
  return _internal_has_key();
}
inline void SLPolicyInfo::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::service_layer::SLPolicyKey& SLPolicyInfo::_internal_key() const {
  const ::service_layer::SLPolicyKey* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLPolicyKey&>(
      ::service_layer::_SLPolicyKey_default_instance_);
}
inline const ::service_layer::SLPolicyKey& SLPolicyInfo::key() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyInfo.Key)
  return _internal_key();
}
inline void SLPolicyInfo::unsafe_arena_set_allocated_key(
    ::service_layer::SLPolicyKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyInfo.Key)
}
inline ::service_layer::SLPolicyKey* SLPolicyInfo::release_key() {
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyInfo::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyInfo.Key)
  
  ::service_layer::SLPolicyKey* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::service_layer::SLPolicyKey* SLPolicyInfo::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLPolicyKey>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::service_layer::SLPolicyKey* SLPolicyInfo::mutable_key() {
  ::service_layer::SLPolicyKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyInfo.Key)
  return _msg;
}
inline void SLPolicyInfo::set_allocated_key(::service_layer::SLPolicyKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLPolicyKey>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyInfo.Key)
}

// repeated .service_layer.SLPolicyRule PolicyRules = 2;
inline int SLPolicyInfo::_internal_policyrules_size() const {
  return policyrules_.size();
}
inline int SLPolicyInfo::policyrules_size() const {
  return _internal_policyrules_size();
}
inline void SLPolicyInfo::clear_policyrules() {
  policyrules_.Clear();
}
inline ::service_layer::SLPolicyRule* SLPolicyInfo::mutable_policyrules(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyInfo.PolicyRules)
  return policyrules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >*
SLPolicyInfo::mutable_policyrules() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyInfo.PolicyRules)
  return &policyrules_;
}
inline const ::service_layer::SLPolicyRule& SLPolicyInfo::_internal_policyrules(int index) const {
  return policyrules_.Get(index);
}
inline const ::service_layer::SLPolicyRule& SLPolicyInfo::policyrules(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyInfo.PolicyRules)
  return _internal_policyrules(index);
}
inline ::service_layer::SLPolicyRule* SLPolicyInfo::_internal_add_policyrules() {
  return policyrules_.Add();
}
inline ::service_layer::SLPolicyRule* SLPolicyInfo::add_policyrules() {
  ::service_layer::SLPolicyRule* _add = _internal_add_policyrules();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyInfo.PolicyRules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyRule >&
SLPolicyInfo::policyrules() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyInfo.PolicyRules)
  return policyrules_;
}

// repeated .service_layer.SLPolicyIntf PolicyIntfs = 3;
inline int SLPolicyInfo::_internal_policyintfs_size() const {
  return policyintfs_.size();
}
inline int SLPolicyInfo::policyintfs_size() const {
  return _internal_policyintfs_size();
}
inline void SLPolicyInfo::clear_policyintfs() {
  policyintfs_.Clear();
}
inline ::service_layer::SLPolicyIntf* SLPolicyInfo::mutable_policyintfs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyInfo.PolicyIntfs)
  return policyintfs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >*
SLPolicyInfo::mutable_policyintfs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyInfo.PolicyIntfs)
  return &policyintfs_;
}
inline const ::service_layer::SLPolicyIntf& SLPolicyInfo::_internal_policyintfs(int index) const {
  return policyintfs_.Get(index);
}
inline const ::service_layer::SLPolicyIntf& SLPolicyInfo::policyintfs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyInfo.PolicyIntfs)
  return _internal_policyintfs(index);
}
inline ::service_layer::SLPolicyIntf* SLPolicyInfo::_internal_add_policyintfs() {
  return policyintfs_.Add();
}
inline ::service_layer::SLPolicyIntf* SLPolicyInfo::add_policyintfs() {
  ::service_layer::SLPolicyIntf* _add = _internal_add_policyintfs();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyInfo.PolicyIntfs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyIntf >&
SLPolicyInfo::policyintfs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyInfo.PolicyIntfs)
  return policyintfs_;
}

// -------------------------------------------------------------------

// SLPolicyGetMsgRsp

// .service_layer.SLErrorStatus PolicyCfgOpStatus = 1;
inline bool SLPolicyGetMsgRsp::_internal_has_policycfgopstatus() const {
  return this != internal_default_instance() && policycfgopstatus_ != nullptr;
}
inline bool SLPolicyGetMsgRsp::has_policycfgopstatus() const {
  return _internal_has_policycfgopstatus();
}
inline const ::service_layer::SLErrorStatus& SLPolicyGetMsgRsp::_internal_policycfgopstatus() const {
  const ::service_layer::SLErrorStatus* p = policycfgopstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLPolicyGetMsgRsp::policycfgopstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus)
  return _internal_policycfgopstatus();
}
inline void SLPolicyGetMsgRsp::unsafe_arena_set_allocated_policycfgopstatus(
    ::service_layer::SLErrorStatus* policycfgopstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policycfgopstatus_);
  }
  policycfgopstatus_ = policycfgopstatus;
  if (policycfgopstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus)
}
inline ::service_layer::SLErrorStatus* SLPolicyGetMsgRsp::release_policycfgopstatus() {
  
  ::service_layer::SLErrorStatus* temp = policycfgopstatus_;
  policycfgopstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyGetMsgRsp::unsafe_arena_release_policycfgopstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus)
  
  ::service_layer::SLErrorStatus* temp = policycfgopstatus_;
  policycfgopstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyGetMsgRsp::_internal_mutable_policycfgopstatus() {
  
  if (policycfgopstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    policycfgopstatus_ = p;
  }
  return policycfgopstatus_;
}
inline ::service_layer::SLErrorStatus* SLPolicyGetMsgRsp::mutable_policycfgopstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_policycfgopstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus)
  return _msg;
}
inline void SLPolicyGetMsgRsp::set_allocated_policycfgopstatus(::service_layer::SLErrorStatus* policycfgopstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(policycfgopstatus_);
  }
  if (policycfgopstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policycfgopstatus));
    if (message_arena != submessage_arena) {
      policycfgopstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policycfgopstatus, submessage_arena);
    }
    
  } else {
    
  }
  policycfgopstatus_ = policycfgopstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus)
}

// repeated .service_layer.SLPolicyInfo PolicyObjs = 2;
inline int SLPolicyGetMsgRsp::_internal_policyobjs_size() const {
  return policyobjs_.size();
}
inline int SLPolicyGetMsgRsp::policyobjs_size() const {
  return _internal_policyobjs_size();
}
inline void SLPolicyGetMsgRsp::clear_policyobjs() {
  policyobjs_.Clear();
}
inline ::service_layer::SLPolicyInfo* SLPolicyGetMsgRsp::mutable_policyobjs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyGetMsgRsp.PolicyObjs)
  return policyobjs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyInfo >*
SLPolicyGetMsgRsp::mutable_policyobjs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLPolicyGetMsgRsp.PolicyObjs)
  return &policyobjs_;
}
inline const ::service_layer::SLPolicyInfo& SLPolicyGetMsgRsp::_internal_policyobjs(int index) const {
  return policyobjs_.Get(index);
}
inline const ::service_layer::SLPolicyInfo& SLPolicyGetMsgRsp::policyobjs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyGetMsgRsp.PolicyObjs)
  return _internal_policyobjs(index);
}
inline ::service_layer::SLPolicyInfo* SLPolicyGetMsgRsp::_internal_add_policyobjs() {
  return policyobjs_.Add();
}
inline ::service_layer::SLPolicyInfo* SLPolicyGetMsgRsp::add_policyobjs() {
  ::service_layer::SLPolicyInfo* _add = _internal_add_policyobjs();
  // @@protoc_insertion_point(field_add:service_layer.SLPolicyGetMsgRsp.PolicyObjs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLPolicyInfo >&
SLPolicyGetMsgRsp::policyobjs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLPolicyGetMsgRsp.PolicyObjs)
  return policyobjs_;
}

// -------------------------------------------------------------------

// SLPolicyGlobalGetMsg

// -------------------------------------------------------------------

// SLPolicyGlobalGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLPolicyGlobalGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLPolicyGlobalGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLPolicyGlobalGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLPolicyGlobalGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLPolicyGlobalGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLPolicyGlobalGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyGlobalGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLPolicyGlobalGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLPolicyGlobalGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLPolicyGlobalGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus)
}

// uint32 MaxPolicies = 2;
inline void SLPolicyGlobalGetMsgRsp::clear_maxpolicies() {
  maxpolicies_ = 0u;
}
inline uint32_t SLPolicyGlobalGetMsgRsp::_internal_maxpolicies() const {
  return maxpolicies_;
}
inline uint32_t SLPolicyGlobalGetMsgRsp::maxpolicies() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyGlobalGetMsgRsp.MaxPolicies)
  return _internal_maxpolicies();
}
inline void SLPolicyGlobalGetMsgRsp::_internal_set_maxpolicies(uint32_t value) {
  
  maxpolicies_ = value;
}
inline void SLPolicyGlobalGetMsgRsp::set_maxpolicies(uint32_t value) {
  _internal_set_maxpolicies(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyGlobalGetMsgRsp.MaxPolicies)
}

// uint32 MaxRules = 3;
inline void SLPolicyGlobalGetMsgRsp::clear_maxrules() {
  maxrules_ = 0u;
}
inline uint32_t SLPolicyGlobalGetMsgRsp::_internal_maxrules() const {
  return maxrules_;
}
inline uint32_t SLPolicyGlobalGetMsgRsp::maxrules() const {
  // @@protoc_insertion_point(field_get:service_layer.SLPolicyGlobalGetMsgRsp.MaxRules)
  return _internal_maxrules();
}
inline void SLPolicyGlobalGetMsgRsp::_internal_set_maxrules(uint32_t value) {
  
  maxrules_ = value;
}
inline void SLPolicyGlobalGetMsgRsp::set_maxrules(uint32_t value) {
  _internal_set_maxrules(value);
  // @@protoc_insertion_point(field_set:service_layer.SLPolicyGlobalGetMsgRsp.MaxRules)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service_layer::SLPolicyObjectOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLPolicyObjectOp>() {
  return ::service_layer::SLPolicyObjectOp_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLPolicyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLPolicyType>() {
  return ::service_layer::SLPolicyType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLApplyDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLApplyDirection>() {
  return ::service_layer::SLApplyDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5fpolicy_2eproto
