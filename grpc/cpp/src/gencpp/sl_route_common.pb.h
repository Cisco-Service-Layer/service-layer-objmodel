// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sl_route_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sl_5froute_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sl_5froute_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sl_common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sl_5froute_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sl_5froute_5fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sl_5froute_5fcommon_2eproto;
namespace service_layer {
class SLRouteCommon;
struct SLRouteCommonDefaultTypeInternal;
extern SLRouteCommonDefaultTypeInternal _SLRouteCommon_default_instance_;
class SLRouteGetNotifMsg;
struct SLRouteGetNotifMsgDefaultTypeInternal;
extern SLRouteGetNotifMsgDefaultTypeInternal _SLRouteGetNotifMsg_default_instance_;
class SLRouteGlobalStatsGetMsg;
struct SLRouteGlobalStatsGetMsgDefaultTypeInternal;
extern SLRouteGlobalStatsGetMsgDefaultTypeInternal _SLRouteGlobalStatsGetMsg_default_instance_;
class SLRouteGlobalStatsGetMsgRsp;
struct SLRouteGlobalStatsGetMsgRspDefaultTypeInternal;
extern SLRouteGlobalStatsGetMsgRspDefaultTypeInternal _SLRouteGlobalStatsGetMsgRsp_default_instance_;
class SLRouteGlobalsGetMsg;
struct SLRouteGlobalsGetMsgDefaultTypeInternal;
extern SLRouteGlobalsGetMsgDefaultTypeInternal _SLRouteGlobalsGetMsg_default_instance_;
class SLRouteGlobalsGetMsgRsp;
struct SLRouteGlobalsGetMsgRspDefaultTypeInternal;
extern SLRouteGlobalsGetMsgRspDefaultTypeInternal _SLRouteGlobalsGetMsgRsp_default_instance_;
class SLRouteNotifMarker;
struct SLRouteNotifMarkerDefaultTypeInternal;
extern SLRouteNotifMarkerDefaultTypeInternal _SLRouteNotifMarker_default_instance_;
class SLRouteNotifStatus;
struct SLRouteNotifStatusDefaultTypeInternal;
extern SLRouteNotifStatusDefaultTypeInternal _SLRouteNotifStatus_default_instance_;
class SLRoutePath;
struct SLRoutePathDefaultTypeInternal;
extern SLRoutePathDefaultTypeInternal _SLRoutePath_default_instance_;
class SLRoutePrefix;
struct SLRoutePrefixDefaultTypeInternal;
extern SLRoutePrefixDefaultTypeInternal _SLRoutePrefix_default_instance_;
class SLVRFGetStatsMsgRes;
struct SLVRFGetStatsMsgResDefaultTypeInternal;
extern SLVRFGetStatsMsgResDefaultTypeInternal _SLVRFGetStatsMsgRes_default_instance_;
class SLVRFGetStatsMsgRsp;
struct SLVRFGetStatsMsgRspDefaultTypeInternal;
extern SLVRFGetStatsMsgRspDefaultTypeInternal _SLVRFGetStatsMsgRsp_default_instance_;
class SLVrfNotif;
struct SLVrfNotifDefaultTypeInternal;
extern SLVrfNotifDefaultTypeInternal _SLVrfNotif_default_instance_;
class SLVrfReg;
struct SLVrfRegDefaultTypeInternal;
extern SLVrfRegDefaultTypeInternal _SLVrfReg_default_instance_;
class SLVrfRegGetMsg;
struct SLVrfRegGetMsgDefaultTypeInternal;
extern SLVrfRegGetMsgDefaultTypeInternal _SLVrfRegGetMsg_default_instance_;
class SLVrfRegGetMsgRsp;
struct SLVrfRegGetMsgRspDefaultTypeInternal;
extern SLVrfRegGetMsgRspDefaultTypeInternal _SLVrfRegGetMsgRsp_default_instance_;
class SLVrfRegMsg;
struct SLVrfRegMsgDefaultTypeInternal;
extern SLVrfRegMsgDefaultTypeInternal _SLVrfRegMsg_default_instance_;
class SLVrfRegMsgRes;
struct SLVrfRegMsgResDefaultTypeInternal;
extern SLVrfRegMsgResDefaultTypeInternal _SLVrfRegMsgRes_default_instance_;
class SLVrfRegMsgRsp;
struct SLVrfRegMsgRspDefaultTypeInternal;
extern SLVrfRegMsgRspDefaultTypeInternal _SLVrfRegMsgRsp_default_instance_;
class SLVxLANPath;
struct SLVxLANPathDefaultTypeInternal;
extern SLVxLANPathDefaultTypeInternal _SLVxLANPath_default_instance_;
}  // namespace service_layer
PROTOBUF_NAMESPACE_OPEN
template<> ::service_layer::SLRouteCommon* Arena::CreateMaybeMessage<::service_layer::SLRouteCommon>(Arena*);
template<> ::service_layer::SLRouteGetNotifMsg* Arena::CreateMaybeMessage<::service_layer::SLRouteGetNotifMsg>(Arena*);
template<> ::service_layer::SLRouteGlobalStatsGetMsg* Arena::CreateMaybeMessage<::service_layer::SLRouteGlobalStatsGetMsg>(Arena*);
template<> ::service_layer::SLRouteGlobalStatsGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLRouteGlobalStatsGetMsgRsp>(Arena*);
template<> ::service_layer::SLRouteGlobalsGetMsg* Arena::CreateMaybeMessage<::service_layer::SLRouteGlobalsGetMsg>(Arena*);
template<> ::service_layer::SLRouteGlobalsGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLRouteGlobalsGetMsgRsp>(Arena*);
template<> ::service_layer::SLRouteNotifMarker* Arena::CreateMaybeMessage<::service_layer::SLRouteNotifMarker>(Arena*);
template<> ::service_layer::SLRouteNotifStatus* Arena::CreateMaybeMessage<::service_layer::SLRouteNotifStatus>(Arena*);
template<> ::service_layer::SLRoutePath* Arena::CreateMaybeMessage<::service_layer::SLRoutePath>(Arena*);
template<> ::service_layer::SLRoutePrefix* Arena::CreateMaybeMessage<::service_layer::SLRoutePrefix>(Arena*);
template<> ::service_layer::SLVRFGetStatsMsgRes* Arena::CreateMaybeMessage<::service_layer::SLVRFGetStatsMsgRes>(Arena*);
template<> ::service_layer::SLVRFGetStatsMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLVRFGetStatsMsgRsp>(Arena*);
template<> ::service_layer::SLVrfNotif* Arena::CreateMaybeMessage<::service_layer::SLVrfNotif>(Arena*);
template<> ::service_layer::SLVrfReg* Arena::CreateMaybeMessage<::service_layer::SLVrfReg>(Arena*);
template<> ::service_layer::SLVrfRegGetMsg* Arena::CreateMaybeMessage<::service_layer::SLVrfRegGetMsg>(Arena*);
template<> ::service_layer::SLVrfRegGetMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLVrfRegGetMsgRsp>(Arena*);
template<> ::service_layer::SLVrfRegMsg* Arena::CreateMaybeMessage<::service_layer::SLVrfRegMsg>(Arena*);
template<> ::service_layer::SLVrfRegMsgRes* Arena::CreateMaybeMessage<::service_layer::SLVrfRegMsgRes>(Arena*);
template<> ::service_layer::SLVrfRegMsgRsp* Arena::CreateMaybeMessage<::service_layer::SLVrfRegMsgRsp>(Arena*);
template<> ::service_layer::SLVxLANPath* Arena::CreateMaybeMessage<::service_layer::SLVxLANPath>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service_layer {

enum SLNotifType : int {
  SL_EVENT_TYPE_RESERVED = 0,
  SL_EVENT_TYPE_ERROR = 1,
  SL_EVENT_TYPE_STATUS = 2,
  SL_EVENT_TYPE_ROUTE = 3,
  SL_EVENT_TYPE_START_MARKER = 4,
  SL_EVENT_TYPE_END_MARKER = 5,
  SL_EVENT_TYPE_VRF = 6,
  SLNotifType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLNotifType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLNotifType_IsValid(int value);
constexpr SLNotifType SLNotifType_MIN = SL_EVENT_TYPE_RESERVED;
constexpr SLNotifType SLNotifType_MAX = SL_EVENT_TYPE_VRF;
constexpr int SLNotifType_ARRAYSIZE = SLNotifType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLNotifType_descriptor();
template<typename T>
inline const std::string& SLNotifType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLNotifType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLNotifType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLNotifType_descriptor(), enum_t_value);
}
inline bool SLNotifType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLNotifType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLNotifType>(
    SLNotifType_descriptor(), name, value);
}
enum SLRouteFlags : int {
  SL_ROUTE_FLAG_RESERVED = 0,
  SL_ROUTE_FLAG_PREFER_OVER_LDP = 1,
  SL_ROUTE_FLAG_DISABLE_LABEL_MERGE = 2,
  SL_ROUTE_FLAG_VIABLE_PATHS_ONLY = 3,
  SL_ROUTE_FLAG_ACTIVE_ON_VIABLE_PATH = 4,
  SLRouteFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLRouteFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLRouteFlags_IsValid(int value);
constexpr SLRouteFlags SLRouteFlags_MIN = SL_ROUTE_FLAG_RESERVED;
constexpr SLRouteFlags SLRouteFlags_MAX = SL_ROUTE_FLAG_ACTIVE_ON_VIABLE_PATH;
constexpr int SLRouteFlags_ARRAYSIZE = SLRouteFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLRouteFlags_descriptor();
template<typename T>
inline const std::string& SLRouteFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLRouteFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLRouteFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLRouteFlags_descriptor(), enum_t_value);
}
inline bool SLRouteFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLRouteFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLRouteFlags>(
    SLRouteFlags_descriptor(), name, value);
}
enum SLPathFlags : int {
  SL_PATH_FLAG_RESERVED = 0,
  SL_PATH_FLAG_SINGLE_PATH_OPT = 1,
  SLPathFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SLPathFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SLPathFlags_IsValid(int value);
constexpr SLPathFlags SLPathFlags_MIN = SL_PATH_FLAG_RESERVED;
constexpr SLPathFlags SLPathFlags_MAX = SL_PATH_FLAG_SINGLE_PATH_OPT;
constexpr int SLPathFlags_ARRAYSIZE = SLPathFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLPathFlags_descriptor();
template<typename T>
inline const std::string& SLPathFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLPathFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLPathFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLPathFlags_descriptor(), enum_t_value);
}
inline bool SLPathFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SLPathFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLPathFlags>(
    SLPathFlags_descriptor(), name, value);
}
// ===================================================================

class SLRouteGlobalsGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:service_layer.SLRouteGlobalsGetMsg) */ {
 public:
  inline SLRouteGlobalsGetMsg() : SLRouteGlobalsGetMsg(nullptr) {}
  explicit constexpr SLRouteGlobalsGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteGlobalsGetMsg(const SLRouteGlobalsGetMsg& from);
  SLRouteGlobalsGetMsg(SLRouteGlobalsGetMsg&& from) noexcept
    : SLRouteGlobalsGetMsg() {
    *this = ::std::move(from);
  }

  inline SLRouteGlobalsGetMsg& operator=(const SLRouteGlobalsGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteGlobalsGetMsg& operator=(SLRouteGlobalsGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteGlobalsGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteGlobalsGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLRouteGlobalsGetMsg*>(
               &_SLRouteGlobalsGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SLRouteGlobalsGetMsg& a, SLRouteGlobalsGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteGlobalsGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteGlobalsGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteGlobalsGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteGlobalsGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLRouteGlobalsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLRouteGlobalsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteGlobalsGetMsg";
  }
  protected:
  explicit SLRouteGlobalsGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteGlobalsGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteGlobalsGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteGlobalsGetMsgRsp) */ {
 public:
  inline SLRouteGlobalsGetMsgRsp() : SLRouteGlobalsGetMsgRsp(nullptr) {}
  ~SLRouteGlobalsGetMsgRsp() override;
  explicit constexpr SLRouteGlobalsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteGlobalsGetMsgRsp(const SLRouteGlobalsGetMsgRsp& from);
  SLRouteGlobalsGetMsgRsp(SLRouteGlobalsGetMsgRsp&& from) noexcept
    : SLRouteGlobalsGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLRouteGlobalsGetMsgRsp& operator=(const SLRouteGlobalsGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteGlobalsGetMsgRsp& operator=(SLRouteGlobalsGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteGlobalsGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteGlobalsGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLRouteGlobalsGetMsgRsp*>(
               &_SLRouteGlobalsGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SLRouteGlobalsGetMsgRsp& a, SLRouteGlobalsGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteGlobalsGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteGlobalsGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteGlobalsGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteGlobalsGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteGlobalsGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteGlobalsGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteGlobalsGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteGlobalsGetMsgRsp";
  }
  protected:
  explicit SLRouteGlobalsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kMaxVrfregPerVrfregmsgFieldNumber = 2,
    kMaxRoutePerRoutemsgFieldNumber = 3,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint32 MaxVrfregPerVrfregmsg = 2;
  void clear_maxvrfregpervrfregmsg();
  uint32_t maxvrfregpervrfregmsg() const;
  void set_maxvrfregpervrfregmsg(uint32_t value);
  private:
  uint32_t _internal_maxvrfregpervrfregmsg() const;
  void _internal_set_maxvrfregpervrfregmsg(uint32_t value);
  public:

  // uint32 MaxRoutePerRoutemsg = 3;
  void clear_maxrouteperroutemsg();
  uint32_t maxrouteperroutemsg() const;
  void set_maxrouteperroutemsg(uint32_t value);
  private:
  uint32_t _internal_maxrouteperroutemsg() const;
  void _internal_set_maxrouteperroutemsg(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteGlobalsGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint32_t maxvrfregpervrfregmsg_;
  uint32_t maxrouteperroutemsg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteGlobalStatsGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:service_layer.SLRouteGlobalStatsGetMsg) */ {
 public:
  inline SLRouteGlobalStatsGetMsg() : SLRouteGlobalStatsGetMsg(nullptr) {}
  explicit constexpr SLRouteGlobalStatsGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteGlobalStatsGetMsg(const SLRouteGlobalStatsGetMsg& from);
  SLRouteGlobalStatsGetMsg(SLRouteGlobalStatsGetMsg&& from) noexcept
    : SLRouteGlobalStatsGetMsg() {
    *this = ::std::move(from);
  }

  inline SLRouteGlobalStatsGetMsg& operator=(const SLRouteGlobalStatsGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteGlobalStatsGetMsg& operator=(SLRouteGlobalStatsGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteGlobalStatsGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteGlobalStatsGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLRouteGlobalStatsGetMsg*>(
               &_SLRouteGlobalStatsGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SLRouteGlobalStatsGetMsg& a, SLRouteGlobalStatsGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteGlobalStatsGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteGlobalStatsGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteGlobalStatsGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteGlobalStatsGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SLRouteGlobalStatsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SLRouteGlobalStatsGetMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteGlobalStatsGetMsg";
  }
  protected:
  explicit SLRouteGlobalStatsGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteGlobalStatsGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteGlobalStatsGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteGlobalStatsGetMsgRsp) */ {
 public:
  inline SLRouteGlobalStatsGetMsgRsp() : SLRouteGlobalStatsGetMsgRsp(nullptr) {}
  ~SLRouteGlobalStatsGetMsgRsp() override;
  explicit constexpr SLRouteGlobalStatsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteGlobalStatsGetMsgRsp(const SLRouteGlobalStatsGetMsgRsp& from);
  SLRouteGlobalStatsGetMsgRsp(SLRouteGlobalStatsGetMsgRsp&& from) noexcept
    : SLRouteGlobalStatsGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLRouteGlobalStatsGetMsgRsp& operator=(const SLRouteGlobalStatsGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteGlobalStatsGetMsgRsp& operator=(SLRouteGlobalStatsGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteGlobalStatsGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteGlobalStatsGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLRouteGlobalStatsGetMsgRsp*>(
               &_SLRouteGlobalStatsGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SLRouteGlobalStatsGetMsgRsp& a, SLRouteGlobalStatsGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteGlobalStatsGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteGlobalStatsGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteGlobalStatsGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteGlobalStatsGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteGlobalStatsGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteGlobalStatsGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteGlobalStatsGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteGlobalStatsGetMsgRsp";
  }
  protected:
  explicit SLRouteGlobalStatsGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStatusFieldNumber = 1,
    kVrfCountFieldNumber = 2,
    kRouteCountFieldNumber = 3,
  };
  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // uint32 VrfCount = 2;
  void clear_vrfcount();
  uint32_t vrfcount() const;
  void set_vrfcount(uint32_t value);
  private:
  uint32_t _internal_vrfcount() const;
  void _internal_set_vrfcount(uint32_t value);
  public:

  // uint32 RouteCount = 3;
  void clear_routecount();
  uint32_t routecount() const;
  void set_routecount(uint32_t value);
  private:
  uint32_t _internal_routecount() const;
  void _internal_set_routecount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteGlobalStatsGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLErrorStatus* errstatus_;
  uint32_t vrfcount_;
  uint32_t routecount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfReg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfReg) */ {
 public:
  inline SLVrfReg() : SLVrfReg(nullptr) {}
  ~SLVrfReg() override;
  explicit constexpr SLVrfReg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfReg(const SLVrfReg& from);
  SLVrfReg(SLVrfReg&& from) noexcept
    : SLVrfReg() {
    *this = ::std::move(from);
  }

  inline SLVrfReg& operator=(const SLVrfReg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfReg& operator=(SLVrfReg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfReg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfReg* internal_default_instance() {
    return reinterpret_cast<const SLVrfReg*>(
               &_SLVrfReg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SLVrfReg& a, SLVrfReg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfReg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfReg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfReg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfReg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfReg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfReg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfReg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfReg";
  }
  protected:
  explicit SLVrfReg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kAdminDistanceFieldNumber = 2,
    kVrfPurgeIntervalSecondsFieldNumber = 3,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // uint32 AdminDistance = 2;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 VrfPurgeIntervalSeconds = 3;
  void clear_vrfpurgeintervalseconds();
  uint32_t vrfpurgeintervalseconds() const;
  void set_vrfpurgeintervalseconds(uint32_t value);
  private:
  uint32_t _internal_vrfpurgeintervalseconds() const;
  void _internal_set_vrfpurgeintervalseconds(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfReg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  uint32_t admindistance_;
  uint32_t vrfpurgeintervalseconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfRegMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfRegMsg) */ {
 public:
  inline SLVrfRegMsg() : SLVrfRegMsg(nullptr) {}
  ~SLVrfRegMsg() override;
  explicit constexpr SLVrfRegMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfRegMsg(const SLVrfRegMsg& from);
  SLVrfRegMsg(SLVrfRegMsg&& from) noexcept
    : SLVrfRegMsg() {
    *this = ::std::move(from);
  }

  inline SLVrfRegMsg& operator=(const SLVrfRegMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfRegMsg& operator=(SLVrfRegMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfRegMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfRegMsg* internal_default_instance() {
    return reinterpret_cast<const SLVrfRegMsg*>(
               &_SLVrfRegMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SLVrfRegMsg& a, SLVrfRegMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfRegMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfRegMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfRegMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfRegMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfRegMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfRegMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfRegMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfRegMsg";
  }
  protected:
  explicit SLVrfRegMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfRegMsgsFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // repeated .service_layer.SLVrfReg VrfRegMsgs = 2;
  int vrfregmsgs_size() const;
  private:
  int _internal_vrfregmsgs_size() const;
  public:
  void clear_vrfregmsgs();
  ::service_layer::SLVrfReg* mutable_vrfregmsgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
      mutable_vrfregmsgs();
  private:
  const ::service_layer::SLVrfReg& _internal_vrfregmsgs(int index) const;
  ::service_layer::SLVrfReg* _internal_add_vrfregmsgs();
  public:
  const ::service_layer::SLVrfReg& vrfregmsgs(int index) const;
  ::service_layer::SLVrfReg* add_vrfregmsgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
      vrfregmsgs() const;

  // .service_layer.SLRegOp Oper = 1;
  void clear_oper();
  ::service_layer::SLRegOp oper() const;
  void set_oper(::service_layer::SLRegOp value);
  private:
  ::service_layer::SLRegOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLRegOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfRegMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg > vrfregmsgs_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfRegMsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfRegMsgRes) */ {
 public:
  inline SLVrfRegMsgRes() : SLVrfRegMsgRes(nullptr) {}
  ~SLVrfRegMsgRes() override;
  explicit constexpr SLVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfRegMsgRes(const SLVrfRegMsgRes& from);
  SLVrfRegMsgRes(SLVrfRegMsgRes&& from) noexcept
    : SLVrfRegMsgRes() {
    *this = ::std::move(from);
  }

  inline SLVrfRegMsgRes& operator=(const SLVrfRegMsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfRegMsgRes& operator=(SLVrfRegMsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfRegMsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfRegMsgRes* internal_default_instance() {
    return reinterpret_cast<const SLVrfRegMsgRes*>(
               &_SLVrfRegMsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SLVrfRegMsgRes& a, SLVrfRegMsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfRegMsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfRegMsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfRegMsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfRegMsgRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfRegMsgRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfRegMsgRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfRegMsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfRegMsgRes";
  }
  protected:
  explicit SLVrfRegMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 2,
    kErrStatusFieldNumber = 1,
  };
  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus ErrStatus = 1;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfRegMsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* errstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfRegMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfRegMsgRsp) */ {
 public:
  inline SLVrfRegMsgRsp() : SLVrfRegMsgRsp(nullptr) {}
  ~SLVrfRegMsgRsp() override;
  explicit constexpr SLVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfRegMsgRsp(const SLVrfRegMsgRsp& from);
  SLVrfRegMsgRsp(SLVrfRegMsgRsp&& from) noexcept
    : SLVrfRegMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLVrfRegMsgRsp& operator=(const SLVrfRegMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfRegMsgRsp& operator=(SLVrfRegMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfRegMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfRegMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLVrfRegMsgRsp*>(
               &_SLVrfRegMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SLVrfRegMsgRsp& a, SLVrfRegMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfRegMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfRegMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfRegMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfRegMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfRegMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfRegMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfRegMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfRegMsgRsp";
  }
  protected:
  explicit SLVrfRegMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kStatusSummaryFieldNumber = 1,
  };
  // repeated .service_layer.SLVrfRegMsgRes Results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::service_layer::SLVrfRegMsgRes* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfRegMsgRes >*
      mutable_results();
  private:
  const ::service_layer::SLVrfRegMsgRes& _internal_results(int index) const;
  ::service_layer::SLVrfRegMsgRes* _internal_add_results();
  public:
  const ::service_layer::SLVrfRegMsgRes& results(int index) const;
  ::service_layer::SLVrfRegMsgRes* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfRegMsgRes >&
      results() const;

  // .service_layer.SLErrorStatus StatusSummary = 1;
  bool has_statussummary() const;
  private:
  bool _internal_has_statussummary() const;
  public:
  void clear_statussummary();
  const ::service_layer::SLErrorStatus& statussummary() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_statussummary();
  ::service_layer::SLErrorStatus* mutable_statussummary();
  void set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary);
  private:
  const ::service_layer::SLErrorStatus& _internal_statussummary() const;
  ::service_layer::SLErrorStatus* _internal_mutable_statussummary();
  public:
  void unsafe_arena_set_allocated_statussummary(
      ::service_layer::SLErrorStatus* statussummary);
  ::service_layer::SLErrorStatus* unsafe_arena_release_statussummary();

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfRegMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfRegMsgRes > results_;
  ::service_layer::SLErrorStatus* statussummary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfRegGetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfRegGetMsg) */ {
 public:
  inline SLVrfRegGetMsg() : SLVrfRegGetMsg(nullptr) {}
  ~SLVrfRegGetMsg() override;
  explicit constexpr SLVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfRegGetMsg(const SLVrfRegGetMsg& from);
  SLVrfRegGetMsg(SLVrfRegGetMsg&& from) noexcept
    : SLVrfRegGetMsg() {
    *this = ::std::move(from);
  }

  inline SLVrfRegGetMsg& operator=(const SLVrfRegGetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfRegGetMsg& operator=(SLVrfRegGetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfRegGetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfRegGetMsg* internal_default_instance() {
    return reinterpret_cast<const SLVrfRegGetMsg*>(
               &_SLVrfRegGetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLVrfRegGetMsg& a, SLVrfRegGetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfRegGetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfRegGetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfRegGetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfRegGetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfRegGetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfRegGetMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfRegGetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfRegGetMsg";
  }
  protected:
  explicit SLVrfRegGetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kEntriesCountFieldNumber = 2,
    kGetNextFieldNumber = 3,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // uint32 EntriesCount = 2;
  void clear_entriescount();
  uint32_t entriescount() const;
  void set_entriescount(uint32_t value);
  private:
  uint32_t _internal_entriescount() const;
  void _internal_set_entriescount(uint32_t value);
  public:

  // bool GetNext = 3;
  void clear_getnext();
  bool getnext() const;
  void set_getnext(bool value);
  private:
  bool _internal_getnext() const;
  void _internal_set_getnext(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfRegGetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  uint32_t entriescount_;
  bool getnext_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfRegGetMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfRegGetMsgRsp) */ {
 public:
  inline SLVrfRegGetMsgRsp() : SLVrfRegGetMsgRsp(nullptr) {}
  ~SLVrfRegGetMsgRsp() override;
  explicit constexpr SLVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfRegGetMsgRsp(const SLVrfRegGetMsgRsp& from);
  SLVrfRegGetMsgRsp(SLVrfRegGetMsgRsp&& from) noexcept
    : SLVrfRegGetMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLVrfRegGetMsgRsp& operator=(const SLVrfRegGetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfRegGetMsgRsp& operator=(SLVrfRegGetMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfRegGetMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfRegGetMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLVrfRegGetMsgRsp*>(
               &_SLVrfRegGetMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLVrfRegGetMsgRsp& a, SLVrfRegGetMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfRegGetMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfRegGetMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfRegGetMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfRegGetMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfRegGetMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfRegGetMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfRegGetMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfRegGetMsgRsp";
  }
  protected:
  explicit SLVrfRegGetMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kErrStatusFieldNumber = 2,
    kEofFieldNumber = 1,
  };
  // repeated .service_layer.SLVrfReg Entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::service_layer::SLVrfReg* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
      mutable_entries();
  private:
  const ::service_layer::SLVrfReg& _internal_entries(int index) const;
  ::service_layer::SLVrfReg* _internal_add_entries();
  public:
  const ::service_layer::SLVrfReg& entries(int index) const;
  ::service_layer::SLVrfReg* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
      entries() const;

  // .service_layer.SLErrorStatus ErrStatus = 2;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // bool Eof = 1;
  void clear_eof();
  bool eof() const;
  void set_eof(bool value);
  private:
  bool _internal_eof() const;
  void _internal_set_eof(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfRegGetMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg > entries_;
  ::service_layer::SLErrorStatus* errstatus_;
  bool eof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVRFGetStatsMsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVRFGetStatsMsgRes) */ {
 public:
  inline SLVRFGetStatsMsgRes() : SLVRFGetStatsMsgRes(nullptr) {}
  ~SLVRFGetStatsMsgRes() override;
  explicit constexpr SLVRFGetStatsMsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVRFGetStatsMsgRes(const SLVRFGetStatsMsgRes& from);
  SLVRFGetStatsMsgRes(SLVRFGetStatsMsgRes&& from) noexcept
    : SLVRFGetStatsMsgRes() {
    *this = ::std::move(from);
  }

  inline SLVRFGetStatsMsgRes& operator=(const SLVRFGetStatsMsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVRFGetStatsMsgRes& operator=(SLVRFGetStatsMsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVRFGetStatsMsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVRFGetStatsMsgRes* internal_default_instance() {
    return reinterpret_cast<const SLVRFGetStatsMsgRes*>(
               &_SLVRFGetStatsMsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SLVRFGetStatsMsgRes& a, SLVRFGetStatsMsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVRFGetStatsMsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVRFGetStatsMsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVRFGetStatsMsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVRFGetStatsMsgRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVRFGetStatsMsgRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVRFGetStatsMsgRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVRFGetStatsMsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVRFGetStatsMsgRes";
  }
  protected:
  explicit SLVRFGetStatsMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kRouteCountFieldNumber = 2,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // uint32 RouteCount = 2;
  void clear_routecount();
  uint32_t routecount() const;
  void set_routecount(uint32_t value);
  private:
  uint32_t _internal_routecount() const;
  void _internal_set_routecount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVRFGetStatsMsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  uint32_t routecount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVRFGetStatsMsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVRFGetStatsMsgRsp) */ {
 public:
  inline SLVRFGetStatsMsgRsp() : SLVRFGetStatsMsgRsp(nullptr) {}
  ~SLVRFGetStatsMsgRsp() override;
  explicit constexpr SLVRFGetStatsMsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVRFGetStatsMsgRsp(const SLVRFGetStatsMsgRsp& from);
  SLVRFGetStatsMsgRsp(SLVRFGetStatsMsgRsp&& from) noexcept
    : SLVRFGetStatsMsgRsp() {
    *this = ::std::move(from);
  }

  inline SLVRFGetStatsMsgRsp& operator=(const SLVRFGetStatsMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVRFGetStatsMsgRsp& operator=(SLVRFGetStatsMsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVRFGetStatsMsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVRFGetStatsMsgRsp* internal_default_instance() {
    return reinterpret_cast<const SLVRFGetStatsMsgRsp*>(
               &_SLVRFGetStatsMsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SLVRFGetStatsMsgRsp& a, SLVRFGetStatsMsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVRFGetStatsMsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVRFGetStatsMsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVRFGetStatsMsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVRFGetStatsMsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVRFGetStatsMsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVRFGetStatsMsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVRFGetStatsMsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVRFGetStatsMsgRsp";
  }
  protected:
  explicit SLVRFGetStatsMsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kErrStatusFieldNumber = 2,
    kEofFieldNumber = 1,
  };
  // repeated .service_layer.SLVRFGetStatsMsgRes Entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::service_layer::SLVRFGetStatsMsgRes* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVRFGetStatsMsgRes >*
      mutable_entries();
  private:
  const ::service_layer::SLVRFGetStatsMsgRes& _internal_entries(int index) const;
  ::service_layer::SLVRFGetStatsMsgRes* _internal_add_entries();
  public:
  const ::service_layer::SLVRFGetStatsMsgRes& entries(int index) const;
  ::service_layer::SLVRFGetStatsMsgRes* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVRFGetStatsMsgRes >&
      entries() const;

  // .service_layer.SLErrorStatus ErrStatus = 2;
  bool has_errstatus() const;
  private:
  bool _internal_has_errstatus() const;
  public:
  void clear_errstatus();
  const ::service_layer::SLErrorStatus& errstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_errstatus();
  ::service_layer::SLErrorStatus* mutable_errstatus();
  void set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_errstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_errstatus();
  public:
  void unsafe_arena_set_allocated_errstatus(
      ::service_layer::SLErrorStatus* errstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_errstatus();

  // bool Eof = 1;
  void clear_eof();
  bool eof() const;
  void set_eof(bool value);
  private:
  bool _internal_eof() const;
  void _internal_set_eof(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVRFGetStatsMsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVRFGetStatsMsgRes > entries_;
  ::service_layer::SLErrorStatus* errstatus_;
  bool eof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteGetNotifMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteGetNotifMsg) */ {
 public:
  inline SLRouteGetNotifMsg() : SLRouteGetNotifMsg(nullptr) {}
  ~SLRouteGetNotifMsg() override;
  explicit constexpr SLRouteGetNotifMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteGetNotifMsg(const SLRouteGetNotifMsg& from);
  SLRouteGetNotifMsg(SLRouteGetNotifMsg&& from) noexcept
    : SLRouteGetNotifMsg() {
    *this = ::std::move(from);
  }

  inline SLRouteGetNotifMsg& operator=(const SLRouteGetNotifMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteGetNotifMsg& operator=(SLRouteGetNotifMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteGetNotifMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteGetNotifMsg* internal_default_instance() {
    return reinterpret_cast<const SLRouteGetNotifMsg*>(
               &_SLRouteGetNotifMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SLRouteGetNotifMsg& a, SLRouteGetNotifMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteGetNotifMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteGetNotifMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteGetNotifMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteGetNotifMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteGetNotifMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteGetNotifMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteGetNotifMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteGetNotifMsg";
  }
  protected:
  explicit SLRouteGetNotifMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 3,
    kSrcProtoFieldNumber = 4,
    kSrcProtoTagFieldNumber = 5,
    kCorrelatorFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // string VrfName = 3;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // string SrcProto = 4;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 5;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // uint64 Correlator = 2;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // .service_layer.SLNotifOp Oper = 1;
  void clear_oper();
  ::service_layer::SLNotifOp oper() const;
  void set_oper(::service_layer::SLNotifOp value);
  private:
  ::service_layer::SLNotifOp _internal_oper() const;
  void _internal_set_oper(::service_layer::SLNotifOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteGetNotifMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  uint64_t correlator_;
  int oper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteNotifStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteNotifStatus) */ {
 public:
  inline SLRouteNotifStatus() : SLRouteNotifStatus(nullptr) {}
  ~SLRouteNotifStatus() override;
  explicit constexpr SLRouteNotifStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteNotifStatus(const SLRouteNotifStatus& from);
  SLRouteNotifStatus(SLRouteNotifStatus&& from) noexcept
    : SLRouteNotifStatus() {
    *this = ::std::move(from);
  }

  inline SLRouteNotifStatus& operator=(const SLRouteNotifStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteNotifStatus& operator=(SLRouteNotifStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteNotifStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteNotifStatus* internal_default_instance() {
    return reinterpret_cast<const SLRouteNotifStatus*>(
               &_SLRouteNotifStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SLRouteNotifStatus& a, SLRouteNotifStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteNotifStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteNotifStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteNotifStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteNotifStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteNotifStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteNotifStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteNotifStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteNotifStatus";
  }
  protected:
  explicit SLRouteNotifStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 2,
    kNotifStatusFieldNumber = 3,
    kCorrelatorFieldNumber = 1,
  };
  // string VrfName = 2;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLErrorStatus NotifStatus = 3;
  bool has_notifstatus() const;
  private:
  bool _internal_has_notifstatus() const;
  public:
  void clear_notifstatus();
  const ::service_layer::SLErrorStatus& notifstatus() const;
  PROTOBUF_NODISCARD ::service_layer::SLErrorStatus* release_notifstatus();
  ::service_layer::SLErrorStatus* mutable_notifstatus();
  void set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus);
  private:
  const ::service_layer::SLErrorStatus& _internal_notifstatus() const;
  ::service_layer::SLErrorStatus* _internal_mutable_notifstatus();
  public:
  void unsafe_arena_set_allocated_notifstatus(
      ::service_layer::SLErrorStatus* notifstatus);
  ::service_layer::SLErrorStatus* unsafe_arena_release_notifstatus();

  // uint64 Correlator = 1;
  void clear_correlator();
  uint64_t correlator() const;
  void set_correlator(uint64_t value);
  private:
  uint64_t _internal_correlator() const;
  void _internal_set_correlator(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteNotifStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::service_layer::SLErrorStatus* notifstatus_;
  uint64_t correlator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteNotifMarker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteNotifMarker) */ {
 public:
  inline SLRouteNotifMarker() : SLRouteNotifMarker(nullptr) {}
  ~SLRouteNotifMarker() override;
  explicit constexpr SLRouteNotifMarker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteNotifMarker(const SLRouteNotifMarker& from);
  SLRouteNotifMarker(SLRouteNotifMarker&& from) noexcept
    : SLRouteNotifMarker() {
    *this = ::std::move(from);
  }

  inline SLRouteNotifMarker& operator=(const SLRouteNotifMarker& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteNotifMarker& operator=(SLRouteNotifMarker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteNotifMarker& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteNotifMarker* internal_default_instance() {
    return reinterpret_cast<const SLRouteNotifMarker*>(
               &_SLRouteNotifMarker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SLRouteNotifMarker& a, SLRouteNotifMarker& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteNotifMarker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteNotifMarker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteNotifMarker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteNotifMarker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteNotifMarker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteNotifMarker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteNotifMarker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteNotifMarker";
  }
  protected:
  explicit SLRouteNotifMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteNotifMarker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVrfNotif final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVrfNotif) */ {
 public:
  inline SLVrfNotif() : SLVrfNotif(nullptr) {}
  ~SLVrfNotif() override;
  explicit constexpr SLVrfNotif(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVrfNotif(const SLVrfNotif& from);
  SLVrfNotif(SLVrfNotif&& from) noexcept
    : SLVrfNotif() {
    *this = ::std::move(from);
  }

  inline SLVrfNotif& operator=(const SLVrfNotif& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVrfNotif& operator=(SLVrfNotif&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVrfNotif& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVrfNotif* internal_default_instance() {
    return reinterpret_cast<const SLVrfNotif*>(
               &_SLVrfNotif_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SLVrfNotif& a, SLVrfNotif& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVrfNotif* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVrfNotif* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVrfNotif* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVrfNotif>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVrfNotif& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVrfNotif& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVrfNotif* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVrfNotif";
  }
  protected:
  explicit SLVrfNotif(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrfNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string VrfName = 1;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // .service_layer.SLObjectOp Status = 2;
  void clear_status();
  ::service_layer::SLObjectOp status() const;
  void set_status(::service_layer::SLObjectOp value);
  private:
  ::service_layer::SLObjectOp _internal_status() const;
  void _internal_set_status(::service_layer::SLObjectOp value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVrfNotif)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRouteCommon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRouteCommon) */ {
 public:
  inline SLRouteCommon() : SLRouteCommon(nullptr) {}
  ~SLRouteCommon() override;
  explicit constexpr SLRouteCommon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRouteCommon(const SLRouteCommon& from);
  SLRouteCommon(SLRouteCommon&& from) noexcept
    : SLRouteCommon() {
    *this = ::std::move(from);
  }

  inline SLRouteCommon& operator=(const SLRouteCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRouteCommon& operator=(SLRouteCommon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRouteCommon& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRouteCommon* internal_default_instance() {
    return reinterpret_cast<const SLRouteCommon*>(
               &_SLRouteCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SLRouteCommon& a, SLRouteCommon& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRouteCommon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRouteCommon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRouteCommon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRouteCommon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRouteCommon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRouteCommon& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRouteCommon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRouteCommon";
  }
  protected:
  explicit SLRouteCommon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteFlagsFieldNumber = 7,
    kSrcProtoFieldNumber = 4,
    kSrcProtoTagFieldNumber = 5,
    kAdminDistanceFieldNumber = 1,
    kLocalLabelFieldNumber = 2,
    kTagFieldNumber = 3,
    kMetricFieldNumber = 8,
    kPriorityFieldNumber = 9,
  };
  // repeated .service_layer.SLRouteFlags RouteFlags = 7;
  int routeflags_size() const;
  private:
  int _internal_routeflags_size() const;
  public:
  void clear_routeflags();
  private:
  ::service_layer::SLRouteFlags _internal_routeflags(int index) const;
  void _internal_add_routeflags(::service_layer::SLRouteFlags value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_routeflags();
  public:
  ::service_layer::SLRouteFlags routeflags(int index) const;
  void set_routeflags(int index, ::service_layer::SLRouteFlags value);
  void add_routeflags(::service_layer::SLRouteFlags value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& routeflags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_routeflags();

  // string SrcProto = 4;
  void clear_srcproto();
  const std::string& srcproto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcproto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcproto();
  PROTOBUF_NODISCARD std::string* release_srcproto();
  void set_allocated_srcproto(std::string* srcproto);
  private:
  const std::string& _internal_srcproto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcproto(const std::string& value);
  std::string* _internal_mutable_srcproto();
  public:

  // string SrcProtoTag = 5;
  void clear_srcprototag();
  const std::string& srcprototag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcprototag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcprototag();
  PROTOBUF_NODISCARD std::string* release_srcprototag();
  void set_allocated_srcprototag(std::string* srcprototag);
  private:
  const std::string& _internal_srcprototag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcprototag(const std::string& value);
  std::string* _internal_mutable_srcprototag();
  public:

  // uint32 AdminDistance = 1;
  void clear_admindistance();
  uint32_t admindistance() const;
  void set_admindistance(uint32_t value);
  private:
  uint32_t _internal_admindistance() const;
  void _internal_set_admindistance(uint32_t value);
  public:

  // uint32 LocalLabel = 2;
  void clear_locallabel();
  uint32_t locallabel() const;
  void set_locallabel(uint32_t value);
  private:
  uint32_t _internal_locallabel() const;
  void _internal_set_locallabel(uint32_t value);
  public:

  // uint32 Tag = 3;
  void clear_tag();
  uint32_t tag() const;
  void set_tag(uint32_t value);
  private:
  uint32_t _internal_tag() const;
  void _internal_set_tag(uint32_t value);
  public:

  // uint32 Metric = 8;
  void clear_metric();
  uint32_t metric() const;
  void set_metric(uint32_t value);
  private:
  uint32_t _internal_metric() const;
  void _internal_set_metric(uint32_t value);
  public:

  // .service_layer.SLUpdatePriority Priority = 9;
  void clear_priority();
  ::service_layer::SLUpdatePriority priority() const;
  void set_priority(::service_layer::SLUpdatePriority value);
  private:
  ::service_layer::SLUpdatePriority _internal_priority() const;
  void _internal_set_priority(::service_layer::SLUpdatePriority value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRouteCommon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> routeflags_;
  mutable std::atomic<int> _routeflags_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcproto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcprototag_;
  uint32_t admindistance_;
  uint32_t locallabel_;
  uint32_t tag_;
  uint32_t metric_;
  int priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLVxLANPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLVxLANPath) */ {
 public:
  inline SLVxLANPath() : SLVxLANPath(nullptr) {}
  ~SLVxLANPath() override;
  explicit constexpr SLVxLANPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLVxLANPath(const SLVxLANPath& from);
  SLVxLANPath(SLVxLANPath&& from) noexcept
    : SLVxLANPath() {
    *this = ::std::move(from);
  }

  inline SLVxLANPath& operator=(const SLVxLANPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLVxLANPath& operator=(SLVxLANPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLVxLANPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLVxLANPath* internal_default_instance() {
    return reinterpret_cast<const SLVxLANPath*>(
               &_SLVxLANPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SLVxLANPath& a, SLVxLANPath& b) {
    a.Swap(&b);
  }
  inline void Swap(SLVxLANPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLVxLANPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLVxLANPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLVxLANPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLVxLANPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLVxLANPath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLVxLANPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLVxLANPath";
  }
  protected:
  explicit SLVxLANPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceMacAddressFieldNumber = 2,
    kDestMacAddressFieldNumber = 3,
    kSrcIpAddressFieldNumber = 4,
    kDestIpAddressFieldNumber = 5,
    kVNIFieldNumber = 1,
  };
  // bytes SourceMacAddress = 2;
  void clear_sourcemacaddress();
  const std::string& sourcemacaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcemacaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcemacaddress();
  PROTOBUF_NODISCARD std::string* release_sourcemacaddress();
  void set_allocated_sourcemacaddress(std::string* sourcemacaddress);
  private:
  const std::string& _internal_sourcemacaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcemacaddress(const std::string& value);
  std::string* _internal_mutable_sourcemacaddress();
  public:

  // bytes DestMacAddress = 3;
  void clear_destmacaddress();
  const std::string& destmacaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destmacaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destmacaddress();
  PROTOBUF_NODISCARD std::string* release_destmacaddress();
  void set_allocated_destmacaddress(std::string* destmacaddress);
  private:
  const std::string& _internal_destmacaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destmacaddress(const std::string& value);
  std::string* _internal_mutable_destmacaddress();
  public:

  // .service_layer.SLIpAddress SrcIpAddress = 4;
  bool has_srcipaddress() const;
  private:
  bool _internal_has_srcipaddress() const;
  public:
  void clear_srcipaddress();
  const ::service_layer::SLIpAddress& srcipaddress() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_srcipaddress();
  ::service_layer::SLIpAddress* mutable_srcipaddress();
  void set_allocated_srcipaddress(::service_layer::SLIpAddress* srcipaddress);
  private:
  const ::service_layer::SLIpAddress& _internal_srcipaddress() const;
  ::service_layer::SLIpAddress* _internal_mutable_srcipaddress();
  public:
  void unsafe_arena_set_allocated_srcipaddress(
      ::service_layer::SLIpAddress* srcipaddress);
  ::service_layer::SLIpAddress* unsafe_arena_release_srcipaddress();

  // .service_layer.SLIpAddress DestIpAddress = 5;
  bool has_destipaddress() const;
  private:
  bool _internal_has_destipaddress() const;
  public:
  void clear_destipaddress();
  const ::service_layer::SLIpAddress& destipaddress() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_destipaddress();
  ::service_layer::SLIpAddress* mutable_destipaddress();
  void set_allocated_destipaddress(::service_layer::SLIpAddress* destipaddress);
  private:
  const ::service_layer::SLIpAddress& _internal_destipaddress() const;
  ::service_layer::SLIpAddress* _internal_mutable_destipaddress();
  public:
  void unsafe_arena_set_allocated_destipaddress(
      ::service_layer::SLIpAddress* destipaddress);
  ::service_layer::SLIpAddress* unsafe_arena_release_destipaddress();

  // uint32 VNI = 1;
  void clear_vni();
  uint32_t vni() const;
  void set_vni(uint32_t value);
  private:
  uint32_t _internal_vni() const;
  void _internal_set_vni(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLVxLANPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcemacaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destmacaddress_;
  ::service_layer::SLIpAddress* srcipaddress_;
  ::service_layer::SLIpAddress* destipaddress_;
  uint32_t vni_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRoutePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRoutePath) */ {
 public:
  inline SLRoutePath() : SLRoutePath(nullptr) {}
  ~SLRoutePath() override;
  explicit constexpr SLRoutePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRoutePath(const SLRoutePath& from);
  SLRoutePath(SLRoutePath&& from) noexcept
    : SLRoutePath() {
    *this = ::std::move(from);
  }

  inline SLRoutePath& operator=(const SLRoutePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRoutePath& operator=(SLRoutePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRoutePath& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kPathGroupKey = 15,
    ENTRY_NOT_SET = 0,
  };

  static inline const SLRoutePath* internal_default_instance() {
    return reinterpret_cast<const SLRoutePath*>(
               &_SLRoutePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SLRoutePath& a, SLRoutePath& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRoutePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRoutePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRoutePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRoutePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRoutePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRoutePath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRoutePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRoutePath";
  }
  protected:
  explicit SLRoutePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtectedPathBitmapFieldNumber = 7,
    kLabelStackFieldNumber = 8,
    kRemoteAddressFieldNumber = 9,
    kPathFlagsFieldNumber = 14,
    kVrfNameFieldNumber = 4,
    kVtepRouterMacAddressFieldNumber = 11,
    kNexthopAddressFieldNumber = 1,
    kNexthopInterfaceFieldNumber = 2,
    kVxLANPathFieldNumber = 12,
    kLoadMetricFieldNumber = 3,
    kPathIdFieldNumber = 6,
    kEncapTypeFieldNumber = 10,
    kPathGroupKeyFieldNumber = 15,
  };
  // repeated uint64 ProtectedPathBitmap = 7;
  int protectedpathbitmap_size() const;
  private:
  int _internal_protectedpathbitmap_size() const;
  public:
  void clear_protectedpathbitmap();
  private:
  uint64_t _internal_protectedpathbitmap(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_protectedpathbitmap() const;
  void _internal_add_protectedpathbitmap(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_protectedpathbitmap();
  public:
  uint64_t protectedpathbitmap(int index) const;
  void set_protectedpathbitmap(int index, uint64_t value);
  void add_protectedpathbitmap(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      protectedpathbitmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_protectedpathbitmap();

  // repeated uint32 LabelStack = 8;
  int labelstack_size() const;
  private:
  int _internal_labelstack_size() const;
  public:
  void clear_labelstack();
  private:
  uint32_t _internal_labelstack(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_labelstack() const;
  void _internal_add_labelstack(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_labelstack();
  public:
  uint32_t labelstack(int index) const;
  void set_labelstack(int index, uint32_t value);
  void add_labelstack(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      labelstack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_labelstack();

  // repeated .service_layer.SLIpAddress RemoteAddress = 9;
  int remoteaddress_size() const;
  private:
  int _internal_remoteaddress_size() const;
  public:
  void clear_remoteaddress();
  ::service_layer::SLIpAddress* mutable_remoteaddress(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLIpAddress >*
      mutable_remoteaddress();
  private:
  const ::service_layer::SLIpAddress& _internal_remoteaddress(int index) const;
  ::service_layer::SLIpAddress* _internal_add_remoteaddress();
  public:
  const ::service_layer::SLIpAddress& remoteaddress(int index) const;
  ::service_layer::SLIpAddress* add_remoteaddress();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLIpAddress >&
      remoteaddress() const;

  // repeated .service_layer.SLPathFlags PathFlags = 14;
  int pathflags_size() const;
  private:
  int _internal_pathflags_size() const;
  public:
  void clear_pathflags();
  private:
  ::service_layer::SLPathFlags _internal_pathflags(int index) const;
  void _internal_add_pathflags(::service_layer::SLPathFlags value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_pathflags();
  public:
  ::service_layer::SLPathFlags pathflags(int index) const;
  void set_pathflags(int index, ::service_layer::SLPathFlags value);
  void add_pathflags(::service_layer::SLPathFlags value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& pathflags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_pathflags();

  // string VrfName = 4;
  void clear_vrfname();
  const std::string& vrfname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vrfname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vrfname();
  PROTOBUF_NODISCARD std::string* release_vrfname();
  void set_allocated_vrfname(std::string* vrfname);
  private:
  const std::string& _internal_vrfname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vrfname(const std::string& value);
  std::string* _internal_mutable_vrfname();
  public:

  // bytes VtepRouterMacAddress = 11 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_vteproutermacaddress();
  PROTOBUF_DEPRECATED const std::string& vteproutermacaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_vteproutermacaddress(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_vteproutermacaddress();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_vteproutermacaddress();
  PROTOBUF_DEPRECATED void set_allocated_vteproutermacaddress(std::string* vteproutermacaddress);
  private:
  const std::string& _internal_vteproutermacaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vteproutermacaddress(const std::string& value);
  std::string* _internal_mutable_vteproutermacaddress();
  public:

  // .service_layer.SLIpAddress NexthopAddress = 1;
  bool has_nexthopaddress() const;
  private:
  bool _internal_has_nexthopaddress() const;
  public:
  void clear_nexthopaddress();
  const ::service_layer::SLIpAddress& nexthopaddress() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_nexthopaddress();
  ::service_layer::SLIpAddress* mutable_nexthopaddress();
  void set_allocated_nexthopaddress(::service_layer::SLIpAddress* nexthopaddress);
  private:
  const ::service_layer::SLIpAddress& _internal_nexthopaddress() const;
  ::service_layer::SLIpAddress* _internal_mutable_nexthopaddress();
  public:
  void unsafe_arena_set_allocated_nexthopaddress(
      ::service_layer::SLIpAddress* nexthopaddress);
  ::service_layer::SLIpAddress* unsafe_arena_release_nexthopaddress();

  // .service_layer.SLInterface NexthopInterface = 2;
  bool has_nexthopinterface() const;
  private:
  bool _internal_has_nexthopinterface() const;
  public:
  void clear_nexthopinterface();
  const ::service_layer::SLInterface& nexthopinterface() const;
  PROTOBUF_NODISCARD ::service_layer::SLInterface* release_nexthopinterface();
  ::service_layer::SLInterface* mutable_nexthopinterface();
  void set_allocated_nexthopinterface(::service_layer::SLInterface* nexthopinterface);
  private:
  const ::service_layer::SLInterface& _internal_nexthopinterface() const;
  ::service_layer::SLInterface* _internal_mutable_nexthopinterface();
  public:
  void unsafe_arena_set_allocated_nexthopinterface(
      ::service_layer::SLInterface* nexthopinterface);
  ::service_layer::SLInterface* unsafe_arena_release_nexthopinterface();

  // .service_layer.SLVxLANPath VxLANPath = 12;
  bool has_vxlanpath() const;
  private:
  bool _internal_has_vxlanpath() const;
  public:
  void clear_vxlanpath();
  const ::service_layer::SLVxLANPath& vxlanpath() const;
  PROTOBUF_NODISCARD ::service_layer::SLVxLANPath* release_vxlanpath();
  ::service_layer::SLVxLANPath* mutable_vxlanpath();
  void set_allocated_vxlanpath(::service_layer::SLVxLANPath* vxlanpath);
  private:
  const ::service_layer::SLVxLANPath& _internal_vxlanpath() const;
  ::service_layer::SLVxLANPath* _internal_mutable_vxlanpath();
  public:
  void unsafe_arena_set_allocated_vxlanpath(
      ::service_layer::SLVxLANPath* vxlanpath);
  ::service_layer::SLVxLANPath* unsafe_arena_release_vxlanpath();

  // uint32 LoadMetric = 3;
  void clear_loadmetric();
  uint32_t loadmetric() const;
  void set_loadmetric(uint32_t value);
  private:
  uint32_t _internal_loadmetric() const;
  void _internal_set_loadmetric(uint32_t value);
  public:

  // uint32 PathId = 6;
  void clear_pathid();
  uint32_t pathid() const;
  void set_pathid(uint32_t value);
  private:
  uint32_t _internal_pathid() const;
  void _internal_set_pathid(uint32_t value);
  public:

  // .service_layer.SLEncapType EncapType = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_encaptype();
  PROTOBUF_DEPRECATED ::service_layer::SLEncapType encaptype() const;
  PROTOBUF_DEPRECATED void set_encaptype(::service_layer::SLEncapType value);
  private:
  ::service_layer::SLEncapType _internal_encaptype() const;
  void _internal_set_encaptype(::service_layer::SLEncapType value);
  public:

  // .service_layer.SLPathGroupRefKey PathGroupKey = 15;
  bool has_pathgroupkey() const;
  private:
  bool _internal_has_pathgroupkey() const;
  public:
  void clear_pathgroupkey();
  const ::service_layer::SLPathGroupRefKey& pathgroupkey() const;
  PROTOBUF_NODISCARD ::service_layer::SLPathGroupRefKey* release_pathgroupkey();
  ::service_layer::SLPathGroupRefKey* mutable_pathgroupkey();
  void set_allocated_pathgroupkey(::service_layer::SLPathGroupRefKey* pathgroupkey);
  private:
  const ::service_layer::SLPathGroupRefKey& _internal_pathgroupkey() const;
  ::service_layer::SLPathGroupRefKey* _internal_mutable_pathgroupkey();
  public:
  void unsafe_arena_set_allocated_pathgroupkey(
      ::service_layer::SLPathGroupRefKey* pathgroupkey);
  ::service_layer::SLPathGroupRefKey* unsafe_arena_release_pathgroupkey();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:service_layer.SLRoutePath)
 private:
  class _Internal;
  void set_has_pathgroupkey();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > protectedpathbitmap_;
  mutable std::atomic<int> _protectedpathbitmap_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > labelstack_;
  mutable std::atomic<int> _labelstack_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLIpAddress > remoteaddress_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> pathflags_;
  mutable std::atomic<int> _pathflags_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vrfname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vteproutermacaddress_;
  ::service_layer::SLIpAddress* nexthopaddress_;
  ::service_layer::SLInterface* nexthopinterface_;
  ::service_layer::SLVxLANPath* vxlanpath_;
  uint32_t loadmetric_;
  uint32_t pathid_;
  int encaptype_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::service_layer::SLPathGroupRefKey* pathgroupkey_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SLRoutePrefix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service_layer.SLRoutePrefix) */ {
 public:
  inline SLRoutePrefix() : SLRoutePrefix(nullptr) {}
  ~SLRoutePrefix() override;
  explicit constexpr SLRoutePrefix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLRoutePrefix(const SLRoutePrefix& from);
  SLRoutePrefix(SLRoutePrefix&& from) noexcept
    : SLRoutePrefix() {
    *this = ::std::move(from);
  }

  inline SLRoutePrefix& operator=(const SLRoutePrefix& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLRoutePrefix& operator=(SLRoutePrefix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLRoutePrefix& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLRoutePrefix* internal_default_instance() {
    return reinterpret_cast<const SLRoutePrefix*>(
               &_SLRoutePrefix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SLRoutePrefix& a, SLRoutePrefix& b) {
    a.Swap(&b);
  }
  inline void Swap(SLRoutePrefix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLRoutePrefix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLRoutePrefix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SLRoutePrefix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLRoutePrefix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLRoutePrefix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLRoutePrefix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service_layer.SLRoutePrefix";
  }
  protected:
  explicit SLRoutePrefix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
    kPrefixLenFieldNumber = 2,
  };
  // .service_layer.SLIpAddress Prefix = 1;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const ::service_layer::SLIpAddress& prefix() const;
  PROTOBUF_NODISCARD ::service_layer::SLIpAddress* release_prefix();
  ::service_layer::SLIpAddress* mutable_prefix();
  void set_allocated_prefix(::service_layer::SLIpAddress* prefix);
  private:
  const ::service_layer::SLIpAddress& _internal_prefix() const;
  ::service_layer::SLIpAddress* _internal_mutable_prefix();
  public:
  void unsafe_arena_set_allocated_prefix(
      ::service_layer::SLIpAddress* prefix);
  ::service_layer::SLIpAddress* unsafe_arena_release_prefix();

  // uint32 PrefixLen = 2;
  void clear_prefixlen();
  uint32_t prefixlen() const;
  void set_prefixlen(uint32_t value);
  private:
  uint32_t _internal_prefixlen() const;
  void _internal_set_prefixlen(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service_layer.SLRoutePrefix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service_layer::SLIpAddress* prefix_;
  uint32_t prefixlen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sl_5froute_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLRouteGlobalsGetMsg

// -------------------------------------------------------------------

// SLRouteGlobalsGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLRouteGlobalsGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLRouteGlobalsGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLRouteGlobalsGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLRouteGlobalsGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLRouteGlobalsGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalsGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalsGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalsGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalsGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLRouteGlobalsGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus)
}

// uint32 MaxVrfregPerVrfregmsg = 2;
inline void SLRouteGlobalsGetMsgRsp::clear_maxvrfregpervrfregmsg() {
  maxvrfregpervrfregmsg_ = 0u;
}
inline uint32_t SLRouteGlobalsGetMsgRsp::_internal_maxvrfregpervrfregmsg() const {
  return maxvrfregpervrfregmsg_;
}
inline uint32_t SLRouteGlobalsGetMsgRsp::maxvrfregpervrfregmsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalsGetMsgRsp.MaxVrfregPerVrfregmsg)
  return _internal_maxvrfregpervrfregmsg();
}
inline void SLRouteGlobalsGetMsgRsp::_internal_set_maxvrfregpervrfregmsg(uint32_t value) {
  
  maxvrfregpervrfregmsg_ = value;
}
inline void SLRouteGlobalsGetMsgRsp::set_maxvrfregpervrfregmsg(uint32_t value) {
  _internal_set_maxvrfregpervrfregmsg(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGlobalsGetMsgRsp.MaxVrfregPerVrfregmsg)
}

// uint32 MaxRoutePerRoutemsg = 3;
inline void SLRouteGlobalsGetMsgRsp::clear_maxrouteperroutemsg() {
  maxrouteperroutemsg_ = 0u;
}
inline uint32_t SLRouteGlobalsGetMsgRsp::_internal_maxrouteperroutemsg() const {
  return maxrouteperroutemsg_;
}
inline uint32_t SLRouteGlobalsGetMsgRsp::maxrouteperroutemsg() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalsGetMsgRsp.MaxRoutePerRoutemsg)
  return _internal_maxrouteperroutemsg();
}
inline void SLRouteGlobalsGetMsgRsp::_internal_set_maxrouteperroutemsg(uint32_t value) {
  
  maxrouteperroutemsg_ = value;
}
inline void SLRouteGlobalsGetMsgRsp::set_maxrouteperroutemsg(uint32_t value) {
  _internal_set_maxrouteperroutemsg(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGlobalsGetMsgRsp.MaxRoutePerRoutemsg)
}

// -------------------------------------------------------------------

// SLRouteGlobalStatsGetMsg

// -------------------------------------------------------------------

// SLRouteGlobalStatsGetMsgRsp

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLRouteGlobalStatsGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLRouteGlobalStatsGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLRouteGlobalStatsGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLRouteGlobalStatsGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLRouteGlobalStatsGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalStatsGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalStatsGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalStatsGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLRouteGlobalStatsGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLRouteGlobalStatsGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus)
}

// uint32 VrfCount = 2;
inline void SLRouteGlobalStatsGetMsgRsp::clear_vrfcount() {
  vrfcount_ = 0u;
}
inline uint32_t SLRouteGlobalStatsGetMsgRsp::_internal_vrfcount() const {
  return vrfcount_;
}
inline uint32_t SLRouteGlobalStatsGetMsgRsp::vrfcount() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalStatsGetMsgRsp.VrfCount)
  return _internal_vrfcount();
}
inline void SLRouteGlobalStatsGetMsgRsp::_internal_set_vrfcount(uint32_t value) {
  
  vrfcount_ = value;
}
inline void SLRouteGlobalStatsGetMsgRsp::set_vrfcount(uint32_t value) {
  _internal_set_vrfcount(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGlobalStatsGetMsgRsp.VrfCount)
}

// uint32 RouteCount = 3;
inline void SLRouteGlobalStatsGetMsgRsp::clear_routecount() {
  routecount_ = 0u;
}
inline uint32_t SLRouteGlobalStatsGetMsgRsp::_internal_routecount() const {
  return routecount_;
}
inline uint32_t SLRouteGlobalStatsGetMsgRsp::routecount() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGlobalStatsGetMsgRsp.RouteCount)
  return _internal_routecount();
}
inline void SLRouteGlobalStatsGetMsgRsp::_internal_set_routecount(uint32_t value) {
  
  routecount_ = value;
}
inline void SLRouteGlobalStatsGetMsgRsp::set_routecount(uint32_t value) {
  _internal_set_routecount(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGlobalStatsGetMsgRsp.RouteCount)
}

// -------------------------------------------------------------------

// SLVrfReg

// string VrfName = 1;
inline void SLVrfReg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLVrfReg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfReg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVrfReg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVrfReg.VrfName)
}
inline std::string* SLVrfReg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfReg.VrfName)
  return _s;
}
inline const std::string& SLVrfReg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLVrfReg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVrfReg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVrfReg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfReg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVrfReg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfReg.VrfName)
}

// uint32 AdminDistance = 2;
inline void SLVrfReg::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLVrfReg::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLVrfReg::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfReg.AdminDistance)
  return _internal_admindistance();
}
inline void SLVrfReg::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLVrfReg::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfReg.AdminDistance)
}

// uint32 VrfPurgeIntervalSeconds = 3;
inline void SLVrfReg::clear_vrfpurgeintervalseconds() {
  vrfpurgeintervalseconds_ = 0u;
}
inline uint32_t SLVrfReg::_internal_vrfpurgeintervalseconds() const {
  return vrfpurgeintervalseconds_;
}
inline uint32_t SLVrfReg::vrfpurgeintervalseconds() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfReg.VrfPurgeIntervalSeconds)
  return _internal_vrfpurgeintervalseconds();
}
inline void SLVrfReg::_internal_set_vrfpurgeintervalseconds(uint32_t value) {
  
  vrfpurgeintervalseconds_ = value;
}
inline void SLVrfReg::set_vrfpurgeintervalseconds(uint32_t value) {
  _internal_set_vrfpurgeintervalseconds(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfReg.VrfPurgeIntervalSeconds)
}

// -------------------------------------------------------------------

// SLVrfRegMsg

// .service_layer.SLRegOp Oper = 1;
inline void SLVrfRegMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLRegOp SLVrfRegMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLRegOp >(oper_);
}
inline ::service_layer::SLRegOp SLVrfRegMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsg.Oper)
  return _internal_oper();
}
inline void SLVrfRegMsg::_internal_set_oper(::service_layer::SLRegOp value) {
  
  oper_ = value;
}
inline void SLVrfRegMsg::set_oper(::service_layer::SLRegOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegMsg.Oper)
}

// repeated .service_layer.SLVrfReg VrfRegMsgs = 2;
inline int SLVrfRegMsg::_internal_vrfregmsgs_size() const {
  return vrfregmsgs_.size();
}
inline int SLVrfRegMsg::vrfregmsgs_size() const {
  return _internal_vrfregmsgs_size();
}
inline void SLVrfRegMsg::clear_vrfregmsgs() {
  vrfregmsgs_.Clear();
}
inline ::service_layer::SLVrfReg* SLVrfRegMsg::mutable_vrfregmsgs(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
SLVrfRegMsg::mutable_vrfregmsgs() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLVrfRegMsg.VrfRegMsgs)
  return &vrfregmsgs_;
}
inline const ::service_layer::SLVrfReg& SLVrfRegMsg::_internal_vrfregmsgs(int index) const {
  return vrfregmsgs_.Get(index);
}
inline const ::service_layer::SLVrfReg& SLVrfRegMsg::vrfregmsgs(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsg.VrfRegMsgs)
  return _internal_vrfregmsgs(index);
}
inline ::service_layer::SLVrfReg* SLVrfRegMsg::_internal_add_vrfregmsgs() {
  return vrfregmsgs_.Add();
}
inline ::service_layer::SLVrfReg* SLVrfRegMsg::add_vrfregmsgs() {
  ::service_layer::SLVrfReg* _add = _internal_add_vrfregmsgs();
  // @@protoc_insertion_point(field_add:service_layer.SLVrfRegMsg.VrfRegMsgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
SLVrfRegMsg::vrfregmsgs() const {
  // @@protoc_insertion_point(field_list:service_layer.SLVrfRegMsg.VrfRegMsgs)
  return vrfregmsgs_;
}

// -------------------------------------------------------------------

// SLVrfRegMsgRes

// .service_layer.SLErrorStatus ErrStatus = 1;
inline bool SLVrfRegMsgRes::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLVrfRegMsgRes::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLVrfRegMsgRes::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLVrfRegMsgRes::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsgRes.ErrStatus)
  return _internal_errstatus();
}
inline void SLVrfRegMsgRes::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVrfRegMsgRes.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRes::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRes::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfRegMsgRes.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRes::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRes::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegMsgRes.ErrStatus)
  return _msg;
}
inline void SLVrfRegMsgRes::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfRegMsgRes.ErrStatus)
}

// string VrfName = 2;
inline void SLVrfRegMsgRes::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLVrfRegMsgRes::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsgRes.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVrfRegMsgRes::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegMsgRes.VrfName)
}
inline std::string* SLVrfRegMsgRes::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegMsgRes.VrfName)
  return _s;
}
inline const std::string& SLVrfRegMsgRes::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLVrfRegMsgRes::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVrfRegMsgRes::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVrfRegMsgRes::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfRegMsgRes.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVrfRegMsgRes::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfRegMsgRes.VrfName)
}

// -------------------------------------------------------------------

// SLVrfRegMsgRsp

// .service_layer.SLErrorStatus StatusSummary = 1;
inline bool SLVrfRegMsgRsp::_internal_has_statussummary() const {
  return this != internal_default_instance() && statussummary_ != nullptr;
}
inline bool SLVrfRegMsgRsp::has_statussummary() const {
  return _internal_has_statussummary();
}
inline const ::service_layer::SLErrorStatus& SLVrfRegMsgRsp::_internal_statussummary() const {
  const ::service_layer::SLErrorStatus* p = statussummary_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLVrfRegMsgRsp::statussummary() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsgRsp.StatusSummary)
  return _internal_statussummary();
}
inline void SLVrfRegMsgRsp::unsafe_arena_set_allocated_statussummary(
    ::service_layer::SLErrorStatus* statussummary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  statussummary_ = statussummary;
  if (statussummary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVrfRegMsgRsp.StatusSummary)
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRsp::release_statussummary() {
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRsp::unsafe_arena_release_statussummary() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfRegMsgRsp.StatusSummary)
  
  ::service_layer::SLErrorStatus* temp = statussummary_;
  statussummary_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRsp::_internal_mutable_statussummary() {
  
  if (statussummary_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    statussummary_ = p;
  }
  return statussummary_;
}
inline ::service_layer::SLErrorStatus* SLVrfRegMsgRsp::mutable_statussummary() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_statussummary();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegMsgRsp.StatusSummary)
  return _msg;
}
inline void SLVrfRegMsgRsp::set_allocated_statussummary(::service_layer::SLErrorStatus* statussummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary_);
  }
  if (statussummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statussummary));
    if (message_arena != submessage_arena) {
      statussummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statussummary, submessage_arena);
    }
    
  } else {
    
  }
  statussummary_ = statussummary;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfRegMsgRsp.StatusSummary)
}

// repeated .service_layer.SLVrfRegMsgRes Results = 2;
inline int SLVrfRegMsgRsp::_internal_results_size() const {
  return results_.size();
}
inline int SLVrfRegMsgRsp::results_size() const {
  return _internal_results_size();
}
inline void SLVrfRegMsgRsp::clear_results() {
  results_.Clear();
}
inline ::service_layer::SLVrfRegMsgRes* SLVrfRegMsgRsp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegMsgRsp.Results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfRegMsgRes >*
SLVrfRegMsgRsp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLVrfRegMsgRsp.Results)
  return &results_;
}
inline const ::service_layer::SLVrfRegMsgRes& SLVrfRegMsgRsp::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::service_layer::SLVrfRegMsgRes& SLVrfRegMsgRsp::results(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegMsgRsp.Results)
  return _internal_results(index);
}
inline ::service_layer::SLVrfRegMsgRes* SLVrfRegMsgRsp::_internal_add_results() {
  return results_.Add();
}
inline ::service_layer::SLVrfRegMsgRes* SLVrfRegMsgRsp::add_results() {
  ::service_layer::SLVrfRegMsgRes* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:service_layer.SLVrfRegMsgRsp.Results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfRegMsgRes >&
SLVrfRegMsgRsp::results() const {
  // @@protoc_insertion_point(field_list:service_layer.SLVrfRegMsgRsp.Results)
  return results_;
}

// -------------------------------------------------------------------

// SLVrfRegGetMsg

// string VrfName = 1;
inline void SLVrfRegGetMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLVrfRegGetMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVrfRegGetMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegGetMsg.VrfName)
}
inline std::string* SLVrfRegGetMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegGetMsg.VrfName)
  return _s;
}
inline const std::string& SLVrfRegGetMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLVrfRegGetMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVrfRegGetMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVrfRegGetMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfRegGetMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVrfRegGetMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfRegGetMsg.VrfName)
}

// uint32 EntriesCount = 2;
inline void SLVrfRegGetMsg::clear_entriescount() {
  entriescount_ = 0u;
}
inline uint32_t SLVrfRegGetMsg::_internal_entriescount() const {
  return entriescount_;
}
inline uint32_t SLVrfRegGetMsg::entriescount() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsg.EntriesCount)
  return _internal_entriescount();
}
inline void SLVrfRegGetMsg::_internal_set_entriescount(uint32_t value) {
  
  entriescount_ = value;
}
inline void SLVrfRegGetMsg::set_entriescount(uint32_t value) {
  _internal_set_entriescount(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegGetMsg.EntriesCount)
}

// bool GetNext = 3;
inline void SLVrfRegGetMsg::clear_getnext() {
  getnext_ = false;
}
inline bool SLVrfRegGetMsg::_internal_getnext() const {
  return getnext_;
}
inline bool SLVrfRegGetMsg::getnext() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsg.GetNext)
  return _internal_getnext();
}
inline void SLVrfRegGetMsg::_internal_set_getnext(bool value) {
  
  getnext_ = value;
}
inline void SLVrfRegGetMsg::set_getnext(bool value) {
  _internal_set_getnext(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegGetMsg.GetNext)
}

// -------------------------------------------------------------------

// SLVrfRegGetMsgRsp

// bool Eof = 1;
inline void SLVrfRegGetMsgRsp::clear_eof() {
  eof_ = false;
}
inline bool SLVrfRegGetMsgRsp::_internal_eof() const {
  return eof_;
}
inline bool SLVrfRegGetMsgRsp::eof() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsgRsp.Eof)
  return _internal_eof();
}
inline void SLVrfRegGetMsgRsp::_internal_set_eof(bool value) {
  
  eof_ = value;
}
inline void SLVrfRegGetMsgRsp::set_eof(bool value) {
  _internal_set_eof(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfRegGetMsgRsp.Eof)
}

// .service_layer.SLErrorStatus ErrStatus = 2;
inline bool SLVrfRegGetMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLVrfRegGetMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLVrfRegGetMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLVrfRegGetMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLVrfRegGetMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVrfRegGetMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLVrfRegGetMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegGetMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfRegGetMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVrfRegGetMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLVrfRegGetMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegGetMsgRsp.ErrStatus)
  return _msg;
}
inline void SLVrfRegGetMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfRegGetMsgRsp.ErrStatus)
}

// repeated .service_layer.SLVrfReg Entries = 3;
inline int SLVrfRegGetMsgRsp::_internal_entries_size() const {
  return entries_.size();
}
inline int SLVrfRegGetMsgRsp::entries_size() const {
  return _internal_entries_size();
}
inline void SLVrfRegGetMsgRsp::clear_entries() {
  entries_.Clear();
}
inline ::service_layer::SLVrfReg* SLVrfRegGetMsgRsp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfRegGetMsgRsp.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >*
SLVrfRegGetMsgRsp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLVrfRegGetMsgRsp.Entries)
  return &entries_;
}
inline const ::service_layer::SLVrfReg& SLVrfRegGetMsgRsp::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::service_layer::SLVrfReg& SLVrfRegGetMsgRsp::entries(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfRegGetMsgRsp.Entries)
  return _internal_entries(index);
}
inline ::service_layer::SLVrfReg* SLVrfRegGetMsgRsp::_internal_add_entries() {
  return entries_.Add();
}
inline ::service_layer::SLVrfReg* SLVrfRegGetMsgRsp::add_entries() {
  ::service_layer::SLVrfReg* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:service_layer.SLVrfRegGetMsgRsp.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVrfReg >&
SLVrfRegGetMsgRsp::entries() const {
  // @@protoc_insertion_point(field_list:service_layer.SLVrfRegGetMsgRsp.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SLVRFGetStatsMsgRes

// string VrfName = 1;
inline void SLVRFGetStatsMsgRes::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLVRFGetStatsMsgRes::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVRFGetStatsMsgRes.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVRFGetStatsMsgRes::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVRFGetStatsMsgRes.VrfName)
}
inline std::string* SLVRFGetStatsMsgRes::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVRFGetStatsMsgRes.VrfName)
  return _s;
}
inline const std::string& SLVRFGetStatsMsgRes::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLVRFGetStatsMsgRes::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVRFGetStatsMsgRes::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVRFGetStatsMsgRes::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLVRFGetStatsMsgRes.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVRFGetStatsMsgRes::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVRFGetStatsMsgRes.VrfName)
}

// uint32 RouteCount = 2;
inline void SLVRFGetStatsMsgRes::clear_routecount() {
  routecount_ = 0u;
}
inline uint32_t SLVRFGetStatsMsgRes::_internal_routecount() const {
  return routecount_;
}
inline uint32_t SLVRFGetStatsMsgRes::routecount() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVRFGetStatsMsgRes.RouteCount)
  return _internal_routecount();
}
inline void SLVRFGetStatsMsgRes::_internal_set_routecount(uint32_t value) {
  
  routecount_ = value;
}
inline void SLVRFGetStatsMsgRes::set_routecount(uint32_t value) {
  _internal_set_routecount(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVRFGetStatsMsgRes.RouteCount)
}

// -------------------------------------------------------------------

// SLVRFGetStatsMsgRsp

// bool Eof = 1;
inline void SLVRFGetStatsMsgRsp::clear_eof() {
  eof_ = false;
}
inline bool SLVRFGetStatsMsgRsp::_internal_eof() const {
  return eof_;
}
inline bool SLVRFGetStatsMsgRsp::eof() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVRFGetStatsMsgRsp.Eof)
  return _internal_eof();
}
inline void SLVRFGetStatsMsgRsp::_internal_set_eof(bool value) {
  
  eof_ = value;
}
inline void SLVRFGetStatsMsgRsp::set_eof(bool value) {
  _internal_set_eof(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVRFGetStatsMsgRsp.Eof)
}

// .service_layer.SLErrorStatus ErrStatus = 2;
inline bool SLVRFGetStatsMsgRsp::_internal_has_errstatus() const {
  return this != internal_default_instance() && errstatus_ != nullptr;
}
inline bool SLVRFGetStatsMsgRsp::has_errstatus() const {
  return _internal_has_errstatus();
}
inline const ::service_layer::SLErrorStatus& SLVRFGetStatsMsgRsp::_internal_errstatus() const {
  const ::service_layer::SLErrorStatus* p = errstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLVRFGetStatsMsgRsp::errstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVRFGetStatsMsgRsp.ErrStatus)
  return _internal_errstatus();
}
inline void SLVRFGetStatsMsgRsp::unsafe_arena_set_allocated_errstatus(
    ::service_layer::SLErrorStatus* errstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  errstatus_ = errstatus;
  if (errstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVRFGetStatsMsgRsp.ErrStatus)
}
inline ::service_layer::SLErrorStatus* SLVRFGetStatsMsgRsp::release_errstatus() {
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVRFGetStatsMsgRsp::unsafe_arena_release_errstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLVRFGetStatsMsgRsp.ErrStatus)
  
  ::service_layer::SLErrorStatus* temp = errstatus_;
  errstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLVRFGetStatsMsgRsp::_internal_mutable_errstatus() {
  
  if (errstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    errstatus_ = p;
  }
  return errstatus_;
}
inline ::service_layer::SLErrorStatus* SLVRFGetStatsMsgRsp::mutable_errstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_errstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVRFGetStatsMsgRsp.ErrStatus)
  return _msg;
}
inline void SLVRFGetStatsMsgRsp::set_allocated_errstatus(::service_layer::SLErrorStatus* errstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus_);
  }
  if (errstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errstatus));
    if (message_arena != submessage_arena) {
      errstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errstatus, submessage_arena);
    }
    
  } else {
    
  }
  errstatus_ = errstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVRFGetStatsMsgRsp.ErrStatus)
}

// repeated .service_layer.SLVRFGetStatsMsgRes Entries = 3;
inline int SLVRFGetStatsMsgRsp::_internal_entries_size() const {
  return entries_.size();
}
inline int SLVRFGetStatsMsgRsp::entries_size() const {
  return _internal_entries_size();
}
inline void SLVRFGetStatsMsgRsp::clear_entries() {
  entries_.Clear();
}
inline ::service_layer::SLVRFGetStatsMsgRes* SLVRFGetStatsMsgRsp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLVRFGetStatsMsgRsp.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVRFGetStatsMsgRes >*
SLVRFGetStatsMsgRsp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLVRFGetStatsMsgRsp.Entries)
  return &entries_;
}
inline const ::service_layer::SLVRFGetStatsMsgRes& SLVRFGetStatsMsgRsp::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::service_layer::SLVRFGetStatsMsgRes& SLVRFGetStatsMsgRsp::entries(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLVRFGetStatsMsgRsp.Entries)
  return _internal_entries(index);
}
inline ::service_layer::SLVRFGetStatsMsgRes* SLVRFGetStatsMsgRsp::_internal_add_entries() {
  return entries_.Add();
}
inline ::service_layer::SLVRFGetStatsMsgRes* SLVRFGetStatsMsgRsp::add_entries() {
  ::service_layer::SLVRFGetStatsMsgRes* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:service_layer.SLVRFGetStatsMsgRsp.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLVRFGetStatsMsgRes >&
SLVRFGetStatsMsgRsp::entries() const {
  // @@protoc_insertion_point(field_list:service_layer.SLVRFGetStatsMsgRsp.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SLRouteGetNotifMsg

// .service_layer.SLNotifOp Oper = 1;
inline void SLRouteGetNotifMsg::clear_oper() {
  oper_ = 0;
}
inline ::service_layer::SLNotifOp SLRouteGetNotifMsg::_internal_oper() const {
  return static_cast< ::service_layer::SLNotifOp >(oper_);
}
inline ::service_layer::SLNotifOp SLRouteGetNotifMsg::oper() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGetNotifMsg.Oper)
  return _internal_oper();
}
inline void SLRouteGetNotifMsg::_internal_set_oper(::service_layer::SLNotifOp value) {
  
  oper_ = value;
}
inline void SLRouteGetNotifMsg::set_oper(::service_layer::SLNotifOp value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGetNotifMsg.Oper)
}

// uint64 Correlator = 2;
inline void SLRouteGetNotifMsg::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLRouteGetNotifMsg::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLRouteGetNotifMsg::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGetNotifMsg.Correlator)
  return _internal_correlator();
}
inline void SLRouteGetNotifMsg::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLRouteGetNotifMsg::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGetNotifMsg.Correlator)
}

// string VrfName = 3;
inline void SLRouteGetNotifMsg::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLRouteGetNotifMsg::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGetNotifMsg.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteGetNotifMsg::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGetNotifMsg.VrfName)
}
inline std::string* SLRouteGetNotifMsg::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteGetNotifMsg.VrfName)
  return _s;
}
inline const std::string& SLRouteGetNotifMsg::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLRouteGetNotifMsg::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteGetNotifMsg.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteGetNotifMsg::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteGetNotifMsg.VrfName)
}

// string SrcProto = 4;
inline void SLRouteGetNotifMsg::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLRouteGetNotifMsg::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGetNotifMsg.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteGetNotifMsg::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGetNotifMsg.SrcProto)
}
inline std::string* SLRouteGetNotifMsg::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteGetNotifMsg.SrcProto)
  return _s;
}
inline const std::string& SLRouteGetNotifMsg::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLRouteGetNotifMsg::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteGetNotifMsg.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteGetNotifMsg::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteGetNotifMsg.SrcProto)
}

// string SrcProtoTag = 5;
inline void SLRouteGetNotifMsg::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLRouteGetNotifMsg::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteGetNotifMsg.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteGetNotifMsg::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteGetNotifMsg.SrcProtoTag)
}
inline std::string* SLRouteGetNotifMsg::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteGetNotifMsg.SrcProtoTag)
  return _s;
}
inline const std::string& SLRouteGetNotifMsg::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLRouteGetNotifMsg::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteGetNotifMsg::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteGetNotifMsg.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteGetNotifMsg::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteGetNotifMsg.SrcProtoTag)
}

// -------------------------------------------------------------------

// SLRouteNotifStatus

// uint64 Correlator = 1;
inline void SLRouteNotifStatus::clear_correlator() {
  correlator_ = uint64_t{0u};
}
inline uint64_t SLRouteNotifStatus::_internal_correlator() const {
  return correlator_;
}
inline uint64_t SLRouteNotifStatus::correlator() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteNotifStatus.Correlator)
  return _internal_correlator();
}
inline void SLRouteNotifStatus::_internal_set_correlator(uint64_t value) {
  
  correlator_ = value;
}
inline void SLRouteNotifStatus::set_correlator(uint64_t value) {
  _internal_set_correlator(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteNotifStatus.Correlator)
}

// string VrfName = 2;
inline void SLRouteNotifStatus::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLRouteNotifStatus::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteNotifStatus.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteNotifStatus::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteNotifStatus.VrfName)
}
inline std::string* SLRouteNotifStatus::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteNotifStatus.VrfName)
  return _s;
}
inline const std::string& SLRouteNotifStatus::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLRouteNotifStatus::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteNotifStatus::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteNotifStatus::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteNotifStatus.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteNotifStatus::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteNotifStatus.VrfName)
}

// .service_layer.SLErrorStatus NotifStatus = 3;
inline bool SLRouteNotifStatus::_internal_has_notifstatus() const {
  return this != internal_default_instance() && notifstatus_ != nullptr;
}
inline bool SLRouteNotifStatus::has_notifstatus() const {
  return _internal_has_notifstatus();
}
inline const ::service_layer::SLErrorStatus& SLRouteNotifStatus::_internal_notifstatus() const {
  const ::service_layer::SLErrorStatus* p = notifstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLErrorStatus&>(
      ::service_layer::_SLErrorStatus_default_instance_);
}
inline const ::service_layer::SLErrorStatus& SLRouteNotifStatus::notifstatus() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteNotifStatus.NotifStatus)
  return _internal_notifstatus();
}
inline void SLRouteNotifStatus::unsafe_arena_set_allocated_notifstatus(
    ::service_layer::SLErrorStatus* notifstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  notifstatus_ = notifstatus;
  if (notifstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRouteNotifStatus.NotifStatus)
}
inline ::service_layer::SLErrorStatus* SLRouteNotifStatus::release_notifstatus() {
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteNotifStatus::unsafe_arena_release_notifstatus() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteNotifStatus.NotifStatus)
  
  ::service_layer::SLErrorStatus* temp = notifstatus_;
  notifstatus_ = nullptr;
  return temp;
}
inline ::service_layer::SLErrorStatus* SLRouteNotifStatus::_internal_mutable_notifstatus() {
  
  if (notifstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLErrorStatus>(GetArenaForAllocation());
    notifstatus_ = p;
  }
  return notifstatus_;
}
inline ::service_layer::SLErrorStatus* SLRouteNotifStatus::mutable_notifstatus() {
  ::service_layer::SLErrorStatus* _msg = _internal_mutable_notifstatus();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteNotifStatus.NotifStatus)
  return _msg;
}
inline void SLRouteNotifStatus::set_allocated_notifstatus(::service_layer::SLErrorStatus* notifstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus_);
  }
  if (notifstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(notifstatus));
    if (message_arena != submessage_arena) {
      notifstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifstatus, submessage_arena);
    }
    
  } else {
    
  }
  notifstatus_ = notifstatus;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteNotifStatus.NotifStatus)
}

// -------------------------------------------------------------------

// SLRouteNotifMarker

// string VrfName = 1;
inline void SLRouteNotifMarker::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLRouteNotifMarker::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteNotifMarker.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteNotifMarker::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteNotifMarker.VrfName)
}
inline std::string* SLRouteNotifMarker::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteNotifMarker.VrfName)
  return _s;
}
inline const std::string& SLRouteNotifMarker::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLRouteNotifMarker::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteNotifMarker::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteNotifMarker::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteNotifMarker.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteNotifMarker::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteNotifMarker.VrfName)
}

// -------------------------------------------------------------------

// SLVrfNotif

// string VrfName = 1;
inline void SLVrfNotif::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLVrfNotif::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfNotif.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVrfNotif::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVrfNotif.VrfName)
}
inline std::string* SLVrfNotif::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVrfNotif.VrfName)
  return _s;
}
inline const std::string& SLVrfNotif::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLVrfNotif::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVrfNotif::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVrfNotif::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLVrfNotif.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVrfNotif::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVrfNotif.VrfName)
}

// .service_layer.SLObjectOp Status = 2;
inline void SLVrfNotif::clear_status() {
  status_ = 0;
}
inline ::service_layer::SLObjectOp SLVrfNotif::_internal_status() const {
  return static_cast< ::service_layer::SLObjectOp >(status_);
}
inline ::service_layer::SLObjectOp SLVrfNotif::status() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVrfNotif.Status)
  return _internal_status();
}
inline void SLVrfNotif::_internal_set_status(::service_layer::SLObjectOp value) {
  
  status_ = value;
}
inline void SLVrfNotif::set_status(::service_layer::SLObjectOp value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVrfNotif.Status)
}

// -------------------------------------------------------------------

// SLRouteCommon

// uint32 AdminDistance = 1;
inline void SLRouteCommon::clear_admindistance() {
  admindistance_ = 0u;
}
inline uint32_t SLRouteCommon::_internal_admindistance() const {
  return admindistance_;
}
inline uint32_t SLRouteCommon::admindistance() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.AdminDistance)
  return _internal_admindistance();
}
inline void SLRouteCommon::_internal_set_admindistance(uint32_t value) {
  
  admindistance_ = value;
}
inline void SLRouteCommon::set_admindistance(uint32_t value) {
  _internal_set_admindistance(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.AdminDistance)
}

// uint32 LocalLabel = 2;
inline void SLRouteCommon::clear_locallabel() {
  locallabel_ = 0u;
}
inline uint32_t SLRouteCommon::_internal_locallabel() const {
  return locallabel_;
}
inline uint32_t SLRouteCommon::locallabel() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.LocalLabel)
  return _internal_locallabel();
}
inline void SLRouteCommon::_internal_set_locallabel(uint32_t value) {
  
  locallabel_ = value;
}
inline void SLRouteCommon::set_locallabel(uint32_t value) {
  _internal_set_locallabel(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.LocalLabel)
}

// uint32 Tag = 3;
inline void SLRouteCommon::clear_tag() {
  tag_ = 0u;
}
inline uint32_t SLRouteCommon::_internal_tag() const {
  return tag_;
}
inline uint32_t SLRouteCommon::tag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.Tag)
  return _internal_tag();
}
inline void SLRouteCommon::_internal_set_tag(uint32_t value) {
  
  tag_ = value;
}
inline void SLRouteCommon::set_tag(uint32_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.Tag)
}

// string SrcProto = 4;
inline void SLRouteCommon::clear_srcproto() {
  srcproto_.ClearToEmpty();
}
inline const std::string& SLRouteCommon::srcproto() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.SrcProto)
  return _internal_srcproto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteCommon::set_srcproto(ArgT0&& arg0, ArgT... args) {
 
 srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.SrcProto)
}
inline std::string* SLRouteCommon::mutable_srcproto() {
  std::string* _s = _internal_mutable_srcproto();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteCommon.SrcProto)
  return _s;
}
inline const std::string& SLRouteCommon::_internal_srcproto() const {
  return srcproto_.Get();
}
inline void SLRouteCommon::_internal_set_srcproto(const std::string& value) {
  
  srcproto_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteCommon::_internal_mutable_srcproto() {
  
  return srcproto_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteCommon::release_srcproto() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteCommon.SrcProto)
  return srcproto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteCommon::set_allocated_srcproto(std::string* srcproto) {
  if (srcproto != nullptr) {
    
  } else {
    
  }
  srcproto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcproto,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcproto_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcproto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteCommon.SrcProto)
}

// string SrcProtoTag = 5;
inline void SLRouteCommon::clear_srcprototag() {
  srcprototag_.ClearToEmpty();
}
inline const std::string& SLRouteCommon::srcprototag() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.SrcProtoTag)
  return _internal_srcprototag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRouteCommon::set_srcprototag(ArgT0&& arg0, ArgT... args) {
 
 srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.SrcProtoTag)
}
inline std::string* SLRouteCommon::mutable_srcprototag() {
  std::string* _s = _internal_mutable_srcprototag();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRouteCommon.SrcProtoTag)
  return _s;
}
inline const std::string& SLRouteCommon::_internal_srcprototag() const {
  return srcprototag_.Get();
}
inline void SLRouteCommon::_internal_set_srcprototag(const std::string& value) {
  
  srcprototag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRouteCommon::_internal_mutable_srcprototag() {
  
  return srcprototag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRouteCommon::release_srcprototag() {
  // @@protoc_insertion_point(field_release:service_layer.SLRouteCommon.SrcProtoTag)
  return srcprototag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRouteCommon::set_allocated_srcprototag(std::string* srcprototag) {
  if (srcprototag != nullptr) {
    
  } else {
    
  }
  srcprototag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcprototag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcprototag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcprototag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRouteCommon.SrcProtoTag)
}

// repeated .service_layer.SLRouteFlags RouteFlags = 7;
inline int SLRouteCommon::_internal_routeflags_size() const {
  return routeflags_.size();
}
inline int SLRouteCommon::routeflags_size() const {
  return _internal_routeflags_size();
}
inline void SLRouteCommon::clear_routeflags() {
  routeflags_.Clear();
}
inline ::service_layer::SLRouteFlags SLRouteCommon::_internal_routeflags(int index) const {
  return static_cast< ::service_layer::SLRouteFlags >(routeflags_.Get(index));
}
inline ::service_layer::SLRouteFlags SLRouteCommon::routeflags(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.RouteFlags)
  return _internal_routeflags(index);
}
inline void SLRouteCommon::set_routeflags(int index, ::service_layer::SLRouteFlags value) {
  routeflags_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.RouteFlags)
}
inline void SLRouteCommon::_internal_add_routeflags(::service_layer::SLRouteFlags value) {
  routeflags_.Add(value);
}
inline void SLRouteCommon::add_routeflags(::service_layer::SLRouteFlags value) {
  _internal_add_routeflags(value);
  // @@protoc_insertion_point(field_add:service_layer.SLRouteCommon.RouteFlags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLRouteCommon::routeflags() const {
  // @@protoc_insertion_point(field_list:service_layer.SLRouteCommon.RouteFlags)
  return routeflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLRouteCommon::_internal_mutable_routeflags() {
  return &routeflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLRouteCommon::mutable_routeflags() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLRouteCommon.RouteFlags)
  return _internal_mutable_routeflags();
}

// uint32 Metric = 8;
inline void SLRouteCommon::clear_metric() {
  metric_ = 0u;
}
inline uint32_t SLRouteCommon::_internal_metric() const {
  return metric_;
}
inline uint32_t SLRouteCommon::metric() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.Metric)
  return _internal_metric();
}
inline void SLRouteCommon::_internal_set_metric(uint32_t value) {
  
  metric_ = value;
}
inline void SLRouteCommon::set_metric(uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.Metric)
}

// .service_layer.SLUpdatePriority Priority = 9;
inline void SLRouteCommon::clear_priority() {
  priority_ = 0;
}
inline ::service_layer::SLUpdatePriority SLRouteCommon::_internal_priority() const {
  return static_cast< ::service_layer::SLUpdatePriority >(priority_);
}
inline ::service_layer::SLUpdatePriority SLRouteCommon::priority() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRouteCommon.Priority)
  return _internal_priority();
}
inline void SLRouteCommon::_internal_set_priority(::service_layer::SLUpdatePriority value) {
  
  priority_ = value;
}
inline void SLRouteCommon::set_priority(::service_layer::SLUpdatePriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRouteCommon.Priority)
}

// -------------------------------------------------------------------

// SLVxLANPath

// uint32 VNI = 1;
inline void SLVxLANPath::clear_vni() {
  vni_ = 0u;
}
inline uint32_t SLVxLANPath::_internal_vni() const {
  return vni_;
}
inline uint32_t SLVxLANPath::vni() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVxLANPath.VNI)
  return _internal_vni();
}
inline void SLVxLANPath::_internal_set_vni(uint32_t value) {
  
  vni_ = value;
}
inline void SLVxLANPath::set_vni(uint32_t value) {
  _internal_set_vni(value);
  // @@protoc_insertion_point(field_set:service_layer.SLVxLANPath.VNI)
}

// bytes SourceMacAddress = 2;
inline void SLVxLANPath::clear_sourcemacaddress() {
  sourcemacaddress_.ClearToEmpty();
}
inline const std::string& SLVxLANPath::sourcemacaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVxLANPath.SourceMacAddress)
  return _internal_sourcemacaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVxLANPath::set_sourcemacaddress(ArgT0&& arg0, ArgT... args) {
 
 sourcemacaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVxLANPath.SourceMacAddress)
}
inline std::string* SLVxLANPath::mutable_sourcemacaddress() {
  std::string* _s = _internal_mutable_sourcemacaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVxLANPath.SourceMacAddress)
  return _s;
}
inline const std::string& SLVxLANPath::_internal_sourcemacaddress() const {
  return sourcemacaddress_.Get();
}
inline void SLVxLANPath::_internal_set_sourcemacaddress(const std::string& value) {
  
  sourcemacaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVxLANPath::_internal_mutable_sourcemacaddress() {
  
  return sourcemacaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVxLANPath::release_sourcemacaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLVxLANPath.SourceMacAddress)
  return sourcemacaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVxLANPath::set_allocated_sourcemacaddress(std::string* sourcemacaddress) {
  if (sourcemacaddress != nullptr) {
    
  } else {
    
  }
  sourcemacaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcemacaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcemacaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourcemacaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVxLANPath.SourceMacAddress)
}

// bytes DestMacAddress = 3;
inline void SLVxLANPath::clear_destmacaddress() {
  destmacaddress_.ClearToEmpty();
}
inline const std::string& SLVxLANPath::destmacaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVxLANPath.DestMacAddress)
  return _internal_destmacaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLVxLANPath::set_destmacaddress(ArgT0&& arg0, ArgT... args) {
 
 destmacaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLVxLANPath.DestMacAddress)
}
inline std::string* SLVxLANPath::mutable_destmacaddress() {
  std::string* _s = _internal_mutable_destmacaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVxLANPath.DestMacAddress)
  return _s;
}
inline const std::string& SLVxLANPath::_internal_destmacaddress() const {
  return destmacaddress_.Get();
}
inline void SLVxLANPath::_internal_set_destmacaddress(const std::string& value) {
  
  destmacaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLVxLANPath::_internal_mutable_destmacaddress() {
  
  return destmacaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLVxLANPath::release_destmacaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLVxLANPath.DestMacAddress)
  return destmacaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLVxLANPath::set_allocated_destmacaddress(std::string* destmacaddress) {
  if (destmacaddress != nullptr) {
    
  } else {
    
  }
  destmacaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destmacaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destmacaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destmacaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVxLANPath.DestMacAddress)
}

// .service_layer.SLIpAddress SrcIpAddress = 4;
inline bool SLVxLANPath::_internal_has_srcipaddress() const {
  return this != internal_default_instance() && srcipaddress_ != nullptr;
}
inline bool SLVxLANPath::has_srcipaddress() const {
  return _internal_has_srcipaddress();
}
inline const ::service_layer::SLIpAddress& SLVxLANPath::_internal_srcipaddress() const {
  const ::service_layer::SLIpAddress* p = srcipaddress_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLVxLANPath::srcipaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVxLANPath.SrcIpAddress)
  return _internal_srcipaddress();
}
inline void SLVxLANPath::unsafe_arena_set_allocated_srcipaddress(
    ::service_layer::SLIpAddress* srcipaddress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(srcipaddress_);
  }
  srcipaddress_ = srcipaddress;
  if (srcipaddress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVxLANPath.SrcIpAddress)
}
inline ::service_layer::SLIpAddress* SLVxLANPath::release_srcipaddress() {
  
  ::service_layer::SLIpAddress* temp = srcipaddress_;
  srcipaddress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::unsafe_arena_release_srcipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLVxLANPath.SrcIpAddress)
  
  ::service_layer::SLIpAddress* temp = srcipaddress_;
  srcipaddress_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::_internal_mutable_srcipaddress() {
  
  if (srcipaddress_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    srcipaddress_ = p;
  }
  return srcipaddress_;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::mutable_srcipaddress() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_srcipaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVxLANPath.SrcIpAddress)
  return _msg;
}
inline void SLVxLANPath::set_allocated_srcipaddress(::service_layer::SLIpAddress* srcipaddress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(srcipaddress_);
  }
  if (srcipaddress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(srcipaddress));
    if (message_arena != submessage_arena) {
      srcipaddress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, srcipaddress, submessage_arena);
    }
    
  } else {
    
  }
  srcipaddress_ = srcipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVxLANPath.SrcIpAddress)
}

// .service_layer.SLIpAddress DestIpAddress = 5;
inline bool SLVxLANPath::_internal_has_destipaddress() const {
  return this != internal_default_instance() && destipaddress_ != nullptr;
}
inline bool SLVxLANPath::has_destipaddress() const {
  return _internal_has_destipaddress();
}
inline const ::service_layer::SLIpAddress& SLVxLANPath::_internal_destipaddress() const {
  const ::service_layer::SLIpAddress* p = destipaddress_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLVxLANPath::destipaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLVxLANPath.DestIpAddress)
  return _internal_destipaddress();
}
inline void SLVxLANPath::unsafe_arena_set_allocated_destipaddress(
    ::service_layer::SLIpAddress* destipaddress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destipaddress_);
  }
  destipaddress_ = destipaddress;
  if (destipaddress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLVxLANPath.DestIpAddress)
}
inline ::service_layer::SLIpAddress* SLVxLANPath::release_destipaddress() {
  
  ::service_layer::SLIpAddress* temp = destipaddress_;
  destipaddress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::unsafe_arena_release_destipaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLVxLANPath.DestIpAddress)
  
  ::service_layer::SLIpAddress* temp = destipaddress_;
  destipaddress_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::_internal_mutable_destipaddress() {
  
  if (destipaddress_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    destipaddress_ = p;
  }
  return destipaddress_;
}
inline ::service_layer::SLIpAddress* SLVxLANPath::mutable_destipaddress() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_destipaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLVxLANPath.DestIpAddress)
  return _msg;
}
inline void SLVxLANPath::set_allocated_destipaddress(::service_layer::SLIpAddress* destipaddress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destipaddress_);
  }
  if (destipaddress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destipaddress));
    if (message_arena != submessage_arena) {
      destipaddress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destipaddress, submessage_arena);
    }
    
  } else {
    
  }
  destipaddress_ = destipaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLVxLANPath.DestIpAddress)
}

// -------------------------------------------------------------------

// SLRoutePath

// .service_layer.SLIpAddress NexthopAddress = 1;
inline bool SLRoutePath::_internal_has_nexthopaddress() const {
  return this != internal_default_instance() && nexthopaddress_ != nullptr;
}
inline bool SLRoutePath::has_nexthopaddress() const {
  return _internal_has_nexthopaddress();
}
inline const ::service_layer::SLIpAddress& SLRoutePath::_internal_nexthopaddress() const {
  const ::service_layer::SLIpAddress* p = nexthopaddress_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLRoutePath::nexthopaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.NexthopAddress)
  return _internal_nexthopaddress();
}
inline void SLRoutePath::unsafe_arena_set_allocated_nexthopaddress(
    ::service_layer::SLIpAddress* nexthopaddress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopaddress_);
  }
  nexthopaddress_ = nexthopaddress;
  if (nexthopaddress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRoutePath.NexthopAddress)
}
inline ::service_layer::SLIpAddress* SLRoutePath::release_nexthopaddress() {
  
  ::service_layer::SLIpAddress* temp = nexthopaddress_;
  nexthopaddress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLRoutePath::unsafe_arena_release_nexthopaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.NexthopAddress)
  
  ::service_layer::SLIpAddress* temp = nexthopaddress_;
  nexthopaddress_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLRoutePath::_internal_mutable_nexthopaddress() {
  
  if (nexthopaddress_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    nexthopaddress_ = p;
  }
  return nexthopaddress_;
}
inline ::service_layer::SLIpAddress* SLRoutePath::mutable_nexthopaddress() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_nexthopaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.NexthopAddress)
  return _msg;
}
inline void SLRoutePath::set_allocated_nexthopaddress(::service_layer::SLIpAddress* nexthopaddress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopaddress_);
  }
  if (nexthopaddress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopaddress));
    if (message_arena != submessage_arena) {
      nexthopaddress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopaddress, submessage_arena);
    }
    
  } else {
    
  }
  nexthopaddress_ = nexthopaddress;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePath.NexthopAddress)
}

// .service_layer.SLInterface NexthopInterface = 2;
inline bool SLRoutePath::_internal_has_nexthopinterface() const {
  return this != internal_default_instance() && nexthopinterface_ != nullptr;
}
inline bool SLRoutePath::has_nexthopinterface() const {
  return _internal_has_nexthopinterface();
}
inline const ::service_layer::SLInterface& SLRoutePath::_internal_nexthopinterface() const {
  const ::service_layer::SLInterface* p = nexthopinterface_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLInterface&>(
      ::service_layer::_SLInterface_default_instance_);
}
inline const ::service_layer::SLInterface& SLRoutePath::nexthopinterface() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.NexthopInterface)
  return _internal_nexthopinterface();
}
inline void SLRoutePath::unsafe_arena_set_allocated_nexthopinterface(
    ::service_layer::SLInterface* nexthopinterface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopinterface_);
  }
  nexthopinterface_ = nexthopinterface;
  if (nexthopinterface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRoutePath.NexthopInterface)
}
inline ::service_layer::SLInterface* SLRoutePath::release_nexthopinterface() {
  
  ::service_layer::SLInterface* temp = nexthopinterface_;
  nexthopinterface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLInterface* SLRoutePath::unsafe_arena_release_nexthopinterface() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.NexthopInterface)
  
  ::service_layer::SLInterface* temp = nexthopinterface_;
  nexthopinterface_ = nullptr;
  return temp;
}
inline ::service_layer::SLInterface* SLRoutePath::_internal_mutable_nexthopinterface() {
  
  if (nexthopinterface_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLInterface>(GetArenaForAllocation());
    nexthopinterface_ = p;
  }
  return nexthopinterface_;
}
inline ::service_layer::SLInterface* SLRoutePath::mutable_nexthopinterface() {
  ::service_layer::SLInterface* _msg = _internal_mutable_nexthopinterface();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.NexthopInterface)
  return _msg;
}
inline void SLRoutePath::set_allocated_nexthopinterface(::service_layer::SLInterface* nexthopinterface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopinterface_);
  }
  if (nexthopinterface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthopinterface));
    if (message_arena != submessage_arena) {
      nexthopinterface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthopinterface, submessage_arena);
    }
    
  } else {
    
  }
  nexthopinterface_ = nexthopinterface;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePath.NexthopInterface)
}

// uint32 LoadMetric = 3;
inline void SLRoutePath::clear_loadmetric() {
  loadmetric_ = 0u;
}
inline uint32_t SLRoutePath::_internal_loadmetric() const {
  return loadmetric_;
}
inline uint32_t SLRoutePath::loadmetric() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.LoadMetric)
  return _internal_loadmetric();
}
inline void SLRoutePath::_internal_set_loadmetric(uint32_t value) {
  
  loadmetric_ = value;
}
inline void SLRoutePath::set_loadmetric(uint32_t value) {
  _internal_set_loadmetric(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.LoadMetric)
}

// string VrfName = 4;
inline void SLRoutePath::clear_vrfname() {
  vrfname_.ClearToEmpty();
}
inline const std::string& SLRoutePath::vrfname() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.VrfName)
  return _internal_vrfname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRoutePath::set_vrfname(ArgT0&& arg0, ArgT... args) {
 
 vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.VrfName)
}
inline std::string* SLRoutePath::mutable_vrfname() {
  std::string* _s = _internal_mutable_vrfname();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.VrfName)
  return _s;
}
inline const std::string& SLRoutePath::_internal_vrfname() const {
  return vrfname_.Get();
}
inline void SLRoutePath::_internal_set_vrfname(const std::string& value) {
  
  vrfname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRoutePath::_internal_mutable_vrfname() {
  
  return vrfname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRoutePath::release_vrfname() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.VrfName)
  return vrfname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRoutePath::set_allocated_vrfname(std::string* vrfname) {
  if (vrfname != nullptr) {
    
  } else {
    
  }
  vrfname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vrfname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vrfname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vrfname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePath.VrfName)
}

// uint32 PathId = 6;
inline void SLRoutePath::clear_pathid() {
  pathid_ = 0u;
}
inline uint32_t SLRoutePath::_internal_pathid() const {
  return pathid_;
}
inline uint32_t SLRoutePath::pathid() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.PathId)
  return _internal_pathid();
}
inline void SLRoutePath::_internal_set_pathid(uint32_t value) {
  
  pathid_ = value;
}
inline void SLRoutePath::set_pathid(uint32_t value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.PathId)
}

// repeated uint64 ProtectedPathBitmap = 7;
inline int SLRoutePath::_internal_protectedpathbitmap_size() const {
  return protectedpathbitmap_.size();
}
inline int SLRoutePath::protectedpathbitmap_size() const {
  return _internal_protectedpathbitmap_size();
}
inline void SLRoutePath::clear_protectedpathbitmap() {
  protectedpathbitmap_.Clear();
}
inline uint64_t SLRoutePath::_internal_protectedpathbitmap(int index) const {
  return protectedpathbitmap_.Get(index);
}
inline uint64_t SLRoutePath::protectedpathbitmap(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.ProtectedPathBitmap)
  return _internal_protectedpathbitmap(index);
}
inline void SLRoutePath::set_protectedpathbitmap(int index, uint64_t value) {
  protectedpathbitmap_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.ProtectedPathBitmap)
}
inline void SLRoutePath::_internal_add_protectedpathbitmap(uint64_t value) {
  protectedpathbitmap_.Add(value);
}
inline void SLRoutePath::add_protectedpathbitmap(uint64_t value) {
  _internal_add_protectedpathbitmap(value);
  // @@protoc_insertion_point(field_add:service_layer.SLRoutePath.ProtectedPathBitmap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SLRoutePath::_internal_protectedpathbitmap() const {
  return protectedpathbitmap_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SLRoutePath::protectedpathbitmap() const {
  // @@protoc_insertion_point(field_list:service_layer.SLRoutePath.ProtectedPathBitmap)
  return _internal_protectedpathbitmap();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SLRoutePath::_internal_mutable_protectedpathbitmap() {
  return &protectedpathbitmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SLRoutePath::mutable_protectedpathbitmap() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLRoutePath.ProtectedPathBitmap)
  return _internal_mutable_protectedpathbitmap();
}

// repeated uint32 LabelStack = 8;
inline int SLRoutePath::_internal_labelstack_size() const {
  return labelstack_.size();
}
inline int SLRoutePath::labelstack_size() const {
  return _internal_labelstack_size();
}
inline void SLRoutePath::clear_labelstack() {
  labelstack_.Clear();
}
inline uint32_t SLRoutePath::_internal_labelstack(int index) const {
  return labelstack_.Get(index);
}
inline uint32_t SLRoutePath::labelstack(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.LabelStack)
  return _internal_labelstack(index);
}
inline void SLRoutePath::set_labelstack(int index, uint32_t value) {
  labelstack_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.LabelStack)
}
inline void SLRoutePath::_internal_add_labelstack(uint32_t value) {
  labelstack_.Add(value);
}
inline void SLRoutePath::add_labelstack(uint32_t value) {
  _internal_add_labelstack(value);
  // @@protoc_insertion_point(field_add:service_layer.SLRoutePath.LabelStack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SLRoutePath::_internal_labelstack() const {
  return labelstack_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SLRoutePath::labelstack() const {
  // @@protoc_insertion_point(field_list:service_layer.SLRoutePath.LabelStack)
  return _internal_labelstack();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SLRoutePath::_internal_mutable_labelstack() {
  return &labelstack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SLRoutePath::mutable_labelstack() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLRoutePath.LabelStack)
  return _internal_mutable_labelstack();
}

// repeated .service_layer.SLIpAddress RemoteAddress = 9;
inline int SLRoutePath::_internal_remoteaddress_size() const {
  return remoteaddress_.size();
}
inline int SLRoutePath::remoteaddress_size() const {
  return _internal_remoteaddress_size();
}
inline ::service_layer::SLIpAddress* SLRoutePath::mutable_remoteaddress(int index) {
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.RemoteAddress)
  return remoteaddress_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLIpAddress >*
SLRoutePath::mutable_remoteaddress() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLRoutePath.RemoteAddress)
  return &remoteaddress_;
}
inline const ::service_layer::SLIpAddress& SLRoutePath::_internal_remoteaddress(int index) const {
  return remoteaddress_.Get(index);
}
inline const ::service_layer::SLIpAddress& SLRoutePath::remoteaddress(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.RemoteAddress)
  return _internal_remoteaddress(index);
}
inline ::service_layer::SLIpAddress* SLRoutePath::_internal_add_remoteaddress() {
  return remoteaddress_.Add();
}
inline ::service_layer::SLIpAddress* SLRoutePath::add_remoteaddress() {
  ::service_layer::SLIpAddress* _add = _internal_add_remoteaddress();
  // @@protoc_insertion_point(field_add:service_layer.SLRoutePath.RemoteAddress)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service_layer::SLIpAddress >&
SLRoutePath::remoteaddress() const {
  // @@protoc_insertion_point(field_list:service_layer.SLRoutePath.RemoteAddress)
  return remoteaddress_;
}

// .service_layer.SLEncapType EncapType = 10 [deprecated = true];
inline void SLRoutePath::clear_encaptype() {
  encaptype_ = 0;
}
inline ::service_layer::SLEncapType SLRoutePath::_internal_encaptype() const {
  return static_cast< ::service_layer::SLEncapType >(encaptype_);
}
inline ::service_layer::SLEncapType SLRoutePath::encaptype() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.EncapType)
  return _internal_encaptype();
}
inline void SLRoutePath::_internal_set_encaptype(::service_layer::SLEncapType value) {
  
  encaptype_ = value;
}
inline void SLRoutePath::set_encaptype(::service_layer::SLEncapType value) {
  _internal_set_encaptype(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.EncapType)
}

// bytes VtepRouterMacAddress = 11 [deprecated = true];
inline void SLRoutePath::clear_vteproutermacaddress() {
  vteproutermacaddress_.ClearToEmpty();
}
inline const std::string& SLRoutePath::vteproutermacaddress() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.VtepRouterMacAddress)
  return _internal_vteproutermacaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SLRoutePath::set_vteproutermacaddress(ArgT0&& arg0, ArgT... args) {
 
 vteproutermacaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.VtepRouterMacAddress)
}
inline std::string* SLRoutePath::mutable_vteproutermacaddress() {
  std::string* _s = _internal_mutable_vteproutermacaddress();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.VtepRouterMacAddress)
  return _s;
}
inline const std::string& SLRoutePath::_internal_vteproutermacaddress() const {
  return vteproutermacaddress_.Get();
}
inline void SLRoutePath::_internal_set_vteproutermacaddress(const std::string& value) {
  
  vteproutermacaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SLRoutePath::_internal_mutable_vteproutermacaddress() {
  
  return vteproutermacaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SLRoutePath::release_vteproutermacaddress() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.VtepRouterMacAddress)
  return vteproutermacaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SLRoutePath::set_allocated_vteproutermacaddress(std::string* vteproutermacaddress) {
  if (vteproutermacaddress != nullptr) {
    
  } else {
    
  }
  vteproutermacaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vteproutermacaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vteproutermacaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vteproutermacaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePath.VtepRouterMacAddress)
}

// .service_layer.SLVxLANPath VxLANPath = 12;
inline bool SLRoutePath::_internal_has_vxlanpath() const {
  return this != internal_default_instance() && vxlanpath_ != nullptr;
}
inline bool SLRoutePath::has_vxlanpath() const {
  return _internal_has_vxlanpath();
}
inline void SLRoutePath::clear_vxlanpath() {
  if (GetArenaForAllocation() == nullptr && vxlanpath_ != nullptr) {
    delete vxlanpath_;
  }
  vxlanpath_ = nullptr;
}
inline const ::service_layer::SLVxLANPath& SLRoutePath::_internal_vxlanpath() const {
  const ::service_layer::SLVxLANPath* p = vxlanpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLVxLANPath&>(
      ::service_layer::_SLVxLANPath_default_instance_);
}
inline const ::service_layer::SLVxLANPath& SLRoutePath::vxlanpath() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.VxLANPath)
  return _internal_vxlanpath();
}
inline void SLRoutePath::unsafe_arena_set_allocated_vxlanpath(
    ::service_layer::SLVxLANPath* vxlanpath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vxlanpath_);
  }
  vxlanpath_ = vxlanpath;
  if (vxlanpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRoutePath.VxLANPath)
}
inline ::service_layer::SLVxLANPath* SLRoutePath::release_vxlanpath() {
  
  ::service_layer::SLVxLANPath* temp = vxlanpath_;
  vxlanpath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLVxLANPath* SLRoutePath::unsafe_arena_release_vxlanpath() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.VxLANPath)
  
  ::service_layer::SLVxLANPath* temp = vxlanpath_;
  vxlanpath_ = nullptr;
  return temp;
}
inline ::service_layer::SLVxLANPath* SLRoutePath::_internal_mutable_vxlanpath() {
  
  if (vxlanpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLVxLANPath>(GetArenaForAllocation());
    vxlanpath_ = p;
  }
  return vxlanpath_;
}
inline ::service_layer::SLVxLANPath* SLRoutePath::mutable_vxlanpath() {
  ::service_layer::SLVxLANPath* _msg = _internal_mutable_vxlanpath();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.VxLANPath)
  return _msg;
}
inline void SLRoutePath::set_allocated_vxlanpath(::service_layer::SLVxLANPath* vxlanpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vxlanpath_;
  }
  if (vxlanpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::service_layer::SLVxLANPath>::GetOwningArena(vxlanpath);
    if (message_arena != submessage_arena) {
      vxlanpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vxlanpath, submessage_arena);
    }
    
  } else {
    
  }
  vxlanpath_ = vxlanpath;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePath.VxLANPath)
}

// repeated .service_layer.SLPathFlags PathFlags = 14;
inline int SLRoutePath::_internal_pathflags_size() const {
  return pathflags_.size();
}
inline int SLRoutePath::pathflags_size() const {
  return _internal_pathflags_size();
}
inline void SLRoutePath::clear_pathflags() {
  pathflags_.Clear();
}
inline ::service_layer::SLPathFlags SLRoutePath::_internal_pathflags(int index) const {
  return static_cast< ::service_layer::SLPathFlags >(pathflags_.Get(index));
}
inline ::service_layer::SLPathFlags SLRoutePath::pathflags(int index) const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.PathFlags)
  return _internal_pathflags(index);
}
inline void SLRoutePath::set_pathflags(int index, ::service_layer::SLPathFlags value) {
  pathflags_.Set(index, value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePath.PathFlags)
}
inline void SLRoutePath::_internal_add_pathflags(::service_layer::SLPathFlags value) {
  pathflags_.Add(value);
}
inline void SLRoutePath::add_pathflags(::service_layer::SLPathFlags value) {
  _internal_add_pathflags(value);
  // @@protoc_insertion_point(field_add:service_layer.SLRoutePath.PathFlags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SLRoutePath::pathflags() const {
  // @@protoc_insertion_point(field_list:service_layer.SLRoutePath.PathFlags)
  return pathflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLRoutePath::_internal_mutable_pathflags() {
  return &pathflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SLRoutePath::mutable_pathflags() {
  // @@protoc_insertion_point(field_mutable_list:service_layer.SLRoutePath.PathFlags)
  return _internal_mutable_pathflags();
}

// .service_layer.SLPathGroupRefKey PathGroupKey = 15;
inline bool SLRoutePath::_internal_has_pathgroupkey() const {
  return entry_case() == kPathGroupKey;
}
inline bool SLRoutePath::has_pathgroupkey() const {
  return _internal_has_pathgroupkey();
}
inline void SLRoutePath::set_has_pathgroupkey() {
  _oneof_case_[0] = kPathGroupKey;
}
inline ::service_layer::SLPathGroupRefKey* SLRoutePath::release_pathgroupkey() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePath.PathGroupKey)
  if (_internal_has_pathgroupkey()) {
    clear_has_entry();
      ::service_layer::SLPathGroupRefKey* temp = entry_.pathgroupkey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.pathgroupkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service_layer::SLPathGroupRefKey& SLRoutePath::_internal_pathgroupkey() const {
  return _internal_has_pathgroupkey()
      ? *entry_.pathgroupkey_
      : reinterpret_cast< ::service_layer::SLPathGroupRefKey&>(::service_layer::_SLPathGroupRefKey_default_instance_);
}
inline const ::service_layer::SLPathGroupRefKey& SLRoutePath::pathgroupkey() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePath.PathGroupKey)
  return _internal_pathgroupkey();
}
inline ::service_layer::SLPathGroupRefKey* SLRoutePath::unsafe_arena_release_pathgroupkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service_layer.SLRoutePath.PathGroupKey)
  if (_internal_has_pathgroupkey()) {
    clear_has_entry();
    ::service_layer::SLPathGroupRefKey* temp = entry_.pathgroupkey_;
    entry_.pathgroupkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SLRoutePath::unsafe_arena_set_allocated_pathgroupkey(::service_layer::SLPathGroupRefKey* pathgroupkey) {
  clear_entry();
  if (pathgroupkey) {
    set_has_pathgroupkey();
    entry_.pathgroupkey_ = pathgroupkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRoutePath.PathGroupKey)
}
inline ::service_layer::SLPathGroupRefKey* SLRoutePath::_internal_mutable_pathgroupkey() {
  if (!_internal_has_pathgroupkey()) {
    clear_entry();
    set_has_pathgroupkey();
    entry_.pathgroupkey_ = CreateMaybeMessage< ::service_layer::SLPathGroupRefKey >(GetArenaForAllocation());
  }
  return entry_.pathgroupkey_;
}
inline ::service_layer::SLPathGroupRefKey* SLRoutePath::mutable_pathgroupkey() {
  ::service_layer::SLPathGroupRefKey* _msg = _internal_mutable_pathgroupkey();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePath.PathGroupKey)
  return _msg;
}

inline bool SLRoutePath::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void SLRoutePath::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline SLRoutePath::EntryCase SLRoutePath::entry_case() const {
  return SLRoutePath::EntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLRoutePrefix

// .service_layer.SLIpAddress Prefix = 1;
inline bool SLRoutePrefix::_internal_has_prefix() const {
  return this != internal_default_instance() && prefix_ != nullptr;
}
inline bool SLRoutePrefix::has_prefix() const {
  return _internal_has_prefix();
}
inline const ::service_layer::SLIpAddress& SLRoutePrefix::_internal_prefix() const {
  const ::service_layer::SLIpAddress* p = prefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::service_layer::SLIpAddress&>(
      ::service_layer::_SLIpAddress_default_instance_);
}
inline const ::service_layer::SLIpAddress& SLRoutePrefix::prefix() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePrefix.Prefix)
  return _internal_prefix();
}
inline void SLRoutePrefix::unsafe_arena_set_allocated_prefix(
    ::service_layer::SLIpAddress* prefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  prefix_ = prefix;
  if (prefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service_layer.SLRoutePrefix.Prefix)
}
inline ::service_layer::SLIpAddress* SLRoutePrefix::release_prefix() {
  
  ::service_layer::SLIpAddress* temp = prefix_;
  prefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service_layer::SLIpAddress* SLRoutePrefix::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_release:service_layer.SLRoutePrefix.Prefix)
  
  ::service_layer::SLIpAddress* temp = prefix_;
  prefix_ = nullptr;
  return temp;
}
inline ::service_layer::SLIpAddress* SLRoutePrefix::_internal_mutable_prefix() {
  
  if (prefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::service_layer::SLIpAddress>(GetArenaForAllocation());
    prefix_ = p;
  }
  return prefix_;
}
inline ::service_layer::SLIpAddress* SLRoutePrefix::mutable_prefix() {
  ::service_layer::SLIpAddress* _msg = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:service_layer.SLRoutePrefix.Prefix)
  return _msg;
}
inline void SLRoutePrefix::set_allocated_prefix(::service_layer::SLIpAddress* prefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  if (prefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix));
    if (message_arena != submessage_arena) {
      prefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prefix, submessage_arena);
    }
    
  } else {
    
  }
  prefix_ = prefix;
  // @@protoc_insertion_point(field_set_allocated:service_layer.SLRoutePrefix.Prefix)
}

// uint32 PrefixLen = 2;
inline void SLRoutePrefix::clear_prefixlen() {
  prefixlen_ = 0u;
}
inline uint32_t SLRoutePrefix::_internal_prefixlen() const {
  return prefixlen_;
}
inline uint32_t SLRoutePrefix::prefixlen() const {
  // @@protoc_insertion_point(field_get:service_layer.SLRoutePrefix.PrefixLen)
  return _internal_prefixlen();
}
inline void SLRoutePrefix::_internal_set_prefixlen(uint32_t value) {
  
  prefixlen_ = value;
}
inline void SLRoutePrefix::set_prefixlen(uint32_t value) {
  _internal_set_prefixlen(value);
  // @@protoc_insertion_point(field_set:service_layer.SLRoutePrefix.PrefixLen)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_layer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service_layer::SLNotifType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLNotifType>() {
  return ::service_layer::SLNotifType_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLRouteFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLRouteFlags>() {
  return ::service_layer::SLRouteFlags_descriptor();
}
template <> struct is_proto_enum< ::service_layer::SLPathFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_layer::SLPathFlags>() {
  return ::service_layer::SLPathFlags_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sl_5froute_5fcommon_2eproto
