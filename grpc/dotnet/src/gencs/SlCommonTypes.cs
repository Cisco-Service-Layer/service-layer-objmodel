// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: sl_common_types.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ServiceLayer {

  /// <summary>Holder for reflection information generated from sl_common_types.proto</summary>
  public static partial class SlCommonTypesReflection {

    #region Descriptor
    /// <summary>File descriptor for sl_common_types.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static SlCommonTypesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVzbF9jb21tb25fdHlwZXMucHJvdG8SDXNlcnZpY2VfbGF5ZXIiqGgKDVNM",
            "RXJyb3JTdGF0dXMSNAoGU3RhdHVzGAEgASgOMiQuc2VydmljZV9sYXllci5T",
            "TEVycm9yU3RhdHVzLlNMRXJybm8i4GcKB1NMRXJybm8SDgoKU0xfU1VDQ0VT",
            "UxAAEhQKEFNMX05PVF9DT05ORUNURUQQARINCglTTF9FQUdBSU4QAhINCglT",
            "TF9FTk9NRU0QAxIMCghTTF9FQlVTWRAEEg0KCVNMX0VJTlZBTBAFEhYKElNM",
            "X1VOU1VQUE9SVEVEX1ZFUhAGEhQKEFNMX05PVF9BVkFJTEFCTEUQBxIbChdT",
            "TF9TVFJFQU1fTk9UX1NVUFBPUlRFRBAIEg4KClNMX0VOT1RTVVAQCRIPCgtT",
            "TF9TT01FX0VSUhAKEg4KClNMX1RJTUVPVVQQCxIRCg1TTF9OT1RJRl9URVJN",
            "EAwSEAoMU0xfQVVUSF9GQUlMEA0SHQoZU0xfQUNLX1RZUEVfTk9UX1NVUFBP",
            "UlRFRBAOEhkKFFNMX0lOSVRfU1RBUlRfT0ZGU0VUEIAKEhgKE1NMX0lOSVRf",
            "U1RBVEVfQ0xFQVIQgQoSGAoTU0xfSU5JVF9TVEFURV9SRUFEWRCCChIcChdT",
            "TF9JTklUX1VOU1VQUE9SVEVEX1ZFUhCDChIjCh5TTF9JTklUX1NFUlZFUl9O",
            "T1RfSU5JVElBTElaRUQQhAoSJgohU0xfSU5JVF9TRVJWRVJfTU9ERV9DSEFO",
            "R0VfRkFJTEVEEIUKEhwKF1NMX1JQQ19WUkZfU1RBUlRfT0ZGU0VUEIAgEiUK",
            "IFNMX1JQQ19WUkZfVE9PX01BTllfVlJGX1JFR19NU0dTEIEgEiYKIVNMX1JQ",
            "Q19WUkZfU0VSVkVSX05PVF9JTklUSUFMSVpFRBCCIBImCiFTTF9SUENfVlJG",
            "X09QX05PVFNVUF9XSVRIX0FVVE9SRUcQgyASGAoTU0xfVlJGX1NUQVJUX09G",
            "RlNFVBCAQBIYChNTTF9WUkZfTkFNRV9UT09MT05HEIFAEhUKEFNMX1ZSRl9O",
            "T1RfRk9VTkQQgkASFwoSU0xfVlJGX05PX1RBQkxFX0lEEINAEiYKIVNMX1ZS",
            "Rl9SRUdfSU5WQUxJRF9BRE1JTl9ESVNUQU5DRRCEQBIZChRTTF9WUkZfVEFC",
            "TEVfQUREX0VSUhCFQBIiCh1TTF9WUkZfVEFCTEVfUkVHSVNUUkFUSU9OX0VS",
            "UhCGQBIkCh9TTF9WUkZfVEFCTEVfVU5SRUdJU1RSQVRJT05fRVJSEIdAEhkK",
            "FFNMX1ZSRl9UQUJMRV9FT0ZfRVJSEIhAEiAKG1NMX1ZSRl9SRUdfVlJGX05B",
            "TUVfTUlTU0lORxCJQBInCiJTTF9WUkZfVjRfUk9VVEVfUkVQTEFZX0ZBVEFM",
            "X0VSUk9SEJBAEicKIlNMX1ZSRl9WNl9ST1VURV9SRVBMQVlfRkFUQUxfRVJS",
            "T1IQkUASHgoZU0xfVlJGX1Y0X1JPVVRFX1JFUExBWV9PSxCSQBIeChlTTF9W",
            "UkZfVjZfUk9VVEVfUkVQTEFZX09LEJNAEh4KGVNMX1JQQ19ST1VURV9TVEFS",
            "VF9PRkZTRVQQgGASIQocU0xfUlBDX1JPVVRFX1RPT19NQU5ZX1JPVVRFUxCB",
            "YBIiCh1TTF9SUENfUk9VVEVfVlJGX05BTUVfVE9PTE9ORxCCYBIfChpTTF9S",
            "UENfUk9VVEVfVlJGX05PVF9GT1VORBCDYBIeChlTTF9SUENfUk9VVEVfVlJG",
            "X05PX1RBQkxFEIRgEioKJVNMX1JQQ19ST1VURV9WUkZfVEFCTEVfTk9UX1JF",
            "R0lTVEVSRUQQhWASIgodU0xfUlBDX1JPVVRFX1ZSRl9OQU1FX01JU1NJTkcQ",
            "hmASKAojU0xfUlBDX1JPVVRFX0lOSVRfTU9ERV9JTkNPTVBBVElCTEUQh2AS",
            "KAojU0xfUlBDX1JPVVRFX1NFUlZFUl9OT1RfSU5JVElBTElaRUQQiGASKQok",
            "U0xfUlBDX1JPVVRFX05PVElGX1NSQ19QUk9UT19UT09MT05HEIlgEi0KKFNM",
            "X1JQQ19ST1VURV9OT1RJRl9TUkNfUFJPVE9fVEFHX1RPT0xPTkcQimASIwoe",
            "U0xfUlBDX1JPVVRFX0dFVF9NQVRDSF9JTlZBTElEEItgEiIKHVNMX1JQQ19S",
            "T1VURV9HRVRfTUFUQ0hfTk9UU1VQEIxgEhsKFVNMX1JPVVRFX1NUQVJUX09G",
            "RlNFVBCAgAESGwoVU0xfUk9VVEVfQUREX05PX1BBVEhTEIGAARIeChhTTF9S",
            "T1VURV9VUERBVEVfTk9fUEFUSFMQgoABEiEKG1NMX1JPVVRFX0lOVkFMSURf",
            "UFJFRklYX0xFThCDgAESJQofU0xfUk9VVEVfSU5WQUxJRF9BRE1JTl9ESVNU",
            "QU5DRRCEgAESIAoaU0xfUk9VVEVfSU5WQUxJRF9OVU1fUEFUSFMQhYABEiAK",
            "GlNMX1JPVVRFX0lOVkFMSURfUFJFRklYX1NaEIaAARIdChdTTF9ST1VURV9J",
            "TlZBTElEX1BSRUZJWBCHgAESKgokU0xfUk9VVEVfRVJSX1JJQl9UQUJMRV9M",
            "SU1JVF9SRUFDSEVEEIiAARIjCh1TTF9ST1VURV9FUlJfUklCX0lOVkFMSURf",
            "QVJHUxCJgAESJwohU0xfUk9VVEVfRVJSX1JJQl9QQVRIX1RBQkxFX0xJTUlU",
            "EIqAARIjCh1TTF9ST1VURV9FUlJfUklCX1RPT01BTllQQVRIUxCLgAESFQoP",
            "U0xfUk9VVEVfRUVYSVNUEIyAARIcChZTTF9ST1VURV9IT1NUX0JJVFNfU0VU",
            "EI2AARIjCh1TTF9ST1VURV9JTlZBTElEX1BSRUZJWF9NQ0FTVBCOgAESIAoa",
            "U0xfUk9VVEVfUEFUSF9BRklfTUlTTUFUQ0gQj4ABEiQKHlNMX1JPVVRFX1RP",
            "T01BTllfUFJJTUFSWV9QQVRIUxCQgAESIwodU0xfUk9VVEVfVE9PTUFOWV9C",
            "QUNLVVBfUEFUSFMQkYABEhcKEVNMX1JPVVRFX0RCX05PTUVNEJKAARIiChxT",
            "TF9ST1VURV9JTlZBTElEX0xPQ0FMX0xBQkVMEJOAARIcChZTTF9ST1VURV9J",
            "TlZBTElEX0ZMQUdTEJSAARIfChlTTF9ST1VURV9JTlZBTElEX1BSSU9SSVRZ",
            "EJWAARIdChdTTF9ST1VURV9JTlZBTElEX01FVFJJQxCWgAESGgoUU0xfUEFU",
            "SF9TVEFSVF9PRkZTRVQQgKABEhkKE1NMX1BBVEhfTkhfTk9fVEFCTEUQgaAB",
            "Eh8KGVNMX1BBVEhfTkhfSU5URl9OT1RfRk9VTkQQgqABEiEKG1NMX1BBVEhf",
            "SU5WQUxJRF9MQUJFTF9DT1VOVBCDoAESGAoSU0xfUEFUSF9JTlZBTElEX0lE",
            "EISgARIeChhTTF9QQVRIX1ZSRl9OQU1FX1RPT0xPTkcQhaABEiIKHFNMX1BB",
            "VEhfTkhfSU5URl9OQU1FX1RPT0xPTkcQhqABEiAKGlNMX1BBVEhfTkhfSU5W",
            "QUxJRF9BRERSX1NaEIegARIhChtTTF9QQVRIX05IX0lORl9OQU1FX01JU1NJ",
            "TkcQiKABEiMKHVNMX1BBVEhfSU5WQUxJRF9ORVhUX0hPUF9BRERSEImgARIn",
            "CiFTTF9QQVRIX0lOVkFMSURfUkVNT1RFX0FERFJfQ09VTlQQiqABEiQKHlNM",
            "X1BBVEhfUkVNT1RFX0FERFJfSU5WQUxJRF9TWhCLoAESJgogU0xfUEFUSF9S",
            "RU1PVEVfQUREUl9BRklfTUlTTUFUQ0gQjKABEiYKIFNMX1BBVEhfSU5WQUxJ",
            "RF9QUk9URUNURURfQklUTUFQEI2gARIpCiNTTF9QQVRIX0JBQ0tVUF9NSVNT",
            "SU5HX1BSSU1BUllfUEFUSBCOoAESIQobU0xfUEFUSF9QUklNQVJZX0lEX1JF",
            "UEVBVEVEEI+gARIgChpTTF9QQVRIX0JBQ0tVUF9JRF9SRVBFQVRFRBCQoAES",
            "KgokU0xfUEFUSF9QUklNQVJZX1RPT01BTllfQkFDS1VQX1BBVEhTEJGgARIk",
            "Ch5TTF9QQVRIX1BSSU1BUllfVE9PTUFOWV9MQUJFTFMQkqABEikKI1NMX1BB",
            "VEhfUFJJTUFSWV9UT09NQU5ZX1JFTU9URV9BRERSEJOgARIhChtTTF9QQVRI",
            "X1JFTU9URV9BRERSX0lOVkFMSUQQlKABEhsKFVNMX1BBVEhfSU5WQUxJRF9M",
            "QUJFTBCVoAESKAoiU0xfUEFUSF9ST1VURVJfTUFDX0FERFJfSU5WQUxJRF9T",
            "WhCWoAESIwodU0xfUEFUSF9CQUNLVVBfVE9PTUFOWV9MQUJFTFMQl6ABEhkK",
            "E1NMX1BBVEhfSU5WQUxJRF9WTkkQmKABEiAKGlNMX1BBVEhfSU5WQUxJRF9F",
            "TkNBUF9BRERSEJmgARIoCiJTTF9QQVRIX0VOQ0FQX1NSQ19EU1RfQUZJX01J",
            "U01BVENIEJqgARIbChVTTF9QQVRIX1JUUl9NQUNfTk9TVVAQm6ABEiEKG1NM",
            "X1BBVEhfRU5DQVBfVFlQRV9NSVNNQVRDSBCcoAESHQoXU0xfUlBDX0JGRF9T",
            "VEFSVF9PRkZTRVQQgMABEiYKIFNMX1JQQ19CRkRfVE9PX01BTllfQkZEX1NF",
            "U1NJT05TEIHAARIiChxTTF9SUENfQkZEX0FQSV9CQURfUEFSQU1FVEVSEILA",
            "ARIqCiRTTF9SUENfQkZEX0FQSV9DTElFTlRfTk9UX1JFR0lTVEVSRUQQg8AB",
            "EiMKHVNMX1JQQ19CRkRfQVBJX0lOVEVSTkFMX0VSUk9SEITAARInCiFTTF9S",
            "UENfQkZEX1NFUlZFUl9OT1RfSU5JVElBTElaRUQQhcABEiIKHFNMX1JQQ19C",
            "RkRfVjRfTk9UX1JFR0lTVEVSRUQQhsABEiIKHFNMX1JQQ19CRkRfVjZfTk9U",
            "X1JFR0lTVEVSRUQQh8ABEhkKE1NMX0JGRF9TVEFSVF9PRkZTRVQQgOABEh4K",
            "GFNMX0JGRF9JTlRGX05BTUVfVE9PTE9ORxCB4AESGwoVU0xfQkZEX0lOVEZf",
            "Tk9UX0ZPVU5EEILgARIeChhTTF9CRkRfSU5WQUxJRF9BVFRSSUJVVEUQg+AB",
            "Eh4KGFNMX0JGRF9JTlRGX05BTUVfTUlTU0lORxCE4AESHgoYU0xfQkZEX0lO",
            "VkFMSURfTkJSX01DQVNUEIXgARIYChJTTF9CRkRfSU5WQUxJRF9OQlIQhuAB",
            "Eh0KF1NMX0JGRF9WUkZfTkFNRV9UT09MT05HEIfgARIaChRTTF9CRkRfQkFE",
            "X1BBUkFNRVRFUhCI4AESHwoZU0xfQkZEX0FQSV9JTlRFUk5BTF9FUlJPUhCJ",
            "4AESGgoUU0xfQkZEX1ZSRl9OT1RfRk9VTkQQiuABEiAKGlNMX0JGRF9JTlZB",
            "TElEX1BSRUZJWF9TSVpFEIvgARIhChtTTF9CRkRfSU5WQUxJRF9TRVNTSU9O",
            "X1RZUEUQjOABEhgKElNMX0JGRF9JTlZBTElEX1ZSRhCN4AESHgoYU0xfQkZE",
            "X1NFU1NJT05fTk9UX0ZPVU5EEI7gARIbChVTTF9CRkRfU0VTU0lPTl9FWElT",
            "VFMQj+ABEh4KGFNMX0JGRF9JTlRFUk5BTF9EQl9FUlJPUhCQ4AESGwoVU0xf",
            "QkZEX1JFQ09WRVJZX0VSUk9SEJHgARIeChhTTF9SUENfTVBMU19TVEFSVF9P",
            "RkZTRVQQgIACEiMKHVNMX1JQQ19NUExTX0lMTV9UT09fTUFOWV9JTE1TEIGA",
            "AhIoCiJTTF9SUENfTVBMU19TRVJWRVJfTk9UX0lOSVRJQUxJWkVEEIKAAhIo",
            "CiJTTF9SUENfTVBMU19JTklUX01PREVfSU5DT01QQVRJQkxFEIOAAhIvCilT",
            "TF9SUENfTVBMU19MQUJFTF9CTEtfVE9PX01BTllfTEFCRUxfQkxLUxCEgAIS",
            "IAoaU0xfUlBDX01QTFNfTk9UX1JFR0lTVEVSRUQQhYACEhcKEVNMX0lMTV9F",
            "UlJfT0ZGU0VUEICgAhIXChFTTF9JTE1fQUREX0ZBSUxFRBCBoAISGwoVU0xf",
            "SUxNX0xTRF9BRERfRkFJTEVEEIKgAhIeChhTTF9JTE1fSU5WQUxJRF9OVU1f",
            "TkhMRkUQg6ACEhoKFFNMX0lMTV9JTlZBTElEX0xBQkVMEISgAhIaChRTTF9J",
            "TE1fREVMRVRFX0ZBSUxFRBCFoAISHgoYU0xfSUxNX0xTRF9ERUxFVEVfRkFJ",
            "TEVEEIagAhIjCh1TTF9JTE1fVE9PTUFOWV9QUklNQVJZX05ITEZFUxCHoAIS",
            "IgocU0xfSUxNX1RPT01BTllfQkFDS1VQX05ITEZFUxCIoAISJwohU0xfSUxN",
            "X0xTRF9BRERfTEFCRUxfQUxMT0NfRkFJTEVEEImgAhIlCh9TTF9JTE1fTFNE",
            "X05ITEZFX0lOVkFMSURfQVRUUklCEIqgAhITCg1TTF9JTE1fRUVYSVNUEIug",
            "AhIVCg9TTF9JTE1fREJfTk9NRU0QjKACEh0KF1NMX0lMTV9JTlZBTElEX0VM",
            "U1BfRVhQEI2gAhIpCiNTTF9JTE1fRUxTUF9FWFBfT1JfREZMVF9BTFJFQURZ",
            "X1NFVBCOoAISGQoTU0xfSUxNX0FERF9OT19QQVRIUxCPoAISHAoWU0xfSUxN",
            "X1VQREFURV9OT19QQVRIUxCQoAISHQoXU0xfSUxNX1VOU1VQUE9SVEVEX0VM",
            "U1AQkaACEiYKIFNMX0lMTV9MQUJFTF9UT09NQU5ZX0VYUF9DTEFTU0VTEJKg",
            "AhIfChlTTF9JTE1fUkVQTEFZX0ZBVEFMX0VSUk9SEJOgAhIWChBTTF9JTE1f",
            "UkVQTEFZX09LEJSgAhIfChlTTF9JTE1fSU5WQUxJRF9QUkVGSVhfTEVOEJWg",
            "AhIaChRTTF9JTE1fSE9TVF9CSVRTX1NFVBCWoAISHgoYU0xfSUxNX0lOVkFM",
            "SURfUFJFRklYX1NaEJegAhIbChVTTF9JTE1fSU5WQUxJRF9QUkVGSVgQmKAC",
            "EiEKG1NMX0lMTV9JTlZBTElEX1BSRUZJWF9NQ0FTVBCZoAISHQoXU0xfSUxN",
            "X1ZSRl9OQU1FX1RPT0xPTkcQoKACEhwKFlNMX0lMTV9WUkZfTk9fVEFCTEVf",
            "SUQQoaACEh0KF1NMX0lMTV9WUkZfTkFNRV9NSVNTSU5HEKKgAhIZChNTTF9O",
            "SExGRV9FUlJfT0ZGU0VUEIDAAhIaChRTTF9OSExGRV9OSF9OT19UQUJMRRCB",
            "wAISIQobU0xfTkhMRkVfTkhfSU5WQUxJRF9BRERSX1NaEILAAhIkCh5TTF9O",
            "SExGRV9JTlZBTElEX05FWFRfSE9QX0FERFIQg8ACEh8KGVNMX05ITEZFX1ZS",
            "Rl9OQU1FX1RPT0xPTkcQhMACEiIKHFNMX05ITEZFX05IX0lORl9OQU1FX01J",
            "U1NJTkcQhcACEiMKHVNMX05ITEZFX05IX0lOVEZfTkFNRV9UT09MT05HEIbA",
            "AhIiChxTTF9OSExGRV9JTlZBTElEX0xBQkVMX0NPVU5UEIfAAhIeChhTTF9O",
            "SExGRV9JTlZBTElEX1BBVEhfSUQQiMACEhwKFlNMX05ITEZFX0lOVkFMSURf",
            "TEFCRUwQicACEicKIVNMX05ITEZFX0lOVkFMSURfUFJPVEVDVEVEX0JJVE1B",
            "UBCKwAISKAoiU0xfTkhMRkVfSU5WQUxJRF9SRU1PVEVfQUREUl9DT1VOVBCL",
            "wAISJQofU0xfTkhMRkVfUkVNT1RFX0FERFJfSU5WQUxJRF9TWhCMwAISJQof",
            "U0xfTkhMRkVfUFJJTUFSWV9UT09NQU5ZX0xBQkVMUxCNwAISKgokU0xfTkhM",
            "RkVfUFJJTUFSWV9UT09NQU5ZX1JFTU9URV9BRERSEI7AAhIhChtTTF9OSExG",
            "RV9CQUNLVVBfSURfUkVQRUFURUQQj8ACEiIKHFNMX05ITEZFX1BSSU1BUllf",
            "SURfUkVQRUFURUQQkMACEiwKJlNMX05ITEZFX0JBQ0tVUF9QUk9URUNURURf",
            "QklUTUFQX0VNUFRZEJHAAhIrCiVTTF9OSExGRV9QUklNQVJZX1RPT01BTllf",
            "QkFDS1VQX1BBVEhTEJLAAhIiChxTTF9OSExGRV9SRU1PVEVfQUREUl9JTlZB",
            "TElEEJPAAhIqCiRTTF9OSExGRV9CQUNLVVBfTUlTU0lOR19QUklNQVJZX1BB",
            "VEgQlMACEh8KGVNMX05ITEZFX05FWFRfSE9QX01JU1NJTkcQlcACEiMKHVNM",
            "X05ITEZFX0xBQkVMX0FDVElPTl9JTlZBTElEEJbAAhIgChpTTF9OSExGRV9O",
            "SF9JTlRGX05PVF9GT1VORBCXwAISGgoUU0xfTkhMRkVfT1BFUl9GQUlMRUQQ",
            "mMACEiMKHVNMX05ITEZFX0xBQkVMX0FDVElPTl9NSVNTSU5HEJnAAhIdChdT",
            "TF9OSExGRV9FWFBfU0VUX0ZBSUxFRBCawAISKgokU0xfTkhMRkVfRUxTUF9Q",
            "Uk9URUNUSU9OX1VOU1VQUE9SVEVEEJvAAhIfChlTTF9OSExGRV9JTlZBTElE",
            "X0VMU1BfRVhQEJzAAhIkCh5TTF9OSExGRV9JTlZBTElEX1BBVEhfUFJJT1JJ",
            "VFkQncACEiIKHFNMX05ITEZFX0lOVkFMSURfTE9BRF9NRVRSSUMQnsACEhwK",
            "FlNMX05ITEZFX0lOVkFMSURfU0VUSUQQn8ACEiUKH1NMX05ITEZFX0lOVkFM",
            "SURfU0VUSURfUFJJT1JJVFkQoMACEi4KKFNMX05ITEZFX0lOVkFMSURfTVVM",
            "VElQTEVfUFJJTUFSWV9TRVRJRFMQocACEiQKHlNMX05ITEZFX05PTl9DT05U",
            "SUdVT1VTX1NFVElEUxCiwAISIQobU0xfTkhMRkVfTk9OX0NPTlRJR1VPVVNf",
            "RVhQEKPAAhInCiFTTF9OSExGRV9JTkNPTlNJU1RFTlRfRVhQX09OX1BBVEgQ",
            "pMACEh0KF1NMX0xBQkVMX0JMS19FUlJfT0ZGU0VUEIDgAhIhChtTTF9MQUJF",
            "TF9CTEtfTFNEX0FERF9GQUlMRUQQgeACEiQKHlNMX0xBQkVMX0JMS19MU0Rf",
            "REVMRVRFX0ZBSUxFRBCC4AISKgokU0xfTEFCRUxfQkxLX0xTRF9MQUJFTF9C",
            "TEtfTk9UX0ZPVU5EEIPgAhInCiFTTF9MQUJFTF9CTEtfTFNEX0xBQkVMX0JM",
            "S19JTl9VU0UQhOACEiUKH1NMX0xBQkVMX0JMS19MU0RfSU5WQUxJRF9BVFRS",
            "SUIQheACEiUKH1NMX0xBQkVMX0JMS19JTlZBTElEX0JMT0NLX1NJWkUQhuAC",
            "EiYKIFNMX0xBQkVMX0JMS19JTlZBTElEX1NUQVJUX0xBQkVMEIfgAhIZChNT",
            "TF9MQUJFTF9CTEtfRUVYSVNUEIjgAhIbChVTTF9MQUJFTF9CTEtfREJfTk9N",
            "RU0QieACEh8KGVNMX0xBQkVMX0JMS19UWVBFX0lOVkFMSUQQiuACEiYKIFNM",
            "X0xBQkVMX0JMS19DTElFTlRfTkFNRV9UT09MT05HEIvgAhIcChZTTF9NUExT",
            "X1JFR19FUlJfT0ZGU0VUEICAAxIVCg9TTF9NUExTX1JFR19FUlIQgYADEhcK",
            "EVNMX01QTFNfVU5SRUdfRVJSEIKAAxIVCg9TTF9NUExTX0VPRl9FUlIQg4AD",
            "Eh4KGFNMX1JQQ19JTlRGX1NUQVJUX09GRlNFVBCAoAMSJQofU0xfUlBDX0lO",
            "VEZfVE9PX01BTllfSU5URVJGQUNFUxCBoAMSKAoiU0xfUlBDX0lOVEZfU0VS",
            "VkVSX05PVF9JTklUSUFMSVpFRBCCoAMSKwolU0xfUlBDX0lOVEZfQVBJX0NM",
            "SUVOVF9OT1RfUkVHSVNURVJFRBCDoAMSGgoUU0xfSU5URl9TVEFSVF9PRkZT",
            "RVQQgMADEiQKHlNMX0lOVEZfSU5URVJGQUNFX05BTUVfTUlTU0lORxCBwAMS",
            "JAoeU0xfSU5URl9JTlRFUkZBQ0VfTkFNRV9UT09MT05HEILAAxIfChlTTF9J",
            "TlRGX0lOVEVSRkFDRV9SRUdfRVJSEIPAAxIfChlTTF9JTlRGX0lOVEVSTkFM",
            "X0RCX0VSUk9SEITAAxIcChZTTF9JTlRGX1JFQ09WRVJZX0VSUk9SEIXAAxIe",
            "ChhTTF9JTlRGX0lOVEVSRkFDRV9FWElTVFMQhsADEiEKG1NMX0lOVEZfSU5U",
            "RVJGQUNFX05PVF9GT1VORBCHwAMSKwolU0xfSU5URl9JTlRFUkZBQ0VfU1RB",
            "VEVfTk9UX1NVUFBPUlRFRBCIwAMSHAoWU0xfTDJfUkVHX1NUQVJUX09GRlNF",
            "VBCA4AMSHAoWU0xfTDJfUkVHSVNUUkFUSU9OX0VSUhCB4AMSHgoYU0xfTDJf",
            "VU5SRUdJU1RSQVRJT05fRVJSEILgAxITCg1TTF9MMl9FT0ZfRVJSEIPgAxIm",
            "CiBTTF9MMl9SRUdfSU5WQUxJRF9BRE1JTl9ESVNUQU5DRRCE4AMSHAoWU0xf",
            "TDJfUkVHX0lTX0RVUExJQ0FURRCF4AMSJgogU0xfTDJfUkVHX1NFUlZFUl9O",
            "T1RfSU5JVElBTElaRUQQhuADEiMKHVNMX1JQQ19MMl9CRF9SRUdfU1RBUlRf",
            "T0ZGU0VUEICABBIjCh1TTF9SUENfTDJfQkRfUkVHX05BTUVfTUlTU0lORxCB",
            "gAQSJAoeU0xfUlBDX0wyX0JEX1JFR19UT09fTUFOWV9NU0dTEIKABBItCidT",
            "TF9SUENfTDJfQkRfUkVHX1NFUlZFUl9OT1RfSU5JVElBTElaRUQQg4AEEiwK",
            "JlNMX1JQQ19MMl9CRF9SRUdfQ0xJRU5UX05PVF9SRUdJU1RFUkVEEISABBIf",
            "ChlTTF9MMl9CRF9SRUdfU1RBUlRfT0ZGU0VUEICgBBIfChlTTF9MMl9CRF9S",
            "RUdJU1RSQVRJT05fRVJSEIGgBBIhChtTTF9MMl9CRF9VTlJFR0lTVFJBVElP",
            "Tl9FUlIQgqAEEhYKEFNMX0wyX0JEX0VPRl9FUlIQg6AEEiAKGlNMX0wyX0JE",
            "X1JFR19OQU1FX1RPT19MT05HEISgBBIfChlTTF9MMl9CRF9SRUdfQkRfTk9U",
            "X0ZPVU5EEIWgBBIiChxTTF9SUENfTDJfUk9VVEVfU1RBUlRfT0ZGU0VUEIDA",
            "BBIjCh1TTF9SUENfTDJfUk9VVEVfVE9PX01BTllfTVNHUxCBwAQSLAomU0xf",
            "UlBDX0wyX1JPVVRFX1NFUlZFUl9OT1RfSU5JVElBTElaRUQQgsAEEisKJVNM",
            "X1JQQ19MMl9ST1VURV9DTElFTlRfTk9UX1JFR0lTVEVSRUQQg8AEEh4KGFNM",
            "X0wyX1JPVVRFX1NUQVJUX09GRlNFVBCA4AQSIQobU0xfTDJfUk9VVEVfQkRf",
            "TkFNRV9NSVNTSU5HEIHgBBIhChtTTF9MMl9ST1VURV9CRF9OQU1FX1RPT0xP",
            "TkcQguAEEh4KGFNMX0wyX1JPVVRFX0JEX05PVF9GT1VORBCD4AQSIwodU0xf",
            "TDJfUk9VVEVfQkRfTk9UX1JFR0lTVEVSRUQQhOAEEh4KGFNMX0wyX1JPVVRF",
            "X0lOVkFMSURfQVJHUxCF4AQSIgocU0xfUlBDX0wyX05PVElGX1NUQVJUX09G",
            "RlNFVBCBgAUSLAomU0xfUlBDX0wyX05PVElGX1NFUlZFUl9OT1RfSU5JVElB",
            "TElaRUQQgoAFEisKJVNMX1JQQ19MMl9OT1RJRl9DTElFTlRfTk9UX1JFR0lT",
            "VEVSRUQQg4AFEiAKGlNMX1JQQ19MMl9OT1RJRl9FTkFCTEVfRVJSEISABRIh",
            "ChtTTF9SUENfTDJfTk9USUZfRElTQUJMRV9FUlIQhYAFEh0KF1NMX1JQQ19M",
            "Ml9OT1RJRl9FT0ZfRVJSEIaABRIlCh9TTF9SUENfTDJfTk9USUZfQkRfTkFN",
            "RV9NSVNTSU5HEIeABRIlCh9TTF9SUENfTDJfTk9USUZfQkRfTkFNRV9UT09M",
            "T05HEIiABRIiChxTTF9SUENfTDJfTk9USUZfQkRfTk9UX0ZPVU5EEImABRIX",
            "ChFTTF9QR19WUkZfQUREX0VSUhCBoAUSGAoSU0xfUEdfVlJGX05PX1ZSRklE",
            "EIKgBRIbChVTTF9QR19TVFJfS0VZX1RPT0xPTkcQg6AFEh8KGVNMX1BHX1RB",
            "UkdFVF9WUkZfTk9fVlJGSUQQhKAFEhsKFVNMX1BHX1NUUl9LRVlfSU5WQUxJ",
            "RBCFoAUSHgoYU0xfTkVYVF9IT1BfU1RBUlRfT0ZGU0VUEIDABRIkCh5TTF9O",
            "RVhUX0hPUF9JTlZBTElEX1BSRUZJWF9MRU4QgcAFEh8KGVNMX05FWFRfSE9Q",
            "X0hPU1RfQklUU19TRVQQgsAFEiYKIFNMX05FWFRfSE9QX0lOVkFMSURfUFJF",
            "RklYX01DQVNUEIPABRIgChpTTF9ORVhUX0hPUF9JTlZBTElEX1BSRUZJWBCE",
            "wAUSJwohU0xfTkVYVF9IT1BfSU5WQUxJRF9ORVhUX0hPUF9BRERSEIXABRIj",
            "Ch1TTF9ORVhUX0hPUF9JTlZBTElEX1BSRUZJWF9TWhCGwAUSIAoaU0xfTkVY",
            "VF9IT1BfUklCX0FERF9GQUlMRUQQh8AFEiQKHlNMX1JPVVRFX1JFRElTVF9S",
            "SUJfQUREX0ZBSUxFRBCIwAUSGQoTU0xfQUNLX1NUQVJUX09GRlNFVBCA4AUS",
            "IQobU0xfQUNLX1BFUk1JVF9OT1RfU1VQUE9SVEVEEIHgBRIZChNTTF9BQ0tf",
            "SU5WQUxJRF9UWVBFEILgBRIcChZTTF9QT0xJQ1lfU1RBUlRfT0ZGU0VUEICA",
            "BhIXChFTTF9QT0xJQ1lfQUREX0VSUhCBgAYSGgoUU0xfUE9MSUNZX0VYSVNU",
            "U19FUlIQgoAGEhoKFFNMX1BPTElDWV9ERUxFVEVfRVJSEIOABhIcChZTTF9Q",
            "T0xJQ1lfUlVMRV9BRERfRVJSEISABhIfChlTTF9QT0xJQ1lfUlVMRV9FWElT",
            "VFNfRVJSEIWABhIfChlTTF9QT0xJQ1lfUlVMRV9ERUxFVEVfRVJSEIaABhIZ",
            "ChNTTF9QT0xJQ1lfQVBQTFlfRVJSEIeABhIbChVTTF9QT0xJQ1lfVU5BUFBM",
            "WV9FUlIQiIAGEiEKG1NMX1BPTElDWV9UT09fTUFOWV9QT0xJQ0lFUxCJgAYS",
            "HQoXU0xfUE9MSUNZX05BTUVfVE9PX0xPTkcQioAGEiIKHFNMX1BPTElDWV9S",
            "VUxFX05BTUVfVE9PX0xPTkcQi4AGEioKJFNMX1BPTElDWV9EVVBMSUNBVEVf",
            "UFJJT1JJVFlfSU5fUlVMRRCMgAYSJAoeU0xfUE9MSUNZX1JVTEVfTU9EX05P",
            "VF9BTExPV0VEEI2ABhIcChZTTF9QT0xJQ1lfSU5WQUxJRF9SVUxFEI6ABhIh",
            "ChtTTF9QT0xJQ1lfUlVMRV9BRERfTk9fUlVMRVMQj4AGEisKJVNMX1BPTElD",
            "WV9JTlZBTElEX01BVENIX0NPVU5UX0lOX1JVTEUQkIAGEiwKJlNMX1BPTElD",
            "WV9JTlZBTElEX0FDVElPTl9DT1VOVF9JTl9SVUxFEJGABhIZChNTTF9QT0xJ",
            "Q1lfTk9UX0ZPVU5EEJKABhIXChFTTF9QT0xJQ1lfSU5WQUxJRBCTgAYSHAoW",
            "U0xfUE9MSUNZX05BTUVfTUlTU0lORxCUgAYSIQobU0xfUE9MSUNZX1JVTEVf",
            "TkFNRV9NSVNTSU5HEJWABhIoCiJTTF9QT0xJQ1lfUFJJT1JJVFlfTUlTU0lO",
            "R19JTl9SVUxFEJaABhIcChZTTF9QT0xJQ1lfVFlQRV9JTlZBTElEEJeABhIh",
            "ChtTTF9QT0xJQ1lfSU5WQUxJRF9ESVJFQ1RJT04QmIAGEiEKG1NMX1BPTElD",
            "WV9JTlRGX05BTUVfVE9PTE9ORxCZgAYSIQobU0xfUE9MSUNZX0lOVEZfTkFN",
            "RV9NSVNTSU5HEJqABhImCiBTTF9QT0xJQ1lfTUFYX1JVTEVfTElNSVRfUkVB",
            "Q0hFRBCbgAYSIQobU0xfUE9MSUNZX1ZSRl9OQU1FX1RPT19MT05HEJyABhIg",
            "ChpTTF9QT0xJQ1lfVlJGX05BTUVfTUlTU0lORxCdgAYSJgogU0xfUE9MSUNZ",
            "X1BBVEhfR1JQX05BTUVfVE9PX0xPTkcQnoAGEiUKH1NMX1BPTElDWV9QQVRI",
            "X0dSUF9OQU1FX01JU1NJTkcQn4AGEiIKHFNMX1BPTElDWV9JTlZBTElEX0RT",
            "Q1BfVkFMVUUQoIAGEiUKH1NMX1BPTElDWV9QUklPUklUWV9TVFJfVE9PX0xP",
            "TkcQoYAGEiYKIFNMX1BPTElDWV9NQVhfSU5URl9MSU1JVF9SRUFDSEVEEKKA",
            "BhIkCh5TTF9QT0xJQ1lfUlVMRV9ERUxFVEVfTk9fUlVMRVMQo4AGEh4KGFNM",
            "X1BPTElDWV9BUFBMWV9OT19JTlRGUxCkgAYSIAoaU0xfUE9MSUNZX1VOQVBQ",
            "TFlfTk9fSU5URlMQpYAGEhsKFVNMX1BPTElDWV9SRVBMQUNFX0VSUhCmgAYS",
            "IAoaU0xfQkdQTFNfVE9QT19TVEFSVF9PRkZTRVQQgKAGEiMKHVNMX0JHUExT",
            "X1NFUlZFUl9OT1RfQVZBSUxBQkxFEIGgBhIoCiJTTF9CR1BMU19NQVhfTUFU",
            "Q0hfRklMVEVSX0VYQ0VFREVEEIKgBhIjCh1TTF9CR1BMU19NQVhfU1RSRUFN",
            "U19FWENFRURFRBCDoAYSGQoTU0xfQkdQX1NUQVJUX09GRlNFVBCAwAYSHgoY",
            "U0xfQkdQX0lOU1RfTkFNRV9UT09MT05HEIHABhIcChZTTF9CR1BfSU5TVF9O",
            "QU1FX0VNUFRZEILABhIhChtTTF9CR1BfSU5TVF9OT1RfSU5JVElBTElaRUQQ",
            "g8AGEh0KF1NMX0JHUF9JTlZBTElEX09CSl9UWVBFEITABhIgChpTTF9CR1Bf",
            "VlJGX05BTUVfVE9PTE9OR19WNBCFwAYSIAoaU0xfQkdQX1ZSRl9OQU1FX1RP",
            "T0xPTkdfVjYQhsAGEiEKG1NMX0JHUF9VTlNVUFBPUlRFRF9WUkZfTkFNRRCH",
            "wAYSIwodU0xfQkdQX0lOVkFMSURfTkJSX0FERFJfTUNBU1QQiMAGEiEKG1NM",
            "X0JHUF9JTlZBTElEX05CUl9BRERSX0VYUBCJwAYSHQoXU0xfQkdQX0lOVkFM",
            "SURfTkJSX0FERFIQisAGEh4KGFNMX0JHUF9JTlZBTElEX05CUl9WNl9TWhCL",
            "wAYSHAoWU0xfQkdQX0lOVkFMSURfTkJSX0tFWRCMwAYSJQofU0xfQkdQX0lO",
            "VkFMSURfTVBBVEhfQUREUl9NQ0FTVBCNwAYSIwodU0xfQkdQX0lOVkFMSURf",
            "TVBBVEhfQUREUl9FWFAQjsAGEh8KGVNMX0JHUF9JTlZBTElEX01QQVRIX0FE",
            "RFIQj8AGEiAKGlNMX0JHUF9JTlZBTElEX01QQVRIX1Y2X1NaEJDABhIhChtT",
            "TF9CR1BfSU5WQUxJRF9OQlJTQUZJX0xJU1QQkcAGEiUKH1NMX0JHUF9VTlNV",
            "UFBPUlRFRF9CR1BfQUZJX1NBRkkQksAGEhwKFlNMX0JHUF9VTlNVUFBPUlRF",
            "RF9BRkkQk8AGEh0KF1NMX0JHUF9VTlNVUFBPUlRFRF9TQUZJEJTABhIaChRT",
            "TF9CR1BfRU1QVFlfT0JKRUNUUxCVwAYSHgoYU0xfQkdQX0VNUFRZX09CSkVD",
            "VF9MSVNUEJbABhIhChtTTF9CR1BfVVBEQVRFX0JXX0dSUF9GQUlMRUQQl8AG",
            "EiUKH1NMX0JHUF9VUERBVEVfTVBBVEhfQUREUl9GQUlMRUQQmMAGEiEKG1NM",
            "X0JHUF9ERUxFVEVfQldfR1JQX0ZBSUxFRBCZwAYSHgoYU0xfQkdQX0RFTEVU",
            "RV9OQlJfRkFJTEVEEJrABhIeChhTTF9CR1BfREVMRVRFX0FGSV9GQUlMRUQQ",
            "m8AGEiUKH1NMX0JHUF9ERUxFVEVfTVBBVEhfQUREUl9GQUlMRUQQnMAGEhoK",
            "FFNMX0JHUF9ERUxFVEVfRkFJTEVEEJ3ABhIkCh5TTF9CR1BfQldfR1JQX05V",
            "TV9PVVRfT0ZfUkFOR0UQnsAGEiUKH1NMX0JHUF9JTl9CV19HUlBfQ09VTlRf",
            "RVhDRUVERUQQn8AGEiYKIFNMX0JHUF9PVVRfQldfR1JQX0NPVU5UX0VYQ0VF",
            "REVEEKDABhIiChxTTF9CR1BfSU5WQUxJRF9JTl9CV0dSUF9MSVNUEKHABhIj",
            "Ch1TTF9CR1BfSU5WQUxJRF9PVVRfQldHUlBfTElTVBCiwAYSIQobU0xfQkdQ",
            "X0xJTktfQldfT1VUX09GX1JBTkdFEKPABhIhChtTTF9CR1BfTkJSX0lEWF9P",
            "VVRfT0ZfUkFOR0UQpMAGEhwKFlNMX0JHUF9JTlZBTElEX0JXX1RZUEUQpcAG",
            "Eh0KF1NMX0JHUF9CV19HUlBfTElTVF9OVUxMEKbABhIeChhTTF9CR1BfTkJS",
            "U0FGSV9MSVNUX05VTEwQp8AGEiUKH1NMX0JHUF9JTlNUX05PVF9DT05GSUdf",
            "SU5fU0xBUEkQqMAGEiYKIFNMX0JHUF9PQkpfTElTVF9JRFhfT1VUX09GX1JB",
            "TkdFEKnABhIdChdTTF9CR1BfQVNOX09VVF9PRl9SQU5HRRCqwAYSHAoWU0xf",
            "QkdQX0lOVkFMSURfQldfVU5JVBCrwAYSIQobU0xfQkdQX09CSkVDVF9UWVBF",
            "X1JFUVVJUkVEEKzABhIgChpTTF9CR1BfT0JKRUNUX0tFWV9SRVFVSVJFRBCt",
            "wAYSIAoaU0xfQkdQX0lOVkFMSURfT0JKRUNUX1RZUEUQrsAGEiYKIFNMX0JH",
            "UF9HRVRfRVhBQ1RfTUFUQ0hfTk9UX0ZPVU5EEK/ABhIjCh1TTF9CR1BfTUFY",
            "X05FSUdIQk9SU19JTl9TWVNEQhCwwAYSIwodU0xfQkdQX01BWF9PQkpFQ1RT",
            "X0lOX1BBWUxPQUQQscAGEhsKFVNMX0JHUF9JTlRFUk5BTF9FUlJfMRCBwgYS",
            "GwoVU0xfQkdQX0lOVEVSTkFMX0VSUl8yEILCBhIbChVTTF9CR1BfSU5URVJO",
            "QUxfRVJSXzMQg8IGEiEKG1NMX1NSVEVfUE9MSUNZX1NUQVJUX09GRlNFVBCA",
            "4AYSJAoeU0xfU1JURV9QT0xJQ1lfUkVRVUVTVF9JTlZBTElEEIHgBhInCiFT",
            "TF9TUlRFX1BPTElDWV9QT0xJQ1lfS0VZX0lOVkFMSUQQguAGEigKIlNMX1NS",
            "VEVfUE9MSUNZX1BPTElDWV9BVFRSX0lOVkFMSUQQg+AGEiMKHVNMX1NSVEVf",
            "UE9MSUNZX0NQX0tFWV9JTlZBTElEEITgBhIkCh5TTF9TUlRFX1BPTElDWV9D",
            "UF9BVFRSX0lOVkFMSUQQheAGEiQKHlNMX1NSVEVfUE9MSUNZX0NMSUVOVF9N",
            "SVNNQVRDSBCG4AYSIwodU0xfU1JURV9QT0xJQ1lfU0VSVklDRV9OT1RfVVAQ",
            "h+AGEiQKHlNMX1NSVEVfUE9MSUNZX0VYQ0VFRF9NU0dfU0laRRCI4AYSHgoY",
            "U0xfSU5URVJOQUxfU1RBUlRfT0ZGU0VUEICAQCI8CgtTTEludGVyZmFjZRIO",
            "CgROYW1lGAEgASgJSAASEAoGSGFuZGxlGAIgASgNSABCCwoJSW50ZXJmYWNl",
            "IkIKC1NMSXBBZGRyZXNzEhMKCVY0QWRkcmVzcxgBIAEoDUgAEhMKCVY2QWRk",
            "cmVzcxgCIAEoDEgAQgkKB0FkZHJlc3MiIAoNU0xJcHY2QWRkcmVzcxIPCgdh",
            "ZGRyZXNzGAEgASgMIicKGFNMQXV0b25vbW91c1N5c3RlbU51bWJlchILCgNh",
            "c24YASABKA0iJQoKU0xPYmplY3RJZBIOCgROYW1lGAEgASgJSABCBwoFZW50",
            "cnkiVAoRU0xQYXRoR3JvdXBSZWZLZXkSDwoHVnJmTmFtZRgBIAEoCRIuCgtQ",
            "YXRoR3JvdXBJZBgCIAEoCzIZLnNlcnZpY2VfbGF5ZXIuU0xPYmplY3RJZCpi",
            "CgdTTFJlZ09wEhUKEVNMX1JFR09QX1JFU0VSVkVEEAASFQoRU0xfUkVHT1Bf",
            "UkVHSVNURVIQARIXChNTTF9SRUdPUF9VTlJFR0lTVEVSEAISEAoMU0xfUkVH",
            "T1BfRU9GEAMqXwoKU0xPYmplY3RPcBIVChFTTF9PQkpPUF9SRVNFUlZFRBAA",
            "EhAKDFNMX09CSk9QX0FERBABEhMKD1NMX09CSk9QX1VQREFURRACEhMKD1NM",
            "X09CSk9QX0RFTEVURRADKlMKCVNMTm90aWZPcBIXChNTTF9OT1RJRk9QX1JF",
            "U0VSVkVEEAASFQoRU0xfTk9USUZPUF9FTkFCTEUQARIWChJTTF9OT1RJRk9Q",
            "X0RJU0FCTEUQAiqJAQoQU0xVcGRhdGVQcmlvcml0eRIYChRTTF9QUklPUklU",
            "WV9SRVNFUlZFRBAAEhgKFFNMX1BSSU9SSVRZX0NSSVRJQ0FMEAQSFAoQU0xf",
            "UFJJT1JJVFlfSElHSBAIEhYKElNMX1BSSU9SSVRZX01FRElVTRAMEhMKD1NM",
            "X1BSSU9SSVRZX0xPVxAQKksKC1NMRW5jYXBUeXBlEhUKEVNMX0VOQ0FQX1JF",
            "U0VSVkVEEAASEgoOU0xfRU5DQVBfVlhMQU4QARIRCg1TTF9FTkNBUF9NUExT",
            "EAIqjQEKC1NMVGFibGVUeXBlEhoKFlNMX1RBQkxFX1RZUEVfUkVTRVJWRUQQ",
            "ABIXChNTTF9JUHY0X1JPVVRFX1RBQkxFEAESFwoTU0xfSVB2Nl9ST1VURV9U",
            "QUJMRRACEhcKE1NMX01QTFNfTEFCRUxfVEFCTEUQAxIXChNTTF9QQVRIX0dS",
            "T1VQX1RBQkxFEAQqRwoMU0xSc3BBQ0tUeXBlEgsKB1JJQl9BQ0sQABITCg9S",
            "SUJfQU5EX0ZJQl9BQ0sQARIVChFSSUJfRklCX0lOVVNFX0FDSxACKnsKDVNM",
            "QUZGaWJTdGF0dXMSEgoOU0xfRklCX1VOS05PV04QABISCg5TTF9GSUJfU1VD",
            "Q0VTUxABEhEKDVNMX0ZJQl9GQUlMRUQQAhIVChFTTF9GSUJfSU5FTElHSUJM",
            "RRADEhgKFFNMX0ZJQl9JTlVTRV9TVUNDRVNTEAQqogEKDlNMUnNwQUNLUGVy",
            "bWl0EhwKGFNMX1BFUk1JVF9GSUJfU1RBVFVTX0FMTBAAEhkKFVNMX1BFUk1J",
            "VF9GSUJfU1VDQ0VTUxABEhgKFFNMX1BFUk1JVF9GSUJfRkFJTEVEEAISHAoY",
            "U0xfUEVSTUlUX0ZJQl9JTkVMSUdJQkxFEAMSHwobU0xfUEVSTUlUX0ZJQl9J",
            "TlVTRV9TVUNDRVNTEAQqZQoPU0xSc3BBY2tDYWRlbmNlEhUKEVNMX1JTUF9D",
            "T05USU5VT1VTEAASFAoQU0xfUlNQX0pVU1RfT05DRRABEhQKEFNMX1JTUF9P",
            "TkNFX0VBQ0gQAhIPCgtTTF9SU1BfTk9ORRADQlFaT2dpdGh1Yi5jb20vQ2lz",
            "Y28tc2VydmljZS1sYXllci9zZXJ2aWNlLWxheWVyLW9iam1vZGVsL2dycGMv",
            "cHJvdG9zO3NlcnZpY2VfbGF5ZXJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::ServiceLayer.SLRegOp), typeof(global::ServiceLayer.SLObjectOp), typeof(global::ServiceLayer.SLNotifOp), typeof(global::ServiceLayer.SLUpdatePriority), typeof(global::ServiceLayer.SLEncapType), typeof(global::ServiceLayer.SLTableType), typeof(global::ServiceLayer.SLRspACKType), typeof(global::ServiceLayer.SLAFFibStatus), typeof(global::ServiceLayer.SLRspACKPermit), typeof(global::ServiceLayer.SLRspAckCadence), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLErrorStatus), global::ServiceLayer.SLErrorStatus.Parser, new[]{ "Status" }, null, new[]{ typeof(global::ServiceLayer.SLErrorStatus.Types.SLErrno) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLInterface), global::ServiceLayer.SLInterface.Parser, new[]{ "Name", "Handle" }, new[]{ "Interface" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLIpAddress), global::ServiceLayer.SLIpAddress.Parser, new[]{ "V4Address", "V6Address" }, new[]{ "Address" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLIpv6Address), global::ServiceLayer.SLIpv6Address.Parser, new[]{ "Address" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLAutonomousSystemNumber), global::ServiceLayer.SLAutonomousSystemNumber.Parser, new[]{ "Asn" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLObjectId), global::ServiceLayer.SLObjectId.Parser, new[]{ "Name" }, new[]{ "Entry" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ServiceLayer.SLPathGroupRefKey), global::ServiceLayer.SLPathGroupRefKey.Parser, new[]{ "VrfName", "PathGroupId" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Registration Operations.
  /// </summary>
  public enum SLRegOp {
    /// <summary>
    /// Reserved. 0x0
    /// </summary>
    [pbr::OriginalName("SL_REGOP_RESERVED")] Reserved = 0,
    /// <summary>
    /// Register. 0x1
    /// </summary>
    [pbr::OriginalName("SL_REGOP_REGISTER")] Register = 1,
    /// <summary>
    /// Un-Register. 0x2
    /// </summary>
    [pbr::OriginalName("SL_REGOP_UNREGISTER")] Unregister = 2,
    /// <summary>
    /// End Of File. 0x3
    /// </summary>
    [pbr::OriginalName("SL_REGOP_EOF")] Eof = 3,
  }

  /// <summary>
  /// Object Operations.
  /// </summary>
  public enum SLObjectOp {
    /// <summary>
    /// Reserved. 0x0
    /// </summary>
    [pbr::OriginalName("SL_OBJOP_RESERVED")] SlObjopReserved = 0,
    /// <summary>
    /// Add. 0x1
    /// </summary>
    [pbr::OriginalName("SL_OBJOP_ADD")] SlObjopAdd = 1,
    /// <summary>
    /// Update. 0x2
    /// </summary>
    [pbr::OriginalName("SL_OBJOP_UPDATE")] SlObjopUpdate = 2,
    /// <summary>
    /// Delete. 0x3
    /// </summary>
    [pbr::OriginalName("SL_OBJOP_DELETE")] SlObjopDelete = 3,
  }

  /// <summary>
  /// Notification Operations.
  /// </summary>
  public enum SLNotifOp {
    /// <summary>
    /// Reserved. 0x0
    /// </summary>
    [pbr::OriginalName("SL_NOTIFOP_RESERVED")] Reserved = 0,
    /// <summary>
    /// Enable. 0x1
    /// </summary>
    [pbr::OriginalName("SL_NOTIFOP_ENABLE")] Enable = 1,
    /// <summary>
    /// Disable. 0x2
    /// </summary>
    [pbr::OriginalName("SL_NOTIFOP_DISABLE")] Disable = 2,
  }

  /// <summary>
  /// Update Priority
  /// </summary>
  public enum SLUpdatePriority {
    /// <summary>
    /// Reserved. 0x0
    /// </summary>
    [pbr::OriginalName("SL_PRIORITY_RESERVED")] SlPriorityReserved = 0,
    [pbr::OriginalName("SL_PRIORITY_CRITICAL")] SlPriorityCritical = 4,
    [pbr::OriginalName("SL_PRIORITY_HIGH")] SlPriorityHigh = 8,
    [pbr::OriginalName("SL_PRIORITY_MEDIUM")] SlPriorityMedium = 12,
    [pbr::OriginalName("SL_PRIORITY_LOW")] SlPriorityLow = 16,
  }

  /// <summary>
  /// Encapsulation Types.
  /// Specify tunnel encapsulation types.
  /// </summary>
  public enum SLEncapType {
    /// <summary>
    /// Reserved. 0x0
    /// </summary>
    [pbr::OriginalName("SL_ENCAP_RESERVED")] SlEncapReserved = 0,
    /// <summary>
    /// Vxlan encap. 0x1
    /// </summary>
    [pbr::OriginalName("SL_ENCAP_VXLAN")] SlEncapVxlan = 1,
    /// <summary>
    /// Mpls encap. 0x2
    /// </summary>
    [pbr::OriginalName("SL_ENCAP_MPLS")] SlEncapMpls = 2,
  }

  /// <summary>
  /// Table types in a VRF.
  /// </summary>
  public enum SLTableType {
    /// <summary>
    /// Reserved Table type. 0x0
    /// </summary>
    [pbr::OriginalName("SL_TABLE_TYPE_RESERVED")] Reserved = 0,
    /// <summary>
    /// IPv4 Route table. 0x1
    /// </summary>
    [pbr::OriginalName("SL_IPv4_ROUTE_TABLE")] SlIpv4RouteTable = 1,
    /// <summary>
    /// IPv6 Route table. 0x2
    /// </summary>
    [pbr::OriginalName("SL_IPv6_ROUTE_TABLE")] SlIpv6RouteTable = 2,
    /// <summary>
    /// MPLS label table. 0x3
    /// </summary>
    [pbr::OriginalName("SL_MPLS_LABEL_TABLE")] SlMplsLabelTable = 3,
    /// <summary>
    /// Path Group Table. 0x4
    /// </summary>
    [pbr::OriginalName("SL_PATH_GROUP_TABLE")] SlPathGroupTable = 4,
  }

  public enum SLRspACKType {
    /// <summary>
    /// When the operating mode is RIB_ACK,
    /// once the object in the operation is successfully applied to
    /// the network element's RIB, SL_SUCCESS is returned for that operation.
    /// On an error, the object is not updated in the network element's RIB
    /// and error is returned to the client.
    ///
    /// The operation is considered complete once result of RIB programming
    /// is sent back to the client.
    ///
    /// By default, ACK type is assumed to be RIB_ACK.
    /// </summary>
    [pbr::OriginalName("RIB_ACK")] RibAck = 0,
    /// <summary>
    /// When the operating mode is RIB_AND_FIB_ACK,
    /// the first result returned for the operation is RIB's result.
    /// If the object in the operation is successfully applied to RIB,
    /// SL_SUCCESS is returned.
    ///
    /// If the object in the operation is not active and cannot be programmed to
    /// FIB, SL_FIB_INELIGIBLE is returned as a second response and the
    /// operation is considered complete.
    ///
    /// As a result of an operation on an object, if another previously
    /// programmed object becomes ineligible, previously programmed object will
    /// be removed from FIB and SL_FIB_INELIGIBLE will be sent asynchronously
    /// with the last known OperationID for that object. However, the object will
    /// continue to remain in RIB.
    ///
    /// Eventually, when the object becomes active, the object is sent to FIB
    /// and result of the hardware programming is returned asynchronously with
    /// the last known OperationID for that object.
    ///
    /// **Note 1: while the object is waiting for FIB to be programmed,
    /// client can send another update on the object and the object remains
    /// in-active.
    /// The network element may coalesce such back to back operations.
    /// In this scenario, only the last operation on the object is responded to
    /// with corresponding hardware programming result.
    ///
    /// **Note 2: relay of FIB programming status is supported only in server
    /// streaming RPC.
    /// However, the AckType RIB_AND_FIB_ACK is supported in both unary (SLAFOp)
    /// as well as streaming (SLAFOpStream) RPC. When unary RPC is used for
    /// programming an object with ackType as RIB_AND_FIB_ACK, FIB programming
    /// will be tracked internally by the server and can be retrieved
    /// through get operation.
    /// </summary>
    [pbr::OriginalName("RIB_AND_FIB_ACK")] RibAndFibAck = 1,
    /// <summary>
    /// When the ack type is RIB_FIB_INUSE_ACK, along with the behavior
    /// explained above for RIB_AND_FIB_ACK, the client will receive an
    /// additional response of type SL_FIB_INUSE_SUCCESS. RIB_FIB_INUSE_ACK
    /// indicates that object has been programmed in FIB and is being actively
    /// used by one or more forwarding chains.
    /// // RIB_FIB_INUSE_ACK is supported only for object of type SLPathGroup.
    /// </summary>
    [pbr::OriginalName("RIB_FIB_INUSE_ACK")] RibFibInuseAck = 2,
  }

  /// <summary>
  /// SLAFFibStatus defines possible status for hardware programming of
  /// the operaration.
  /// </summary>
  public enum SLAFFibStatus {
    /// <summary>
    /// Hardware programming status is not available for this operation at
    /// this time.
    /// </summary>
    [pbr::OriginalName("SL_FIB_UNKNOWN")] SlFibUnknown = 0,
    /// <summary>
    /// The operation is successfully programmed in hardware.
    /// </summary>
    [pbr::OriginalName("SL_FIB_SUCCESS")] SlFibSuccess = 1,
    /// <summary>
    /// Hardware programming failure
    /// </summary>
    [pbr::OriginalName("SL_FIB_FAILED")] SlFibFailed = 2,
    /// <summary>
    /// The object is not eligible (e.g. not best path, next hop down, etc.)
    /// to be programmed in hardware.
    /// </summary>
    [pbr::OriginalName("SL_FIB_INELIGIBLE")] SlFibIneligible = 3,
    /// <summary>
    /// The forwarding chain using this object is fully active in hardware
    /// and is in-use by at least one referencing object that is also
    /// programmed in hardware.
    /// </summary>
    [pbr::OriginalName("SL_FIB_INUSE_SUCCESS")] SlFibInuseSuccess = 4,
  }

  /// <summary>
  /// SLRspACKPermit defines the list that control the types of hardware
  /// programming responses as defined in SLAFFibStatus that the client is
  /// interested in.
  /// If the SL-API client is interested in only a subset of possible responses
  /// for hardware programming, then the corresponding Permit types can be added
  /// to the list.
  /// Control of response type is supported ONLY when ACK type is
  /// RIB_AND_FIB_ACK or RIB_FIB_INUSE_ACK and is NOT supported when ACK type
  /// is RIB_ACK.
  /// When AckPermit is not set by the SL-API client, the SL-API server
  /// will default to SL_PERMIT_ALL
  /// </summary>
  public enum SLRspACKPermit {
    /// <summary>
    /// An undefined or 0 value Permits all SLAFFibStatus to be relayed to client
    /// </summary>
    [pbr::OriginalName("SL_PERMIT_FIB_STATUS_ALL")] SlPermitFibStatusAll = 0,
    /// <summary>
    /// Permits SL_FIB_SUCCESS to be relayed to client
    /// </summary>
    [pbr::OriginalName("SL_PERMIT_FIB_SUCCESS")] SlPermitFibSuccess = 1,
    /// <summary>
    /// Permits SL_FIB_FAILED to be relayed to client
    /// </summary>
    [pbr::OriginalName("SL_PERMIT_FIB_FAILED")] SlPermitFibFailed = 2,
    /// <summary>
    /// Permits SL_FIB_INELIGIBLE to be relayed to client
    /// </summary>
    [pbr::OriginalName("SL_PERMIT_FIB_INELIGIBLE")] SlPermitFibIneligible = 3,
    /// <summary>
    /// Permits SL_FIB_INUSE_SUCCESS to be relayed to client
    /// </summary>
    [pbr::OriginalName("SL_PERMIT_FIB_INUSE_SUCCESS")] SlPermitFibInuseSuccess = 4,
  }

  /// <summary>
  /// SLRspAckCadence controls the cadence of hardware programming responses.
  /// When SLRspAckCadence is NOT set by the SL-API client, the SL-API server
  /// will default to SL_RSP_CONTINOUS and send responses defined by
  /// SLRspACKPermit, for all hardware programming events including events that
  /// are internal to the router such as insertion or removal of line cards.
  /// Control of cadence is supported only when ACK type is RIB_AND_FIB_ACK
  /// or RIB_FIB_INUSE_ACK.
  /// </summary>
  public enum SLRspAckCadence {
    /// <summary>
    /// Continuous relay of hardware programming/re-programming responses
    /// </summary>
    [pbr::OriginalName("SL_RSP_CONTINUOUS")] SlRspContinuous = 0,
    /// <summary>
    /// SL_RSP_JUST_ONCE cadence will allow only the first response for hardware
    /// programming among the response types defined by SLRspACKPermit
    ///
    /// For Example:
    /// In the case where client sends
    /// Permit == SL_PERMIT_FIB_INELIGIBLE |
    ///           SL_PERMIT_FIB_SUCCESS |
    ///           SL_PERMIT_FIB_FAILED
    /// Cadence == SL_RSP_JUST_ONCE and at the time of programming if the
    /// object was not viable to be programmed in hardware, then the first
    /// response would be SL_FIB_INELIGIBLE.
    /// There will no further notification even when the object becomes
    /// viable and programmed in FIB.
    /// </summary>
    [pbr::OriginalName("SL_RSP_JUST_ONCE")] SlRspJustOnce = 1,
    /// <summary>
    /// SL_RSP_ONCE_EACH cadence will allow only the first response for hardware
    /// programming per response type defined by SLRspACKPermit
    ///
    /// For Example:
    /// In the case where client sends
    /// Permit == SL_PERMIT_FIB_INELIGIBLE |
    ///           SL_PERMIT_FIB_SUCCESS |
    ///           SL_PERMIT_FIB_FAILED
    /// and Cadence == SL_RSP_ONCE_EACH and at the time of programming if
    /// the object was not viable to be programmed in hardware, then the
    /// first response would be SL_FIB_INELIGIBLE.
    /// Later, whenever the route becomes viable and gets programmed in the
    /// FIB the corresponding result SL_FIB_SUCCESS/SL_FIB_FAILED will
    /// be also be notified.
    /// This  will be particularly useful in the case of out of order programming
    /// where the prefix is ineligible until referenced PathGroup is programmed.
    /// </summary>
    [pbr::OriginalName("SL_RSP_ONCE_EACH")] SlRspOnceEach = 2,
    /// <summary>
    /// Blocks all response types. This option is used when client expects
    /// the hw-programming to be tracked internally within service-layer gRPC
    /// server but doesn't expect any notification to be sent to the client.
    /// When SL_RSP_NONE is used, the value of SLRspACKPermit is ignored.
    /// </summary>
    [pbr::OriginalName("SL_RSP_NONE")] SlRspNone = 3,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Status codes, including errors and success codes.
  /// All service layer errors are defined below.
  /// </summary>
  public sealed partial class SLErrorStatus : pb::IMessage<SLErrorStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLErrorStatus> _parser = new pb::MessageParser<SLErrorStatus>(() => new SLErrorStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLErrorStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLErrorStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLErrorStatus(SLErrorStatus other) : this() {
      status_ = other.status_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLErrorStatus Clone() {
      return new SLErrorStatus(this);
    }

    /// <summary>Field number for the "Status" field.</summary>
    public const int StatusFieldNumber = 1;
    private global::ServiceLayer.SLErrorStatus.Types.SLErrno status_ = global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ServiceLayer.SLErrorStatus.Types.SLErrno Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLErrorStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLErrorStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Status != global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Status != global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Status != global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLErrorStatus other) {
      if (other == null) {
        return;
      }
      if (other.Status != global::ServiceLayer.SLErrorStatus.Types.SLErrno.SlSuccess) {
        Status = other.Status;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = (global::ServiceLayer.SLErrorStatus.Types.SLErrno) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Status = (global::ServiceLayer.SLErrorStatus.Types.SLErrno) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SLErrorStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum SLErrno {
        /// <summary>
        /// Success, no errors detected. 0x0.
        /// </summary>
        [pbr::OriginalName("SL_SUCCESS")] SlSuccess = 0,
        /// <summary>
        /// Client not connected. 0x1
        /// </summary>
        [pbr::OriginalName("SL_NOT_CONNECTED")] SlNotConnected = 1,
        /// <summary>
        /// Operation must be retried. 0x2
        /// </summary>
        [pbr::OriginalName("SL_EAGAIN")] SlEagain = 2,
        /// <summary>
        /// One or more components does not have sufficient memory. 0x3
        /// </summary>
        [pbr::OriginalName("SL_ENOMEM")] SlEnomem = 3,
        /// <summary>
        /// Too many outstanding requests. 0x4
        /// </summary>
        [pbr::OriginalName("SL_EBUSY")] SlEbusy = 4,
        /// <summary>
        /// One or more arguments are invalid. 0x5
        /// </summary>
        [pbr::OriginalName("SL_EINVAL")] SlEinval = 5,
        /// <summary>
        /// Unsupported version. 0x6
        /// </summary>
        [pbr::OriginalName("SL_UNSUPPORTED_VER")] SlUnsupportedVer = 6,
        /// <summary>
        /// Not Available. 0x7
        /// </summary>
        [pbr::OriginalName("SL_NOT_AVAILABLE")] SlNotAvailable = 7,
        /// <summary>
        /// Stream mode not supported. 0x8
        /// </summary>
        [pbr::OriginalName("SL_STREAM_NOT_SUPPORTED")] SlStreamNotSupported = 8,
        /// <summary>
        /// Operation not supported. 0x9
        /// </summary>
        [pbr::OriginalName("SL_ENOTSUP")] SlEnotsup = 9,
        /// <summary>
        /// One or more objects is errored:
        /// Each object must be individually examined. 0xa
        /// </summary>
        [pbr::OriginalName("SL_SOME_ERR")] SlSomeErr = 10,
        /// <summary>
        /// Operation Timed out.
        /// The result of the operation is undeterministic (success or fail). 0xb
        /// </summary>
        [pbr::OriginalName("SL_TIMEOUT")] SlTimeout = 11,
        /// <summary>
        /// Due to some event, the client will no longer receive notification
        /// events on this channel. 0xc
        /// Such events include:
        /// - Notification Session was hijacked by another client.
        /// </summary>
        [pbr::OriginalName("SL_NOTIF_TERM")] SlNotifTerm = 12,
        /// <summary>
        /// Authentication failure.
        /// Incorrect credentials passed in by RPC. 0xd
        /// </summary>
        [pbr::OriginalName("SL_AUTH_FAIL")] SlAuthFail = 13,
        /// <summary>
        /// Ack type not supported error. 0xe
        /// </summary>
        [pbr::OriginalName("SL_ACK_TYPE_NOT_SUPPORTED")] SlAckTypeNotSupported = 14,
        /// <summary>
        /// Offset for INIT errors. 0x500
        /// </summary>
        [pbr::OriginalName("SL_INIT_START_OFFSET")] SlInitStartOffset = 1280,
        /// <summary>
        /// Success, no errors detected - clear state.
        /// This error is returned on the first-ever initialization, or,
        /// when a fatal event has occured and all previous state was lost. 0x501
        /// </summary>
        [pbr::OriginalName("SL_INIT_STATE_CLEAR")] SlInitStateClear = 1281,
        /// <summary>
        /// Success, no errors detected - previous state is recovered.
        /// This error is returned on a client re-initialization with
        /// successful recovery of state. Note that any unacknowledged
        /// data previously sent should be considered lost. 0x502
        /// </summary>
        [pbr::OriginalName("SL_INIT_STATE_READY")] SlInitStateReady = 1282,
        /// <summary>
        /// Server software incompatible with client software version. 0x503
        /// </summary>
        [pbr::OriginalName("SL_INIT_UNSUPPORTED_VER")] SlInitUnsupportedVer = 1283,
        /// <summary>
        /// Initialization request received while server is not ready. 0x504
        /// </summary>
        [pbr::OriginalName("SL_INIT_SERVER_NOT_INITIALIZED")] SlInitServerNotInitialized = 1284,
        /// <summary>
        /// Server operational mode change from stream to non-stream
        /// or vice-versa failed. 0x505
        /// </summary>
        [pbr::OriginalName("SL_INIT_SERVER_MODE_CHANGE_FAILED")] SlInitServerModeChangeFailed = 1285,
        /// <summary>
        /// Offset for VRF errors. 0x1000
        /// </summary>
        [pbr::OriginalName("SL_RPC_VRF_START_OFFSET")] SlRpcVrfStartOffset = 4096,
        /// <summary>
        /// Operation rejected for ALL VRFs due to too many VRF registration
        /// messages in the request. 0x1001
        /// </summary>
        [pbr::OriginalName("SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS")] SlRpcVrfTooManyVrfRegMsgs = 4097,
        /// <summary>
        /// Operation rejected for all VRFs as server is not initialized. 0x1002
        /// </summary>
        [pbr::OriginalName("SL_RPC_VRF_SERVER_NOT_INITIALIZED")] SlRpcVrfServerNotInitialized = 4098,
        /// <summary>
        /// Operation not supported in auto-register mode. 0x1003
        /// </summary>
        [pbr::OriginalName("SL_RPC_VRF_OP_NOTSUP_WITH_AUTOREG")] SlRpcVrfOpNotsupWithAutoreg = 4099,
        /// <summary>
        /// Offset for VRF errors. 0x2000
        /// </summary>
        [pbr::OriginalName("SL_VRF_START_OFFSET")] SlVrfStartOffset = 8192,
        /// <summary>
        /// VRF name in the VRF registration message is too long. 0x2001
        /// </summary>
        [pbr::OriginalName("SL_VRF_NAME_TOOLONG")] SlVrfNameToolong = 8193,
        /// <summary>
        /// VRF not found during a unregister or EOF. 0x2002
        /// </summary>
        [pbr::OriginalName("SL_VRF_NOT_FOUND")] SlVrfNotFound = 8194,
        /// <summary>
        /// On a VRF registration, Table ID for the VRF is not found. 0x2003
        /// </summary>
        [pbr::OriginalName("SL_VRF_NO_TABLE_ID")] SlVrfNoTableId = 8195,
        /// <summary>
        /// VRF add registration message with invalid administrative distance.
        /// 0x2004
        /// </summary>
        [pbr::OriginalName("SL_VRF_REG_INVALID_ADMIN_DISTANCE")] SlVrfRegInvalidAdminDistance = 8196,
        /// <summary>
        /// On a VRF registration, Table cannot be added to persistent memory.
        /// 0x2005
        /// </summary>
        [pbr::OriginalName("SL_VRF_TABLE_ADD_ERR")] SlVrfTableAddErr = 8197,
        /// <summary>
        /// VRF table cannot be registered with RIB. 0x2006
        /// </summary>
        [pbr::OriginalName("SL_VRF_TABLE_REGISTRATION_ERR")] SlVrfTableRegistrationErr = 8198,
        /// <summary>
        /// VRF table cannot be unregistered with RIB. 0x2007
        /// </summary>
        [pbr::OriginalName("SL_VRF_TABLE_UNREGISTRATION_ERR")] SlVrfTableUnregistrationErr = 8199,
        /// <summary>
        /// VRF table RIB EOF operation error. 0x2008
        /// </summary>
        [pbr::OriginalName("SL_VRF_TABLE_EOF_ERR")] SlVrfTableEofErr = 8200,
        /// <summary>
        /// VRF registration message does not have a VRF name. 0x2009
        /// </summary>
        [pbr::OriginalName("SL_VRF_REG_VRF_NAME_MISSING")] SlVrfRegVrfNameMissing = 8201,
        /// <summary>
        /// IPv4 routes in VRF cannot be played to Routing Information Base
        /// on a process restart or connection re-establishment.
        /// The Forwarding Information Base can
        /// can be inconsistent. Agent/Controller should initiate a
        /// recovery action by reloading the device. 0x2010
        /// </summary>
        [pbr::OriginalName("SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR")] SlVrfV4RouteReplayFatalError = 8208,
        /// <summary>
        /// IPv6 routes in VRF cannot be played to Routing Information Base
        /// on a process restart or connection re-establishment.
        /// The Forwarding Information Base can
        /// can be inconsistent. Agent/Controller should initiate a
        /// recovery action by reloading the device. 0x2011
        /// </summary>
        [pbr::OriginalName("SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR")] SlVrfV6RouteReplayFatalError = 8209,
        /// <summary>
        /// IPv4 routes in VRF were played to Routing Information Base
        /// on a process restart or connection re-establishment. 0x2012
        /// </summary>
        [pbr::OriginalName("SL_VRF_V4_ROUTE_REPLAY_OK")] SlVrfV4RouteReplayOk = 8210,
        /// <summary>
        /// IPv6 routes in VRF were played to Routing Information Base
        /// on a process restart or connection re-establishment. 0x2013
        /// </summary>
        [pbr::OriginalName("SL_VRF_V6_ROUTE_REPLAY_OK")] SlVrfV6RouteReplayOk = 8211,
        /// <summary>
        /// Offset for Route operation errors. 0x3000
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_START_OFFSET")] SlRpcRouteStartOffset = 12288,
        /// <summary>
        /// Operation rejected for ALL routes due to too many routes in the
        /// request. 0x3001
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_TOO_MANY_ROUTES")] SlRpcRouteTooManyRoutes = 12289,
        /// <summary>
        /// Operation rejected for ALL routes as the request's VRF name
        /// is too long. 0x3002
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_VRF_NAME_TOOLONG")] SlRpcRouteVrfNameToolong = 12290,
        /// <summary>
        /// Operation rejected for ALL routes as VRF for the given name
        /// is not found. 0x3003
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_VRF_NOT_FOUND")] SlRpcRouteVrfNotFound = 12291,
        /// <summary>
        /// Operation rejected for ALL routes as VRF's Table ID is not found.
        /// 0x3004
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_VRF_NO_TABLE")] SlRpcRouteVrfNoTable = 12292,
        /// <summary>
        /// Operation rejected for ALL routes as VRF is not registered with RIB.
        /// 0x3005
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED")] SlRpcRouteVrfTableNotRegistered = 12293,
        /// <summary>
        /// Route Operation rejected for ALL objects as VRF name is missing.
        /// 0x3006
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_VRF_NAME_MISSING")] SlRpcRouteVrfNameMissing = 12294,
        /// <summary>
        /// Operation rejected for all routes as the RPC request is
        /// not supported for the library's initialization mode. 0x3007
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE")] SlRpcRouteInitModeIncompatible = 12295,
        /// <summary>
        /// Operation rejected for all routes as server is not initialized.
        /// 0x3008
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_SERVER_NOT_INITIALIZED")] SlRpcRouteServerNotInitialized = 12296,
        /// <summary>
        /// Operation rejected as the request's SrcProto is too long. 0x3009
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG")] SlRpcRouteNotifSrcProtoToolong = 12297,
        /// <summary>
        /// Operation rejected as the request's SrcProtoTag is too long. 0x300a
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG")] SlRpcRouteNotifSrcProtoTagToolong = 12298,
        /// <summary>
        /// Operation rejected as the requested match value/values/criteria
        /// is invalid. 0x300b
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_GET_MATCH_INVALID")] SlRpcRouteGetMatchInvalid = 12299,
        /// <summary>
        /// Operation rejected as the requested match value/values/criteria
        /// is not supported. 0x300c
        /// </summary>
        [pbr::OriginalName("SL_RPC_ROUTE_GET_MATCH_NOTSUP")] SlRpcRouteGetMatchNotsup = 12300,
        /// <summary>
        /// Offset for route errors. 0x4000
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_START_OFFSET")] SlRouteStartOffset = 16384,
        /// <summary>
        /// Route add operation requested but no paths were provided. 0x4001
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_ADD_NO_PATHS")] SlRouteAddNoPaths = 16385,
        /// <summary>
        /// Route update operation requested but no paths were provided. 0x4002
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_UPDATE_NO_PATHS")] SlRouteUpdateNoPaths = 16386,
        /// <summary>
        /// Route's prefix length is invalid. 0x4003
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_PREFIX_LEN")] SlRouteInvalidPrefixLen = 16387,
        /// <summary>
        /// Route's admininstrative distance is invalid. 0x4004
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_ADMIN_DISTANCE")] SlRouteInvalidAdminDistance = 16388,
        /// <summary>
        /// Route's number of paths exceeds system capabilities. 0x4005
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_NUM_PATHS")] SlRouteInvalidNumPaths = 16389,
        /// <summary>
        /// Size of IPv6 prefix is invalid. 0x4006
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_PREFIX_SZ")] SlRouteInvalidPrefixSz = 16390,
        /// <summary>
        /// Route's prefix is invalid. 0x4007
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_PREFIX")] SlRouteInvalidPrefix = 16391,
        /// <summary>
        /// Route programming failed in RIB as VRF table limit reached. 0x4008
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED")] SlRouteErrRibTableLimitReached = 16392,
        /// <summary>
        /// RIB route programming failed in RIB due to invalid arguments. 0x4009
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_ERR_RIB_INVALID_ARGS")] SlRouteErrRibInvalidArgs = 16393,
        /// <summary>
        /// One or more paths could not be programmed in RIB as VRF
        /// table limit reached. 0x400a
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT")] SlRouteErrRibPathTableLimit = 16394,
        /// <summary>
        /// One or more paths could not be programmed in RIB as number of paths
        /// reached system limit. 0x400b
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_ERR_RIB_TOOMANYPATHS")] SlRouteErrRibToomanypaths = 16395,
        /// <summary>
        /// This route already exists in the database. 0x400c
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_EEXIST")] SlRouteEexist = 16396,
        /// <summary>
        /// Route prefix has host bits set. 0x400d
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_HOST_BITS_SET")] SlRouteHostBitsSet = 16397,
        /// <summary>
        /// IPv4 Route prefix is a multicast address. 0x400e
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_PREFIX_MCAST")] SlRouteInvalidPrefixMcast = 16398,
        /// <summary>
        /// Route and Path AFI does not match. 0x400f
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_PATH_AFI_MISMATCH")] SlRoutePathAfiMismatch = 16399,
        /// <summary>
        /// Number of primary paths exceeds system capabilities. 0x4010
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_TOOMANY_PRIMARY_PATHS")] SlRouteToomanyPrimaryPaths = 16400,
        /// <summary>
        /// Number of backup paths exceeds system capabilities. 0x4011
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_TOOMANY_BACKUP_PATHS")] SlRouteToomanyBackupPaths = 16401,
        /// <summary>
        /// The route database is out of memory. 0x4012
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_DB_NOMEM")] SlRouteDbNomem = 16402,
        /// <summary>
        /// The route has an invalid local label. 0x4013
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_LOCAL_LABEL")] SlRouteInvalidLocalLabel = 16403,
        /// <summary>
        /// Invalid route flags. 0x4014
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_FLAGS")] SlRouteInvalidFlags = 16404,
        /// <summary>
        /// Invalid route priority. 0x4015
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_PRIORITY")] SlRouteInvalidPriority = 16405,
        /// <summary>
        /// Invalid route metric. 0x4016
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_INVALID_METRIC")] SlRouteInvalidMetric = 16406,
        /// <summary>
        /// Offset for route path errors. 0x5000
        /// </summary>
        [pbr::OriginalName("SL_PATH_START_OFFSET")] SlPathStartOffset = 20480,
        /// <summary>
        /// VRF table for the path could not be determined. 0x5001
        /// </summary>
        [pbr::OriginalName("SL_PATH_NH_NO_TABLE")] SlPathNhNoTable = 20481,
        /// <summary>
        /// Path next hop interface not found. 0x5002
        /// </summary>
        [pbr::OriginalName("SL_PATH_NH_INTF_NOT_FOUND")] SlPathNhIntfNotFound = 20482,
        /// <summary>
        /// Number of labels in the path exceeds system capabilities. 0x5003
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_LABEL_COUNT")] SlPathInvalidLabelCount = 20483,
        /// <summary>
        /// Path ID assigned to the path falls outside the supported range.
        /// 0x5004
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_ID")] SlPathInvalidId = 20484,
        /// <summary>
        /// Path VRF name exceeds supported length. 0x5005
        /// </summary>
        [pbr::OriginalName("SL_PATH_VRF_NAME_TOOLONG")] SlPathVrfNameToolong = 20485,
        /// <summary>
        /// Path next hop interface name exceeds supported length. 0x5006
        /// </summary>
        [pbr::OriginalName("SL_PATH_NH_INTF_NAME_TOOLONG")] SlPathNhIntfNameToolong = 20486,
        /// <summary>
        /// Size of next hop IPv6 address is invalid. 0x5007
        /// </summary>
        [pbr::OriginalName("SL_PATH_NH_INVALID_ADDR_SZ")] SlPathNhInvalidAddrSz = 20487,
        /// <summary>
        /// Next hop interface name is missing from path. 0x5008
        /// </summary>
        [pbr::OriginalName("SL_PATH_NH_INF_NAME_MISSING")] SlPathNhInfNameMissing = 20488,
        /// <summary>
        /// Path has an invalid next hop address. 0x5009
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_NEXT_HOP_ADDR")] SlPathInvalidNextHopAddr = 20489,
        /// <summary>
        /// Number of remote backup addresses in the path exceeds
        /// system capabilities. 0x500a
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_REMOTE_ADDR_COUNT")] SlPathInvalidRemoteAddrCount = 20490,
        /// <summary>
        /// Size of IPv6 remote backup address is invalid. 0x500b
        /// </summary>
        [pbr::OriginalName("SL_PATH_REMOTE_ADDR_INVALID_SZ")] SlPathRemoteAddrInvalidSz = 20491,
        /// <summary>
        /// Route and Path remote backup address AFI does not match. 0x500c
        /// </summary>
        [pbr::OriginalName("SL_PATH_REMOTE_ADDR_AFI_MISMATCH")] SlPathRemoteAddrAfiMismatch = 20492,
        /// <summary>
        /// Path has an invalid protection bitmap. 0x500d
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_PROTECTED_BITMAP")] SlPathInvalidProtectedBitmap = 20493,
        /// <summary>
        /// Protection bitmap of a backup path refers to a missing path. 0x500e
        /// </summary>
        [pbr::OriginalName("SL_PATH_BACKUP_MISSING_PRIMARY_PATH")] SlPathBackupMissingPrimaryPath = 20494,
        /// <summary>
        /// Too many primary paths with same Path ID. 0x500f
        /// </summary>
        [pbr::OriginalName("SL_PATH_PRIMARY_ID_REPEATED")] SlPathPrimaryIdRepeated = 20495,
        /// <summary>
        /// Too many pure backup paths with same Path ID. 0x5010
        /// </summary>
        [pbr::OriginalName("SL_PATH_BACKUP_ID_REPEATED")] SlPathBackupIdRepeated = 20496,
        /// <summary>
        /// A primary path has too many backup paths. 0x5011
        /// </summary>
        [pbr::OriginalName("SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS")] SlPathPrimaryToomanyBackupPaths = 20497,
        /// <summary>
        /// A primary path has too many labels. 0x5012
        /// </summary>
        [pbr::OriginalName("SL_PATH_PRIMARY_TOOMANY_LABELS")] SlPathPrimaryToomanyLabels = 20498,
        /// <summary>
        /// A primary path has too many remote addresses. 0x5013
        /// </summary>
        [pbr::OriginalName("SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR")] SlPathPrimaryToomanyRemoteAddr = 20499,
        /// <summary>
        /// A pure backup remote address is invalid. 0x5014
        /// </summary>
        [pbr::OriginalName("SL_PATH_REMOTE_ADDR_INVALID")] SlPathRemoteAddrInvalid = 20500,
        /// <summary>
        /// Path has an invalid label. 0x5015
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_LABEL")] SlPathInvalidLabel = 20501,
        /// <summary>
        /// Size of router mac address is invalid. 0x5016
        /// </summary>
        [pbr::OriginalName("SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ")] SlPathRouterMacAddrInvalidSz = 20502,
        /// <summary>
        /// A backup path has too many labels. 0x5017
        /// </summary>
        [pbr::OriginalName("SL_PATH_BACKUP_TOOMANY_LABELS")] SlPathBackupToomanyLabels = 20503,
        /// <summary>
        /// Invalid VNI for VxLAN encap. 0x5018
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_VNI")] SlPathInvalidVni = 20504,
        /// <summary>
        /// Path has an invalid  encap address. 0x5019
        /// </summary>
        [pbr::OriginalName("SL_PATH_INVALID_ENCAP_ADDR")] SlPathInvalidEncapAddr = 20505,
        /// <summary>
        /// Path encapsulation source and destination AFI mismatch. 0x501a
        /// </summary>
        [pbr::OriginalName("SL_PATH_ENCAP_SRC_DST_AFI_MISMATCH")] SlPathEncapSrcDstAfiMismatch = 20506,
        /// <summary>
        /// PATH router mac is not supported with VxLAN path attributes. 0x501b
        /// </summary>
        [pbr::OriginalName("SL_PATH_RTR_MAC_NOSUP")] SlPathRtrMacNosup = 20507,
        /// <summary>
        /// Path Encap type attribute does not match specified encapsulation.
        /// 0x501c
        /// </summary>
        [pbr::OriginalName("SL_PATH_ENCAP_TYPE_MISMATCH")] SlPathEncapTypeMismatch = 20508,
        /// <summary>
        /// Offset for BFD operation errors. 0x6000
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_START_OFFSET")] SlRpcBfdStartOffset = 24576,
        /// <summary>
        /// BFD Operation rejected for ALL Sessions as the BFD Session count
        /// is beyond supported limit. 0x6001
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_TOO_MANY_BFD_SESSIONS")] SlRpcBfdTooManyBfdSessions = 24577,
        /// <summary>
        /// BFD Operation rejected due to one or many invalid parameters. 0x6002
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_API_BAD_PARAMETER")] SlRpcBfdApiBadParameter = 24578,
        /// <summary>
        /// BFD Operation failed as server is not registered with BFD. 0x6003
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_API_CLIENT_NOT_REGISTERED")] SlRpcBfdApiClientNotRegistered = 24579,
        /// <summary>
        /// BFD Operation failed with internal error. 0x6004
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_API_INTERNAL_ERROR")] SlRpcBfdApiInternalError = 24580,
        /// <summary>
        /// BFD Operation rejected as server is not initialized. 0x6005
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_SERVER_NOT_INITIALIZED")] SlRpcBfdServerNotInitialized = 24581,
        /// <summary>
        /// BFD IPv4 not registered. 0x6006
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_V4_NOT_REGISTERED")] SlRpcBfdV4NotRegistered = 24582,
        /// <summary>
        /// BFD IPv6 not registered. 0x6007
        /// </summary>
        [pbr::OriginalName("SL_RPC_BFD_V6_NOT_REGISTERED")] SlRpcBfdV6NotRegistered = 24583,
        /// <summary>
        /// Offset for BFD errors. 0x7000
        /// </summary>
        [pbr::OriginalName("SL_BFD_START_OFFSET")] SlBfdStartOffset = 28672,
        /// <summary>
        /// BFD Session's interface name exceeds supported length. 0x7001
        /// </summary>
        [pbr::OriginalName("SL_BFD_INTF_NAME_TOOLONG")] SlBfdIntfNameToolong = 28673,
        /// <summary>
        /// BFD Session's interface not found. 0x7002
        /// </summary>
        [pbr::OriginalName("SL_BFD_INTF_NOT_FOUND")] SlBfdIntfNotFound = 28674,
        /// <summary>
        /// BFD Session's tx interval or multiplier are beyond the
        /// supported range. 0x7003
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_ATTRIBUTE")] SlBfdInvalidAttribute = 28675,
        /// <summary>
        /// BFD Session's interface name is missing. 0x7004
        /// </summary>
        [pbr::OriginalName("SL_BFD_INTF_NAME_MISSING")] SlBfdIntfNameMissing = 28676,
        /// <summary>
        /// BFD Session's neighbor is mcast address. 0x7005
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_NBR_MCAST")] SlBfdInvalidNbrMcast = 28677,
        /// <summary>
        /// BFD Session's neighbor address is invalid. 0x7006
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_NBR")] SlBfdInvalidNbr = 28678,
        /// <summary>
        /// BFD Session's VRF Name is too long. 0x7007
        /// </summary>
        [pbr::OriginalName("SL_BFD_VRF_NAME_TOOLONG")] SlBfdVrfNameToolong = 28679,
        /// <summary>
        /// BFD Session's one or more parameters are invalid.
        /// For example, Multihop BFD can not have the interface name set. 0x7008
        /// </summary>
        [pbr::OriginalName("SL_BFD_BAD_PARAMETER")] SlBfdBadParameter = 28680,
        /// <summary>
        /// BFD Session failed with internal error. 0x7009
        /// </summary>
        [pbr::OriginalName("SL_BFD_API_INTERNAL_ERROR")] SlBfdApiInternalError = 28681,
        /// <summary>
        /// BFD Session's VRF not found. 0x700a
        /// </summary>
        [pbr::OriginalName("SL_BFD_VRF_NOT_FOUND")] SlBfdVrfNotFound = 28682,
        /// <summary>
        /// BFD Session's neighbor IPv6 prefix size is invalid. 0x700b
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_PREFIX_SIZE")] SlBfdInvalidPrefixSize = 28683,
        /// <summary>
        /// BFD Session type invalid. 0x700c
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_SESSION_TYPE")] SlBfdInvalidSessionType = 28684,
        /// <summary>
        /// BFD Session's VRF is Invalid. 0x700d
        /// </summary>
        [pbr::OriginalName("SL_BFD_INVALID_VRF")] SlBfdInvalidVrf = 28685,
        /// <summary>
        /// BFD Session not found. 0x700e
        /// </summary>
        [pbr::OriginalName("SL_BFD_SESSION_NOT_FOUND")] SlBfdSessionNotFound = 28686,
        /// <summary>
        /// BFD Session exists. 0x700f
        /// </summary>
        [pbr::OriginalName("SL_BFD_SESSION_EXISTS")] SlBfdSessionExists = 28687,
        /// <summary>
        /// BFD Internal database error. 0x7010
        /// </summary>
        [pbr::OriginalName("SL_BFD_INTERNAL_DB_ERROR")] SlBfdInternalDbError = 28688,
        /// <summary>
        /// BFD Recovery error. 0x7011
        /// </summary>
        [pbr::OriginalName("SL_BFD_RECOVERY_ERROR")] SlBfdRecoveryError = 28689,
        /// <summary>
        /// Offset for MPLS operation errors. 0x8000
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_START_OFFSET")] SlRpcMplsStartOffset = 32768,
        /// <summary>
        /// Operation rejected for ALL ILMS due to too many ILMS in the
        /// request. 0x8001
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_ILM_TOO_MANY_ILMS")] SlRpcMplsIlmTooManyIlms = 32769,
        /// <summary>
        /// Operation rejected for all ILMs as server is not initialized.
        /// 0x0x8002
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_SERVER_NOT_INITIALIZED")] SlRpcMplsServerNotInitialized = 32770,
        /// <summary>
        /// Operation rejected for all ILMs as the RPC request is
        /// not supported for the library's initialization mode. 0x8003
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE")] SlRpcMplsInitModeIncompatible = 32771,
        /// <summary>
        /// Operation rejected for ALL label blocks due to too many
        /// label blocks in the request. 0x8004
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS")] SlRpcMplsLabelBlkTooManyLabelBlks = 32772,
        /// <summary>
        /// Operation rejected for ALL ILMs as MPLS layer is not registered.
        /// 0x8005
        /// </summary>
        [pbr::OriginalName("SL_RPC_MPLS_NOT_REGISTERED")] SlRpcMplsNotRegistered = 32773,
        /// <summary>
        /// Offset for MPLS ILM errors. 0x9000
        /// </summary>
        [pbr::OriginalName("SL_ILM_ERR_OFFSET")] SlIlmErrOffset = 36864,
        /// <summary>
        /// MPLS ILM add to service layer failed. 0x9001
        /// </summary>
        [pbr::OriginalName("SL_ILM_ADD_FAILED")] SlIlmAddFailed = 36865,
        /// <summary>
        /// MPLS ILM add to Label Switching Database failed. 0x9002
        /// </summary>
        [pbr::OriginalName("SL_ILM_LSD_ADD_FAILED")] SlIlmLsdAddFailed = 36866,
        /// <summary>
        /// MPLS ILM NHLFE count exceeded max supported number. 0x9003
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_NUM_NHLFE")] SlIlmInvalidNumNhlfe = 36867,
        /// <summary>
        /// MPLS ILM label value out of range. 0x9004
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_LABEL")] SlIlmInvalidLabel = 36868,
        /// <summary>
        /// MPLS ILM delete from service layer failed. 0x9005
        /// </summary>
        [pbr::OriginalName("SL_ILM_DELETE_FAILED")] SlIlmDeleteFailed = 36869,
        /// <summary>
        /// MPLS ILM delete from Label Switching Database failed. 0x9006
        /// </summary>
        [pbr::OriginalName("SL_ILM_LSD_DELETE_FAILED")] SlIlmLsdDeleteFailed = 36870,
        /// <summary>
        /// Number of primary NHLFEs exceeds system capabilities. 0x9007
        /// </summary>
        [pbr::OriginalName("SL_ILM_TOOMANY_PRIMARY_NHLFES")] SlIlmToomanyPrimaryNhlfes = 36871,
        /// <summary>
        /// Number of backup NHLFEs exceeds system capabilities. 0x9008
        /// </summary>
        [pbr::OriginalName("SL_ILM_TOOMANY_BACKUP_NHLFES")] SlIlmToomanyBackupNhlfes = 36872,
        /// <summary>
        /// MPLS ILM label alloc failed in Label switching database. 0x9009
        /// </summary>
        [pbr::OriginalName("SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED")] SlIlmLsdAddLabelAllocFailed = 36873,
        /// <summary>
        /// MPLS ILM NHLFE attribute invalid. 0x900a
        /// </summary>
        [pbr::OriginalName("SL_ILM_LSD_NHLFE_INVALID_ATTRIB")] SlIlmLsdNhlfeInvalidAttrib = 36874,
        /// <summary>
        /// MPLS ILM already exists in the database. 0x900b
        /// </summary>
        [pbr::OriginalName("SL_ILM_EEXIST")] SlIlmEexist = 36875,
        /// <summary>
        /// The ILM database is out of memory. 0x900c
        /// </summary>
        [pbr::OriginalName("SL_ILM_DB_NOMEM")] SlIlmDbNomem = 36876,
        /// <summary>
        /// EXP value is outside of the valid range of &lt;0-7>. 0x900d
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_ELSP_EXP")] SlIlmInvalidElspExp = 36877,
        /// <summary>
        /// EXP value or Default already set. 0x900e
        /// </summary>
        [pbr::OriginalName("SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET")] SlIlmElspExpOrDfltAlreadySet = 36878,
        /// <summary>
        /// MPLS ILM add operation requested but no paths were provided. 0x900f
        /// </summary>
        [pbr::OriginalName("SL_ILM_ADD_NO_PATHS")] SlIlmAddNoPaths = 36879,
        /// <summary>
        /// MPLS ILM update operation requested but no paths were provided.
        /// 0x9010
        /// </summary>
        [pbr::OriginalName("SL_ILM_UPDATE_NO_PATHS")] SlIlmUpdateNoPaths = 36880,
        /// <summary>
        /// LSP and ELSP on the same label not supported. 0x9011
        /// </summary>
        [pbr::OriginalName("SL_ILM_UNSUPPORTED_ELSP")] SlIlmUnsupportedElsp = 36881,
        /// <summary>
        /// Number of EXP classes on the label exceed system capabilities. 0x9012
        /// </summary>
        [pbr::OriginalName("SL_ILM_LABEL_TOOMANY_EXP_CLASSES")] SlIlmLabelToomanyExpClasses = 36882,
        /// <summary>
        /// MPLS ILMs cannot be played to Label Switching Database
        /// on a process restart or connection re-establishment.
        /// The Forwarding Information Base can
        /// can be inconsistent. Agent/Controller should initiate a
        /// recovery action by reloading the device. 0x9013
        /// </summary>
        [pbr::OriginalName("SL_ILM_REPLAY_FATAL_ERROR")] SlIlmReplayFatalError = 36883,
        /// <summary>
        /// MPLS ILMs were played to Label Switching Database
        /// on a process restart or connection re-establishment. 0x9014
        /// </summary>
        [pbr::OriginalName("SL_ILM_REPLAY_OK")] SlIlmReplayOk = 36884,
        /// <summary>
        /// ILM's prefix length is invalid. 0x9015
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_PREFIX_LEN")] SlIlmInvalidPrefixLen = 36885,
        /// <summary>
        /// ILM prefix has host bits set. 0x9016
        /// </summary>
        [pbr::OriginalName("SL_ILM_HOST_BITS_SET")] SlIlmHostBitsSet = 36886,
        /// <summary>
        /// Size of IPv6 prefix is invalid. 0x9017
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_PREFIX_SZ")] SlIlmInvalidPrefixSz = 36887,
        /// <summary>
        /// ILM's prefix is invalid. 0x9018
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_PREFIX")] SlIlmInvalidPrefix = 36888,
        /// <summary>
        /// ILM's IPv4 Route prefix is a multicast address. 0x9019
        /// </summary>
        [pbr::OriginalName("SL_ILM_INVALID_PREFIX_MCAST")] SlIlmInvalidPrefixMcast = 36889,
        /// <summary>
        /// VRF name is too long. 0x9020
        /// </summary>
        [pbr::OriginalName("SL_ILM_VRF_NAME_TOOLONG")] SlIlmVrfNameToolong = 36896,
        /// <summary>
        /// VRF's table ID not found. 0x9021
        /// </summary>
        [pbr::OriginalName("SL_ILM_VRF_NO_TABLE_ID")] SlIlmVrfNoTableId = 36897,
        /// <summary>
        /// VRF name of the ILM route not specified. 0x9022
        /// </summary>
        [pbr::OriginalName("SL_ILM_VRF_NAME_MISSING")] SlIlmVrfNameMissing = 36898,
        /// <summary>
        /// Offset for MPLS NHLFE errors. 0xa000
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_ERR_OFFSET")] SlNhlfeErrOffset = 40960,
        /// <summary>
        /// MPLS NHLFE vrf table could not be determined. 0xa001
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NH_NO_TABLE")] SlNhlfeNhNoTable = 40961,
        /// <summary>
        /// Size of next hop IPv6 address is invalid. 0xa002
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NH_INVALID_ADDR_SZ")] SlNhlfeNhInvalidAddrSz = 40962,
        /// <summary>
        /// NHLFE has an invalid next hop address. 0xa003
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_NEXT_HOP_ADDR")] SlNhlfeInvalidNextHopAddr = 40963,
        /// <summary>
        /// Path VRF name exceeds supported length. 0xa004
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_VRF_NAME_TOOLONG")] SlNhlfeVrfNameToolong = 40964,
        /// <summary>
        /// Next hop interface name is missing from path. 0xa005
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NH_INF_NAME_MISSING")] SlNhlfeNhInfNameMissing = 40965,
        /// <summary>
        /// Interface name exceeds supported length. 0xa006
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NH_INTF_NAME_TOOLONG")] SlNhlfeNhIntfNameToolong = 40966,
        /// <summary>
        /// Number of labels in the path incompatible with system capabilities
        /// for the given label action. 0xa007
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_LABEL_COUNT")] SlNhlfeInvalidLabelCount = 40967,
        /// <summary>
        /// Path id is invalid in NHLFE. 0xa008
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_PATH_ID")] SlNhlfeInvalidPathId = 40968,
        /// <summary>
        /// MPLS NHLFE label value out of range. 0xa009
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_LABEL")] SlNhlfeInvalidLabel = 40969,
        /// <summary>
        /// NHLFE has an invalid protection bitmap. 0xa00a
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_PROTECTED_BITMAP")] SlNhlfeInvalidProtectedBitmap = 40970,
        /// <summary>
        /// Number of remote backup addresses in the NHLFE exceeds
        /// system capabilities. 0xa00b
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_REMOTE_ADDR_COUNT")] SlNhlfeInvalidRemoteAddrCount = 40971,
        /// <summary>
        /// Size of IPv6 remote backup address is invalid. 0xa00c
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_REMOTE_ADDR_INVALID_SZ")] SlNhlfeRemoteAddrInvalidSz = 40972,
        /// <summary>
        /// A primary NHLFE has too many labels. 0xa00d
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_PRIMARY_TOOMANY_LABELS")] SlNhlfePrimaryToomanyLabels = 40973,
        /// <summary>
        /// A primary NHLFE has too many remote addresses. 0xa00e
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR")] SlNhlfePrimaryToomanyRemoteAddr = 40974,
        /// <summary>
        /// Too many pure backup NHLFE with same Path ID. 0xa00f
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_BACKUP_ID_REPEATED")] SlNhlfeBackupIdRepeated = 40975,
        /// <summary>
        /// Too many primary NHLFE with same Path ID. 0xa010
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_PRIMARY_ID_REPEATED")] SlNhlfePrimaryIdRepeated = 40976,
        /// <summary>
        /// Pure backup NHLFE has a empty protected bitmap. 0xa011
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY")] SlNhlfeBackupProtectedBitmapEmpty = 40977,
        /// <summary>
        /// A primary NHLFE has too many backup paths. 0xa012
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS")] SlNhlfePrimaryToomanyBackupPaths = 40978,
        /// <summary>
        /// A pure backup remote address is invalid. 0xa013
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_REMOTE_ADDR_INVALID")] SlNhlfeRemoteAddrInvalid = 40979,
        /// <summary>
        /// Protection bitmap of a backup NHLFE refers to a missing path. 0xa014
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH")] SlNhlfeBackupMissingPrimaryPath = 40980,
        /// <summary>
        /// NHLFE next-hop missing. 0xa015
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NEXT_HOP_MISSING")] SlNhlfeNextHopMissing = 40981,
        /// <summary>
        /// Label action specified is invalid. 0xa016
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_LABEL_ACTION_INVALID")] SlNhlfeLabelActionInvalid = 40982,
        /// <summary>
        /// NHLFE next hop interface not found. 0xa017
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NH_INTF_NOT_FOUND")] SlNhlfeNhIntfNotFound = 40983,
        /// <summary>
        /// MPLS NHLFE operation failed. 0xa018
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_OPER_FAILED")] SlNhlfeOperFailed = 40984,
        /// <summary>
        /// MPLS NHLFE label action missing. 0xa019
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_LABEL_ACTION_MISSING")] SlNhlfeLabelActionMissing = 40985,
        /// <summary>
        /// Setting EXP value failed. 0xa01a
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_EXP_SET_FAILED")] SlNhlfeExpSetFailed = 40986,
        /// <summary>
        /// ELSP protection is unsupported. 0xa01b
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED")] SlNhlfeElspProtectionUnsupported = 40987,
        /// <summary>
        /// EXP value is outside of the valid range of &lt;0-7>. 0xa01c
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_ELSP_EXP")] SlNhlfeInvalidElspExp = 40988,
        /// <summary>
        /// Path Priority is invalid (valid: 0 or 1). 0xa01d
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_PATH_PRIORITY")] SlNhlfeInvalidPathPriority = 40989,
        /// <summary>
        /// Load metric is not zero for a down path. 0xa01e
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_LOAD_METRIC")] SlNhlfeInvalidLoadMetric = 40990,
        /// <summary>
        /// Set ID value is outside of the valid range of &lt;0-7>. 0xa01f
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_SETID")] SlNhlfeInvalidSetid = 40991,
        /// <summary>
        /// Two paths with the same Set ID have different path priorities. 0xa020
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_SETID_PRIORITY")] SlNhlfeInvalidSetidPriority = 40992,
        /// <summary>
        /// Multiple Set IDs are set as the primary. 0xa021
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS")] SlNhlfeInvalidMultiplePrimarySetids = 40993,
        /// <summary>
        /// Paths with the same SET ID are not contiguous. 0xa022
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NON_CONTIGUOUS_SETIDS")] SlNhlfeNonContiguousSetids = 40994,
        /// <summary>
        /// Paths with same EXP classification are not contiguous. 0xa023
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_NON_CONTIGUOUS_EXP")] SlNhlfeNonContiguousExp = 40995,
        /// <summary>
        /// On a ILM, mix of NHLFE with EXP class and others without any EXP
        /// class are not allowed. 0xa024
        /// </summary>
        [pbr::OriginalName("SL_NHLFE_INCONSISTENT_EXP_ON_PATH")] SlNhlfeInconsistentExpOnPath = 40996,
        /// <summary>
        /// Offset for label block errors. 0xb000
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_ERR_OFFSET")] SlLabelBlkErrOffset = 45056,
        /// <summary>
        /// MPLS label block add from Label Switching Database failed. 0xb001
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_LSD_ADD_FAILED")] SlLabelBlkLsdAddFailed = 45057,
        /// <summary>
        /// MPLS label block delete from Label Switching Database failed. 0xb002
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_LSD_DELETE_FAILED")] SlLabelBlkLsdDeleteFailed = 45058,
        /// <summary>
        /// MPLS label block not found. 0xb003
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND")] SlLabelBlkLsdLabelBlkNotFound = 45059,
        /// <summary>
        /// MPLS label block in use. 0xb004
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE")] SlLabelBlkLsdLabelBlkInUse = 45060,
        /// <summary>
        /// MPLS label block attribute invalid. 0xb005
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_LSD_INVALID_ATTRIB")] SlLabelBlkLsdInvalidAttrib = 45061,
        /// <summary>
        /// MPLS label block size > max size per block. 0xb006
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_INVALID_BLOCK_SIZE")] SlLabelBlkInvalidBlockSize = 45062,
        /// <summary>
        /// MPLS label start_label &lt; min label for platform . 0xb007
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_INVALID_START_LABEL")] SlLabelBlkInvalidStartLabel = 45063,
        /// <summary>
        /// MPLS label block already exists in the database. 0xb008
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_EEXIST")] SlLabelBlkEexist = 45064,
        /// <summary>
        /// MPLS label database is out of memory. 0xb009
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_DB_NOMEM")] SlLabelBlkDbNomem = 45065,
        /// <summary>
        /// MPLS label block type invalid. 0xb00a
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_TYPE_INVALID")] SlLabelBlkTypeInvalid = 45066,
        /// <summary>
        /// MPLS label block client name exceeds max length. 0xb00b
        /// </summary>
        [pbr::OriginalName("SL_LABEL_BLK_CLIENT_NAME_TOOLONG")] SlLabelBlkClientNameToolong = 45067,
        /// <summary>
        /// Offset for MPLS registration errors. 0xc000
        /// </summary>
        [pbr::OriginalName("SL_MPLS_REG_ERR_OFFSET")] SlMplsRegErrOffset = 49152,
        /// <summary>
        /// MPLS registration error. 0xc001
        /// </summary>
        [pbr::OriginalName("SL_MPLS_REG_ERR")] SlMplsRegErr = 49153,
        /// <summary>
        /// MPLS unregistration error. 0xc002
        /// </summary>
        [pbr::OriginalName("SL_MPLS_UNREG_ERR")] SlMplsUnregErr = 49154,
        /// <summary>
        /// MPLS EOF error. 0xc003
        /// </summary>
        [pbr::OriginalName("SL_MPLS_EOF_ERR")] SlMplsEofErr = 49155,
        /// <summary>
        /// Offset for Interface operation errors. 0xd000
        /// </summary>
        [pbr::OriginalName("SL_RPC_INTF_START_OFFSET")] SlRpcIntfStartOffset = 53248,
        /// <summary>
        /// Interface Operation rejected for ALL Sessions as the Interface
        /// Session count is beyond supported limit. 0xd001
        /// </summary>
        [pbr::OriginalName("SL_RPC_INTF_TOO_MANY_INTERFACES")] SlRpcIntfTooManyInterfaces = 53249,
        /// <summary>
        /// Interface Operation rejected as server is not initialized. 0xd002
        /// </summary>
        [pbr::OriginalName("SL_RPC_INTF_SERVER_NOT_INITIALIZED")] SlRpcIntfServerNotInitialized = 53250,
        /// <summary>
        /// Interface Operation failed as server is not registered with
        /// interface manager. 0xd003
        /// </summary>
        [pbr::OriginalName("SL_RPC_INTF_API_CLIENT_NOT_REGISTERED")] SlRpcIntfApiClientNotRegistered = 53251,
        /// <summary>
        /// Offset for Interface object errors. 0xe000
        /// </summary>
        [pbr::OriginalName("SL_INTF_START_OFFSET")] SlIntfStartOffset = 57344,
        /// <summary>
        /// Interface object's interface name missing. 0xe001
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_NAME_MISSING")] SlIntfInterfaceNameMissing = 57345,
        /// <summary>
        /// Interface object's interface name exceeds supported length. 0xe002
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_NAME_TOOLONG")] SlIntfInterfaceNameToolong = 57346,
        /// <summary>
        /// Interface internal registration error. 0xe003
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_REG_ERR")] SlIntfInterfaceRegErr = 57347,
        /// <summary>
        /// Internal database error. 0xe004
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERNAL_DB_ERROR")] SlIntfInternalDbError = 57348,
        /// <summary>
        /// Interface Recovery error. 0xe005
        /// </summary>
        [pbr::OriginalName("SL_INTF_RECOVERY_ERROR")] SlIntfRecoveryError = 57349,
        /// <summary>
        /// Interface exists. 0xe006
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_EXISTS")] SlIntfInterfaceExists = 57350,
        /// <summary>
        /// Interface not found. 0xe007
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_NOT_FOUND")] SlIntfInterfaceNotFound = 57351,
        /// <summary>
        /// Interface State not supported. 0xe008
        /// </summary>
        [pbr::OriginalName("SL_INTF_INTERFACE_STATE_NOT_SUPPORTED")] SlIntfInterfaceStateNotSupported = 57352,
        /// <summary>
        /// Offset for Global L2 operation errors. 0xf000
        /// </summary>
        [pbr::OriginalName("SL_L2_REG_START_OFFSET")] SlL2RegStartOffset = 61440,
        /// <summary>
        /// Client cannot be registered with Layer-2 RIB. 0xf001
        /// </summary>
        [pbr::OriginalName("SL_L2_REGISTRATION_ERR")] SlL2RegistrationErr = 61441,
        /// <summary>
        /// Client cannot be unregistered with Layer-2 RIB. 0xf002
        /// </summary>
        [pbr::OriginalName("SL_L2_UNREGISTRATION_ERR")] SlL2UnregistrationErr = 61442,
        /// <summary>
        /// EOF Operation error. 0xf003
        /// </summary>
        [pbr::OriginalName("SL_L2_EOF_ERR")] SlL2EofErr = 61443,
        /// <summary>
        /// L2 registration message with invalid admin distance. 0xf004
        /// </summary>
        [pbr::OriginalName("SL_L2_REG_INVALID_ADMIN_DISTANCE")] SlL2RegInvalidAdminDistance = 61444,
        /// <summary>
        /// Duplicate L2 registration message. 0xf005
        /// </summary>
        [pbr::OriginalName("SL_L2_REG_IS_DUPLICATE")] SlL2RegIsDuplicate = 61445,
        /// <summary>
        /// L2 registration rejected as server is not initialized. 0xf006
        /// </summary>
        [pbr::OriginalName("SL_L2_REG_SERVER_NOT_INITIALIZED")] SlL2RegServerNotInitialized = 61446,
        /// <summary>
        /// Offset for L2 BD operation errors. 0x10000
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_BD_REG_START_OFFSET")] SlRpcL2BdRegStartOffset = 65536,
        /// <summary>
        /// Operation is rejected for all BDs as name is missing. 0x10001
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_BD_REG_NAME_MISSING")] SlRpcL2BdRegNameMissing = 65537,
        /// <summary>
        /// Operation rejected for all BDs due to too many BD registration
        /// messages in the request. 0x10002
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_BD_REG_TOO_MANY_MSGS")] SlRpcL2BdRegTooManyMsgs = 65538,
        /// <summary>
        /// Operation rejected for all BDs as server is not initialized.
        /// 0x10003
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED")] SlRpcL2BdRegServerNotInitialized = 65539,
        /// <summary>
        /// Operation rejected for all BDs as client is not registered.
        /// 0x10004
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED")] SlRpcL2BdRegClientNotRegistered = 65540,
        /// <summary>
        /// Offset for L2 BD object errors. 0x11000
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_REG_START_OFFSET")] SlL2BdRegStartOffset = 69632,
        /// <summary>
        /// BD cannot be registered with Layer-2 RIB. 0x11001
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_REGISTRATION_ERR")] SlL2BdRegistrationErr = 69633,
        /// <summary>
        /// BD cannot be unregistered with Layer-2 RIB. 0x11002
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_UNREGISTRATION_ERR")] SlL2BdUnregistrationErr = 69634,
        /// <summary>
        /// BD EOF Operation error. 0x11003
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_EOF_ERR")] SlL2BdEofErr = 69635,
        /// <summary>
        /// Name is too long in BD registration message. 0x11004
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_REG_NAME_TOO_LONG")] SlL2BdRegNameTooLong = 69636,
        /// <summary>
        /// BD not found in BD registration message. 0x11005
        /// </summary>
        [pbr::OriginalName("SL_L2_BD_REG_BD_NOT_FOUND")] SlL2BdRegBdNotFound = 69637,
        /// <summary>
        /// Offset for L2 Route Operation errors. 0x12000
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_ROUTE_START_OFFSET")] SlRpcL2RouteStartOffset = 73728,
        /// <summary>
        /// Operation rejected for all L2 routes due to too many messages
        /// in the request. 0x12001
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_ROUTE_TOO_MANY_MSGS")] SlRpcL2RouteTooManyMsgs = 73729,
        /// <summary>
        /// Operation rejected for all L2 routes as server is not
        /// initialized. 0x12002
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED")] SlRpcL2RouteServerNotInitialized = 73730,
        /// <summary>
        /// Operation rejected for all L2 routes as client is not
        /// registered. 0x12003
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED")] SlRpcL2RouteClientNotRegistered = 73731,
        /// <summary>
        /// Offset for L2 object errors. 0x13000
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_START_OFFSET")] SlL2RouteStartOffset = 77824,
        /// <summary>
        /// L2 route operation rejected as BD name is missing. 0x13001
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_BD_NAME_MISSING")] SlL2RouteBdNameMissing = 77825,
        /// <summary>
        /// L2 route operation rejected as BD name is too long. 0x13002
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_BD_NAME_TOOLONG")] SlL2RouteBdNameToolong = 77826,
        /// <summary>
        /// L2 route operation rejected as BD not found. 0x13003
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_BD_NOT_FOUND")] SlL2RouteBdNotFound = 77827,
        /// <summary>
        /// L2 route operation rejected as BD is not registered. 0x13004
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_BD_NOT_REGISTERED")] SlL2RouteBdNotRegistered = 77828,
        /// <summary>
        /// L2 route operation rejected due to one or more invalid
        /// arguments. 0x13005
        /// </summary>
        [pbr::OriginalName("SL_L2_ROUTE_INVALID_ARGS")] SlL2RouteInvalidArgs = 77829,
        /// <summary>
        /// Offset for L2 Get Notification Operation errors. 0x14000
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_START_OFFSET")] SlRpcL2NotifStartOffset = 81921,
        /// <summary>
        /// L2 notification request rejected as server is not initialized.
        /// 0x14002
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED")] SlRpcL2NotifServerNotInitialized = 81922,
        /// <summary>
        /// L2 notification request rejected as client is not registered.
        /// 0x14003
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED")] SlRpcL2NotifClientNotRegistered = 81923,
        /// <summary>
        /// L2 notification enable error. 0x14004
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_ENABLE_ERR")] SlRpcL2NotifEnableErr = 81924,
        /// <summary>
        /// L2 notification disable error. 0x14005
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_DISABLE_ERR")] SlRpcL2NotifDisableErr = 81925,
        /// <summary>
        /// L2 notification EOF error. 0x14006
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_EOF_ERR")] SlRpcL2NotifEofErr = 81926,
        /// <summary>
        /// L2 notification request rejected as BD name is missing. 0x14007
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_BD_NAME_MISSING")] SlRpcL2NotifBdNameMissing = 81927,
        /// <summary>
        /// L2 notification request rejected as BD name is too long.
        /// 0x14008
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_BD_NAME_TOOLONG")] SlRpcL2NotifBdNameToolong = 81928,
        /// <summary>
        /// L2 notification request rejected as BD not found. 0x14009
        /// </summary>
        [pbr::OriginalName("SL_RPC_L2_NOTIF_BD_NOT_FOUND")] SlRpcL2NotifBdNotFound = 81929,
        /// <summary>
        /// Container VRF for PathGroup could not be added. 0x15001
        /// </summary>
        [pbr::OriginalName("SL_PG_VRF_ADD_ERR")] SlPgVrfAddErr = 86017,
        /// <summary>
        /// PathGroup's VRF ID could not be determined. 0x15002
        /// </summary>
        [pbr::OriginalName("SL_PG_VRF_NO_VRFID")] SlPgVrfNoVrfid = 86018,
        /// <summary>
        /// PathGroup's string key is too long. 0x15003
        /// </summary>
        [pbr::OriginalName("SL_PG_STR_KEY_TOOLONG")] SlPgStrKeyToolong = 86019,
        /// <summary>
        /// ID of a next hop VRF in a path in the PathGroup cannot be determined.
        /// 0x15004
        /// </summary>
        [pbr::OriginalName("SL_PG_TARGET_VRF_NO_VRFID")] SlPgTargetVrfNoVrfid = 86020,
        /// <summary>
        /// PathGroup's string key contains invalid characters. 0x15005
        /// </summary>
        [pbr::OriginalName("SL_PG_STR_KEY_INVALID")] SlPgStrKeyInvalid = 86021,
        /// <summary>
        /// Offset for Nexthop request errors. 0x16000
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_START_OFFSET")] SlNextHopStartOffset = 90112,
        /// <summary>
        /// Nexthop prefix length is invalid. 0x16001
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_INVALID_PREFIX_LEN")] SlNextHopInvalidPrefixLen = 90113,
        /// <summary>
        /// Nexthop prefix has host bits set. 0x16002
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_HOST_BITS_SET")] SlNextHopHostBitsSet = 90114,
        /// <summary>
        /// IPv4 Route prefix is a multicast address. 0x16003
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_INVALID_PREFIX_MCAST")] SlNextHopInvalidPrefixMcast = 90115,
        /// <summary>
        /// Nexthop prefix is invalid. 0x16004
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_INVALID_PREFIX")] SlNextHopInvalidPrefix = 90116,
        /// <summary>
        /// Invalid next hop address. 0x16005
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_INVALID_NEXT_HOP_ADDR")] SlNextHopInvalidNextHopAddr = 90117,
        /// <summary>
        /// Size of IPv6 prefix is invalid. 0x16006
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_INVALID_PREFIX_SZ")] SlNextHopInvalidPrefixSz = 90118,
        /// <summary>
        /// Unable to program NH tracking registration to RIB. 0x16007
        /// </summary>
        [pbr::OriginalName("SL_NEXT_HOP_RIB_ADD_FAILED")] SlNextHopRibAddFailed = 90119,
        /// <summary>
        /// Unable to program route redist registration to RIB. 0x16008
        /// </summary>
        [pbr::OriginalName("SL_ROUTE_REDIST_RIB_ADD_FAILED")] SlRouteRedistRibAddFailed = 90120,
        /// <summary>
        /// Offset for Hardware Ack errors. 0x17000
        /// </summary>
        [pbr::OriginalName("SL_ACK_START_OFFSET")] SlAckStartOffset = 94208,
        /// <summary>
        /// Ack permit is supported only on streaming RPC with ack type set
        /// to RIB_AND_FIB_ACK or RIB_FIB_INUSE_ACK. 0x17001
        /// </summary>
        [pbr::OriginalName("SL_ACK_PERMIT_NOT_SUPPORTED")] SlAckPermitNotSupported = 94209,
        /// <summary>
        /// The Ack type requested is not supported on the object type. 0x17002
        /// </summary>
        [pbr::OriginalName("SL_ACK_INVALID_TYPE")] SlAckInvalidType = 94210,
        /// <summary>
        /// Offset for policy object operations. 0x18000
        /// </summary>
        [pbr::OriginalName("SL_POLICY_START_OFFSET")] SlPolicyStartOffset = 98304,
        /// <summary>
        /// Policy object could not be created. 0x18001
        /// </summary>
        [pbr::OriginalName("SL_POLICY_ADD_ERR")] SlPolicyAddErr = 98305,
        /// <summary>
        /// Policy object already exists. 0x18002
        /// </summary>
        [pbr::OriginalName("SL_POLICY_EXISTS_ERR")] SlPolicyExistsErr = 98306,
        /// <summary>
        /// Policy object delete failed. 0x18003
        /// </summary>
        [pbr::OriginalName("SL_POLICY_DELETE_ERR")] SlPolicyDeleteErr = 98307,
        /// <summary>
        /// Rule could not be created. 0x18004
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_ADD_ERR")] SlPolicyRuleAddErr = 98308,
        /// <summary>
        /// Rule already exists. 0x18005
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_EXISTS_ERR")] SlPolicyRuleExistsErr = 98309,
        /// <summary>
        /// Rule delete error. 0x18006
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_DELETE_ERR")] SlPolicyRuleDeleteErr = 98310,
        /// <summary>
        /// Policy object apply error. 0x18007
        /// </summary>
        [pbr::OriginalName("SL_POLICY_APPLY_ERR")] SlPolicyApplyErr = 98311,
        /// <summary>
        /// Policy object unapply error. 0x18008
        /// </summary>
        [pbr::OriginalName("SL_POLICY_UNAPPLY_ERR")] SlPolicyUnapplyErr = 98312,
        /// <summary>
        /// Operation rejected due to too many policies in the request. 0x18009
        /// </summary>
        [pbr::OriginalName("SL_POLICY_TOO_MANY_POLICIES")] SlPolicyTooManyPolicies = 98313,
        /// <summary>
        /// Policy name is too long. 0x1800a
        /// </summary>
        [pbr::OriginalName("SL_POLICY_NAME_TOO_LONG")] SlPolicyNameTooLong = 98314,
        /// <summary>
        /// Rule name is too long. 0x1800b
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_NAME_TOO_LONG")] SlPolicyRuleNameTooLong = 98315,
        /// <summary>
        /// Duplicate priority for the rule in the same policy. 0x1800c
        /// </summary>
        [pbr::OriginalName("SL_POLICY_DUPLICATE_PRIORITY_IN_RULE")] SlPolicyDuplicatePriorityInRule = 98316,
        /// <summary>
        /// Rule modification not allowed. 0x1800d
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_MOD_NOT_ALLOWED")] SlPolicyRuleModNotAllowed = 98317,
        /// <summary>
        /// Rule belongs to a different policy. 0x1800e
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID_RULE")] SlPolicyInvalidRule = 98318,
        /// <summary>
        /// Rule add operation requested but no rules were provided. 0x1800f
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_ADD_NO_RULES")] SlPolicyRuleAddNoRules = 98319,
        /// <summary>
        /// Rule add operation requested but no matches were provided. 0x18010
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID_MATCH_COUNT_IN_RULE")] SlPolicyInvalidMatchCountInRule = 98320,
        /// <summary>
        /// Rule add operation requested but no actions were provided. 0x18011
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID_ACTION_COUNT_IN_RULE")] SlPolicyInvalidActionCountInRule = 98321,
        /// <summary>
        /// Policy not found.0x18012
        /// </summary>
        [pbr::OriginalName("SL_POLICY_NOT_FOUND")] SlPolicyNotFound = 98322,
        /// <summary>
        /// Policy invalid. 0x18013
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID")] SlPolicyInvalid = 98323,
        /// <summary>
        /// Policy name missing. 0x18014
        /// </summary>
        [pbr::OriginalName("SL_POLICY_NAME_MISSING")] SlPolicyNameMissing = 98324,
        /// <summary>
        /// Rule name missing. 0x18015
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_NAME_MISSING")] SlPolicyRuleNameMissing = 98325,
        /// <summary>
        /// Priority missing in rule. 0x18016
        /// </summary>
        [pbr::OriginalName("SL_POLICY_PRIORITY_MISSING_IN_RULE")] SlPolicyPriorityMissingInRule = 98326,
        /// <summary>
        /// Invalid policy type. 0x18017
        /// </summary>
        [pbr::OriginalName("SL_POLICY_TYPE_INVALID")] SlPolicyTypeInvalid = 98327,
        /// <summary>
        /// Invalid policy direction. 0x18018
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID_DIRECTION")] SlPolicyInvalidDirection = 98328,
        /// <summary>
        /// Policy object's interface name exceeds supported length. 0x18019
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INTF_NAME_TOOLONG")] SlPolicyIntfNameToolong = 98329,
        /// <summary>
        /// Policy object's interface name is missing. 0x1801a
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INTF_NAME_MISSING")] SlPolicyIntfNameMissing = 98330,
        /// <summary>
        /// Max rule limit within a policy is reached. 0x1801b
        /// </summary>
        [pbr::OriginalName("SL_POLICY_MAX_RULE_LIMIT_REACHED")] SlPolicyMaxRuleLimitReached = 98331,
        /// <summary>
        /// Vrf name in policy object is too long. 0x1801c
        /// </summary>
        [pbr::OriginalName("SL_POLICY_VRF_NAME_TOO_LONG")] SlPolicyVrfNameTooLong = 98332,
        /// <summary>
        /// Vrf name missing in policy object. 0x1801d
        /// </summary>
        [pbr::OriginalName("SL_POLICY_VRF_NAME_MISSING")] SlPolicyVrfNameMissing = 98333,
        /// <summary>
        /// Path Group name in policy object too long. 0x1801e
        /// </summary>
        [pbr::OriginalName("SL_POLICY_PATH_GRP_NAME_TOO_LONG")] SlPolicyPathGrpNameTooLong = 98334,
        /// <summary>
        /// Path Group name missing in policy object. 0x1801f
        /// </summary>
        [pbr::OriginalName("SL_POLICY_PATH_GRP_NAME_MISSING")] SlPolicyPathGrpNameMissing = 98335,
        /// <summary>
        /// Invalid Dscp Value. 0x18020
        /// </summary>
        [pbr::OriginalName("SL_POLICY_INVALID_DSCP_VALUE")] SlPolicyInvalidDscpValue = 98336,
        /// <summary>
        /// Priority string too long. 0x18021
        /// </summary>
        [pbr::OriginalName("SL_POLICY_PRIORITY_STR_TOO_LONG")] SlPolicyPriorityStrTooLong = 98337,
        /// <summary>
        /// Max interfaces limit in policy reached. 0x18022
        /// </summary>
        [pbr::OriginalName("SL_POLICY_MAX_INTF_LIMIT_REACHED")] SlPolicyMaxIntfLimitReached = 98338,
        /// <summary>
        /// Rule delete operation requested but no rules were provided. 0x18023
        /// </summary>
        [pbr::OriginalName("SL_POLICY_RULE_DELETE_NO_RULES")] SlPolicyRuleDeleteNoRules = 98339,
        /// <summary>
        /// Policy apply requested but no interfaces were provided. 0x18024
        /// </summary>
        [pbr::OriginalName("SL_POLICY_APPLY_NO_INTFS")] SlPolicyApplyNoIntfs = 98340,
        /// <summary>
        /// Policy unapply requested but no interfaces were provided. 0x18025
        /// </summary>
        [pbr::OriginalName("SL_POLICY_UNAPPLY_NO_INTFS")] SlPolicyUnapplyNoIntfs = 98341,
        /// <summary>
        /// Policy object replace failed. 0x18026
        /// </summary>
        [pbr::OriginalName("SL_POLICY_REPLACE_ERR")] SlPolicyReplaceErr = 98342,
        /// <summary>
        /// Offset for Bgpls Topology errors. 0x19000
        /// </summary>
        [pbr::OriginalName("SL_BGPLS_TOPO_START_OFFSET")] SlBgplsTopoStartOffset = 102400,
        /// <summary>
        /// LSLIB Server which is required for BGPLS Topology Service
        /// is not available. 0x19001
        /// </summary>
        [pbr::OriginalName("SL_BGPLS_SERVER_NOT_AVAILABLE")] SlBgplsServerNotAvailable = 102401,
        /// <summary>
        /// Maximum match filters in SLBgplsTopoNotifReqMsg exceeded. 0x19002
        /// </summary>
        [pbr::OriginalName("SL_BGPLS_MAX_MATCH_FILTER_EXCEEDED")] SlBgplsMaxMatchFilterExceeded = 102402,
        /// <summary>
        /// Maximum SLBgplsTopoNotifStream exceeded. 0x19003
        /// </summary>
        [pbr::OriginalName("SL_BGPLS_MAX_STREAMS_EXCEEDED")] SlBgplsMaxStreamsExceeded = 102403,
        /// <summary>
        /// Offset for bgp object operations. 0x1a000
        /// </summary>
        [pbr::OriginalName("SL_BGP_START_OFFSET")] SlBgpStartOffset = 106496,
        /// <summary>
        /// BGP instance name too long. 0x1a001
        /// </summary>
        [pbr::OriginalName("SL_BGP_INST_NAME_TOOLONG")] SlBgpInstNameToolong = 106497,
        /// <summary>
        /// BGP instance name empty. 0x1a002
        /// </summary>
        [pbr::OriginalName("SL_BGP_INST_NAME_EMPTY")] SlBgpInstNameEmpty = 106498,
        /// <summary>
        /// BGP instance not initialized. 0x1a003
        /// </summary>
        [pbr::OriginalName("SL_BGP_INST_NOT_INITIALIZED")] SlBgpInstNotInitialized = 106499,
        /// <summary>
        /// BGP invalid object type. 0x1a004
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_OBJ_TYPE")] SlBgpInvalidObjType = 106500,
        /// <summary>
        /// BGP vrf name too long for v4 neighbor. 0x1a005
        /// </summary>
        [pbr::OriginalName("SL_BGP_VRF_NAME_TOOLONG_V4")] SlBgpVrfNameToolongV4 = 106501,
        /// <summary>
        /// BGP vrf name too long for v6 neighbor. 0x1a006
        /// </summary>
        [pbr::OriginalName("SL_BGP_VRF_NAME_TOOLONG_V6")] SlBgpVrfNameToolongV6 = 106502,
        /// <summary>
        /// BGP unsupported vrf name. 0x1a007
        /// </summary>
        [pbr::OriginalName("SL_BGP_UNSUPPORTED_VRF_NAME")] SlBgpUnsupportedVrfName = 106503,
        /// <summary>
        /// BGP invalid neighbor address multicast. 0x1a008
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBR_ADDR_MCAST")] SlBgpInvalidNbrAddrMcast = 106504,
        /// <summary>
        /// BGP invalid neighbor address experimental. 0x1a009
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBR_ADDR_EXP")] SlBgpInvalidNbrAddrExp = 106505,
        /// <summary>
        /// BGP invalid neighbor address. 0x1a00a
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBR_ADDR")] SlBgpInvalidNbrAddr = 106506,
        /// <summary>
        /// BGP invalid neighbor v6 address size. 0x1a00b
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBR_V6_SZ")] SlBgpInvalidNbrV6Sz = 106507,
        /// <summary>
        /// BGP invalid neighbor key. 0x1a00c
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBR_KEY")] SlBgpInvalidNbrKey = 106508,
        /// <summary>
        /// BGP invalid mpath address multicast. 0x1a00d
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_MPATH_ADDR_MCAST")] SlBgpInvalidMpathAddrMcast = 106509,
        /// <summary>
        /// BGP invalid mpath address experimental. 0x1a00e
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_MPATH_ADDR_EXP")] SlBgpInvalidMpathAddrExp = 106510,
        /// <summary>
        /// BGP invalid mpath address. 0x1a00f
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_MPATH_ADDR")] SlBgpInvalidMpathAddr = 106511,
        /// <summary>
        /// BGP invalid mpath v6 address size. 0x1a010
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_MPATH_V6_SZ")] SlBgpInvalidMpathV6Sz = 106512,
        /// <summary>
        /// BGP invalid neighbor afi/safi list. 0x1a011
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_NBRSAFI_LIST")] SlBgpInvalidNbrsafiList = 106513,
        /// <summary>
        /// BGP unsupported BGP afi/safi. 0x1a012
        /// </summary>
        [pbr::OriginalName("SL_BGP_UNSUPPORTED_BGP_AFI_SAFI")] SlBgpUnsupportedBgpAfiSafi = 106514,
        /// <summary>
        /// BGP unsupported afi. 0x1a013
        /// </summary>
        [pbr::OriginalName("SL_BGP_UNSUPPORTED_AFI")] SlBgpUnsupportedAfi = 106515,
        /// <summary>
        /// BGP unsupported safi. 0x1a014
        /// </summary>
        [pbr::OriginalName("SL_BGP_UNSUPPORTED_SAFI")] SlBgpUnsupportedSafi = 106516,
        /// <summary>
        /// BGP empty object. 0x1a015
        /// </summary>
        [pbr::OriginalName("SL_BGP_EMPTY_OBJECTS")] SlBgpEmptyObjects = 106517,
        /// <summary>
        /// BGP empty object list. 0x1a016
        /// </summary>
        [pbr::OriginalName("SL_BGP_EMPTY_OBJECT_LIST")] SlBgpEmptyObjectList = 106518,
        /// <summary>
        /// BGP updating bandwidth-group database failed. 0x1a017
        /// </summary>
        [pbr::OriginalName("SL_BGP_UPDATE_BW_GRP_FAILED")] SlBgpUpdateBwGrpFailed = 106519,
        /// <summary>
        /// BGP updating mpath database failed. 0x1a018
        /// </summary>
        [pbr::OriginalName("SL_BGP_UPDATE_MPATH_ADDR_FAILED")] SlBgpUpdateMpathAddrFailed = 106520,
        /// <summary>
        /// BGP deleting from bandwidth-group database failed. 0x1a019
        /// </summary>
        [pbr::OriginalName("SL_BGP_DELETE_BW_GRP_FAILED")] SlBgpDeleteBwGrpFailed = 106521,
        /// <summary>
        /// BGP deleting neighbor from database failed. 0x1a01a
        /// </summary>
        [pbr::OriginalName("SL_BGP_DELETE_NBR_FAILED")] SlBgpDeleteNbrFailed = 106522,
        /// <summary>
        /// BGP deleting afi/safi from database failed. 0x1a01b
        /// </summary>
        [pbr::OriginalName("SL_BGP_DELETE_AFI_FAILED")] SlBgpDeleteAfiFailed = 106523,
        /// <summary>
        /// BGP deleting from mpath database failed. 0x1a01c
        /// </summary>
        [pbr::OriginalName("SL_BGP_DELETE_MPATH_ADDR_FAILED")] SlBgpDeleteMpathAddrFailed = 106524,
        /// <summary>
        /// BGP deleting from database failed. 0x1a01d
        /// </summary>
        [pbr::OriginalName("SL_BGP_DELETE_FAILED")] SlBgpDeleteFailed = 106525,
        /// <summary>
        /// BGP bandwidth-group number out of range. 0x1a01e
        /// </summary>
        [pbr::OriginalName("SL_BGP_BW_GRP_NUM_OUT_OF_RANGE")] SlBgpBwGrpNumOutOfRange = 106526,
        /// <summary>
        /// BGP inbound bandwidth-group count exceeds limit. 0x1a01f
        /// </summary>
        [pbr::OriginalName("SL_BGP_IN_BW_GRP_COUNT_EXCEEDED")] SlBgpInBwGrpCountExceeded = 106527,
        /// <summary>
        /// BGP outbound bandwidth-group count exceeds limit. 0x1a020
        /// </summary>
        [pbr::OriginalName("SL_BGP_OUT_BW_GRP_COUNT_EXCEEDED")] SlBgpOutBwGrpCountExceeded = 106528,
        /// <summary>
        /// BGP invalid inbound bandwidth-group list. 0x1a021
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_IN_BWGRP_LIST")] SlBgpInvalidInBwgrpList = 106529,
        /// <summary>
        /// BGP invalid outbound bandwidth-group count list. 0x1a022
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_OUT_BWGRP_LIST")] SlBgpInvalidOutBwgrpList = 106530,
        /// <summary>
        /// BGP link bandwidth out of range. 0x1a023
        /// </summary>
        [pbr::OriginalName("SL_BGP_LINK_BW_OUT_OF_RANGE")] SlBgpLinkBwOutOfRange = 106531,
        /// <summary>
        /// BGP neighbor index out of range. 0x1a024
        /// </summary>
        [pbr::OriginalName("SL_BGP_NBR_IDX_OUT_OF_RANGE")] SlBgpNbrIdxOutOfRange = 106532,
        /// <summary>
        /// BGP invalid bandwidth-group type. 0x1a025
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_BW_TYPE")] SlBgpInvalidBwType = 106533,
        /// <summary>
        /// BGP neighbor bandwidth-group list is NULL. 0x1a026
        /// </summary>
        [pbr::OriginalName("SL_BGP_BW_GRP_LIST_NULL")] SlBgpBwGrpListNull = 106534,
        /// <summary>
        /// BGP neighbor afi/safi list is NULL. 0x1a027
        /// </summary>
        [pbr::OriginalName("SL_BGP_NBRSAFI_LIST_NULL")] SlBgpNbrsafiListNull = 106535,
        /// <summary>
        /// BGP instance does not exist in SL-API. 0x1a028
        /// </summary>
        [pbr::OriginalName("SL_BGP_INST_NOT_CONFIG_IN_SLAPI")] SlBgpInstNotConfigInSlapi = 106536,
        /// <summary>
        /// BGP object list index out of range. 0x1a029
        /// </summary>
        [pbr::OriginalName("SL_BGP_OBJ_LIST_IDX_OUT_OF_RANGE")] SlBgpObjListIdxOutOfRange = 106537,
        /// <summary>
        /// BGP AS number out of range. 0x1a02a
        /// </summary>
        [pbr::OriginalName("SL_BGP_ASN_OUT_OF_RANGE")] SlBgpAsnOutOfRange = 106538,
        /// <summary>
        /// BGP invalid bandwidth-unit. 0x1a02b
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_BW_UNIT")] SlBgpInvalidBwUnit = 106539,
        /// <summary>
        /// BGP Object Type required when get_next is FALSE. 0x1a02c
        /// </summary>
        [pbr::OriginalName("SL_BGP_OBJECT_TYPE_REQUIRED")] SlBgpObjectTypeRequired = 106540,
        /// <summary>
        /// BGP Object Key required when get_next is FALSE. 0x1a02d
        /// </summary>
        [pbr::OriginalName("SL_BGP_OBJECT_KEY_REQUIRED")] SlBgpObjectKeyRequired = 106541,
        /// <summary>
        /// BGP invalid object type. 0x1a02e
        /// </summary>
        [pbr::OriginalName("SL_BGP_INVALID_OBJECT_TYPE")] SlBgpInvalidObjectType = 106542,
        /// <summary>
        /// BGP exact match for get request is not found. 0x1a02f
        /// </summary>
        [pbr::OriginalName("SL_BGP_GET_EXACT_MATCH_NOT_FOUND")] SlBgpGetExactMatchNotFound = 106543,
        /// <summary>
        /// BGP maximum neighbor count reached. 0x1a030
        /// </summary>
        [pbr::OriginalName("SL_BGP_MAX_NEIGHBORS_IN_SYSDB")] SlBgpMaxNeighborsInSysdb = 106544,
        /// <summary>
        /// BGP maximum object count reached. 0x1a031
        /// </summary>
        [pbr::OriginalName("SL_BGP_MAX_OBJECTS_IN_PAYLOAD")] SlBgpMaxObjectsInPayload = 106545,
        /// <summary>
        /// BGP Internal Error 1. 0x1a101
        /// </summary>
        [pbr::OriginalName("SL_BGP_INTERNAL_ERR_1")] SlBgpInternalErr1 = 106753,
        /// <summary>
        /// BGP Internal Error 2. 0x1a102
        /// </summary>
        [pbr::OriginalName("SL_BGP_INTERNAL_ERR_2")] SlBgpInternalErr2 = 106754,
        /// <summary>
        /// BGP Internal Error 3. 0x1a103
        /// </summary>
        [pbr::OriginalName("SL_BGP_INTERNAL_ERR_3")] SlBgpInternalErr3 = 106755,
        /// <summary>
        /// Offset for policy object operations. 0x1b000
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_START_OFFSET")] SlSrtePolicyStartOffset = 110592,
        /// <summary>
        /// Policy request message is not valid. 0x1b001
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_REQUEST_INVALID")] SlSrtePolicyRequestInvalid = 110593,
        /// <summary>
        /// Policy Key is missing or invalid. 0x1b002
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_POLICY_KEY_INVALID")] SlSrtePolicyPolicyKeyInvalid = 110594,
        /// <summary>
        /// Policy attributes are invalid. 0x1b003
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_POLICY_ATTR_INVALID")] SlSrtePolicyPolicyAttrInvalid = 110595,
        /// <summary>
        /// Candidate Path Key is missing or invalid. 0x1b004
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_CP_KEY_INVALID")] SlSrtePolicyCpKeyInvalid = 110596,
        /// <summary>
        /// Candidate Path attributes are invalid. 0x1b005
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_CP_ATTR_INVALID")] SlSrtePolicyCpAttrInvalid = 110597,
        /// <summary>
        /// Policy Client ID mismatch. 0x1b006
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_CLIENT_MISMATCH")] SlSrtePolicyClientMismatch = 110598,
        /// <summary>
        /// SR-TE policy service is not ready. 0x1b007
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_SERVICE_NOT_UP")] SlSrtePolicyServiceNotUp = 110599,
        /// <summary>
        /// Request message bigger than supported size. 0x1b008
        /// </summary>
        [pbr::OriginalName("SL_SRTE_POLICY_EXCEED_MSG_SIZE")] SlSrtePolicyExceedMsgSize = 110600,
        /// <summary>
        /// Offset for Internal errors. 0x100000
        /// </summary>
        [pbr::OriginalName("SL_INTERNAL_START_OFFSET")] SlInternalStartOffset = 1048576,
      }

    }
    #endregion

  }

  /// <summary>
  /// Interface info.
  /// </summary>
  public sealed partial class SLInterface : pb::IMessage<SLInterface>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLInterface> _parser = new pb::MessageParser<SLInterface>(() => new SLInterface());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLInterface> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLInterface() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLInterface(SLInterface other) : this() {
      switch (other.InterfaceCase) {
        case InterfaceOneofCase.Name:
          Name = other.Name;
          break;
        case InterfaceOneofCase.Handle:
          Handle = other.Handle;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLInterface Clone() {
      return new SLInterface(this);
    }

    /// <summary>Field number for the "Name" field.</summary>
    public const int NameFieldNumber = 1;
    /// <summary>
    /// Interface name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return interfaceCase_ == InterfaceOneofCase.Name ? (string) interface_ : ""; }
      set {
        interface_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        interfaceCase_ = InterfaceOneofCase.Name;
      }
    }

    /// <summary>Field number for the "Handle" field.</summary>
    public const int HandleFieldNumber = 2;
    /// <summary>
    /// Interface handle. Can be retrieved from Interface API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Handle {
      get { return interfaceCase_ == InterfaceOneofCase.Handle ? (uint) interface_ : 0; }
      set {
        interface_ = value;
        interfaceCase_ = InterfaceOneofCase.Handle;
      }
    }

    private object interface_;
    /// <summary>Enum of possible cases for the "Interface" oneof.</summary>
    public enum InterfaceOneofCase {
      None = 0,
      Name = 1,
      Handle = 2,
    }
    private InterfaceOneofCase interfaceCase_ = InterfaceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InterfaceOneofCase InterfaceCase {
      get { return interfaceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInterface() {
      interfaceCase_ = InterfaceOneofCase.None;
      interface_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLInterface);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLInterface other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Handle != other.Handle) return false;
      if (InterfaceCase != other.InterfaceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (interfaceCase_ == InterfaceOneofCase.Name) hash ^= Name.GetHashCode();
      if (interfaceCase_ == InterfaceOneofCase.Handle) hash ^= Handle.GetHashCode();
      hash ^= (int) interfaceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (interfaceCase_ == InterfaceOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (interfaceCase_ == InterfaceOneofCase.Handle) {
        output.WriteRawTag(16);
        output.WriteUInt32(Handle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (interfaceCase_ == InterfaceOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (interfaceCase_ == InterfaceOneofCase.Handle) {
        output.WriteRawTag(16);
        output.WriteUInt32(Handle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (interfaceCase_ == InterfaceOneofCase.Name) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (interfaceCase_ == InterfaceOneofCase.Handle) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Handle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLInterface other) {
      if (other == null) {
        return;
      }
      switch (other.InterfaceCase) {
        case InterfaceOneofCase.Name:
          Name = other.Name;
          break;
        case InterfaceOneofCase.Handle:
          Handle = other.Handle;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Handle = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Handle = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// One of IPv4 or IPv6 addresses.
  /// </summary>
  public sealed partial class SLIpAddress : pb::IMessage<SLIpAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLIpAddress> _parser = new pb::MessageParser<SLIpAddress>(() => new SLIpAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLIpAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpAddress(SLIpAddress other) : this() {
      switch (other.AddressCase) {
        case AddressOneofCase.V4Address:
          V4Address = other.V4Address;
          break;
        case AddressOneofCase.V6Address:
          V6Address = other.V6Address;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpAddress Clone() {
      return new SLIpAddress(this);
    }

    /// <summary>Field number for the "V4Address" field.</summary>
    public const int V4AddressFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint V4Address {
      get { return addressCase_ == AddressOneofCase.V4Address ? (uint) address_ : 0; }
      set {
        address_ = value;
        addressCase_ = AddressOneofCase.V4Address;
      }
    }

    /// <summary>Field number for the "V6Address" field.</summary>
    public const int V6AddressFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString V6Address {
      get { return addressCase_ == AddressOneofCase.V6Address ? (pb::ByteString) address_ : pb::ByteString.Empty; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        addressCase_ = AddressOneofCase.V6Address;
      }
    }

    private object address_;
    /// <summary>Enum of possible cases for the "Address" oneof.</summary>
    public enum AddressOneofCase {
      None = 0,
      V4Address = 1,
      V6Address = 2,
    }
    private AddressOneofCase addressCase_ = AddressOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AddressOneofCase AddressCase {
      get { return addressCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAddress() {
      addressCase_ = AddressOneofCase.None;
      address_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLIpAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLIpAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (V4Address != other.V4Address) return false;
      if (V6Address != other.V6Address) return false;
      if (AddressCase != other.AddressCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (addressCase_ == AddressOneofCase.V4Address) hash ^= V4Address.GetHashCode();
      if (addressCase_ == AddressOneofCase.V6Address) hash ^= V6Address.GetHashCode();
      hash ^= (int) addressCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (addressCase_ == AddressOneofCase.V4Address) {
        output.WriteRawTag(8);
        output.WriteUInt32(V4Address);
      }
      if (addressCase_ == AddressOneofCase.V6Address) {
        output.WriteRawTag(18);
        output.WriteBytes(V6Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (addressCase_ == AddressOneofCase.V4Address) {
        output.WriteRawTag(8);
        output.WriteUInt32(V4Address);
      }
      if (addressCase_ == AddressOneofCase.V6Address) {
        output.WriteRawTag(18);
        output.WriteBytes(V6Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (addressCase_ == AddressOneofCase.V4Address) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(V4Address);
      }
      if (addressCase_ == AddressOneofCase.V6Address) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(V6Address);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLIpAddress other) {
      if (other == null) {
        return;
      }
      switch (other.AddressCase) {
        case AddressOneofCase.V4Address:
          V4Address = other.V4Address;
          break;
        case AddressOneofCase.V6Address:
          V6Address = other.V6Address;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            V4Address = input.ReadUInt32();
            break;
          }
          case 18: {
            V6Address = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            V4Address = input.ReadUInt32();
            break;
          }
          case 18: {
            V6Address = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IPv6 address.
  /// </summary>
  public sealed partial class SLIpv6Address : pb::IMessage<SLIpv6Address>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLIpv6Address> _parser = new pb::MessageParser<SLIpv6Address>(() => new SLIpv6Address());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLIpv6Address> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpv6Address() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpv6Address(SLIpv6Address other) : this() {
      address_ = other.address_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLIpv6Address Clone() {
      return new SLIpv6Address(this);
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 1;
    private pb::ByteString address_ = pb::ByteString.Empty;
    /// <summary>
    /// Address must have length of 16 bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLIpv6Address);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLIpv6Address other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Address != other.Address) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Address.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Address.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Address);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLIpv6Address other) {
      if (other == null) {
        return;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Address = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Address = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Autonomous System Number (ASN)
  /// </summary>
  public sealed partial class SLAutonomousSystemNumber : pb::IMessage<SLAutonomousSystemNumber>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLAutonomousSystemNumber> _parser = new pb::MessageParser<SLAutonomousSystemNumber>(() => new SLAutonomousSystemNumber());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLAutonomousSystemNumber> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLAutonomousSystemNumber() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLAutonomousSystemNumber(SLAutonomousSystemNumber other) : this() {
      asn_ = other.asn_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLAutonomousSystemNumber Clone() {
      return new SLAutonomousSystemNumber(this);
    }

    /// <summary>Field number for the "asn" field.</summary>
    public const int AsnFieldNumber = 1;
    private uint asn_;
    /// <summary>
    /// If 2-byte ASNs are in use, the low-order 16 bits MUST be used,
    /// and the high-order bits MUST be set to 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Asn {
      get { return asn_; }
      set {
        asn_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLAutonomousSystemNumber);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLAutonomousSystemNumber other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Asn != other.Asn) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Asn != 0) hash ^= Asn.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Asn != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Asn);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Asn != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Asn);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Asn != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Asn);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLAutonomousSystemNumber other) {
      if (other == null) {
        return;
      }
      if (other.Asn != 0) {
        Asn = other.Asn;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Asn = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Asn = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Common Object Identifier.
  /// </summary>
  public sealed partial class SLObjectId : pb::IMessage<SLObjectId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLObjectId> _parser = new pb::MessageParser<SLObjectId>(() => new SLObjectId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLObjectId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLObjectId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLObjectId(SLObjectId other) : this() {
      switch (other.EntryCase) {
        case EntryOneofCase.Name:
          Name = other.Name;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLObjectId Clone() {
      return new SLObjectId(this);
    }

    /// <summary>Field number for the "Name" field.</summary>
    public const int NameFieldNumber = 1;
    /// <summary>
    /// Name of object.
    /// The string can contain only non white space printable ASCII characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return entryCase_ == EntryOneofCase.Name ? (string) entry_ : ""; }
      set {
        entry_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        entryCase_ = EntryOneofCase.Name;
      }
    }

    private object entry_;
    /// <summary>Enum of possible cases for the "entry" oneof.</summary>
    public enum EntryOneofCase {
      None = 0,
      Name = 1,
    }
    private EntryOneofCase entryCase_ = EntryOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntryOneofCase EntryCase {
      get { return entryCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEntry() {
      entryCase_ = EntryOneofCase.None;
      entry_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLObjectId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLObjectId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (EntryCase != other.EntryCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (entryCase_ == EntryOneofCase.Name) hash ^= Name.GetHashCode();
      hash ^= (int) entryCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (entryCase_ == EntryOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (entryCase_ == EntryOneofCase.Name) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (entryCase_ == EntryOneofCase.Name) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLObjectId other) {
      if (other == null) {
        return;
      }
      switch (other.EntryCase) {
        case EntryOneofCase.Name:
          Name = other.Name;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Path group reference key. This can be used by route, label
  /// or policy objects to refer a path group object.
  /// </summary>
  public sealed partial class SLPathGroupRefKey : pb::IMessage<SLPathGroupRefKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SLPathGroupRefKey> _parser = new pb::MessageParser<SLPathGroupRefKey>(() => new SLPathGroupRefKey());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SLPathGroupRefKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ServiceLayer.SlCommonTypesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLPathGroupRefKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLPathGroupRefKey(SLPathGroupRefKey other) : this() {
      vrfName_ = other.vrfName_;
      pathGroupId_ = other.pathGroupId_ != null ? other.pathGroupId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SLPathGroupRefKey Clone() {
      return new SLPathGroupRefKey(this);
    }

    /// <summary>Field number for the "VrfName" field.</summary>
    public const int VrfNameFieldNumber = 1;
    private string vrfName_ = "";
    /// <summary>
    /// VRF name
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VrfName {
      get { return vrfName_; }
      set {
        vrfName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "PathGroupId" field.</summary>
    public const int PathGroupIdFieldNumber = 2;
    private global::ServiceLayer.SLObjectId pathGroupId_;
    /// <summary>
    /// Path Group ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::ServiceLayer.SLObjectId PathGroupId {
      get { return pathGroupId_; }
      set {
        pathGroupId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SLPathGroupRefKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SLPathGroupRefKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VrfName != other.VrfName) return false;
      if (!object.Equals(PathGroupId, other.PathGroupId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (VrfName.Length != 0) hash ^= VrfName.GetHashCode();
      if (pathGroupId_ != null) hash ^= PathGroupId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (VrfName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VrfName);
      }
      if (pathGroupId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PathGroupId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (VrfName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VrfName);
      }
      if (pathGroupId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PathGroupId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (VrfName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VrfName);
      }
      if (pathGroupId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PathGroupId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SLPathGroupRefKey other) {
      if (other == null) {
        return;
      }
      if (other.VrfName.Length != 0) {
        VrfName = other.VrfName;
      }
      if (other.pathGroupId_ != null) {
        if (pathGroupId_ == null) {
          PathGroupId = new global::ServiceLayer.SLObjectId();
        }
        PathGroupId.MergeFrom(other.PathGroupId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VrfName = input.ReadString();
            break;
          }
          case 18: {
            if (pathGroupId_ == null) {
              PathGroupId = new global::ServiceLayer.SLObjectId();
            }
            input.ReadMessage(PathGroupId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VrfName = input.ReadString();
            break;
          }
          case 18: {
            if (pathGroupId_ == null) {
              PathGroupId = new global::ServiceLayer.SLObjectId();
            }
            input.ReadMessage(PathGroupId);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
