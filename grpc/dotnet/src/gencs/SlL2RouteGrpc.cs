// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: sl_l2_route.proto
// </auto-generated>
// Original file comments:
// @file
// @brief Server RPC proto file for L2 routes.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016, 2023 by cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace ServiceLayer {
  /// <summary>
  /// @defgroup SLRouteL2Oper
  /// @ingroup L2Route
  /// Defines RPC calls for L2 route changes and Bridge-Domain (BD) registration.
  /// This service declares calls for adding, deleting, updating and getting
  /// L2 routes.
  /// @{
  /// </summary>
  public static partial class SLL2Oper
  {
    static readonly string __ServiceName = "service_layer.SLL2Oper";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2GlobalsGetMsg> __Marshaller_service_layer_SLL2GlobalsGetMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2GlobalsGetMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2GlobalsGetMsgRsp> __Marshaller_service_layer_SLL2GlobalsGetMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2GlobalsGetMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2RegMsg> __Marshaller_service_layer_SLL2RegMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2RegMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2RegMsgRsp> __Marshaller_service_layer_SLL2RegMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2RegMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2BdRegMsg> __Marshaller_service_layer_SLL2BdRegMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2BdRegMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2BdRegMsgRsp> __Marshaller_service_layer_SLL2BdRegMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2BdRegMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2RouteMsg> __Marshaller_service_layer_SLL2RouteMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2RouteMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2RouteMsgRsp> __Marshaller_service_layer_SLL2RouteMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2RouteMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2GetNotifMsg> __Marshaller_service_layer_SLL2GetNotifMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2GetNotifMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLL2Notif> __Marshaller_service_layer_SLL2Notif = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLL2Notif.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2GlobalsGetMsg, global::ServiceLayer.SLL2GlobalsGetMsgRsp> __Method_SLL2GlobalsGet = new grpc::Method<global::ServiceLayer.SLL2GlobalsGetMsg, global::ServiceLayer.SLL2GlobalsGetMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLL2GlobalsGet",
        __Marshaller_service_layer_SLL2GlobalsGetMsg,
        __Marshaller_service_layer_SLL2GlobalsGetMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2RegMsg, global::ServiceLayer.SLL2RegMsgRsp> __Method_SLL2RegOp = new grpc::Method<global::ServiceLayer.SLL2RegMsg, global::ServiceLayer.SLL2RegMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLL2RegOp",
        __Marshaller_service_layer_SLL2RegMsg,
        __Marshaller_service_layer_SLL2RegMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2BdRegMsg, global::ServiceLayer.SLL2BdRegMsgRsp> __Method_SLL2BdRegOp = new grpc::Method<global::ServiceLayer.SLL2BdRegMsg, global::ServiceLayer.SLL2BdRegMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLL2BdRegOp",
        __Marshaller_service_layer_SLL2BdRegMsg,
        __Marshaller_service_layer_SLL2BdRegMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp> __Method_SLL2RouteOp = new grpc::Method<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLL2RouteOp",
        __Marshaller_service_layer_SLL2RouteMsg,
        __Marshaller_service_layer_SLL2RouteMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp> __Method_SLL2RouteOpStream = new grpc::Method<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SLL2RouteOpStream",
        __Marshaller_service_layer_SLL2RouteMsg,
        __Marshaller_service_layer_SLL2RouteMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLL2GetNotifMsg, global::ServiceLayer.SLL2Notif> __Method_SLL2GetNotifStream = new grpc::Method<global::ServiceLayer.SLL2GetNotifMsg, global::ServiceLayer.SLL2Notif>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SLL2GetNotifStream",
        __Marshaller_service_layer_SLL2GetNotifMsg,
        __Marshaller_service_layer_SLL2Notif);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::ServiceLayer.SlL2RouteReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of SLL2Oper</summary>
    [grpc::BindServiceMethod(typeof(SLL2Oper), "BindService")]
    public abstract partial class SLL2OperBase
    {
      /// <summary>
      /// Used to retrieve global L2 info from the server.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLL2GlobalsGetMsgRsp> SLL2GlobalsGet(global::ServiceLayer.SLL2GlobalsGetMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      ///     Global L2 registration.
      ///     A client Must Register BEFORE sending BD registration messages
      ///     (to add/update/delete routes) or BEFORE requesting for L2 route
      ///     notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     Global L2 un-registration.
      ///     This call is used to convey that the client is no longer
      ///     interested in programming L2 routes and in receiving L2 route
      ///     notifications. All programmed L2 routes will be deleted on the
      ///     server and the server will stop sending L2 route notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_EOF:
      ///     Global L2 End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known
      ///     objects and to convey the end of requests for L2 route
      ///     notifications.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLL2RegMsgRsp> SLL2RegOp(global::ServiceLayer.SLL2RegMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      ///     BD registration: Sends a list of BD registration messages and
      ///     expects a list of registration responses.
      ///     A client Must Register a BD BEFORE L2 Routes can be added/modified
      ///     in that BD.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     BD un-registration: Sends a list of BD un-registration messages
      ///     and expects a list of un-registration responses.
      ///     This can be used to convey that the client is no longer
      ///     interested in programming routes in this BD. All installed L2
      ///     routes will be removed.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      ///     BD End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects
      ///     in that BD.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLL2BdRegMsgRsp> SLL2BdRegOp(global::ServiceLayer.SLL2BdRegMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      /// Route add. Fails if the route already exists.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      /// Route update. Creates or updates the route.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      /// Route delete. The route path is not necessary to delete the route.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLL2RouteMsgRsp> SLL2RouteOp(global::ServiceLayer.SLL2RouteMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Stream adds/updates/deletes of L2 Routes.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task SLL2RouteOpStream(grpc::IAsyncStreamReader<global::ServiceLayer.SLL2RouteMsg> requestStream, grpc::IServerStreamWriter<global::ServiceLayer.SLL2RouteMsgRsp> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// This call is used to get a stream of BD state and route notifications.
      /// It can be used to get "push" notifications for route
      /// adds/updates/deletes.
      /// The caller must maintain the GRPC channel as long as there is
      /// interest in route notifications.
      ///
      /// The call takes 3 types of notification requests:
      /// 1. Request for BD state notifications only (pass only Oper and
      ///    Correlator).
      /// 2. Request for BD state and Route notifications in all BDs.
      /// 3. Request for Route notifications per-BD.
      ///    This should be sent after requesting for BD state notifications
      ///    and after receiving BD-ready notification.
      ///
      /// The success/failure of the notification request is relayed in the
      /// SLL2NotifStatusMsg followed by a Start marker, any routes if present,
      /// and an End Marker.
      ///
      /// After all requests are sent, client should send GetNotifEof = TRUE.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task SLL2GetNotifStream(grpc::IAsyncStreamReader<global::ServiceLayer.SLL2GetNotifMsg> requestStream, grpc::IServerStreamWriter<global::ServiceLayer.SLL2Notif> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for SLL2Oper</summary>
    public partial class SLL2OperClient : grpc::ClientBase<SLL2OperClient>
    {
      /// <summary>Creates a new client for SLL2Oper</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SLL2OperClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for SLL2Oper that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SLL2OperClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SLL2OperClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SLL2OperClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Used to retrieve global L2 info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2GlobalsGetMsgRsp SLL2GlobalsGet(global::ServiceLayer.SLL2GlobalsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2GlobalsGet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Used to retrieve global L2 info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2GlobalsGetMsgRsp SLL2GlobalsGet(global::ServiceLayer.SLL2GlobalsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLL2GlobalsGet, null, options, request);
      }
      /// <summary>
      /// Used to retrieve global L2 info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2GlobalsGetMsgRsp> SLL2GlobalsGetAsync(global::ServiceLayer.SLL2GlobalsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2GlobalsGetAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Used to retrieve global L2 info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2GlobalsGetMsgRsp> SLL2GlobalsGetAsync(global::ServiceLayer.SLL2GlobalsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLL2GlobalsGet, null, options, request);
      }
      /// <summary>
      /// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      ///     Global L2 registration.
      ///     A client Must Register BEFORE sending BD registration messages
      ///     (to add/update/delete routes) or BEFORE requesting for L2 route
      ///     notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     Global L2 un-registration.
      ///     This call is used to convey that the client is no longer
      ///     interested in programming L2 routes and in receiving L2 route
      ///     notifications. All programmed L2 routes will be deleted on the
      ///     server and the server will stop sending L2 route notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_EOF:
      ///     Global L2 End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known
      ///     objects and to convey the end of requests for L2 route
      ///     notifications.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2RegMsgRsp SLL2RegOp(global::ServiceLayer.SLL2RegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2RegOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      ///     Global L2 registration.
      ///     A client Must Register BEFORE sending BD registration messages
      ///     (to add/update/delete routes) or BEFORE requesting for L2 route
      ///     notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     Global L2 un-registration.
      ///     This call is used to convey that the client is no longer
      ///     interested in programming L2 routes and in receiving L2 route
      ///     notifications. All programmed L2 routes will be deleted on the
      ///     server and the server will stop sending L2 route notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_EOF:
      ///     Global L2 End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known
      ///     objects and to convey the end of requests for L2 route
      ///     notifications.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2RegMsgRsp SLL2RegOp(global::ServiceLayer.SLL2RegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLL2RegOp, null, options, request);
      }
      /// <summary>
      /// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      ///     Global L2 registration.
      ///     A client Must Register BEFORE sending BD registration messages
      ///     (to add/update/delete routes) or BEFORE requesting for L2 route
      ///     notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     Global L2 un-registration.
      ///     This call is used to convey that the client is no longer
      ///     interested in programming L2 routes and in receiving L2 route
      ///     notifications. All programmed L2 routes will be deleted on the
      ///     server and the server will stop sending L2 route notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_EOF:
      ///     Global L2 End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known
      ///     objects and to convey the end of requests for L2 route
      ///     notifications.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2RegMsgRsp> SLL2RegOpAsync(global::ServiceLayer.SLL2RegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2RegOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
      ///     Global L2 registration.
      ///     A client Must Register BEFORE sending BD registration messages
      ///     (to add/update/delete routes) or BEFORE requesting for L2 route
      ///     notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     Global L2 un-registration.
      ///     This call is used to convey that the client is no longer
      ///     interested in programming L2 routes and in receiving L2 route
      ///     notifications. All programmed L2 routes will be deleted on the
      ///     server and the server will stop sending L2 route notifications.
      ///
      /// SLL2RegMsg.Oper = SL_REGOP_EOF:
      ///     Global L2 End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known
      ///     objects and to convey the end of requests for L2 route
      ///     notifications.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2RegMsgRsp> SLL2RegOpAsync(global::ServiceLayer.SLL2RegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLL2RegOp, null, options, request);
      }
      /// <summary>
      /// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      ///     BD registration: Sends a list of BD registration messages and
      ///     expects a list of registration responses.
      ///     A client Must Register a BD BEFORE L2 Routes can be added/modified
      ///     in that BD.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     BD un-registration: Sends a list of BD un-registration messages
      ///     and expects a list of un-registration responses.
      ///     This can be used to convey that the client is no longer
      ///     interested in programming routes in this BD. All installed L2
      ///     routes will be removed.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      ///     BD End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects
      ///     in that BD.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2BdRegMsgRsp SLL2BdRegOp(global::ServiceLayer.SLL2BdRegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2BdRegOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      ///     BD registration: Sends a list of BD registration messages and
      ///     expects a list of registration responses.
      ///     A client Must Register a BD BEFORE L2 Routes can be added/modified
      ///     in that BD.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     BD un-registration: Sends a list of BD un-registration messages
      ///     and expects a list of un-registration responses.
      ///     This can be used to convey that the client is no longer
      ///     interested in programming routes in this BD. All installed L2
      ///     routes will be removed.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      ///     BD End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects
      ///     in that BD.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2BdRegMsgRsp SLL2BdRegOp(global::ServiceLayer.SLL2BdRegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLL2BdRegOp, null, options, request);
      }
      /// <summary>
      /// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      ///     BD registration: Sends a list of BD registration messages and
      ///     expects a list of registration responses.
      ///     A client Must Register a BD BEFORE L2 Routes can be added/modified
      ///     in that BD.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     BD un-registration: Sends a list of BD un-registration messages
      ///     and expects a list of un-registration responses.
      ///     This can be used to convey that the client is no longer
      ///     interested in programming routes in this BD. All installed L2
      ///     routes will be removed.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      ///     BD End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects
      ///     in that BD.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2BdRegMsgRsp> SLL2BdRegOpAsync(global::ServiceLayer.SLL2BdRegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2BdRegOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
      ///     BD registration: Sends a list of BD registration messages and
      ///     expects a list of registration responses.
      ///     A client Must Register a BD BEFORE L2 Routes can be added/modified
      ///     in that BD.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
      ///     BD un-registration: Sends a list of BD un-registration messages
      ///     and expects a list of un-registration responses.
      ///     This can be used to convey that the client is no longer
      ///     interested in programming routes in this BD. All installed L2
      ///     routes will be removed.
      ///
      /// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
      ///     BD End Of File message.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects
      ///     in that BD.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their routes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2BdRegMsgRsp> SLL2BdRegOpAsync(global::ServiceLayer.SLL2BdRegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLL2BdRegOp, null, options, request);
      }
      /// <summary>
      /// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      /// Route add. Fails if the route already exists.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      /// Route update. Creates or updates the route.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      /// Route delete. The route path is not necessary to delete the route.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2RouteMsgRsp SLL2RouteOp(global::ServiceLayer.SLL2RouteMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2RouteOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      /// Route add. Fails if the route already exists.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      /// Route update. Creates or updates the route.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      /// Route delete. The route path is not necessary to delete the route.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLL2RouteMsgRsp SLL2RouteOp(global::ServiceLayer.SLL2RouteMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLL2RouteOp, null, options, request);
      }
      /// <summary>
      /// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      /// Route add. Fails if the route already exists.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      /// Route update. Creates or updates the route.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      /// Route delete. The route path is not necessary to delete the route.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2RouteMsgRsp> SLL2RouteOpAsync(global::ServiceLayer.SLL2RouteMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2RouteOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
      /// Route add. Fails if the route already exists.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
      /// Route update. Creates or updates the route.
      ///
      /// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
      /// Route delete. The route path is not necessary to delete the route.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLL2RouteMsgRsp> SLL2RouteOpAsync(global::ServiceLayer.SLL2RouteMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLL2RouteOp, null, options, request);
      }
      /// <summary>
      /// Stream adds/updates/deletes of L2 Routes.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp> SLL2RouteOpStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2RouteOpStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Stream adds/updates/deletes of L2 Routes.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp> SLL2RouteOpStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SLL2RouteOpStream, null, options);
      }
      /// <summary>
      /// This call is used to get a stream of BD state and route notifications.
      /// It can be used to get "push" notifications for route
      /// adds/updates/deletes.
      /// The caller must maintain the GRPC channel as long as there is
      /// interest in route notifications.
      ///
      /// The call takes 3 types of notification requests:
      /// 1. Request for BD state notifications only (pass only Oper and
      ///    Correlator).
      /// 2. Request for BD state and Route notifications in all BDs.
      /// 3. Request for Route notifications per-BD.
      ///    This should be sent after requesting for BD state notifications
      ///    and after receiving BD-ready notification.
      ///
      /// The success/failure of the notification request is relayed in the
      /// SLL2NotifStatusMsg followed by a Start marker, any routes if present,
      /// and an End Marker.
      ///
      /// After all requests are sent, client should send GetNotifEof = TRUE.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLL2GetNotifMsg, global::ServiceLayer.SLL2Notif> SLL2GetNotifStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLL2GetNotifStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// This call is used to get a stream of BD state and route notifications.
      /// It can be used to get "push" notifications for route
      /// adds/updates/deletes.
      /// The caller must maintain the GRPC channel as long as there is
      /// interest in route notifications.
      ///
      /// The call takes 3 types of notification requests:
      /// 1. Request for BD state notifications only (pass only Oper and
      ///    Correlator).
      /// 2. Request for BD state and Route notifications in all BDs.
      /// 3. Request for Route notifications per-BD.
      ///    This should be sent after requesting for BD state notifications
      ///    and after receiving BD-ready notification.
      ///
      /// The success/failure of the notification request is relayed in the
      /// SLL2NotifStatusMsg followed by a Start marker, any routes if present,
      /// and an End Marker.
      ///
      /// After all requests are sent, client should send GetNotifEof = TRUE.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLL2GetNotifMsg, global::ServiceLayer.SLL2Notif> SLL2GetNotifStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SLL2GetNotifStream, null, options);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override SLL2OperClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new SLL2OperClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(SLL2OperBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_SLL2GlobalsGet, serviceImpl.SLL2GlobalsGet)
          .AddMethod(__Method_SLL2RegOp, serviceImpl.SLL2RegOp)
          .AddMethod(__Method_SLL2BdRegOp, serviceImpl.SLL2BdRegOp)
          .AddMethod(__Method_SLL2RouteOp, serviceImpl.SLL2RouteOp)
          .AddMethod(__Method_SLL2RouteOpStream, serviceImpl.SLL2RouteOpStream)
          .AddMethod(__Method_SLL2GetNotifStream, serviceImpl.SLL2GetNotifStream).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, SLL2OperBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_SLL2GlobalsGet, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLL2GlobalsGetMsg, global::ServiceLayer.SLL2GlobalsGetMsgRsp>(serviceImpl.SLL2GlobalsGet));
      serviceBinder.AddMethod(__Method_SLL2RegOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLL2RegMsg, global::ServiceLayer.SLL2RegMsgRsp>(serviceImpl.SLL2RegOp));
      serviceBinder.AddMethod(__Method_SLL2BdRegOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLL2BdRegMsg, global::ServiceLayer.SLL2BdRegMsgRsp>(serviceImpl.SLL2BdRegOp));
      serviceBinder.AddMethod(__Method_SLL2RouteOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp>(serviceImpl.SLL2RouteOp));
      serviceBinder.AddMethod(__Method_SLL2RouteOpStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::ServiceLayer.SLL2RouteMsg, global::ServiceLayer.SLL2RouteMsgRsp>(serviceImpl.SLL2RouteOpStream));
      serviceBinder.AddMethod(__Method_SLL2GetNotifStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::ServiceLayer.SLL2GetNotifMsg, global::ServiceLayer.SLL2Notif>(serviceImpl.SLL2GetNotifStream));
    }

  }
}
#endregion
