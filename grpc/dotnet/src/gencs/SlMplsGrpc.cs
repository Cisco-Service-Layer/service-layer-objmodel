/*
 * Copyright (c) 2023 by cisco Systems, Inc. All rights reserved.
 */
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: sl_mpls.proto
// </auto-generated>
// Original file comments:
// @file
// @brief RPC proto file for MPLS types.
//
// ----------------------------------------------------------------
//  Copyright (c) 2019, 2023 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//
//
// @defgroup MPLS
// @brief MPLS service definitions.
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace ServiceLayer {
  /// <summary>
  /// @defgroup SLMpls
  /// @ingroup MPLS
  /// Defines RPCs for MPLS Registrations, label block reservations, and ILM entries
  /// manipulations.
  /// Clients Must register for MPLS operations e.g. Incoming Label Map operations.
  /// Once registered, a client Must reserve an MPLS label (dynamic allocation) 
  /// before using it as an incoming label map. 
  /// Labels are reserved in blocks through the block reservation operations.
  ///
  /// This file also defines RPC calls for adding, deleting, updating, and querying
  /// incoming label map entries (see RFC 3031)
  ///
  /// Incoming Label Map (ILM): A mapping from incoming labels to 
  /// corresponding NHLFEs. It is used when forwarding packets that
  /// arrive as labeled packets. 
  ///
  /// Next Hop Forwarding Entry (NHLE): An entry containing next-hop
  /// information and label manipulation instructions. This is also referred to
  /// as the ILM Path.
  ///
  /// @{
  /// </summary>
  public static partial class SLMplsOper
  {
    static readonly string __ServiceName = "service_layer.SLMplsOper";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsRegMsg> __Marshaller_service_layer_SLMplsRegMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsRegMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsRegMsgRsp> __Marshaller_service_layer_SLMplsRegMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsRegMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsGetMsg> __Marshaller_service_layer_SLMplsGetMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsGetMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsGetMsgRsp> __Marshaller_service_layer_SLMplsGetMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsGetMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsGetStatsMsgRsp> __Marshaller_service_layer_SLMplsGetStatsMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsGetStatsMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsLabelBlockMsg> __Marshaller_service_layer_SLMplsLabelBlockMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsLabelBlockMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsLabelBlockMsgRsp> __Marshaller_service_layer_SLMplsLabelBlockMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsLabelBlockMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsLabelBlockGetMsg> __Marshaller_service_layer_SLMplsLabelBlockGetMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsLabelBlockGetMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsLabelBlockGetMsgRsp> __Marshaller_service_layer_SLMplsLabelBlockGetMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsLabelBlockGetMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsIlmMsg> __Marshaller_service_layer_SLMplsIlmMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsIlmMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsIlmMsgRsp> __Marshaller_service_layer_SLMplsIlmMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsIlmMsgRsp.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsIlmGetMsg> __Marshaller_service_layer_SLMplsIlmGetMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsIlmGetMsg.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::ServiceLayer.SLMplsIlmGetMsgRsp> __Marshaller_service_layer_SLMplsIlmGetMsgRsp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ServiceLayer.SLMplsIlmGetMsgRsp.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsRegMsg, global::ServiceLayer.SLMplsRegMsgRsp> __Method_SLMplsRegOp = new grpc::Method<global::ServiceLayer.SLMplsRegMsg, global::ServiceLayer.SLMplsRegMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsRegOp",
        __Marshaller_service_layer_SLMplsRegMsg,
        __Marshaller_service_layer_SLMplsRegMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetMsgRsp> __Method_SLMplsGet = new grpc::Method<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsGet",
        __Marshaller_service_layer_SLMplsGetMsg,
        __Marshaller_service_layer_SLMplsGetMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetStatsMsgRsp> __Method_SLMplsGetStats = new grpc::Method<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetStatsMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsGetStats",
        __Marshaller_service_layer_SLMplsGetMsg,
        __Marshaller_service_layer_SLMplsGetStatsMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsLabelBlockMsg, global::ServiceLayer.SLMplsLabelBlockMsgRsp> __Method_SLMplsLabelBlockOp = new grpc::Method<global::ServiceLayer.SLMplsLabelBlockMsg, global::ServiceLayer.SLMplsLabelBlockMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsLabelBlockOp",
        __Marshaller_service_layer_SLMplsLabelBlockMsg,
        __Marshaller_service_layer_SLMplsLabelBlockMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsLabelBlockGetMsg, global::ServiceLayer.SLMplsLabelBlockGetMsgRsp> __Method_SLMplsLabelBlockGet = new grpc::Method<global::ServiceLayer.SLMplsLabelBlockGetMsg, global::ServiceLayer.SLMplsLabelBlockGetMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsLabelBlockGet",
        __Marshaller_service_layer_SLMplsLabelBlockGetMsg,
        __Marshaller_service_layer_SLMplsLabelBlockGetMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp> __Method_SLMplsIlmOp = new grpc::Method<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsIlmOp",
        __Marshaller_service_layer_SLMplsIlmMsg,
        __Marshaller_service_layer_SLMplsIlmMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp> __Method_SLMplsIlmGet = new grpc::Method<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SLMplsIlmGet",
        __Marshaller_service_layer_SLMplsIlmGetMsg,
        __Marshaller_service_layer_SLMplsIlmGetMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp> __Method_SLMplsIlmOpStream = new grpc::Method<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SLMplsIlmOpStream",
        __Marshaller_service_layer_SLMplsIlmMsg,
        __Marshaller_service_layer_SLMplsIlmMsgRsp);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp> __Method_SLMplsIlmGetStream = new grpc::Method<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SLMplsIlmGetStream",
        __Marshaller_service_layer_SLMplsIlmGetMsg,
        __Marshaller_service_layer_SLMplsIlmGetMsgRsp);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::ServiceLayer.SlMplsReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of SLMplsOper</summary>
    [grpc::BindServiceMethod(typeof(SLMplsOper), "BindService")]
    public abstract partial class SLMplsOperBase
    {
      /// <summary>
      /// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
      ///     Global MPLS registration.
      ///     A client Must Register BEFORE MPLS objects can be added/modified.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
      ///     Global MPLS un-registration.
      ///     This call is used to end all MPLS notifications and unregister any
      ///     interest in MPLS object configuration.
      ///     This call cleans up all MPLS objects previously requested.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_EOF.
      ///     MPLS End Of File.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their MPLS objects.
      ///
      /// The MPLS registration operations can be used by the client to
      /// synchronize label block allocations and ILMs with the device. When
      /// the client re-registers with the server using SL_REGOP_REGISTER,
      /// server marks all label block allocations and ILMs as stale.
      /// Client then must reprogram label block allocations and ILMs.
      /// When client sends SL_REGOP_EOF, any objects not reprogrammed
      /// are removed from the device.
      ///
      /// The client must perform all operations (MPLS registration,
      /// label block and ILM) from a single execution context.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsRegMsgRsp> SLMplsRegOp(global::ServiceLayer.SLMplsRegMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Retrieve global MPLS info from the server.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsGetMsgRsp> SLMplsGet(global::ServiceLayer.SLMplsGetMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Retrieve global MPLS Stats from the server.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsGetStatsMsgRsp> SLMplsGetStats(global::ServiceLayer.SLMplsGetMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
      ///     Add a contiguous label block.
      ///     Add request may fail if the full block cannot be allocated.
      ///
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
      ///     Delete a contiguous label block.
      ///     Delete request may fail if the block is in use or the keys don't
      ///     match the keys used on add.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsLabelBlockMsgRsp> SLMplsLabelBlockOp(global::ServiceLayer.SLMplsLabelBlockMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Retrieve Label Block attributes.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsLabelBlockGetMsgRsp> SLMplsLabelBlockGet(global::ServiceLayer.SLMplsLabelBlockGetMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is considered a success.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsIlmMsgRsp> SLMplsIlmOp(global::ServiceLayer.SLMplsIlmMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Retrieve MPLS ILM entry attributes.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::ServiceLayer.SLMplsIlmGetMsgRsp> SLMplsIlmGet(global::ServiceLayer.SLMplsIlmGetMsg request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is returned as success.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task SLMplsIlmOpStream(grpc::IAsyncStreamReader<global::ServiceLayer.SLMplsIlmMsg> requestStream, grpc::IServerStreamWriter<global::ServiceLayer.SLMplsIlmMsgRsp> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Stream-Get of incoming label map
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task SLMplsIlmGetStream(grpc::IAsyncStreamReader<global::ServiceLayer.SLMplsIlmGetMsg> requestStream, grpc::IServerStreamWriter<global::ServiceLayer.SLMplsIlmGetMsgRsp> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for SLMplsOper</summary>
    public partial class SLMplsOperClient : grpc::ClientBase<SLMplsOperClient>
    {
      /// <summary>Creates a new client for SLMplsOper</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SLMplsOperClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for SLMplsOper that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SLMplsOperClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SLMplsOperClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SLMplsOperClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
      ///     Global MPLS registration.
      ///     A client Must Register BEFORE MPLS objects can be added/modified.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
      ///     Global MPLS un-registration.
      ///     This call is used to end all MPLS notifications and unregister any
      ///     interest in MPLS object configuration.
      ///     This call cleans up all MPLS objects previously requested.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_EOF.
      ///     MPLS End Of File.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their MPLS objects.
      ///
      /// The MPLS registration operations can be used by the client to
      /// synchronize label block allocations and ILMs with the device. When
      /// the client re-registers with the server using SL_REGOP_REGISTER,
      /// server marks all label block allocations and ILMs as stale.
      /// Client then must reprogram label block allocations and ILMs.
      /// When client sends SL_REGOP_EOF, any objects not reprogrammed
      /// are removed from the device.
      ///
      /// The client must perform all operations (MPLS registration,
      /// label block and ILM) from a single execution context.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsRegMsgRsp SLMplsRegOp(global::ServiceLayer.SLMplsRegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsRegOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
      ///     Global MPLS registration.
      ///     A client Must Register BEFORE MPLS objects can be added/modified.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
      ///     Global MPLS un-registration.
      ///     This call is used to end all MPLS notifications and unregister any
      ///     interest in MPLS object configuration.
      ///     This call cleans up all MPLS objects previously requested.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_EOF.
      ///     MPLS End Of File.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their MPLS objects.
      ///
      /// The MPLS registration operations can be used by the client to
      /// synchronize label block allocations and ILMs with the device. When
      /// the client re-registers with the server using SL_REGOP_REGISTER,
      /// server marks all label block allocations and ILMs as stale.
      /// Client then must reprogram label block allocations and ILMs.
      /// When client sends SL_REGOP_EOF, any objects not reprogrammed
      /// are removed from the device.
      ///
      /// The client must perform all operations (MPLS registration,
      /// label block and ILM) from a single execution context.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsRegMsgRsp SLMplsRegOp(global::ServiceLayer.SLMplsRegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsRegOp, null, options, request);
      }
      /// <summary>
      /// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
      ///     Global MPLS registration.
      ///     A client Must Register BEFORE MPLS objects can be added/modified.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
      ///     Global MPLS un-registration.
      ///     This call is used to end all MPLS notifications and unregister any
      ///     interest in MPLS object configuration.
      ///     This call cleans up all MPLS objects previously requested.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_EOF.
      ///     MPLS End Of File.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their MPLS objects.
      ///
      /// The MPLS registration operations can be used by the client to
      /// synchronize label block allocations and ILMs with the device. When
      /// the client re-registers with the server using SL_REGOP_REGISTER,
      /// server marks all label block allocations and ILMs as stale.
      /// Client then must reprogram label block allocations and ILMs.
      /// When client sends SL_REGOP_EOF, any objects not reprogrammed
      /// are removed from the device.
      ///
      /// The client must perform all operations (MPLS registration,
      /// label block and ILM) from a single execution context.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsRegMsgRsp> SLMplsRegOpAsync(global::ServiceLayer.SLMplsRegMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsRegOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
      ///     Global MPLS registration.
      ///     A client Must Register BEFORE MPLS objects can be added/modified.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
      ///     Global MPLS un-registration.
      ///     This call is used to end all MPLS notifications and unregister any
      ///     interest in MPLS object configuration.
      ///     This call cleans up all MPLS objects previously requested.
      ///
      /// SLMplsRegMsg.Oper = SL_REGOP_EOF.
      ///     MPLS End Of File.
      ///     After Registration, the client is expected to send an EOF
      ///     message to convey the end of replay of the client's known objects.
      ///     This is especially useful under certain restart scenarios when the
      ///     client and the server are trying to synchronize their MPLS objects.
      ///
      /// The MPLS registration operations can be used by the client to
      /// synchronize label block allocations and ILMs with the device. When
      /// the client re-registers with the server using SL_REGOP_REGISTER,
      /// server marks all label block allocations and ILMs as stale.
      /// Client then must reprogram label block allocations and ILMs.
      /// When client sends SL_REGOP_EOF, any objects not reprogrammed
      /// are removed from the device.
      ///
      /// The client must perform all operations (MPLS registration,
      /// label block and ILM) from a single execution context.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsRegMsgRsp> SLMplsRegOpAsync(global::ServiceLayer.SLMplsRegMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsRegOp, null, options, request);
      }
      /// <summary>
      /// Retrieve global MPLS info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsGetMsgRsp SLMplsGet(global::ServiceLayer.SLMplsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsGet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve global MPLS info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsGetMsgRsp SLMplsGet(global::ServiceLayer.SLMplsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsGet, null, options, request);
      }
      /// <summary>
      /// Retrieve global MPLS info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsGetMsgRsp> SLMplsGetAsync(global::ServiceLayer.SLMplsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsGetAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve global MPLS info from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsGetMsgRsp> SLMplsGetAsync(global::ServiceLayer.SLMplsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsGet, null, options, request);
      }
      /// <summary>
      /// Retrieve global MPLS Stats from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsGetStatsMsgRsp SLMplsGetStats(global::ServiceLayer.SLMplsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsGetStats(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve global MPLS Stats from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsGetStatsMsgRsp SLMplsGetStats(global::ServiceLayer.SLMplsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsGetStats, null, options, request);
      }
      /// <summary>
      /// Retrieve global MPLS Stats from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsGetStatsMsgRsp> SLMplsGetStatsAsync(global::ServiceLayer.SLMplsGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsGetStatsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve global MPLS Stats from the server.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsGetStatsMsgRsp> SLMplsGetStatsAsync(global::ServiceLayer.SLMplsGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsGetStats, null, options, request);
      }
      /// <summary>
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
      ///     Add a contiguous label block.
      ///     Add request may fail if the full block cannot be allocated.
      ///
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
      ///     Delete a contiguous label block.
      ///     Delete request may fail if the block is in use or the keys don't
      ///     match the keys used on add.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsLabelBlockMsgRsp SLMplsLabelBlockOp(global::ServiceLayer.SLMplsLabelBlockMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsLabelBlockOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
      ///     Add a contiguous label block.
      ///     Add request may fail if the full block cannot be allocated.
      ///
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
      ///     Delete a contiguous label block.
      ///     Delete request may fail if the block is in use or the keys don't
      ///     match the keys used on add.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsLabelBlockMsgRsp SLMplsLabelBlockOp(global::ServiceLayer.SLMplsLabelBlockMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsLabelBlockOp, null, options, request);
      }
      /// <summary>
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
      ///     Add a contiguous label block.
      ///     Add request may fail if the full block cannot be allocated.
      ///
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
      ///     Delete a contiguous label block.
      ///     Delete request may fail if the block is in use or the keys don't
      ///     match the keys used on add.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsLabelBlockMsgRsp> SLMplsLabelBlockOpAsync(global::ServiceLayer.SLMplsLabelBlockMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsLabelBlockOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
      ///     Add a contiguous label block.
      ///     Add request may fail if the full block cannot be allocated.
      ///
      /// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
      ///     Delete a contiguous label block.
      ///     Delete request may fail if the block is in use or the keys don't
      ///     match the keys used on add.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsLabelBlockMsgRsp> SLMplsLabelBlockOpAsync(global::ServiceLayer.SLMplsLabelBlockMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsLabelBlockOp, null, options, request);
      }
      /// <summary>
      /// Retrieve Label Block attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsLabelBlockGetMsgRsp SLMplsLabelBlockGet(global::ServiceLayer.SLMplsLabelBlockGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsLabelBlockGet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve Label Block attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsLabelBlockGetMsgRsp SLMplsLabelBlockGet(global::ServiceLayer.SLMplsLabelBlockGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsLabelBlockGet, null, options, request);
      }
      /// <summary>
      /// Retrieve Label Block attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsLabelBlockGetMsgRsp> SLMplsLabelBlockGetAsync(global::ServiceLayer.SLMplsLabelBlockGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsLabelBlockGetAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve Label Block attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsLabelBlockGetMsgRsp> SLMplsLabelBlockGetAsync(global::ServiceLayer.SLMplsLabelBlockGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsLabelBlockGet, null, options, request);
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is considered a success.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsIlmMsgRsp SLMplsIlmOp(global::ServiceLayer.SLMplsIlmMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmOp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is considered a success.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsIlmMsgRsp SLMplsIlmOp(global::ServiceLayer.SLMplsIlmMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsIlmOp, null, options, request);
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is considered a success.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsIlmMsgRsp> SLMplsIlmOpAsync(global::ServiceLayer.SLMplsIlmMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmOpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is considered a success.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsIlmMsgRsp> SLMplsIlmOpAsync(global::ServiceLayer.SLMplsIlmMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsIlmOp, null, options, request);
      }
      /// <summary>
      /// Retrieve MPLS ILM entry attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsIlmGetMsgRsp SLMplsIlmGet(global::ServiceLayer.SLMplsIlmGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmGet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve MPLS ILM entry attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::ServiceLayer.SLMplsIlmGetMsgRsp SLMplsIlmGet(global::ServiceLayer.SLMplsIlmGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SLMplsIlmGet, null, options, request);
      }
      /// <summary>
      /// Retrieve MPLS ILM entry attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsIlmGetMsgRsp> SLMplsIlmGetAsync(global::ServiceLayer.SLMplsIlmGetMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmGetAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Retrieve MPLS ILM entry attributes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::ServiceLayer.SLMplsIlmGetMsgRsp> SLMplsIlmGetAsync(global::ServiceLayer.SLMplsIlmGetMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SLMplsIlmGet, null, options, request);
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is returned as success.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp> SLMplsIlmOpStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmOpStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
      ///     Add incoming label map entry. Fails if the entry already
      ///     exists and not stale. First ADD operation on a stale entry
      ///     is allowed and the entry is no longer considered stale.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
      ///     Create or update incoming label map entry.
      ///
      /// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
      ///     Delete incoming label map entry. Delete of a
      ///     non-existant entry is returned as success.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp> SLMplsIlmOpStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SLMplsIlmOpStream, null, options);
      }
      /// <summary>
      /// Stream-Get of incoming label map
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp> SLMplsIlmGetStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SLMplsIlmGetStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Stream-Get of incoming label map
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncDuplexStreamingCall<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp> SLMplsIlmGetStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SLMplsIlmGetStream, null, options);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override SLMplsOperClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new SLMplsOperClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(SLMplsOperBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_SLMplsRegOp, serviceImpl.SLMplsRegOp)
          .AddMethod(__Method_SLMplsGet, serviceImpl.SLMplsGet)
          .AddMethod(__Method_SLMplsGetStats, serviceImpl.SLMplsGetStats)
          .AddMethod(__Method_SLMplsLabelBlockOp, serviceImpl.SLMplsLabelBlockOp)
          .AddMethod(__Method_SLMplsLabelBlockGet, serviceImpl.SLMplsLabelBlockGet)
          .AddMethod(__Method_SLMplsIlmOp, serviceImpl.SLMplsIlmOp)
          .AddMethod(__Method_SLMplsIlmGet, serviceImpl.SLMplsIlmGet)
          .AddMethod(__Method_SLMplsIlmOpStream, serviceImpl.SLMplsIlmOpStream)
          .AddMethod(__Method_SLMplsIlmGetStream, serviceImpl.SLMplsIlmGetStream).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, SLMplsOperBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_SLMplsRegOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsRegMsg, global::ServiceLayer.SLMplsRegMsgRsp>(serviceImpl.SLMplsRegOp));
      serviceBinder.AddMethod(__Method_SLMplsGet, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetMsgRsp>(serviceImpl.SLMplsGet));
      serviceBinder.AddMethod(__Method_SLMplsGetStats, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsGetMsg, global::ServiceLayer.SLMplsGetStatsMsgRsp>(serviceImpl.SLMplsGetStats));
      serviceBinder.AddMethod(__Method_SLMplsLabelBlockOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsLabelBlockMsg, global::ServiceLayer.SLMplsLabelBlockMsgRsp>(serviceImpl.SLMplsLabelBlockOp));
      serviceBinder.AddMethod(__Method_SLMplsLabelBlockGet, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsLabelBlockGetMsg, global::ServiceLayer.SLMplsLabelBlockGetMsgRsp>(serviceImpl.SLMplsLabelBlockGet));
      serviceBinder.AddMethod(__Method_SLMplsIlmOp, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp>(serviceImpl.SLMplsIlmOp));
      serviceBinder.AddMethod(__Method_SLMplsIlmGet, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp>(serviceImpl.SLMplsIlmGet));
      serviceBinder.AddMethod(__Method_SLMplsIlmOpStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::ServiceLayer.SLMplsIlmMsg, global::ServiceLayer.SLMplsIlmMsgRsp>(serviceImpl.SLMplsIlmOpStream));
      serviceBinder.AddMethod(__Method_SLMplsIlmGetStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::ServiceLayer.SLMplsIlmGetMsg, global::ServiceLayer.SLMplsIlmGetMsgRsp>(serviceImpl.SLMplsIlmGetStream));
    }

  }
}
#endregion
