// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_common_types.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Registration Operations.
type SLRegOp int32

const (
	// Reserved. 0x0
	SLRegOp_SL_REGOP_RESERVED SLRegOp = 0
	// Register. 0x1
	SLRegOp_SL_REGOP_REGISTER SLRegOp = 1
	// Un-Register. 0x2
	SLRegOp_SL_REGOP_UNREGISTER SLRegOp = 2
	// End Of File. 0x3
	SLRegOp_SL_REGOP_EOF SLRegOp = 3
)

var SLRegOp_name = map[int32]string{
	0: "SL_REGOP_RESERVED",
	1: "SL_REGOP_REGISTER",
	2: "SL_REGOP_UNREGISTER",
	3: "SL_REGOP_EOF",
}
var SLRegOp_value = map[string]int32{
	"SL_REGOP_RESERVED":   0,
	"SL_REGOP_REGISTER":   1,
	"SL_REGOP_UNREGISTER": 2,
	"SL_REGOP_EOF":        3,
}

func (x SLRegOp) String() string {
	return proto.EnumName(SLRegOp_name, int32(x))
}
func (SLRegOp) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

// Object Operations.
type SLObjectOp int32

const (
	// Reserved. 0x0
	SLObjectOp_SL_OBJOP_RESERVED SLObjectOp = 0
	// Add. 0x1
	SLObjectOp_SL_OBJOP_ADD SLObjectOp = 1
	// Update. 0x2
	SLObjectOp_SL_OBJOP_UPDATE SLObjectOp = 2
	// Delete. 0x3
	SLObjectOp_SL_OBJOP_DELETE SLObjectOp = 3
)

var SLObjectOp_name = map[int32]string{
	0: "SL_OBJOP_RESERVED",
	1: "SL_OBJOP_ADD",
	2: "SL_OBJOP_UPDATE",
	3: "SL_OBJOP_DELETE",
}
var SLObjectOp_value = map[string]int32{
	"SL_OBJOP_RESERVED": 0,
	"SL_OBJOP_ADD":      1,
	"SL_OBJOP_UPDATE":   2,
	"SL_OBJOP_DELETE":   3,
}

func (x SLObjectOp) String() string {
	return proto.EnumName(SLObjectOp_name, int32(x))
}
func (SLObjectOp) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

// Notification Operations.
type SLNotifOp int32

const (
	// Reserved. 0x0
	SLNotifOp_SL_NOTIFOP_RESERVED SLNotifOp = 0
	// Enable. 0x1
	SLNotifOp_SL_NOTIFOP_ENABLE SLNotifOp = 1
	// Disable. 0x2
	SLNotifOp_SL_NOTIFOP_DISABLE SLNotifOp = 2
)

var SLNotifOp_name = map[int32]string{
	0: "SL_NOTIFOP_RESERVED",
	1: "SL_NOTIFOP_ENABLE",
	2: "SL_NOTIFOP_DISABLE",
}
var SLNotifOp_value = map[string]int32{
	"SL_NOTIFOP_RESERVED": 0,
	"SL_NOTIFOP_ENABLE":   1,
	"SL_NOTIFOP_DISABLE":  2,
}

func (x SLNotifOp) String() string {
	return proto.EnumName(SLNotifOp_name, int32(x))
}
func (SLNotifOp) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

// Encapsulation Types.
// Specify tunnel encapsulation types: VXLAN or MPLS.
// This will determine the interpretation of some fields VrfName and
// LabelStack in SLRoutePath. It will mandate the presence of certain fields.
type SLEncapType int32

const (
	// Reserved. 0x0
	SLEncapType_SL_ENCAP_RESERVED SLEncapType = 0
	// Vxlan encap. 0x1
	SLEncapType_SL_ENCAP_VXLAN SLEncapType = 1
	// Mpls encap. 0x2
	SLEncapType_SL_ENCAP_MPLS SLEncapType = 2
)

var SLEncapType_name = map[int32]string{
	0: "SL_ENCAP_RESERVED",
	1: "SL_ENCAP_VXLAN",
	2: "SL_ENCAP_MPLS",
}
var SLEncapType_value = map[string]int32{
	"SL_ENCAP_RESERVED": 0,
	"SL_ENCAP_VXLAN":    1,
	"SL_ENCAP_MPLS":     2,
}

func (x SLEncapType) String() string {
	return proto.EnumName(SLEncapType_name, int32(x))
}
func (SLEncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

type SLErrorStatus_SLErrno int32

const (
	// Success, no errors detected. 0x0.
	SLErrorStatus_SL_SUCCESS SLErrorStatus_SLErrno = 0
	// Client is not connected.
	// The client is expected to remain connected after init and version
	// validation, RPC calls can fail with this error code otherwise.
	// Refer to RPC SLGlobalInitNotif. 0x1
	SLErrorStatus_SL_NOT_CONNECTED SLErrorStatus_SLErrno = 1
	// Operation must be retried. 0x2
	SLErrorStatus_SL_EAGAIN SLErrorStatus_SLErrno = 2
	// One or more components does not have sufficient memory. 0x3
	SLErrorStatus_SL_ENOMEM SLErrorStatus_SLErrno = 3
	// Too many outstanding requests. 0x4
	SLErrorStatus_SL_EBUSY SLErrorStatus_SLErrno = 4
	// One or more arguments are invalid. 0x5
	SLErrorStatus_SL_EINVAL SLErrorStatus_SLErrno = 5
	// Unsupported version. 0x6
	SLErrorStatus_SL_UNSUPPORTED_VER SLErrorStatus_SLErrno = 6
	// Not Available. 0x7
	SLErrorStatus_SL_NOT_AVAILABLE SLErrorStatus_SLErrno = 7
	// Stream mode not supported. 0x8
	SLErrorStatus_SL_STREAM_NOT_SUPPORTED SLErrorStatus_SLErrno = 8
	// Operation not supported. 0x9
	SLErrorStatus_SL_ENOTSUP SLErrorStatus_SLErrno = 9
	// One or more objects is errored:
	// Each object must be individually examined. 0xa
	SLErrorStatus_SL_SOME_ERR SLErrorStatus_SLErrno = 10
	// Operation Timed out.
	// The result of the operation is undeterministic (success or fail). 0xb
	SLErrorStatus_SL_TIMEOUT SLErrorStatus_SLErrno = 11
	// Due to some event, the client will no longer receive notification
	// events on this channel. 0xc
	// Such events include:
	// - Notification Session was hijacked by another client.
	SLErrorStatus_SL_NOTIF_TERM SLErrorStatus_SLErrno = 12
	// Offset for INIT errors. 0x500
	SLErrorStatus_SL_INIT_START_OFFSET SLErrorStatus_SLErrno = 1280
	// Success, no errors detected - clear state.
	// This error is returned on the first-ever initialization, or,
	// when a fatal event has occured and all previous state was lost. 0x501
	SLErrorStatus_SL_INIT_STATE_CLEAR SLErrorStatus_SLErrno = 1281
	// Success, no errors detected - previous state is recovered.
	// This error is returned on a client re-initialization with
	// successful recovery of state. Note that any unacknowledged
	// data previously sent should be considered lost. 0x502
	SLErrorStatus_SL_INIT_STATE_READY SLErrorStatus_SLErrno = 1282
	// Server software incompatible with client software version. 0x503
	SLErrorStatus_SL_INIT_UNSUPPORTED_VER SLErrorStatus_SLErrno = 1283
	// Initialization request received while server is not ready. 0x504
	SLErrorStatus_SL_INIT_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 1284
	// Server operational mode change from stream to non-stream
	// or vice-versa failed. 0x505
	SLErrorStatus_SL_INIT_SERVER_MODE_CHANGE_FAILED SLErrorStatus_SLErrno = 1285
	// Offset for VRF errors. 0x1000
	SLErrorStatus_SL_RPC_VRF_START_OFFSET SLErrorStatus_SLErrno = 4096
	// Operation rejected for ALL VRFs due to too many VRF registration
	// messages in the request. 0x1001
	SLErrorStatus_SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS SLErrorStatus_SLErrno = 4097
	// Operation rejected for all VRFs as server is not initialized. 0x1002
	SLErrorStatus_SL_RPC_VRF_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 4098
	// Offset for VRF errors. 0x2000
	SLErrorStatus_SL_VRF_START_OFFSET SLErrorStatus_SLErrno = 8192
	// VRF name in the VRF registration message is too long. 0x2001
	SLErrorStatus_SL_VRF_NAME_TOOLONG SLErrorStatus_SLErrno = 8193
	// VRF not found during a unregister or EOF. 0x2002
	SLErrorStatus_SL_VRF_NOT_FOUND SLErrorStatus_SLErrno = 8194
	// On a VRF registration, Table ID for the VRF is not found. 0x2003
	SLErrorStatus_SL_VRF_NO_TABLE_ID SLErrorStatus_SLErrno = 8195
	// VRF add registration message with invalid administrative distance. 0x2004
	SLErrorStatus_SL_VRF_REG_INVALID_ADMIN_DISTANCE SLErrorStatus_SLErrno = 8196
	// On a VRF registration, Table cannot be added to persistent memory. 0x2005
	SLErrorStatus_SL_VRF_TABLE_ADD_ERR SLErrorStatus_SLErrno = 8197
	// VRF table cannot be registered with RIB. 0x2006
	SLErrorStatus_SL_VRF_TABLE_REGISTRATION_ERR SLErrorStatus_SLErrno = 8198
	// VRF table cannot be unregistered with RIB. 0x2007
	SLErrorStatus_SL_VRF_TABLE_UNREGISTRATION_ERR SLErrorStatus_SLErrno = 8199
	// VRF table RIB EOF operation error. 0x2008
	SLErrorStatus_SL_VRF_TABLE_EOF_ERR SLErrorStatus_SLErrno = 8200
	// VRF registration message does not have a VRF name. 0x2009
	SLErrorStatus_SL_VRF_REG_VRF_NAME_MISSING SLErrorStatus_SLErrno = 8201
	// Offset for Route operation errors. 0x3000
	SLErrorStatus_SL_RPC_ROUTE_START_OFFSET SLErrorStatus_SLErrno = 12288
	// Operation rejected for ALL routes due to too many routes in the
	// request. 0x3001
	SLErrorStatus_SL_RPC_ROUTE_TOO_MANY_ROUTES SLErrorStatus_SLErrno = 12289
	// Operation rejected for ALL routes as the request's VRF name
	// is too long. 0x3002
	SLErrorStatus_SL_RPC_ROUTE_VRF_NAME_TOOLONG SLErrorStatus_SLErrno = 12290
	// Operation rejected for ALL routes as VRF for the given name
	// is not found. 0x3003
	SLErrorStatus_SL_RPC_ROUTE_VRF_NOT_FOUND SLErrorStatus_SLErrno = 12291
	// Operation rejected for ALL routes as VRF's Table ID is not found.
	// 0x3004
	SLErrorStatus_SL_RPC_ROUTE_VRF_NO_TABLE SLErrorStatus_SLErrno = 12292
	// Operation rejected for ALL routes as VRF is not registered with RIB.
	// 0x3005
	SLErrorStatus_SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED SLErrorStatus_SLErrno = 12293
	// Route Operation rejected for ALL objects as VRF name is missing.
	// 0x3006
	SLErrorStatus_SL_RPC_ROUTE_VRF_NAME_MISSING SLErrorStatus_SLErrno = 12294
	// Operation rejected for all routes as the RPC request is
	// not supported for the library's initialization mode. 0x3007
	SLErrorStatus_SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE SLErrorStatus_SLErrno = 12295
	// Operation rejected for all routes as server is not initialized.
	// 0x3008
	SLErrorStatus_SL_RPC_ROUTE_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 12296
	// Operation rejected as the request's SrcProto is too long. 0x3009
	SLErrorStatus_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG SLErrorStatus_SLErrno = 12297
	// Operation rejected as the request's SrcProtoTag is too long. 0x300a
	SLErrorStatus_SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG SLErrorStatus_SLErrno = 12298
	// Offset for route errors. 0x4000
	SLErrorStatus_SL_ROUTE_START_OFFSET SLErrorStatus_SLErrno = 16384
	// Route add operation requested but no paths were provided. 0x4001
	SLErrorStatus_SL_ROUTE_ADD_NO_PATHS SLErrorStatus_SLErrno = 16385
	// Route update operation requested but no paths were provided. 0x4002
	SLErrorStatus_SL_ROUTE_UPDATE_NO_PATHS SLErrorStatus_SLErrno = 16386
	// Route's prefix length is invalid. 0x4003
	SLErrorStatus_SL_ROUTE_INVALID_PREFIX_LEN SLErrorStatus_SLErrno = 16387
	// Route's admininstrative distance is invalid. 0x4004
	SLErrorStatus_SL_ROUTE_INVALID_ADMIN_DISTANCE SLErrorStatus_SLErrno = 16388
	// Route's number of paths exceeds system capabilities. 0x4005
	SLErrorStatus_SL_ROUTE_INVALID_NUM_PATHS SLErrorStatus_SLErrno = 16389
	// Size of IPv6 prefix is invalid. 0x4006
	SLErrorStatus_SL_ROUTE_INVALID_PREFIX_SZ SLErrorStatus_SLErrno = 16390
	// Route's prefix is invalid. 0x4007
	SLErrorStatus_SL_ROUTE_INVALID_PREFIX SLErrorStatus_SLErrno = 16391
	// Route programming failed in RIB as VRF table limit reached. 0x4008
	SLErrorStatus_SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED SLErrorStatus_SLErrno = 16392
	// RIB route programming failed in RIB due to invalid arguments. 0x4009
	SLErrorStatus_SL_ROUTE_ERR_RIB_INVALID_ARGS SLErrorStatus_SLErrno = 16393
	// One or more paths could not be programmed in RIB as VRF
	// table limit reached. 0x400a
	SLErrorStatus_SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT SLErrorStatus_SLErrno = 16394
	// One or more paths could not be programmed in RIB as number of paths
	// reached system limit. 0x400b
	SLErrorStatus_SL_ROUTE_ERR_RIB_TOOMANYPATHS SLErrorStatus_SLErrno = 16395
	// This route already exists in the database. 0x400c
	SLErrorStatus_SL_ROUTE_EEXIST SLErrorStatus_SLErrno = 16396
	// Route prefix has host bits set. 0x400d
	SLErrorStatus_SL_ROUTE_HOST_BITS_SET SLErrorStatus_SLErrno = 16397
	// IPv4 Route prefix is a multicast address. 0x400e
	SLErrorStatus_SL_ROUTE_INVALID_PREFIX_MCAST SLErrorStatus_SLErrno = 16398
	// Route and Path AFI does not match. 0x400f
	SLErrorStatus_SL_ROUTE_PATH_AFI_MISMATCH SLErrorStatus_SLErrno = 16399
	// Number of primary paths exceeds system capabilities. 0x4010
	SLErrorStatus_SL_ROUTE_TOOMANY_PRIMARY_PATHS SLErrorStatus_SLErrno = 16400
	// Number of backup paths exceeds system capabilities. 0x4011
	SLErrorStatus_SL_ROUTE_TOOMANY_BACKUP_PATHS SLErrorStatus_SLErrno = 16401
	// The route database is out of memory. 0x4012
	SLErrorStatus_SL_ROUTE_DB_NOMEM SLErrorStatus_SLErrno = 16402
	// The route has an invalid local label. 0x4013
	SLErrorStatus_SL_ROUTE_INVALID_LOCAL_LABEL SLErrorStatus_SLErrno = 16403
	// Offset for route path errors. 0x5000
	SLErrorStatus_SL_PATH_START_OFFSET SLErrorStatus_SLErrno = 20480
	// VRF table for the path could not be determined. 0x5001
	SLErrorStatus_SL_PATH_NH_NO_TABLE SLErrorStatus_SLErrno = 20481
	// Path next hop interface not found. 0x5002
	SLErrorStatus_SL_PATH_NH_INTF_NOT_FOUND SLErrorStatus_SLErrno = 20482
	// Number of labels in the path exceeds system capabilities. 0x5003
	SLErrorStatus_SL_PATH_INVALID_LABEL_COUNT SLErrorStatus_SLErrno = 20483
	// Path ID assigned to the path falls outside the supported range. 0x5004
	SLErrorStatus_SL_PATH_INVALID_ID SLErrorStatus_SLErrno = 20484
	// Path VRF name exceeds supported length. 0x5005
	SLErrorStatus_SL_PATH_VRF_NAME_TOOLONG SLErrorStatus_SLErrno = 20485
	// Path next hop interface name exceeds supported length. 0x5006
	SLErrorStatus_SL_PATH_NH_INTF_NAME_TOOLONG SLErrorStatus_SLErrno = 20486
	// Size of next hop IPv6 address is invalid. 0x5007
	SLErrorStatus_SL_PATH_NH_INVALID_ADDR_SZ SLErrorStatus_SLErrno = 20487
	// Next hop interface name is missing from path. 0x5008
	SLErrorStatus_SL_PATH_NH_INF_NAME_MISSING SLErrorStatus_SLErrno = 20488
	// Path has an invalid next hop address. 0x5009
	SLErrorStatus_SL_PATH_INVALID_NEXT_HOP_ADDR SLErrorStatus_SLErrno = 20489
	// Number of remote backup addresses in the path exceeds
	// system capabilities. 0x500a
	SLErrorStatus_SL_PATH_INVALID_REMOTE_ADDR_COUNT SLErrorStatus_SLErrno = 20490
	// Size of IPv6 remote backup address is invalid. 0x500b
	SLErrorStatus_SL_PATH_REMOTE_ADDR_INVALID_SZ SLErrorStatus_SLErrno = 20491
	// Route and Path remote backup address AFI does not match. 0x500c
	SLErrorStatus_SL_PATH_REMOTE_ADDR_AFI_MISMATCH SLErrorStatus_SLErrno = 20492
	// Path has an invalid protection bitmap. 0x500d
	SLErrorStatus_SL_PATH_INVALID_PROTECTED_BITMAP SLErrorStatus_SLErrno = 20493
	// Protection bitmap of a backup path refers to a missing path. 0x500e
	SLErrorStatus_SL_PATH_BACKUP_MISSING_PRIMARY_PATH SLErrorStatus_SLErrno = 20494
	// Too many primary paths with same Path ID. 0x500f
	SLErrorStatus_SL_PATH_PRIMARY_ID_REPEATED SLErrorStatus_SLErrno = 20495
	// Too many pure backup paths with same Path ID. 0x5010
	SLErrorStatus_SL_PATH_BACKUP_ID_REPEATED SLErrorStatus_SLErrno = 20496
	// A primary path has too many backup paths. 0x5011
	SLErrorStatus_SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS SLErrorStatus_SLErrno = 20497
	// A primary path has too many labels. 0x5012
	SLErrorStatus_SL_PATH_PRIMARY_TOOMANY_LABELS SLErrorStatus_SLErrno = 20498
	// A primary path has too many remote addresses. 0x5013
	SLErrorStatus_SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR SLErrorStatus_SLErrno = 20499
	// A pure backup remote address is invalid. 0x5014
	SLErrorStatus_SL_PATH_REMOTE_ADDR_INVALID SLErrorStatus_SLErrno = 20500
	// Path has an invalid label. 0x5015
	SLErrorStatus_SL_PATH_INVALID_LABEL SLErrorStatus_SLErrno = 20501
	// Offset for BFD operation errors. 0x6000
	SLErrorStatus_SL_RPC_BFD_START_OFFSET SLErrorStatus_SLErrno = 24576
	// BFD Operation rejected for ALL Sessions as the BFD Session count
	// is beyond supported limit. 0x6001
	SLErrorStatus_SL_RPC_BFD_TOO_MANY_BFD_SESSIONS SLErrorStatus_SLErrno = 24577
	// BFD Operation rejected due to one or many invalid parameters. 0x6002
	SLErrorStatus_SL_RPC_BFD_API_BAD_PARAMETER SLErrorStatus_SLErrno = 24578
	// BFD Operation failed as server is not registered with BFD. 0x6003
	SLErrorStatus_SL_RPC_BFD_API_CLIENT_NOT_REGISTERED SLErrorStatus_SLErrno = 24579
	// BFD Operation failed with internal error. 0x6004
	SLErrorStatus_SL_RPC_BFD_API_INTERNAL_ERROR SLErrorStatus_SLErrno = 24580
	// BFD Operation rejected as server is not initialized. 0x6005
	SLErrorStatus_SL_RPC_BFD_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 24581
	// BFD IPv4 not registered. 0x6006
	SLErrorStatus_SL_RPC_BFD_V4_NOT_REGISTERED SLErrorStatus_SLErrno = 24582
	// BFD IPv6 not registered. 0x6007
	SLErrorStatus_SL_RPC_BFD_V6_NOT_REGISTERED SLErrorStatus_SLErrno = 24583
	// Offset for BFD errors. 0x7000
	SLErrorStatus_SL_BFD_START_OFFSET SLErrorStatus_SLErrno = 28672
	// BFD Session's interface name exceeds supported length. 0x7001
	SLErrorStatus_SL_BFD_INTF_NAME_TOOLONG SLErrorStatus_SLErrno = 28673
	// BFD Session's interface not found. 0x7002
	SLErrorStatus_SL_BFD_INTF_NOT_FOUND SLErrorStatus_SLErrno = 28674
	// BFD Session's tx interval or multiplier are beyond the
	// supported range. 0x7003
	SLErrorStatus_SL_BFD_INVALID_ATTRIBUTE SLErrorStatus_SLErrno = 28675
	// BFD Session's interface name is missing. 0x7004
	SLErrorStatus_SL_BFD_INTF_NAME_MISSING SLErrorStatus_SLErrno = 28676
	// BFD Session's neighbor is mcast address. 0x7005
	SLErrorStatus_SL_BFD_INVALID_NBR_MCAST SLErrorStatus_SLErrno = 28677
	// BFD Session's neighbor address is invalid. 0x7006
	SLErrorStatus_SL_BFD_INVALID_NBR SLErrorStatus_SLErrno = 28678
	// BFD Session's VRF Name is too long. 0x7007
	SLErrorStatus_SL_BFD_VRF_NAME_TOOLONG SLErrorStatus_SLErrno = 28679
	// BFD Session's one or more parameters are invalid.
	// For example, Multihop BFD can not have the interface name set. 0x7008
	SLErrorStatus_SL_BFD_BAD_PARAMETER SLErrorStatus_SLErrno = 28680
	// BFD Session failed with internal error. 0x7009
	SLErrorStatus_SL_BFD_API_INTERNAL_ERROR SLErrorStatus_SLErrno = 28681
	// BFD Session's VRF not found. 0x700a
	SLErrorStatus_SL_BFD_VRF_NOT_FOUND SLErrorStatus_SLErrno = 28682
	// BFD Session's neighbor IPv6 prefix size is invalid. 0x700b
	SLErrorStatus_SL_BFD_INVALID_PREFIX_SIZE SLErrorStatus_SLErrno = 28683
	// BFD Session type invalid. 0x700c
	SLErrorStatus_SL_BFD_INVALID_SESSION_TYPE SLErrorStatus_SLErrno = 28684
	// BFD Session's VRF is Invalid. 0x700d
	SLErrorStatus_SL_BFD_INVALID_VRF SLErrorStatus_SLErrno = 28685
	// BFD Session not found. 0x700e
	SLErrorStatus_SL_BFD_SESSION_NOT_FOUND SLErrorStatus_SLErrno = 28686
	// BFD Session exists. 0x700f
	SLErrorStatus_SL_BFD_SESSION_EXISTS SLErrorStatus_SLErrno = 28687
	// BFD Internal database error. 0x7010
	SLErrorStatus_SL_BFD_INTERNAL_DB_ERROR SLErrorStatus_SLErrno = 28688
	// BFD Recovery error. 0x7011
	SLErrorStatus_SL_BFD_RECOVERY_ERROR SLErrorStatus_SLErrno = 28689
	// Offset for MPLS operation errors. 0x8000
	SLErrorStatus_SL_RPC_MPLS_START_OFFSET SLErrorStatus_SLErrno = 32768
	// Operation rejected for ALL ILMS due to too many ILMS in the
	// request. 0x8001
	SLErrorStatus_SL_RPC_MPLS_ILM_TOO_MANY_ILMS SLErrorStatus_SLErrno = 32769
	// Operation rejected for all ILMs as server is not initialized.
	// 0x0x8002
	SLErrorStatus_SL_RPC_MPLS_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 32770
	// Operation rejected for all ILMs as the RPC request is
	// not supported for the library's initialization mode. 0x8003
	SLErrorStatus_SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE SLErrorStatus_SLErrno = 32771
	// Operation rejected for ALL label blocks due to too many
	// label blocks in the request. 0x8004
	SLErrorStatus_SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS SLErrorStatus_SLErrno = 32772
	// Operation rejected for ALL ILMs as MPLS layer is not registered.
	// 0x8005
	SLErrorStatus_SL_RPC_MPLS_NOT_REGISTERED SLErrorStatus_SLErrno = 32773
	// Offset for MPLS ILM errors. 0x9000
	SLErrorStatus_SL_ILM_ERR_OFFSET SLErrorStatus_SLErrno = 36864
	// MPLS ILM add to service layer failed. 0x9001
	SLErrorStatus_SL_ILM_ADD_FAILED SLErrorStatus_SLErrno = 36865
	// MPLS ILM add to Label Switching Database failed. 0x9002
	SLErrorStatus_SL_ILM_LSD_ADD_FAILED SLErrorStatus_SLErrno = 36866
	// MPLS ILM NHLFE count exceeded max supported number. 0x9003
	SLErrorStatus_SL_ILM_INVALID_NUM_NHLFE SLErrorStatus_SLErrno = 36867
	// MPLS ILM label value out of range. 0x9004
	SLErrorStatus_SL_ILM_INVALID_LABEL SLErrorStatus_SLErrno = 36868
	// MPLS ILM delete from service layer failed. 0x9005
	SLErrorStatus_SL_ILM_DELETE_FAILED SLErrorStatus_SLErrno = 36869
	// MPLS ILM delete from Label Switching Database failed. 0x9006
	SLErrorStatus_SL_ILM_LSD_DELETE_FAILED SLErrorStatus_SLErrno = 36870
	// Number of primary NHLFEs exceeds system capabilities. 0x9007
	SLErrorStatus_SL_ILM_TOOMANY_PRIMARY_NHLFES SLErrorStatus_SLErrno = 36871
	// Number of backup NHLFEs exceeds system capabilities. 0x9008
	SLErrorStatus_SL_ILM_TOOMANY_BACKUP_NHLFES SLErrorStatus_SLErrno = 36872
	// MPLS ILM label alloc failed in Label switching database. 0x9009
	SLErrorStatus_SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED SLErrorStatus_SLErrno = 36873
	// MPLS ILM NHLFE attribute invalid. 0x900a
	SLErrorStatus_SL_ILM_LSD_NHLFE_INVALID_ATTRIB SLErrorStatus_SLErrno = 36874
	// MPLS ILM already exists in the database. 0x900b
	SLErrorStatus_SL_ILM_EEXIST SLErrorStatus_SLErrno = 36875
	// The ILM database is out of memory. 0x900c
	SLErrorStatus_SL_ILM_DB_NOMEM SLErrorStatus_SLErrno = 36876
	// Offset for MPLS NHLFE errors. 0xa000
	SLErrorStatus_SL_NHLFE_ERR_OFFSET SLErrorStatus_SLErrno = 40960
	// MPLS NHLFE vrf table could not be determined. 0xa001
	SLErrorStatus_SL_NHLFE_NH_NO_TABLE SLErrorStatus_SLErrno = 40961
	// Size of next hop IPv6 address is invalid. 0xa002
	SLErrorStatus_SL_NHLFE_NH_INVALID_ADDR_SZ SLErrorStatus_SLErrno = 40962
	// NHLFE has an invalid next hop address. 0xa003
	SLErrorStatus_SL_NHLFE_INVALID_NEXT_HOP_ADDR SLErrorStatus_SLErrno = 40963
	// Path VRF name exceeds supported length. 0xa004
	SLErrorStatus_SL_NHLFE_VRF_NAME_TOOLONG SLErrorStatus_SLErrno = 40964
	// Next hop interface name is missing from path. 0xa005
	SLErrorStatus_SL_NHLFE_NH_INF_NAME_MISSING SLErrorStatus_SLErrno = 40965
	// Interface name exceeds supported length. 0xa006
	SLErrorStatus_SL_NHLFE_NH_INTF_NAME_TOOLONG SLErrorStatus_SLErrno = 40966
	// Number of labels in the path exceeds system capabilities. 0xa007
	SLErrorStatus_SL_NHLFE_INVALID_LABEL_COUNT SLErrorStatus_SLErrno = 40967
	// Path id is invalid in NHLFE. 0xa008
	SLErrorStatus_SL_NHLFE_INVALID_PATH_ID SLErrorStatus_SLErrno = 40968
	// MPLS NHLFE label value out of range. 0xa009
	SLErrorStatus_SL_NHLFE_INVALID_LABEL SLErrorStatus_SLErrno = 40969
	// NHLFE has an invalid protection bitmap. 0xa00a
	SLErrorStatus_SL_NHLFE_INVALID_PROTECTED_BITMAP SLErrorStatus_SLErrno = 40970
	// Number of remote backup addresses in the NHLFE exceeds
	// system capabilities. 0xa00b
	SLErrorStatus_SL_NHLFE_INVALID_REMOTE_ADDR_COUNT SLErrorStatus_SLErrno = 40971
	// Size of IPv6 remote backup address is invalid. 0xa00c
	SLErrorStatus_SL_NHLFE_REMOTE_ADDR_INVALID_SZ SLErrorStatus_SLErrno = 40972
	// A primary NHLFE has too many labels. 0xa00d
	SLErrorStatus_SL_NHLFE_PRIMARY_TOOMANY_LABELS SLErrorStatus_SLErrno = 40973
	// A primary NHLFE has too many remote addresses. 0xa00e
	SLErrorStatus_SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR SLErrorStatus_SLErrno = 40974
	// Too many pure backup NHLFE with same Path ID. 0xa00f
	SLErrorStatus_SL_NHLFE_BACKUP_ID_REPEATED SLErrorStatus_SLErrno = 40975
	// Too many primary NHLFE with same Path ID. 0xa010
	SLErrorStatus_SL_NHLFE_PRIMARY_ID_REPEATED SLErrorStatus_SLErrno = 40976
	// Pure backup NHLFE has a empty protected bitmap. 0xa011
	SLErrorStatus_SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY SLErrorStatus_SLErrno = 40977
	// A primary NHLFE has too many backup paths. 0xa012
	SLErrorStatus_SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS SLErrorStatus_SLErrno = 40978
	// A pure backup remote address is invalid. 0xa013
	SLErrorStatus_SL_NHLFE_REMOTE_ADDR_INVALID SLErrorStatus_SLErrno = 40979
	// Protection bitmap of a backup NHLFE refers to a missing path. 0xa014
	SLErrorStatus_SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH SLErrorStatus_SLErrno = 40980
	// NHLFE next-hop missing. 0xa015
	SLErrorStatus_SL_NHLFE_NEXT_HOP_MISSING SLErrorStatus_SLErrno = 40981
	// Label action specified is invalid. 0xa016
	SLErrorStatus_SL_NHLFE_LABEL_ACTION_INVALID SLErrorStatus_SLErrno = 40982
	// NHLFE next hop interface not found. 0xa017
	SLErrorStatus_SL_NHLFE_NH_INTF_NOT_FOUND SLErrorStatus_SLErrno = 40983
	// MPLS NHLFE operation failed. 0xa018
	SLErrorStatus_SL_NHLFE_OPER_FAILED SLErrorStatus_SLErrno = 40984
	// MPLS NHLFE label action missing. 0xa019
	SLErrorStatus_SL_NHLFE_LABEL_ACTION_MISSING SLErrorStatus_SLErrno = 40985
	// Offset for label block errors. 0xb000
	SLErrorStatus_SL_LABEL_BLK_ERR_OFFSET SLErrorStatus_SLErrno = 45056
	// MPLS label block add from Label Switching Database failed. 0xb001
	SLErrorStatus_SL_LABEL_BLK_LSD_ADD_FAILED SLErrorStatus_SLErrno = 45057
	// MPLS label block delete from Label Switching Database failed. 0xb002
	SLErrorStatus_SL_LABEL_BLK_LSD_DELETE_FAILED SLErrorStatus_SLErrno = 45058
	// MPLS label block not found. 0xb003
	SLErrorStatus_SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND SLErrorStatus_SLErrno = 45059
	// MPLS label block in use. 0xb004
	SLErrorStatus_SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE SLErrorStatus_SLErrno = 45060
	// MPLS label block attribute invalid. 0xb005
	SLErrorStatus_SL_LABEL_BLK_LSD_INVALID_ATTRIB SLErrorStatus_SLErrno = 45061
	// MPLS label block size > max size per block. 0xb006
	SLErrorStatus_SL_LABEL_BLK_INVALID_BLOCK_SIZE SLErrorStatus_SLErrno = 45062
	// MPLS label start_label < min label for platform . 0xb007
	SLErrorStatus_SL_LABEL_BLK_INVALID_START_LABEL SLErrorStatus_SLErrno = 45063
	// MPLS label block already exists in the database. 0xb008
	SLErrorStatus_SL_LABEL_BLK_EEXIST SLErrorStatus_SLErrno = 45064
	// MPLS label database is out of memory. 0xb009
	SLErrorStatus_SL_LABEL_BLK_DB_NOMEM SLErrorStatus_SLErrno = 45065
	// Offset for MPLS registration errors. 0xc000
	SLErrorStatus_SL_MPLS_REG_ERR_OFFSET SLErrorStatus_SLErrno = 49152
	// MPLS registration error. 0xc001
	SLErrorStatus_SL_MPLS_REG_ERR SLErrorStatus_SLErrno = 49153
	// MPLS unregistration error. 0xc002
	SLErrorStatus_SL_MPLS_UNREG_ERR SLErrorStatus_SLErrno = 49154
	// MPLS EOF error. 0xc003
	SLErrorStatus_SL_MPLS_EOF_ERR SLErrorStatus_SLErrno = 49155
	// Offset for Interface operation errors. 0xd000
	SLErrorStatus_SL_RPC_INTF_START_OFFSET SLErrorStatus_SLErrno = 53248
	// Interface Operation rejected for ALL Sessions as the Interface
	// Session count is beyond supported limit. 0xd001
	SLErrorStatus_SL_RPC_INTF_TOO_MANY_INTERFACES SLErrorStatus_SLErrno = 53249
	// Interface Operation rejected as server is not initialized. 0xd002
	SLErrorStatus_SL_RPC_INTF_SERVER_NOT_INITIALIZED SLErrorStatus_SLErrno = 53250
	// Interface Operation failed as server is not registered with
	// interface manager. 0xd003
	SLErrorStatus_SL_RPC_INTF_API_CLIENT_NOT_REGISTERED SLErrorStatus_SLErrno = 53251
	// Offset for Interface object errors. 0xe000
	SLErrorStatus_SL_INTF_START_OFFSET SLErrorStatus_SLErrno = 57344
	// Interface object's interface name missing. 0xe001
	SLErrorStatus_SL_INTF_INTERFACE_NAME_MISSING SLErrorStatus_SLErrno = 57345
	// Interface object's interface name exceeds supported length. 0xe002
	SLErrorStatus_SL_INTF_INTERFACE_NAME_TOOLONG SLErrorStatus_SLErrno = 57346
	// Interface internal registration error. 0xe003
	SLErrorStatus_SL_INTF_INTERFACE_REG_ERR SLErrorStatus_SLErrno = 57347
	// Internal database error. 0xe004
	SLErrorStatus_SL_INTF_INTERNAL_DB_ERROR SLErrorStatus_SLErrno = 57348
	// Interface Recovery error. 0xe005
	SLErrorStatus_SL_INTF_RECOVERY_ERROR SLErrorStatus_SLErrno = 57349
	// Interface exists. 0xe006
	SLErrorStatus_SL_INTF_INTERFACE_EXISTS SLErrorStatus_SLErrno = 57350
	// Interface not found. 0xe007
	SLErrorStatus_SL_INTF_INTERFACE_NOT_FOUND SLErrorStatus_SLErrno = 57351
	// Offset for Internal errors. 0x100000
	SLErrorStatus_SL_INTERNAL_START_OFFSET SLErrorStatus_SLErrno = 1048576
)

var SLErrorStatus_SLErrno_name = map[int32]string{
	0:       "SL_SUCCESS",
	1:       "SL_NOT_CONNECTED",
	2:       "SL_EAGAIN",
	3:       "SL_ENOMEM",
	4:       "SL_EBUSY",
	5:       "SL_EINVAL",
	6:       "SL_UNSUPPORTED_VER",
	7:       "SL_NOT_AVAILABLE",
	8:       "SL_STREAM_NOT_SUPPORTED",
	9:       "SL_ENOTSUP",
	10:      "SL_SOME_ERR",
	11:      "SL_TIMEOUT",
	12:      "SL_NOTIF_TERM",
	1280:    "SL_INIT_START_OFFSET",
	1281:    "SL_INIT_STATE_CLEAR",
	1282:    "SL_INIT_STATE_READY",
	1283:    "SL_INIT_UNSUPPORTED_VER",
	1284:    "SL_INIT_SERVER_NOT_INITIALIZED",
	1285:    "SL_INIT_SERVER_MODE_CHANGE_FAILED",
	4096:    "SL_RPC_VRF_START_OFFSET",
	4097:    "SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS",
	4098:    "SL_RPC_VRF_SERVER_NOT_INITIALIZED",
	8192:    "SL_VRF_START_OFFSET",
	8193:    "SL_VRF_NAME_TOOLONG",
	8194:    "SL_VRF_NOT_FOUND",
	8195:    "SL_VRF_NO_TABLE_ID",
	8196:    "SL_VRF_REG_INVALID_ADMIN_DISTANCE",
	8197:    "SL_VRF_TABLE_ADD_ERR",
	8198:    "SL_VRF_TABLE_REGISTRATION_ERR",
	8199:    "SL_VRF_TABLE_UNREGISTRATION_ERR",
	8200:    "SL_VRF_TABLE_EOF_ERR",
	8201:    "SL_VRF_REG_VRF_NAME_MISSING",
	12288:   "SL_RPC_ROUTE_START_OFFSET",
	12289:   "SL_RPC_ROUTE_TOO_MANY_ROUTES",
	12290:   "SL_RPC_ROUTE_VRF_NAME_TOOLONG",
	12291:   "SL_RPC_ROUTE_VRF_NOT_FOUND",
	12292:   "SL_RPC_ROUTE_VRF_NO_TABLE",
	12293:   "SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED",
	12294:   "SL_RPC_ROUTE_VRF_NAME_MISSING",
	12295:   "SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE",
	12296:   "SL_RPC_ROUTE_SERVER_NOT_INITIALIZED",
	12297:   "SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG",
	12298:   "SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG",
	16384:   "SL_ROUTE_START_OFFSET",
	16385:   "SL_ROUTE_ADD_NO_PATHS",
	16386:   "SL_ROUTE_UPDATE_NO_PATHS",
	16387:   "SL_ROUTE_INVALID_PREFIX_LEN",
	16388:   "SL_ROUTE_INVALID_ADMIN_DISTANCE",
	16389:   "SL_ROUTE_INVALID_NUM_PATHS",
	16390:   "SL_ROUTE_INVALID_PREFIX_SZ",
	16391:   "SL_ROUTE_INVALID_PREFIX",
	16392:   "SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED",
	16393:   "SL_ROUTE_ERR_RIB_INVALID_ARGS",
	16394:   "SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT",
	16395:   "SL_ROUTE_ERR_RIB_TOOMANYPATHS",
	16396:   "SL_ROUTE_EEXIST",
	16397:   "SL_ROUTE_HOST_BITS_SET",
	16398:   "SL_ROUTE_INVALID_PREFIX_MCAST",
	16399:   "SL_ROUTE_PATH_AFI_MISMATCH",
	16400:   "SL_ROUTE_TOOMANY_PRIMARY_PATHS",
	16401:   "SL_ROUTE_TOOMANY_BACKUP_PATHS",
	16402:   "SL_ROUTE_DB_NOMEM",
	16403:   "SL_ROUTE_INVALID_LOCAL_LABEL",
	20480:   "SL_PATH_START_OFFSET",
	20481:   "SL_PATH_NH_NO_TABLE",
	20482:   "SL_PATH_NH_INTF_NOT_FOUND",
	20483:   "SL_PATH_INVALID_LABEL_COUNT",
	20484:   "SL_PATH_INVALID_ID",
	20485:   "SL_PATH_VRF_NAME_TOOLONG",
	20486:   "SL_PATH_NH_INTF_NAME_TOOLONG",
	20487:   "SL_PATH_NH_INVALID_ADDR_SZ",
	20488:   "SL_PATH_NH_INF_NAME_MISSING",
	20489:   "SL_PATH_INVALID_NEXT_HOP_ADDR",
	20490:   "SL_PATH_INVALID_REMOTE_ADDR_COUNT",
	20491:   "SL_PATH_REMOTE_ADDR_INVALID_SZ",
	20492:   "SL_PATH_REMOTE_ADDR_AFI_MISMATCH",
	20493:   "SL_PATH_INVALID_PROTECTED_BITMAP",
	20494:   "SL_PATH_BACKUP_MISSING_PRIMARY_PATH",
	20495:   "SL_PATH_PRIMARY_ID_REPEATED",
	20496:   "SL_PATH_BACKUP_ID_REPEATED",
	20497:   "SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS",
	20498:   "SL_PATH_PRIMARY_TOOMANY_LABELS",
	20499:   "SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR",
	20500:   "SL_PATH_REMOTE_ADDR_INVALID",
	20501:   "SL_PATH_INVALID_LABEL",
	24576:   "SL_RPC_BFD_START_OFFSET",
	24577:   "SL_RPC_BFD_TOO_MANY_BFD_SESSIONS",
	24578:   "SL_RPC_BFD_API_BAD_PARAMETER",
	24579:   "SL_RPC_BFD_API_CLIENT_NOT_REGISTERED",
	24580:   "SL_RPC_BFD_API_INTERNAL_ERROR",
	24581:   "SL_RPC_BFD_SERVER_NOT_INITIALIZED",
	24582:   "SL_RPC_BFD_V4_NOT_REGISTERED",
	24583:   "SL_RPC_BFD_V6_NOT_REGISTERED",
	28672:   "SL_BFD_START_OFFSET",
	28673:   "SL_BFD_INTF_NAME_TOOLONG",
	28674:   "SL_BFD_INTF_NOT_FOUND",
	28675:   "SL_BFD_INVALID_ATTRIBUTE",
	28676:   "SL_BFD_INTF_NAME_MISSING",
	28677:   "SL_BFD_INVALID_NBR_MCAST",
	28678:   "SL_BFD_INVALID_NBR",
	28679:   "SL_BFD_VRF_NAME_TOOLONG",
	28680:   "SL_BFD_BAD_PARAMETER",
	28681:   "SL_BFD_API_INTERNAL_ERROR",
	28682:   "SL_BFD_VRF_NOT_FOUND",
	28683:   "SL_BFD_INVALID_PREFIX_SIZE",
	28684:   "SL_BFD_INVALID_SESSION_TYPE",
	28685:   "SL_BFD_INVALID_VRF",
	28686:   "SL_BFD_SESSION_NOT_FOUND",
	28687:   "SL_BFD_SESSION_EXISTS",
	28688:   "SL_BFD_INTERNAL_DB_ERROR",
	28689:   "SL_BFD_RECOVERY_ERROR",
	32768:   "SL_RPC_MPLS_START_OFFSET",
	32769:   "SL_RPC_MPLS_ILM_TOO_MANY_ILMS",
	32770:   "SL_RPC_MPLS_SERVER_NOT_INITIALIZED",
	32771:   "SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE",
	32772:   "SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS",
	32773:   "SL_RPC_MPLS_NOT_REGISTERED",
	36864:   "SL_ILM_ERR_OFFSET",
	36865:   "SL_ILM_ADD_FAILED",
	36866:   "SL_ILM_LSD_ADD_FAILED",
	36867:   "SL_ILM_INVALID_NUM_NHLFE",
	36868:   "SL_ILM_INVALID_LABEL",
	36869:   "SL_ILM_DELETE_FAILED",
	36870:   "SL_ILM_LSD_DELETE_FAILED",
	36871:   "SL_ILM_TOOMANY_PRIMARY_NHLFES",
	36872:   "SL_ILM_TOOMANY_BACKUP_NHLFES",
	36873:   "SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED",
	36874:   "SL_ILM_LSD_NHLFE_INVALID_ATTRIB",
	36875:   "SL_ILM_EEXIST",
	36876:   "SL_ILM_DB_NOMEM",
	40960:   "SL_NHLFE_ERR_OFFSET",
	40961:   "SL_NHLFE_NH_NO_TABLE",
	40962:   "SL_NHLFE_NH_INVALID_ADDR_SZ",
	40963:   "SL_NHLFE_INVALID_NEXT_HOP_ADDR",
	40964:   "SL_NHLFE_VRF_NAME_TOOLONG",
	40965:   "SL_NHLFE_NH_INF_NAME_MISSING",
	40966:   "SL_NHLFE_NH_INTF_NAME_TOOLONG",
	40967:   "SL_NHLFE_INVALID_LABEL_COUNT",
	40968:   "SL_NHLFE_INVALID_PATH_ID",
	40969:   "SL_NHLFE_INVALID_LABEL",
	40970:   "SL_NHLFE_INVALID_PROTECTED_BITMAP",
	40971:   "SL_NHLFE_INVALID_REMOTE_ADDR_COUNT",
	40972:   "SL_NHLFE_REMOTE_ADDR_INVALID_SZ",
	40973:   "SL_NHLFE_PRIMARY_TOOMANY_LABELS",
	40974:   "SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR",
	40975:   "SL_NHLFE_BACKUP_ID_REPEATED",
	40976:   "SL_NHLFE_PRIMARY_ID_REPEATED",
	40977:   "SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY",
	40978:   "SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS",
	40979:   "SL_NHLFE_REMOTE_ADDR_INVALID",
	40980:   "SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH",
	40981:   "SL_NHLFE_NEXT_HOP_MISSING",
	40982:   "SL_NHLFE_LABEL_ACTION_INVALID",
	40983:   "SL_NHLFE_NH_INTF_NOT_FOUND",
	40984:   "SL_NHLFE_OPER_FAILED",
	40985:   "SL_NHLFE_LABEL_ACTION_MISSING",
	45056:   "SL_LABEL_BLK_ERR_OFFSET",
	45057:   "SL_LABEL_BLK_LSD_ADD_FAILED",
	45058:   "SL_LABEL_BLK_LSD_DELETE_FAILED",
	45059:   "SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND",
	45060:   "SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE",
	45061:   "SL_LABEL_BLK_LSD_INVALID_ATTRIB",
	45062:   "SL_LABEL_BLK_INVALID_BLOCK_SIZE",
	45063:   "SL_LABEL_BLK_INVALID_START_LABEL",
	45064:   "SL_LABEL_BLK_EEXIST",
	45065:   "SL_LABEL_BLK_DB_NOMEM",
	49152:   "SL_MPLS_REG_ERR_OFFSET",
	49153:   "SL_MPLS_REG_ERR",
	49154:   "SL_MPLS_UNREG_ERR",
	49155:   "SL_MPLS_EOF_ERR",
	53248:   "SL_RPC_INTF_START_OFFSET",
	53249:   "SL_RPC_INTF_TOO_MANY_INTERFACES",
	53250:   "SL_RPC_INTF_SERVER_NOT_INITIALIZED",
	53251:   "SL_RPC_INTF_API_CLIENT_NOT_REGISTERED",
	57344:   "SL_INTF_START_OFFSET",
	57345:   "SL_INTF_INTERFACE_NAME_MISSING",
	57346:   "SL_INTF_INTERFACE_NAME_TOOLONG",
	57347:   "SL_INTF_INTERFACE_REG_ERR",
	57348:   "SL_INTF_INTERNAL_DB_ERROR",
	57349:   "SL_INTF_RECOVERY_ERROR",
	57350:   "SL_INTF_INTERFACE_EXISTS",
	57351:   "SL_INTF_INTERFACE_NOT_FOUND",
	1048576: "SL_INTERNAL_START_OFFSET",
}
var SLErrorStatus_SLErrno_value = map[string]int32{
	"SL_SUCCESS":                                0,
	"SL_NOT_CONNECTED":                          1,
	"SL_EAGAIN":                                 2,
	"SL_ENOMEM":                                 3,
	"SL_EBUSY":                                  4,
	"SL_EINVAL":                                 5,
	"SL_UNSUPPORTED_VER":                        6,
	"SL_NOT_AVAILABLE":                          7,
	"SL_STREAM_NOT_SUPPORTED":                   8,
	"SL_ENOTSUP":                                9,
	"SL_SOME_ERR":                               10,
	"SL_TIMEOUT":                                11,
	"SL_NOTIF_TERM":                             12,
	"SL_INIT_START_OFFSET":                      1280,
	"SL_INIT_STATE_CLEAR":                       1281,
	"SL_INIT_STATE_READY":                       1282,
	"SL_INIT_UNSUPPORTED_VER":                   1283,
	"SL_INIT_SERVER_NOT_INITIALIZED":            1284,
	"SL_INIT_SERVER_MODE_CHANGE_FAILED":         1285,
	"SL_RPC_VRF_START_OFFSET":                   4096,
	"SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS":          4097,
	"SL_RPC_VRF_SERVER_NOT_INITIALIZED":         4098,
	"SL_VRF_START_OFFSET":                       8192,
	"SL_VRF_NAME_TOOLONG":                       8193,
	"SL_VRF_NOT_FOUND":                          8194,
	"SL_VRF_NO_TABLE_ID":                        8195,
	"SL_VRF_REG_INVALID_ADMIN_DISTANCE":         8196,
	"SL_VRF_TABLE_ADD_ERR":                      8197,
	"SL_VRF_TABLE_REGISTRATION_ERR":             8198,
	"SL_VRF_TABLE_UNREGISTRATION_ERR":           8199,
	"SL_VRF_TABLE_EOF_ERR":                      8200,
	"SL_VRF_REG_VRF_NAME_MISSING":               8201,
	"SL_RPC_ROUTE_START_OFFSET":                 12288,
	"SL_RPC_ROUTE_TOO_MANY_ROUTES":              12289,
	"SL_RPC_ROUTE_VRF_NAME_TOOLONG":             12290,
	"SL_RPC_ROUTE_VRF_NOT_FOUND":                12291,
	"SL_RPC_ROUTE_VRF_NO_TABLE":                 12292,
	"SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED":     12293,
	"SL_RPC_ROUTE_VRF_NAME_MISSING":             12294,
	"SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE":       12295,
	"SL_RPC_ROUTE_SERVER_NOT_INITIALIZED":       12296,
	"SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG":      12297,
	"SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG":  12298,
	"SL_ROUTE_START_OFFSET":                     16384,
	"SL_ROUTE_ADD_NO_PATHS":                     16385,
	"SL_ROUTE_UPDATE_NO_PATHS":                  16386,
	"SL_ROUTE_INVALID_PREFIX_LEN":               16387,
	"SL_ROUTE_INVALID_ADMIN_DISTANCE":           16388,
	"SL_ROUTE_INVALID_NUM_PATHS":                16389,
	"SL_ROUTE_INVALID_PREFIX_SZ":                16390,
	"SL_ROUTE_INVALID_PREFIX":                   16391,
	"SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED":      16392,
	"SL_ROUTE_ERR_RIB_INVALID_ARGS":             16393,
	"SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT":         16394,
	"SL_ROUTE_ERR_RIB_TOOMANYPATHS":             16395,
	"SL_ROUTE_EEXIST":                           16396,
	"SL_ROUTE_HOST_BITS_SET":                    16397,
	"SL_ROUTE_INVALID_PREFIX_MCAST":             16398,
	"SL_ROUTE_PATH_AFI_MISMATCH":                16399,
	"SL_ROUTE_TOOMANY_PRIMARY_PATHS":            16400,
	"SL_ROUTE_TOOMANY_BACKUP_PATHS":             16401,
	"SL_ROUTE_DB_NOMEM":                         16402,
	"SL_ROUTE_INVALID_LOCAL_LABEL":              16403,
	"SL_PATH_START_OFFSET":                      20480,
	"SL_PATH_NH_NO_TABLE":                       20481,
	"SL_PATH_NH_INTF_NOT_FOUND":                 20482,
	"SL_PATH_INVALID_LABEL_COUNT":               20483,
	"SL_PATH_INVALID_ID":                        20484,
	"SL_PATH_VRF_NAME_TOOLONG":                  20485,
	"SL_PATH_NH_INTF_NAME_TOOLONG":              20486,
	"SL_PATH_NH_INVALID_ADDR_SZ":                20487,
	"SL_PATH_NH_INF_NAME_MISSING":               20488,
	"SL_PATH_INVALID_NEXT_HOP_ADDR":             20489,
	"SL_PATH_INVALID_REMOTE_ADDR_COUNT":         20490,
	"SL_PATH_REMOTE_ADDR_INVALID_SZ":            20491,
	"SL_PATH_REMOTE_ADDR_AFI_MISMATCH":          20492,
	"SL_PATH_INVALID_PROTECTED_BITMAP":          20493,
	"SL_PATH_BACKUP_MISSING_PRIMARY_PATH":       20494,
	"SL_PATH_PRIMARY_ID_REPEATED":               20495,
	"SL_PATH_BACKUP_ID_REPEATED":                20496,
	"SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS":      20497,
	"SL_PATH_PRIMARY_TOOMANY_LABELS":            20498,
	"SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR":       20499,
	"SL_PATH_REMOTE_ADDR_INVALID":               20500,
	"SL_PATH_INVALID_LABEL":                     20501,
	"SL_RPC_BFD_START_OFFSET":                   24576,
	"SL_RPC_BFD_TOO_MANY_BFD_SESSIONS":          24577,
	"SL_RPC_BFD_API_BAD_PARAMETER":              24578,
	"SL_RPC_BFD_API_CLIENT_NOT_REGISTERED":      24579,
	"SL_RPC_BFD_API_INTERNAL_ERROR":             24580,
	"SL_RPC_BFD_SERVER_NOT_INITIALIZED":         24581,
	"SL_RPC_BFD_V4_NOT_REGISTERED":              24582,
	"SL_RPC_BFD_V6_NOT_REGISTERED":              24583,
	"SL_BFD_START_OFFSET":                       28672,
	"SL_BFD_INTF_NAME_TOOLONG":                  28673,
	"SL_BFD_INTF_NOT_FOUND":                     28674,
	"SL_BFD_INVALID_ATTRIBUTE":                  28675,
	"SL_BFD_INTF_NAME_MISSING":                  28676,
	"SL_BFD_INVALID_NBR_MCAST":                  28677,
	"SL_BFD_INVALID_NBR":                        28678,
	"SL_BFD_VRF_NAME_TOOLONG":                   28679,
	"SL_BFD_BAD_PARAMETER":                      28680,
	"SL_BFD_API_INTERNAL_ERROR":                 28681,
	"SL_BFD_VRF_NOT_FOUND":                      28682,
	"SL_BFD_INVALID_PREFIX_SIZE":                28683,
	"SL_BFD_INVALID_SESSION_TYPE":               28684,
	"SL_BFD_INVALID_VRF":                        28685,
	"SL_BFD_SESSION_NOT_FOUND":                  28686,
	"SL_BFD_SESSION_EXISTS":                     28687,
	"SL_BFD_INTERNAL_DB_ERROR":                  28688,
	"SL_BFD_RECOVERY_ERROR":                     28689,
	"SL_RPC_MPLS_START_OFFSET":                  32768,
	"SL_RPC_MPLS_ILM_TOO_MANY_ILMS":             32769,
	"SL_RPC_MPLS_SERVER_NOT_INITIALIZED":        32770,
	"SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE":        32771,
	"SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS": 32772,
	"SL_RPC_MPLS_NOT_REGISTERED":                32773,
	"SL_ILM_ERR_OFFSET":                         36864,
	"SL_ILM_ADD_FAILED":                         36865,
	"SL_ILM_LSD_ADD_FAILED":                     36866,
	"SL_ILM_INVALID_NUM_NHLFE":                  36867,
	"SL_ILM_INVALID_LABEL":                      36868,
	"SL_ILM_DELETE_FAILED":                      36869,
	"SL_ILM_LSD_DELETE_FAILED":                  36870,
	"SL_ILM_TOOMANY_PRIMARY_NHLFES":             36871,
	"SL_ILM_TOOMANY_BACKUP_NHLFES":              36872,
	"SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED":         36873,
	"SL_ILM_LSD_NHLFE_INVALID_ATTRIB":           36874,
	"SL_ILM_EEXIST":                             36875,
	"SL_ILM_DB_NOMEM":                           36876,
	"SL_NHLFE_ERR_OFFSET":                       40960,
	"SL_NHLFE_NH_NO_TABLE":                      40961,
	"SL_NHLFE_NH_INVALID_ADDR_SZ":               40962,
	"SL_NHLFE_INVALID_NEXT_HOP_ADDR":            40963,
	"SL_NHLFE_VRF_NAME_TOOLONG":                 40964,
	"SL_NHLFE_NH_INF_NAME_MISSING":              40965,
	"SL_NHLFE_NH_INTF_NAME_TOOLONG":             40966,
	"SL_NHLFE_INVALID_LABEL_COUNT":              40967,
	"SL_NHLFE_INVALID_PATH_ID":                  40968,
	"SL_NHLFE_INVALID_LABEL":                    40969,
	"SL_NHLFE_INVALID_PROTECTED_BITMAP":         40970,
	"SL_NHLFE_INVALID_REMOTE_ADDR_COUNT":        40971,
	"SL_NHLFE_REMOTE_ADDR_INVALID_SZ":           40972,
	"SL_NHLFE_PRIMARY_TOOMANY_LABELS":           40973,
	"SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR":      40974,
	"SL_NHLFE_BACKUP_ID_REPEATED":               40975,
	"SL_NHLFE_PRIMARY_ID_REPEATED":              40976,
	"SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY":    40977,
	"SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS":     40978,
	"SL_NHLFE_REMOTE_ADDR_INVALID":              40979,
	"SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH":      40980,
	"SL_NHLFE_NEXT_HOP_MISSING":                 40981,
	"SL_NHLFE_LABEL_ACTION_INVALID":             40982,
	"SL_NHLFE_NH_INTF_NOT_FOUND":                40983,
	"SL_NHLFE_OPER_FAILED":                      40984,
	"SL_NHLFE_LABEL_ACTION_MISSING":             40985,
	"SL_LABEL_BLK_ERR_OFFSET":                   45056,
	"SL_LABEL_BLK_LSD_ADD_FAILED":               45057,
	"SL_LABEL_BLK_LSD_DELETE_FAILED":            45058,
	"SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND":      45059,
	"SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE":         45060,
	"SL_LABEL_BLK_LSD_INVALID_ATTRIB":           45061,
	"SL_LABEL_BLK_INVALID_BLOCK_SIZE":           45062,
	"SL_LABEL_BLK_INVALID_START_LABEL":          45063,
	"SL_LABEL_BLK_EEXIST":                       45064,
	"SL_LABEL_BLK_DB_NOMEM":                     45065,
	"SL_MPLS_REG_ERR_OFFSET":                    49152,
	"SL_MPLS_REG_ERR":                           49153,
	"SL_MPLS_UNREG_ERR":                         49154,
	"SL_MPLS_EOF_ERR":                           49155,
	"SL_RPC_INTF_START_OFFSET":                  53248,
	"SL_RPC_INTF_TOO_MANY_INTERFACES":           53249,
	"SL_RPC_INTF_SERVER_NOT_INITIALIZED":        53250,
	"SL_RPC_INTF_API_CLIENT_NOT_REGISTERED":     53251,
	"SL_INTF_START_OFFSET":                      57344,
	"SL_INTF_INTERFACE_NAME_MISSING":            57345,
	"SL_INTF_INTERFACE_NAME_TOOLONG":            57346,
	"SL_INTF_INTERFACE_REG_ERR":                 57347,
	"SL_INTF_INTERNAL_DB_ERROR":                 57348,
	"SL_INTF_RECOVERY_ERROR":                    57349,
	"SL_INTF_INTERFACE_EXISTS":                  57350,
	"SL_INTF_INTERFACE_NOT_FOUND":               57351,
	"SL_INTERNAL_START_OFFSET":                  1048576,
}

func (x SLErrorStatus_SLErrno) String() string {
	return proto.EnumName(SLErrorStatus_SLErrno_name, int32(x))
}
func (SLErrorStatus_SLErrno) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

// Status codes, including errors and success codes.
// All service layer errors are defined below.
type SLErrorStatus struct {
	Status SLErrorStatus_SLErrno `protobuf:"varint,1,opt,name=Status,enum=service_layer.SLErrorStatus_SLErrno" json:"Status,omitempty"`
}

func (m *SLErrorStatus) Reset()                    { *m = SLErrorStatus{} }
func (m *SLErrorStatus) String() string            { return proto.CompactTextString(m) }
func (*SLErrorStatus) ProtoMessage()               {}
func (*SLErrorStatus) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *SLErrorStatus) GetStatus() SLErrorStatus_SLErrno {
	if m != nil {
		return m.Status
	}
	return SLErrorStatus_SL_SUCCESS
}

// Interface info.
type SLInterface struct {
	// One of Interface name or handle
	//
	// Types that are valid to be assigned to Interface:
	//	*SLInterface_Name
	//	*SLInterface_Handle
	Interface isSLInterface_Interface `protobuf_oneof:"Interface"`
}

func (m *SLInterface) Reset()                    { *m = SLInterface{} }
func (m *SLInterface) String() string            { return proto.CompactTextString(m) }
func (*SLInterface) ProtoMessage()               {}
func (*SLInterface) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

type isSLInterface_Interface interface {
	isSLInterface_Interface()
}

type SLInterface_Name struct {
	Name string `protobuf:"bytes,1,opt,name=Name,oneof"`
}
type SLInterface_Handle struct {
	Handle uint32 `protobuf:"varint,2,opt,name=Handle,oneof"`
}

func (*SLInterface_Name) isSLInterface_Interface()   {}
func (*SLInterface_Handle) isSLInterface_Interface() {}

func (m *SLInterface) GetInterface() isSLInterface_Interface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *SLInterface) GetName() string {
	if x, ok := m.GetInterface().(*SLInterface_Name); ok {
		return x.Name
	}
	return ""
}

func (m *SLInterface) GetHandle() uint32 {
	if x, ok := m.GetInterface().(*SLInterface_Handle); ok {
		return x.Handle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLInterface) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLInterface_OneofMarshaler, _SLInterface_OneofUnmarshaler, _SLInterface_OneofSizer, []interface{}{
		(*SLInterface_Name)(nil),
		(*SLInterface_Handle)(nil),
	}
}

func _SLInterface_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLInterface)
	// Interface
	switch x := m.Interface.(type) {
	case *SLInterface_Name:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case *SLInterface_Handle:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Handle))
	case nil:
	default:
		return fmt.Errorf("SLInterface.Interface has unexpected type %T", x)
	}
	return nil
}

func _SLInterface_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLInterface)
	switch tag {
	case 1: // Interface.Name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Interface = &SLInterface_Name{x}
		return true, err
	case 2: // Interface.Handle
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Interface = &SLInterface_Handle{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _SLInterface_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLInterface)
	// Interface
	switch x := m.Interface.(type) {
	case *SLInterface_Name:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *SLInterface_Handle:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Handle))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// One of IPv4 or IPv6 addresses.
type SLIpAddress struct {
	// One of IPv4 or IPv6 address
	//
	// Types that are valid to be assigned to Address:
	//	*SLIpAddress_V4Address
	//	*SLIpAddress_V6Address
	Address isSLIpAddress_Address `protobuf_oneof:"Address"`
}

func (m *SLIpAddress) Reset()                    { *m = SLIpAddress{} }
func (m *SLIpAddress) String() string            { return proto.CompactTextString(m) }
func (*SLIpAddress) ProtoMessage()               {}
func (*SLIpAddress) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

type isSLIpAddress_Address interface {
	isSLIpAddress_Address()
}

type SLIpAddress_V4Address struct {
	V4Address uint32 `protobuf:"varint,1,opt,name=V4Address,oneof"`
}
type SLIpAddress_V6Address struct {
	V6Address []byte `protobuf:"bytes,2,opt,name=V6Address,proto3,oneof"`
}

func (*SLIpAddress_V4Address) isSLIpAddress_Address() {}
func (*SLIpAddress_V6Address) isSLIpAddress_Address() {}

func (m *SLIpAddress) GetAddress() isSLIpAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *SLIpAddress) GetV4Address() uint32 {
	if x, ok := m.GetAddress().(*SLIpAddress_V4Address); ok {
		return x.V4Address
	}
	return 0
}

func (m *SLIpAddress) GetV6Address() []byte {
	if x, ok := m.GetAddress().(*SLIpAddress_V6Address); ok {
		return x.V6Address
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLIpAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLIpAddress_OneofMarshaler, _SLIpAddress_OneofUnmarshaler, _SLIpAddress_OneofSizer, []interface{}{
		(*SLIpAddress_V4Address)(nil),
		(*SLIpAddress_V6Address)(nil),
	}
}

func _SLIpAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLIpAddress)
	// Address
	switch x := m.Address.(type) {
	case *SLIpAddress_V4Address:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.V4Address))
	case *SLIpAddress_V6Address:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.V6Address)
	case nil:
	default:
		return fmt.Errorf("SLIpAddress.Address has unexpected type %T", x)
	}
	return nil
}

func _SLIpAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLIpAddress)
	switch tag {
	case 1: // Address.V4Address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Address = &SLIpAddress_V4Address{uint32(x)}
		return true, err
	case 2: // Address.V6Address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Address = &SLIpAddress_V6Address{x}
		return true, err
	default:
		return false, nil
	}
}

func _SLIpAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLIpAddress)
	// Address
	switch x := m.Address.(type) {
	case *SLIpAddress_V4Address:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.V4Address))
	case *SLIpAddress_V6Address:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.V6Address)))
		n += len(x.V6Address)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SLErrorStatus)(nil), "service_layer.SLErrorStatus")
	proto.RegisterType((*SLInterface)(nil), "service_layer.SLInterface")
	proto.RegisterType((*SLIpAddress)(nil), "service_layer.SLIpAddress")
	proto.RegisterEnum("service_layer.SLRegOp", SLRegOp_name, SLRegOp_value)
	proto.RegisterEnum("service_layer.SLObjectOp", SLObjectOp_name, SLObjectOp_value)
	proto.RegisterEnum("service_layer.SLNotifOp", SLNotifOp_name, SLNotifOp_value)
	proto.RegisterEnum("service_layer.SLEncapType", SLEncapType_name, SLEncapType_value)
	proto.RegisterEnum("service_layer.SLErrorStatus_SLErrno", SLErrorStatus_SLErrno_name, SLErrorStatus_SLErrno_value)
}

func init() { proto.RegisterFile("sl_common_types.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 2314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x59, 0x5b, 0x53, 0x1b, 0x47,
	0x16, 0x36, 0x22, 0x6b, 0x87, 0xf6, 0x25, 0x9d, 0xb1, 0x1d, 0x93, 0xc4, 0xb1, 0x31, 0xbe, 0xac,
	0x4d, 0x76, 0x9d, 0xad, 0xdd, 0x54, 0x9e, 0xf6, 0x41, 0x23, 0xa9, 0x05, 0x13, 0xcf, 0x45, 0x35,
	0x33, 0xa2, 0x20, 0x2f, 0x03, 0xc6, 0xca, 0x56, 0xb6, 0x6c, 0xa0, 0x80, 0xdd, 0x2a, 0xbf, 0x19,
	0xc4, 0x1d, 0x7c, 0x4f, 0xf6, 0xf2, 0xa6, 0x9f, 0xa2, 0xda, 0x5f, 0xa2, 0x9f, 0xb2, 0xa7, 0x2f,
	0xa7, 0x35, 0xdd, 0x33, 0xe2, 0x8d, 0xe9, 0xef, 0xeb, 0x73, 0xba, 0xcf, 0x5d, 0x0d, 0xb9, 0xbe,
	0xf9, 0x3c, 0x5b, 0x59, 0x7b, 0xf1, 0x62, 0x6d, 0x35, 0xdb, 0x7a, 0xb9, 0xde, 0xd9, 0x7c, 0xbc,
	0xbe, 0xb1, 0xb6, 0xb5, 0xe6, 0x5c, 0xde, 0xec, 0x6c, 0xfc, 0xf3, 0x97, 0x95, 0x4e, 0xf6, 0x7c,
	0xf9, 0x65, 0x67, 0x63, 0xfa, 0xc3, 0x9f, 0xc8, 0xe5, 0xc4, 0x67, 0x1b, 0x1b, 0x6b, 0x1b, 0xc9,
	0xd6, 0xf2, 0xd6, 0x3f, 0x36, 0x9d, 0xbf, 0x92, 0xf3, 0xf2, 0xaf, 0xc9, 0xb1, 0xa9, 0xb1, 0x87,
	0x57, 0xfe, 0x7c, 0xef, 0xb1, 0xb1, 0xe3, 0xb1, 0xc1, 0x96, 0x5f, 0xab, 0x6b, 0xb1, 0xda, 0x33,
	0xfd, 0xbf, 0xef, 0xc8, 0x05, 0xb5, 0xe6, 0x5c, 0x21, 0x24, 0xf1, 0xb3, 0xa4, 0x5d, 0xaf, 0xb3,
	0x24, 0xa1, 0xe7, 0x9c, 0x6b, 0x84, 0xc2, 0x77, 0x18, 0xa5, 0x59, 0x3d, 0x0a, 0x43, 0x56, 0x4f,
	0x59, 0x83, 0x8e, 0x39, 0x97, 0xc9, 0x04, 0xac, 0x32, 0x77, 0xd6, 0xf5, 0x42, 0x5a, 0xc1, 0xcf,
	0x30, 0x0a, 0x58, 0x40, 0xc7, 0x9d, 0x4b, 0xe4, 0x53, 0xfe, 0x59, 0x6b, 0x27, 0x8b, 0xf4, 0x13,
	0x04, 0xbd, 0x70, 0xde, 0xf5, 0xe9, 0xef, 0x9c, 0x2f, 0x88, 0x03, 0x9f, 0xed, 0x30, 0x69, 0xb7,
	0x5a, 0x51, 0x0c, 0xe2, 0xb2, 0x79, 0x16, 0xd3, 0xf3, 0x39, 0x45, 0xee, 0xbc, 0xeb, 0xf9, 0x6e,
	0xcd, 0x67, 0xf4, 0x82, 0xf3, 0x35, 0xb9, 0xc1, 0x8f, 0x93, 0xc6, 0xcc, 0x0d, 0x04, 0xa8, 0xb7,
	0xd1, 0x4f, 0xd5, 0x59, 0x41, 0x6d, 0x0a, 0xab, 0x74, 0xc2, 0xf9, 0x8c, 0x5c, 0xe4, 0x64, 0x38,
	0x45, 0xc6, 0xe2, 0x98, 0x12, 0x45, 0x48, 0xbd, 0x80, 0x45, 0xed, 0x94, 0x5e, 0x74, 0x3e, 0xe7,
	0x76, 0xe3, 0x62, 0xbc, 0x66, 0x96, 0xb2, 0x38, 0xa0, 0x97, 0x9c, 0x2f, 0xc9, 0x35, 0x58, 0xf2,
	0x42, 0x0f, 0x44, 0xa7, 0x6e, 0x9c, 0x66, 0x51, 0xb3, 0x99, 0xb0, 0x94, 0xbe, 0x22, 0xce, 0x24,
	0xb9, 0x9a, 0x83, 0x52, 0x96, 0xd5, 0x7d, 0xe6, 0xc6, 0x74, 0xbb, 0x04, 0x81, 0xe3, 0x35, 0x16,
	0xe9, 0x0e, 0x71, 0x6e, 0x8a, 0xf3, 0x0a, 0xc4, 0xbe, 0x62, 0x97, 0x38, 0x77, 0xc9, 0x2d, 0xbd,
	0x8f, 0xc5, 0xb0, 0x28, 0xae, 0xc4, 0xbf, 0x3d, 0xd7, 0xf7, 0x7e, 0x82, 0x4b, 0xed, 0x12, 0xe7,
	0x01, 0xb9, 0x63, 0x91, 0x82, 0xa8, 0x01, 0xca, 0xe7, 0xdc, 0x70, 0x96, 0x65, 0x4d, 0xb0, 0x0d,
	0xf0, 0xf6, 0x50, 0x55, 0xdc, 0xaa, 0x67, 0xf3, 0x71, 0xd3, 0x3a, 0xfc, 0x94, 0x73, 0x9f, 0x4c,
	0xe5, 0xd0, 0x34, 0x8a, 0xb2, 0xc0, 0x0d, 0x17, 0xc5, 0x47, 0xcc, 0x66, 0xb3, 0x20, 0x99, 0x4d,
	0xe8, 0xf6, 0x94, 0x52, 0xa6, 0x85, 0x94, 0x1f, 0x6a, 0x67, 0x4a, 0xdd, 0xb8, 0xa8, 0xa8, 0x9a,
	0x43, 0x42, 0x17, 0x0c, 0x0f, 0x9a, 0xfc, 0x28, 0x9c, 0xa5, 0xdb, 0x55, 0xe7, 0xba, 0xf0, 0xa8,
	0x40, 0x40, 0x60, 0x33, 0x6a, 0x87, 0x20, 0xaa, 0xea, 0xdc, 0x10, 0x01, 0x20, 0x97, 0xb3, 0x94,
	0xfb, 0x39, 0xf3, 0x1a, 0xb4, 0x5b, 0x55, 0x67, 0xc1, 0x13, 0x8a, 0x78, 0xf1, 0x1a, 0x99, 0xdb,
	0x08, 0xbc, 0x30, 0x6b, 0x78, 0xa0, 0x37, 0xac, 0x33, 0xba, 0x5b, 0x55, 0x2e, 0x13, 0xd7, 0x12,
	0xbb, 0xdd, 0x46, 0x43, 0xf8, 0x7b, 0xaf, 0xea, 0x4c, 0x93, 0x6f, 0x0c, 0x08, 0x04, 0xc1, 0xc6,
	0xd8, 0x4d, 0xbd, 0x28, 0x14, 0x9c, 0xfd, 0xaa, 0x73, 0x8f, 0xdc, 0x36, 0x38, 0xed, 0xb0, 0xc0,
	0x3a, 0x28, 0x2a, 0x61, 0x51, 0x53, 0x40, 0x87, 0x55, 0x67, 0x8a, 0x7c, 0x9d, 0x3b, 0xa7, 0xbe,
	0x79, 0xe0, 0x25, 0x89, 0x07, 0x37, 0x3f, 0xaa, 0x3a, 0xb7, 0xc8, 0x97, 0xca, 0xaa, 0x31, 0x04,
	0x1e, 0xb3, 0x6c, 0xb6, 0xe4, 0xdc, 0x21, 0x37, 0x0d, 0x5c, 0xbb, 0x47, 0x7c, 0x82, 0x63, 0x96,
	0xd4, 0x4d, 0x86, 0x94, 0x82, 0x81, 0x77, 0x96, 0x9c, 0xdb, 0xe4, 0xab, 0x22, 0x47, 0x9b, 0xba,
	0xbb, 0x54, 0x38, 0x47, 0xde, 0xe8, 0x74, 0x77, 0xc9, 0x99, 0x21, 0xf7, 0x0b, 0xb8, 0xbc, 0x2e,
	0x17, 0x23, 0xcd, 0xc2, 0x62, 0x1e, 0x6e, 0x67, 0x1c, 0x08, 0xef, 0xbd, 0xbf, 0xe4, 0x3c, 0x24,
	0x77, 0x0d, 0x8e, 0x08, 0x62, 0x11, 0xbd, 0x5e, 0x58, 0x8f, 0x82, 0x16, 0x58, 0x98, 0x6b, 0x3e,
	0x28, 0x32, 0x47, 0x44, 0xde, 0xe1, 0x92, 0xf3, 0x88, 0xdc, 0x33, 0x98, 0x32, 0x7b, 0x93, 0xb8,
	0x9e, 0xb5, 0xe2, 0x28, 0x8d, 0xb4, 0x3d, 0x8e, 0x96, 0x9c, 0x3f, 0x92, 0x87, 0x67, 0x53, 0xdd,
	0x59, 0x4d, 0x3f, 0x5e, 0x82, 0xda, 0x72, 0x9d, 0xd3, 0x4b, 0x3c, 0xf4, 0x6a, 0xcc, 0x00, 0x79,
	0x80, 0x81, 0xd9, 0xe0, 0xf8, 0x73, 0xe0, 0x1b, 0x00, 0x6f, 0x91, 0x49, 0x0d, 0xb6, 0x5b, 0x0d,
	0x57, 0xe8, 0x52, 0xf8, 0x0e, 0xe0, 0x77, 0x44, 0x84, 0xa0, 0x0d, 0x64, 0x1c, 0xb7, 0x62, 0xd6,
	0xf4, 0x16, 0x32, 0x9f, 0x85, 0xb4, 0x0b, 0x94, 0xfb, 0x22, 0x0a, 0x4d, 0x8a, 0x1d, 0xea, 0x40,
	0x9b, 0x92, 0x2e, 0x36, 0x68, 0x61, 0x3b, 0x50, 0xba, 0xf6, 0x46, 0x30, 0x94, 0xae, 0xe4, 0x27,
	0xba, 0x0f, 0x8c, 0x6f, 0x64, 0xa1, 0x28, 0x61, 0xd0, 0x03, 0x80, 0x67, 0xa4, 0x81, 0x05, 0x0c,
	0x11, 0x9e, 0xc5, 0x5e, 0x4d, 0x05, 0x81, 0xef, 0x05, 0x1e, 0x0f, 0x03, 0xb7, 0x3e, 0xc7, 0x7d,
	0x01, 0xdc, 0xbb, 0x32, 0x08, 0x0c, 0xae, 0x3e, 0x7d, 0x0c, 0x25, 0xe5, 0x08, 0x48, 0xbf, 0x97,
	0x35, 0xc5, 0x20, 0xf1, 0xf3, 0xe6, 0xa5, 0xd2, 0xe3, 0x11, 0xd2, 0xc0, 0x3f, 0x3c, 0x13, 0xe4,
	0xfd, 0x4e, 0x80, 0x74, 0x9d, 0x7c, 0x36, 0x24, 0xb1, 0x05, 0x30, 0x0e, 0x3d, 0x85, 0xe5, 0x9b,
	0xe4, 0x0b, 0xbd, 0x3c, 0x17, 0x25, 0x69, 0x56, 0xf3, 0xd2, 0x24, 0xe3, 0xde, 0x7b, 0x6d, 0x49,
	0xb6, 0x8c, 0x12, 0xd4, 0x5d, 0x10, 0xf1, 0xc6, 0xb2, 0x9c, 0x38, 0x9f, 0xdb, 0xf4, 0x78, 0x34,
	0x07, 0x6e, 0x5a, 0x9f, 0xa3, 0x6f, 0x81, 0x71, 0x4f, 0xd4, 0x6b, 0x9d, 0xa3, 0x22, 0x45, 0x5b,
	0xb1, 0x17, 0xb8, 0xf1, 0xa2, 0xf2, 0xc0, 0x3b, 0x4b, 0x19, 0xb2, 0x6a, 0x6e, 0xfd, 0x49, 0xbb,
	0xa5, 0x48, 0xef, 0x81, 0x74, 0x83, 0x7c, 0xae, 0x49, 0x8d, 0x5a, 0x26, 0x5b, 0xe5, 0x07, 0x00,
	0xa6, 0x65, 0x2d, 0x30, 0x8e, 0xea, 0x47, 0x75, 0xd7, 0xcf, 0xa0, 0x07, 0x32, 0x9f, 0x7e, 0x04,
	0xce, 0x57, 0xa2, 0x18, 0x89, 0x33, 0x9a, 0x81, 0xda, 0x1b, 0x83, 0x42, 0x75, 0x15, 0xb1, 0x70,
	0x6e, 0x98, 0xdd, 0xdb, 0x00, 0xdd, 0x16, 0xe9, 0x8f, 0x90, 0x17, 0xa6, 0x46, 0x25, 0xee, 0x61,
	0x9c, 0x0a, 0x82, 0x56, 0xcd, 0x95, 0x42, 0xaf, 0x6f, 0x87, 0x29, 0xed, 0x02, 0x65, 0x52, 0x54,
	0x6b, 0x83, 0x02, 0xd5, 0x7a, 0xb7, 0x87, 0x49, 0x20, 0x90, 0x42, 0x71, 0xda, 0xeb, 0xe1, 0xc5,
	0x4c, 0xed, 0x79, 0xce, 0x7e, 0x0f, 0x5d, 0x30, 0xe4, 0x60, 0x1e, 0x34, 0x62, 0x1e, 0xbc, 0x07,
	0xe6, 0x11, 0x05, 0xc3, 0x2a, 0x3a, 0x87, 0x3d, 0xb4, 0xbf, 0x71, 0xc4, 0x90, 0x2d, 0xa4, 0x10,
	0x16, 0x2d, 0x21, 0x8a, 0x1e, 0xf5, 0x30, 0x28, 0x0d, 0x52, 0xcc, 0x82, 0x48, 0x66, 0x77, 0xac,
	0x2e, 0x7c, 0xdc, 0x43, 0x9f, 0x0b, 0x62, 0x9e, 0x80, 0x9b, 0xe0, 0x58, 0x27, 0xc0, 0x7a, 0x20,
	0xda, 0x6b, 0x81, 0x65, 0x44, 0xd0, 0xa9, 0xc9, 0x1b, 0xc6, 0x21, 0xd0, 0xf9, 0x1c, 0xc5, 0x43,
	0x36, 0x70, 0x5b, 0xf4, 0x35, 0xf0, 0x1e, 0x89, 0x7a, 0x28, 0x78, 0x2a, 0x74, 0xd4, 0x0d, 0x8d,
	0x78, 0xa3, 0x6f, 0x4c, 0x8b, 0x20, 0x26, 0x2e, 0xd3, 0x62, 0x2e, 0x1f, 0x8b, 0xde, 0x9a, 0x66,
	0x55, 0xd2, 0xf2, 0x8c, 0x77, 0x3d, 0x4c, 0x7a, 0x43, 0x48, 0x79, 0xe8, 0x9a, 0x16, 0xb1, 0xb9,
	0x22, 0x5a, 0x12, 0xfa, 0xc1, 0xbc, 0x81, 0xcd, 0xca, 0x59, 0x88, 0x7e, 0x34, 0x6f, 0x50, 0x62,
	0x62, 0xfa, 0x6b, 0x0f, 0xcb, 0x6f, 0x31, 0x32, 0xe9, 0x6f, 0x3d, 0x5d, 0xd0, 0xa0, 0xce, 0xd7,
	0x9a, 0x0d, 0x2b, 0x23, 0xfa, 0x68, 0x73, 0x84, 0x75, 0x6f, 0x15, 0x5c, 0x18, 0x6a, 0xa1, 0xc9,
	0x43, 0x15, 0xef, 0xeb, 0xcc, 0x53, 0x3c, 0xb7, 0xe5, 0xc1, 0xd5, 0xc1, 0x3d, 0x6e, 0x0c, 0x01,
	0x06, 0x6d, 0x8f, 0xee, 0xf4, 0x75, 0x71, 0xcc, 0x71, 0xea, 0xbe, 0xc7, 0xc2, 0xd4, 0x6e, 0x90,
	0xdd, 0xbe, 0xae, 0x03, 0x39, 0x2e, 0x04, 0x3d, 0x8b, 0x43, 0x48, 0x65, 0xa8, 0x6e, 0x51, 0x4c,
	0x77, 0xfb, 0xba, 0x38, 0xe2, 0xd9, 0xcb, 0xdb, 0xde, 0x5e, 0xe1, 0x74, 0xf3, 0xdf, 0xdb, 0x1a,
	0xf7, 0x8b, 0x9c, 0x1f, 0x6c, 0xce, 0x41, 0x1f, 0xeb, 0x43, 0xd1, 0x50, 0x03, 0xcc, 0x60, 0x0e,
	0x15, 0xb3, 0x73, 0x7b, 0x80, 0x4e, 0x18, 0xe2, 0xc3, 0xda, 0x61, 0x6d, 0x56, 0x69, 0x9b, 0xa6,
	0x50, 0xc1, 0xa1, 0x8e, 0xd1, 0xee, 0x08, 0xe1, 0x98, 0xb5, 0xbb, 0xa5, 0xfb, 0xc3, 0x5a, 0xac,
	0xaa, 0xf3, 0xde, 0x00, 0x0b, 0x8f, 0x85, 0xd3, 0xfd, 0x01, 0xba, 0x5f, 0xdc, 0xd8, 0xae, 0x3b,
	0x07, 0x03, 0x2c, 0x96, 0x1c, 0x36, 0xdd, 0x79, 0x38, 0xc0, 0x8a, 0x38, 0xc2, 0x3d, 0x47, 0xc6,
	0x66, 0x73, 0x98, 0x3a, 0x1e, 0x60, 0x56, 0xe5, 0x4f, 0x84, 0x7d, 0x16, 0x9c, 0x46, 0x4f, 0x06,
	0x18, 0xd8, 0x79, 0x86, 0x0a, 0xb8, 0x2c, 0x5d, 0x6c, 0x31, 0x7a, 0x5a, 0x7a, 0x2d, 0x50, 0x44,
	0x5f, 0x1b, 0x06, 0xc1, 0x4d, 0x43, 0xf5, 0x6f, 0x0c, 0x6f, 0x20, 0x2e, 0xba, 0x61, 0x42, 0xdf,
	0xda, 0xd6, 0x96, 0x97, 0x82, 0x2e, 0x23, 0xef, 0xf5, 0xce, 0xd8, 0x1c, 0xb3, 0x7a, 0x04, 0x31,
	0xb7, 0xa8, 0xc0, 0xf7, 0x7a, 0x33, 0x0f, 0xa3, 0xa0, 0xe5, 0x27, 0xf6, 0x2c, 0x54, 0xc9, 0x05,
	0xb6, 0xc0, 0x3d, 0x3f, 0x18, 0x66, 0x15, 0x7c, 0xf0, 0x99, 0xa8, 0x02, 0x13, 0xdd, 0xb4, 0x21,
	0x64, 0xc4, 0x4f, 0x89, 0x22, 0x73, 0xc4, 0x90, 0xd8, 0x05, 0xe6, 0x77, 0xe4, 0x51, 0x9e, 0x29,
	0x7b, 0x53, 0xcd, 0x7f, 0x32, 0x54, 0xaf, 0x97, 0x12, 0x18, 0x97, 0x2a, 0xd8, 0xd2, 0x71, 0x83,
	0x3d, 0xc5, 0x02, 0x43, 0xf6, 0x61, 0x7e, 0x05, 0x3e, 0x71, 0xe8, 0x3e, 0x9a, 0x07, 0xf8, 0xb8,
	0xa7, 0x7e, 0x66, 0x6d, 0x03, 0x20, 0x4d, 0xc7, 0x01, 0x3f, 0x69, 0xe4, 0xc1, 0x1d, 0x00, 0xa5,
	0xe9, 0x38, 0x98, 0x9f, 0xce, 0xc2, 0x39, 0xbf, 0x09, 0x37, 0x00, 0x5c, 0xc6, 0x53, 0x1e, 0x97,
	0x65, 0x6c, 0xd7, 0xc0, 0x1a, 0xcc, 0x87, 0x10, 0xd5, 0xbf, 0xed, 0x0c, 0xb9, 0x5c, 0xa9, 0x89,
	0xef, 0xf7, 0xd0, 0x25, 0xca, 0x13, 0xc6, 0x5c, 0x22, 0x74, 0x27, 0xd0, 0x3b, 0x2b, 0xaa, 0x3c,
	0xe4, 0x49, 0xaa, 0xb6, 0x2b, 0xce, 0x21, 0x70, 0x64, 0x3d, 0xca, 0xdf, 0x4e, 0x9a, 0xd4, 0xf5,
	0x61, 0x08, 0x41, 0x8d, 0x47, 0x40, 0x94, 0x03, 0x2b, 0x12, 0x85, 0x04, 0x2b, 0xf3, 0xa1, 0x7d,
	0x56, 0x9c, 0xab, 0xe2, 0x27, 0xb6, 0xb0, 0xaf, 0x1c, 0xd6, 0x4e, 0x60, 0x51, 0xce, 0x70, 0xe2,
	0xa6, 0x38, 0xfa, 0x9c, 0xc2, 0xb2, 0x2c, 0x4d, 0x52, 0x54, 0xde, 0x1b, 0x7d, 0xb4, 0x8d, 0x84,
	0x8c, 0xb1, 0x06, 0x30, 0x99, 0x65, 0x1a, 0xb3, 0xa7, 0x86, 0x1d, 0xa0, 0xc8, 0x96, 0x65, 0x1e,
	0xd2, 0x9c, 0x09, 0xba, 0xc0, 0x92, 0xd5, 0x40, 0xb2, 0x0a, 0xa5, 0x64, 0xb7, 0x8f, 0x06, 0xcc,
	0x69, 0xb2, 0xea, 0xd8, 0x5e, 0x1f, 0x3d, 0x91, 0xe3, 0x14, 0xe6, 0x1c, 0x4b, 0x50, 0xd9, 0xa4,
	0x75, 0xd0, 0x47, 0x97, 0x9b, 0x1c, 0xd9, 0x00, 0x61, 0xf6, 0x06, 0x5c, 0x4e, 0xbc, 0x25, 0x32,
	0xe8, 0x51, 0x1f, 0xfd, 0x68, 0xed, 0xb6, 0x27, 0x8d, 0xe3, 0x3e, 0x66, 0x9f, 0x49, 0x2c, 0x4e,
	0x42, 0x27, 0x7d, 0xf4, 0xb8, 0x64, 0x8e, 0x18, 0x85, 0x4e, 0x2d, 0xda, 0x88, 0xf9, 0xe0, 0x35,
	0xd0, 0x64, 0x27, 0x2d, 0xa7, 0xe5, 0x07, 0x84, 0x37, 0x96, 0x87, 0x4b, 0x06, 0x98, 0xb7, 0x96,
	0x45, 0xcb, 0xc6, 0xa0, 0x77, 0xc0, 0xf9, 0x03, 0x79, 0x60, 0x8b, 0xb1, 0x4d, 0x92, 0xb1, 0xa0,
	0x95, 0x2e, 0xd2, 0xf7, 0xc0, 0xfe, 0x56, 0xfc, 0x18, 0x2e, 0x3f, 0xa0, 0x31, 0x13, 0x7d, 0xb0,
	0xd4, 0x97, 0xcd, 0x30, 0x1f, 0xad, 0x1b, 0x9f, 0x35, 0xd4, 0xfd, 0x6a, 0x85, 0xa2, 0x0e, 0x54,
	0x0c, 0xb3, 0xdf, 0xac, 0x30, 0x53, 0x19, 0x5a, 0x17, 0xef, 0x15, 0xa8, 0xf1, 0x5f, 0x7d, 0x2c,
	0x7f, 0x56, 0x2c, 0xea, 0x26, 0xf2, 0x6f, 0x2b, 0xaf, 0xa2, 0x16, 0x14, 0x68, 0x95, 0xe1, 0xff,
	0x39, 0x4b, 0x05, 0x9e, 0xe3, 0xbf, 0x40, 0x92, 0xcd, 0x77, 0x58, 0x89, 0xf3, 0x79, 0x3b, 0x40,
	0xcf, 0x0d, 0x61, 0xab, 0x64, 0x6e, 0x0f, 0x30, 0x37, 0x4d, 0x8a, 0x59, 0xe0, 0x76, 0x06, 0x68,
	0x3c, 0x93, 0x35, 0xfc, 0xca, 0xbd, 0x72, 0x0c, 0x30, 0xf6, 0x47, 0x71, 0xe1, 0x27, 0x75, 0x3b,
	0x81, 0x5f, 0xd3, 0x03, 0x0c, 0x55, 0x93, 0x68, 0xd5, 0xb0, 0xbd, 0x12, 0x1a, 0x52, 0x6a, 0x50,
	0x12, 0x9f, 0xc8, 0x6e, 0xbf, 0x0f, 0x34, 0x39, 0x67, 0x16, 0x69, 0xb2, 0x7f, 0xca, 0xd4, 0x3c,
	0x18, 0x60, 0x99, 0xcb, 0x99, 0x4c, 0x16, 0xc6, 0xc3, 0x01, 0xf6, 0x96, 0x21, 0xa4, 0xcb, 0xe3,
	0xd1, 0x00, 0x13, 0x5e, 0x34, 0x32, 0xfe, 0xd0, 0x94, 0xb7, 0xf4, 0xab, 0x71, 0x55, 0x53, 0xf3,
	0x28, 0xb4, 0xe1, 0x71, 0xd5, 0xc6, 0xc4, 0xb2, 0x78, 0xd8, 0x12, 0xc0, 0x8e, 0xc9, 0xc7, 0xb7,
	0xac, 0x2e, 0x2c, 0x0f, 0x7b, 0xbf, 0x88, 0x16, 0xeb, 0xe7, 0xe5, 0x38, 0xbe, 0x53, 0x20, 0x3e,
	0xec, 0xfb, 0x7c, 0xcc, 0x68, 0xba, 0x75, 0xfe, 0x5a, 0x05, 0xb4, 0x61, 0x4f, 0x97, 0x62, 0x46,
	0x74, 0x7f, 0x60, 0x7e, 0xab, 0xdf, 0x9c, 0x04, 0xf3, 0x8c, 0x91, 0x1a, 0xc8, 0xaa, 0x45, 0x16,
	0x4f, 0xd6, 0x1f, 0x57, 0x71, 0x24, 0x30, 0x7d, 0x18, 0xb3, 0x3c, 0x6f, 0x9f, 0xc9, 0xd2, 0x0f,
	0x69, 0xc0, 0x92, 0xe9, 0x67, 0xb1, 0xd0, 0x7a, 0xdd, 0x12, 0x82, 0x31, 0x60, 0xed, 0x02, 0x41,
	0x3a, 0x4b, 0x10, 0xac, 0x09, 0x6b, 0xaf, 0x8f, 0x56, 0xb6, 0xe4, 0xab, 0xf1, 0x6d, 0x1f, 0x70,
	0x99, 0x36, 0xf6, 0x29, 0x75, 0x90, 0x1f, 0xe4, 0x45, 0x48, 0xe5, 0xd6, 0x90, 0x56, 0x9d, 0xfe,
	0x91, 0x3f, 0x7e, 0x7b, 0xab, 0x5b, 0x9d, 0x8d, 0x9f, 0x97, 0x57, 0x3a, 0xce, 0x35, 0xf2, 0x49,
	0xb8, 0xfc, 0xa2, 0x23, 0xfe, 0x1f, 0x30, 0x31, 0x77, 0x2e, 0x16, 0x5f, 0x30, 0x7d, 0x9e, 0x9f,
	0x5b, 0x5e, 0x7d, 0xf6, 0xbc, 0x33, 0x59, 0x81, 0xf5, 0xcb, 0xb0, 0xae, 0xbe, 0x6b, 0x17, 0xc9,
	0x84, 0xde, 0x3c, 0xbd, 0x20, 0x64, 0xad, 0xbb, 0xcf, 0x9e, 0x6d, 0x74, 0x36, 0x37, 0x41, 0xf5,
	0xc4, 0xfc, 0xf7, 0xea, 0x43, 0x08, 0xe4, 0x1b, 0x87, 0x4b, 0x02, 0xff, 0x01, 0x71, 0x2e, 0xf8,
	0x92, 0xc0, 0x71, 0xa9, 0x36, 0x41, 0x2e, 0xa8, 0x3f, 0x67, 0x9e, 0xf2, 0xff, 0x34, 0xc4, 0x9d,
	0xbf, 0x45, 0xeb, 0x10, 0x90, 0xe2, 0x45, 0x84, 0xcd, 0x42, 0xa5, 0x8b, 0x99, 0x88, 0x98, 0x06,
	0x3d, 0x67, 0x2d, 0xcb, 0x68, 0xa0, 0xfc, 0xfd, 0xe4, 0xaa, 0x5e, 0xc6, 0x17, 0x5b, 0x00, 0x2a,
	0x0e, 0x25, 0x97, 0x34, 0x00, 0x81, 0x4d, 0xc7, 0x67, 0x32, 0xfe, 0xea, 0x1f, 0x3d, 0xfd, 0x7b,
	0x67, 0x65, 0x4b, 0xab, 0x89, 0x6a, 0x3f, 0x9a, 0x6a, 0xe4, 0x36, 0xb9, 0x0c, 0x05, 0x0a, 0x34,
	0x5c, 0x15, 0x09, 0x22, 0x57, 0xe4, 0xa3, 0x1e, 0xad, 0x18, 0x8b, 0xb2, 0x48, 0x81, 0x82, 0x84,
	0xff, 0x47, 0x23, 0x5c, 0xdb, 0xfa, 0xe5, 0x67, 0x90, 0x2f, 0x0f, 0x26, 0x9e, 0x1a, 0xcb, 0x2e,
	0x82, 0x00, 0x0b, 0xc5, 0xfc, 0x32, 0xa6, 0xfe, 0xff, 0x81, 0xcb, 0x0d, 0x2f, 0x11, 0xeb, 0x95,
	0x99, 0x27, 0xdc, 0xe6, 0x6c, 0x75, 0x65, 0x79, 0x3d, 0x7d, 0xb9, 0xde, 0x51, 0xbb, 0x59, 0x58,
	0x77, 0x0d, 0xa1, 0x0e, 0xb9, 0xa2, 0x97, 0xe7, 0x17, 0x7c, 0x37, 0x04, 0x89, 0xf2, 0xbf, 0x1a,
	0x72, 0x8d, 0xe7, 0x37, 0xad, 0x3c, 0x3d, 0x2f, 0xfe, 0x6f, 0xf4, 0x97, 0xff, 0x07, 0x00, 0x00,
	0xff, 0xff, 0x81, 0x17, 0xfd, 0x86, 0x50, 0x1a, 0x00, 0x00,
}
