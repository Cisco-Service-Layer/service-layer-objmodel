// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_global.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Global Event Notification types.
type SLGlobalNotifType int32

const (
	// Reserved. 0x0
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_RESERVED SLGlobalNotifType = 0
	// Error. ErrStatus field elaborates on the message. 0x1
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_ERROR SLGlobalNotifType = 1
	// HeartBeat. 0x2
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_HEARTBEAT SLGlobalNotifType = 2
	// Version. SLInitMsgRsp field elaborates on the server version. 0x3
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_VERSION SLGlobalNotifType = 3
)

var SLGlobalNotifType_name = map[int32]string{
	0: "SL_GLOBAL_EVENT_TYPE_RESERVED",
	1: "SL_GLOBAL_EVENT_TYPE_ERROR",
	2: "SL_GLOBAL_EVENT_TYPE_HEARTBEAT",
	3: "SL_GLOBAL_EVENT_TYPE_VERSION",
}
var SLGlobalNotifType_value = map[string]int32{
	"SL_GLOBAL_EVENT_TYPE_RESERVED":  0,
	"SL_GLOBAL_EVENT_TYPE_ERROR":     1,
	"SL_GLOBAL_EVENT_TYPE_HEARTBEAT": 2,
	"SL_GLOBAL_EVENT_TYPE_VERSION":   3,
}

func (x SLGlobalNotifType) String() string {
	return proto.EnumName(SLGlobalNotifType_name, int32(x))
}
func (SLGlobalNotifType) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

// Initialization message sent to the server.
// If the client and server are running compatible version numbers, a
// connection will be made and the server response will be received
// with a successful status code.
type SLInitMsg struct {
	// Client's Major version of service-layer API (refer to sl_version.proto)
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer uint32 `protobuf:"varint,3,opt,name=SubVer" json:"SubVer,omitempty"`
}

func (m *SLInitMsg) Reset()                    { *m = SLInitMsg{} }
func (m *SLInitMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInitMsg) ProtoMessage()               {}
func (*SLInitMsg) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *SLInitMsg) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *SLInitMsg) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *SLInitMsg) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Server's response to the SLInitMsg.
// On Success (ErrStatus), the session with the server is established
// and the client is allowed to proceed.
type SLInitMsgRsp struct {
	// Server's version of service-layer API (refer to sl_version.proto)
	// Major-number revisions are NOT backwards compatible,
	// unless otherwise specified. The Server may reject a session if there
	// is a version number mismatch or non-backwards compatibility.
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer uint32 `protobuf:"varint,3,opt,name=SubVer" json:"SubVer,omitempty"`
}

func (m *SLInitMsgRsp) Reset()                    { *m = SLInitMsgRsp{} }
func (m *SLInitMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLInitMsgRsp) ProtoMessage()               {}
func (*SLInitMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *SLInitMsgRsp) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *SLInitMsgRsp) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *SLInitMsgRsp) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Globals query message.
type SLGlobalNotif struct {
	// Event Type.
	EventType SLGlobalNotifType `protobuf:"varint,1,opt,name=EventType,enum=service_layer.SLGlobalNotifType" json:"EventType,omitempty"`
	// Status code, interpreted based on the Event Type.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_ERROR:
	//       case ErrStatus == SL_NOTIF_TERM:
	//          => Another client is attempting to take over the session.
	//             This session will be closed.
	//       case ErrStatus == (some error from SLErrorStatus)
	//          => Client must look into the specific error message returned.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_HEARTBEAT:
	//       case ErrStatus == SL_SUCCESS
	//          => Client can safely ignore this heartbeat message.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_VERSION:
	//       case ErrStatus == SL_SUCCESS
	//          => Client version accepted.
	//       case ErrStatus == SL_INIT_STATE_READY
	//          => Client version accepted.
	//             Any previous state was sucessfully recovered.
	//       case ErrStatus == SL_INIT_STATE_CLEAR
	//          => Client version accepted. Any previous state was lost.
	//             Client must replay all previous objects to server.
	//       case ErrStatus == SL_UNSUPPORTED_VER
	//          => Client and Server version mismatch. The client is not
	//             allowed to proceed, and the channel will be closed.
	//       case ErrStatus == (some error from SLErrorStatus)
	//          => Client must either try again, or look into the specific
	//             error message returned.
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Further info based on EventType.
	//
	// Types that are valid to be assigned to Event:
	//	*SLGlobalNotif_InitRspMsg
	Event isSLGlobalNotif_Event `protobuf_oneof:"Event"`
}

func (m *SLGlobalNotif) Reset()                    { *m = SLGlobalNotif{} }
func (m *SLGlobalNotif) String() string            { return proto.CompactTextString(m) }
func (*SLGlobalNotif) ProtoMessage()               {}
func (*SLGlobalNotif) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

type isSLGlobalNotif_Event interface {
	isSLGlobalNotif_Event()
}

type SLGlobalNotif_InitRspMsg struct {
	InitRspMsg *SLInitMsgRsp `protobuf:"bytes,3,opt,name=InitRspMsg,oneof"`
}

func (*SLGlobalNotif_InitRspMsg) isSLGlobalNotif_Event() {}

func (m *SLGlobalNotif) GetEvent() isSLGlobalNotif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLGlobalNotif) GetEventType() SLGlobalNotifType {
	if m != nil {
		return m.EventType
	}
	return SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_RESERVED
}

func (m *SLGlobalNotif) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLGlobalNotif) GetInitRspMsg() *SLInitMsgRsp {
	if x, ok := m.GetEvent().(*SLGlobalNotif_InitRspMsg); ok {
		return x.InitRspMsg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLGlobalNotif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLGlobalNotif_OneofMarshaler, _SLGlobalNotif_OneofUnmarshaler, _SLGlobalNotif_OneofSizer, []interface{}{
		(*SLGlobalNotif_InitRspMsg)(nil),
	}
}

func _SLGlobalNotif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLGlobalNotif_InitRspMsg:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InitRspMsg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLGlobalNotif.Event has unexpected type %T", x)
	}
	return nil
}

func _SLGlobalNotif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLGlobalNotif)
	switch tag {
	case 3: // Event.InitRspMsg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLInitMsgRsp)
		err := b.DecodeMessage(msg)
		m.Event = &SLGlobalNotif_InitRspMsg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLGlobalNotif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLGlobalNotif_InitRspMsg:
		s := proto.Size(x.InitRspMsg)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Globals query message.
type SLGlobalsGetMsg struct {
}

func (m *SLGlobalsGetMsg) Reset()                    { *m = SLGlobalsGetMsg{} }
func (m *SLGlobalsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLGlobalsGetMsg) ProtoMessage()               {}
func (*SLGlobalsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

// Platform specific globals Response.
type SLGlobalsGetMsgRsp struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Maximum vrf name length.
	MaxVrfNameLength uint32 `protobuf:"varint,2,opt,name=MaxVrfNameLength" json:"MaxVrfNameLength,omitempty"`
	// Maximum interface name length.
	MaxInterfaceNameLength uint32 `protobuf:"varint,3,opt,name=MaxInterfaceNameLength" json:"MaxInterfaceNameLength,omitempty"`
	// Maximum paths per Route/ILM Entry.
	MaxPathsPerEntry uint32 `protobuf:"varint,4,opt,name=MaxPathsPerEntry" json:"MaxPathsPerEntry,omitempty"`
	// Maximum primary paths per Route/ILM Entry.
	MaxPrimaryPathPerEntry uint32 `protobuf:"varint,5,opt,name=MaxPrimaryPathPerEntry" json:"MaxPrimaryPathPerEntry,omitempty"`
	// Maximum backup paths per Route/ILM Entry.
	MaxBackupPathPerEntry uint32 `protobuf:"varint,6,opt,name=MaxBackupPathPerEntry" json:"MaxBackupPathPerEntry,omitempty"`
	// Maximum MPLS labels per Route/ILM Entry.
	MaxMplsLabelsPerPath uint32 `protobuf:"varint,7,opt,name=MaxMplsLabelsPerPath" json:"MaxMplsLabelsPerPath,omitempty"`
	// Minimum Primary path id number.
	MinPrimaryPathIdNum uint32 `protobuf:"varint,8,opt,name=MinPrimaryPathIdNum" json:"MinPrimaryPathIdNum,omitempty"`
	// Maximum Primary path id number.
	MaxPrimaryPathIdNum uint32 `protobuf:"varint,9,opt,name=MaxPrimaryPathIdNum" json:"MaxPrimaryPathIdNum,omitempty"`
	// Minimum Pure Backup path id number.
	MinBackupPathIdNum uint32 `protobuf:"varint,10,opt,name=MinBackupPathIdNum" json:"MinBackupPathIdNum,omitempty"`
	// Maximum Pure Backup path id number.
	MaxBackupPathIdNum uint32 `protobuf:"varint,11,opt,name=MaxBackupPathIdNum" json:"MaxBackupPathIdNum,omitempty"`
	// Maximum number of remote addresses
	MaxRemoteAddressNum uint32 `protobuf:"varint,12,opt,name=MaxRemoteAddressNum" json:"MaxRemoteAddressNum,omitempty"`
	// Maximum Bridge Domain name length - used for L2 routes.
	MaxL2BdNameLength uint32 `protobuf:"varint,13,opt,name=MaxL2BdNameLength" json:"MaxL2BdNameLength,omitempty"`
	// Maximum Provider Multicast Service Interface (PMSI) tunnel ID length.
	// Used for L2 Inclusive Multicast Ethernet Tag (IMET) routes.
	MaxL2PmsiTunnelIdLength uint32 `protobuf:"varint,14,opt,name=MaxL2PmsiTunnelIdLength" json:"MaxL2PmsiTunnelIdLength,omitempty"`
}

func (m *SLGlobalsGetMsgRsp) Reset()                    { *m = SLGlobalsGetMsgRsp{} }
func (m *SLGlobalsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLGlobalsGetMsgRsp) ProtoMessage()               {}
func (*SLGlobalsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *SLGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLGlobalsGetMsgRsp) GetMaxVrfNameLength() uint32 {
	if m != nil {
		return m.MaxVrfNameLength
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxInterfaceNameLength() uint32 {
	if m != nil {
		return m.MaxInterfaceNameLength
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPathsPerEntry() uint32 {
	if m != nil {
		return m.MaxPathsPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPrimaryPathPerEntry() uint32 {
	if m != nil {
		return m.MaxPrimaryPathPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxBackupPathPerEntry() uint32 {
	if m != nil {
		return m.MaxBackupPathPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxMplsLabelsPerPath() uint32 {
	if m != nil {
		return m.MaxMplsLabelsPerPath
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMinPrimaryPathIdNum() uint32 {
	if m != nil {
		return m.MinPrimaryPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPrimaryPathIdNum() uint32 {
	if m != nil {
		return m.MaxPrimaryPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMinBackupPathIdNum() uint32 {
	if m != nil {
		return m.MinBackupPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxBackupPathIdNum() uint32 {
	if m != nil {
		return m.MaxBackupPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxRemoteAddressNum() uint32 {
	if m != nil {
		return m.MaxRemoteAddressNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxL2BdNameLength() uint32 {
	if m != nil {
		return m.MaxL2BdNameLength
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxL2PmsiTunnelIdLength() uint32 {
	if m != nil {
		return m.MaxL2PmsiTunnelIdLength
	}
	return 0
}

func init() {
	proto.RegisterType((*SLInitMsg)(nil), "service_layer.SLInitMsg")
	proto.RegisterType((*SLInitMsgRsp)(nil), "service_layer.SLInitMsgRsp")
	proto.RegisterType((*SLGlobalNotif)(nil), "service_layer.SLGlobalNotif")
	proto.RegisterType((*SLGlobalsGetMsg)(nil), "service_layer.SLGlobalsGetMsg")
	proto.RegisterType((*SLGlobalsGetMsgRsp)(nil), "service_layer.SLGlobalsGetMsgRsp")
	proto.RegisterEnum("service_layer.SLGlobalNotifType", SLGlobalNotifType_name, SLGlobalNotifType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SLGlobal service

type SLGlobalClient interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Service Layer connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the SLInitMsg
	// message. The server will reply with SL_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message SLGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - SLGlobalNotif.EventType = SL_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to SLGlobalNotif definition for further info.
	SLGlobalInitNotif(ctx context.Context, in *SLInitMsg, opts ...grpc.CallOption) (SLGlobal_SLGlobalInitNotifClient, error)
	// Get platform specific globals
	SLGlobalsGet(ctx context.Context, in *SLGlobalsGetMsg, opts ...grpc.CallOption) (*SLGlobalsGetMsgRsp, error)
}

type sLGlobalClient struct {
	cc *grpc.ClientConn
}

func NewSLGlobalClient(cc *grpc.ClientConn) SLGlobalClient {
	return &sLGlobalClient{cc}
}

func (c *sLGlobalClient) SLGlobalInitNotif(ctx context.Context, in *SLInitMsg, opts ...grpc.CallOption) (SLGlobal_SLGlobalInitNotifClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLGlobal_serviceDesc.Streams[0], c.cc, "/service_layer.SLGlobal/SLGlobalInitNotif", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLGlobalSLGlobalInitNotifClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SLGlobal_SLGlobalInitNotifClient interface {
	Recv() (*SLGlobalNotif, error)
	grpc.ClientStream
}

type sLGlobalSLGlobalInitNotifClient struct {
	grpc.ClientStream
}

func (x *sLGlobalSLGlobalInitNotifClient) Recv() (*SLGlobalNotif, error) {
	m := new(SLGlobalNotif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLGlobalClient) SLGlobalsGet(ctx context.Context, in *SLGlobalsGetMsg, opts ...grpc.CallOption) (*SLGlobalsGetMsgRsp, error) {
	out := new(SLGlobalsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLGlobal/SLGlobalsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SLGlobal service

type SLGlobalServer interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Service Layer connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the SLInitMsg
	// message. The server will reply with SL_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message SLGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - SLGlobalNotif.EventType = SL_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to SLGlobalNotif definition for further info.
	SLGlobalInitNotif(*SLInitMsg, SLGlobal_SLGlobalInitNotifServer) error
	// Get platform specific globals
	SLGlobalsGet(context.Context, *SLGlobalsGetMsg) (*SLGlobalsGetMsgRsp, error)
}

func RegisterSLGlobalServer(s *grpc.Server, srv SLGlobalServer) {
	s.RegisterService(&_SLGlobal_serviceDesc, srv)
}

func _SLGlobal_SLGlobalInitNotif_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SLInitMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SLGlobalServer).SLGlobalInitNotif(m, &sLGlobalSLGlobalInitNotifServer{stream})
}

type SLGlobal_SLGlobalInitNotifServer interface {
	Send(*SLGlobalNotif) error
	grpc.ServerStream
}

type sLGlobalSLGlobalInitNotifServer struct {
	grpc.ServerStream
}

func (x *sLGlobalSLGlobalInitNotifServer) Send(m *SLGlobalNotif) error {
	return x.ServerStream.SendMsg(m)
}

func _SLGlobal_SLGlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLGlobalServer).SLGlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLGlobal/SLGlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLGlobalServer).SLGlobalsGet(ctx, req.(*SLGlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _SLGlobal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLGlobal",
	HandlerType: (*SLGlobalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLGlobalsGet",
			Handler:    _SLGlobal_SLGlobalsGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLGlobalInitNotif",
			Handler:       _SLGlobal_SLGlobalInitNotif_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sl_global.proto",
}

func init() { proto.RegisterFile("sl_global.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 622 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x94, 0xef, 0x6a, 0xdb, 0x30,
	0x14, 0xc5, 0xeb, 0x76, 0xfd, 0x77, 0xdb, 0xb4, 0xa9, 0xb6, 0x76, 0x21, 0xeb, 0x4a, 0x9b, 0x4f,
	0xa3, 0x8c, 0x50, 0xb2, 0x31, 0xc6, 0x60, 0x83, 0x84, 0x89, 0x36, 0xe0, 0xa4, 0x99, 0x1c, 0x02,
	0x63, 0x30, 0xe3, 0x24, 0x6a, 0xeb, 0xcd, 0x7f, 0x82, 0xa4, 0x94, 0xe5, 0x5d, 0xf6, 0x08, 0x7b,
	0x9b, 0xbd, 0xc0, 0x1e, 0x65, 0xb2, 0xac, 0xda, 0x71, 0xed, 0x14, 0x06, 0xfb, 0xa8, 0xfb, 0x3b,
	0x47, 0x3a, 0x57, 0xb6, 0x2e, 0xec, 0x72, 0xcf, 0xbe, 0xf6, 0xc2, 0xa1, 0xe3, 0xd5, 0x27, 0x2c,
	0x14, 0x21, 0x2a, 0x71, 0xca, 0x6e, 0xdd, 0x11, 0xb5, 0x3d, 0x67, 0x46, 0x59, 0x75, 0x5f, 0xf2,
	0x51, 0xe8, 0xfb, 0x61, 0x60, 0x8b, 0xd9, 0x84, 0xf2, 0x58, 0x55, 0xfb, 0x02, 0x9b, 0x96, 0xd9,
	0x0e, 0x5c, 0xd1, 0xe1, 0xd7, 0xa8, 0x0a, 0x1b, 0x1d, 0xe7, 0x5b, 0xc8, 0x06, 0x94, 0x55, 0x8c,
	0x63, 0xe3, 0x45, 0x89, 0x24, 0x6b, 0xc5, 0xdc, 0x20, 0x66, 0xcb, 0x9a, 0xe9, 0x35, 0x3a, 0x80,
	0x35, 0x6b, 0x3a, 0x8c, 0xc8, 0x8a, 0x22, 0x7a, 0x55, 0xfb, 0x0a, 0xdb, 0xc9, 0xe6, 0x84, 0x4f,
	0xfe, 0xfb, 0xfe, 0xbf, 0x0d, 0x28, 0x59, 0xe6, 0xb9, 0xea, 0xba, 0x1b, 0x0a, 0xf7, 0x0a, 0x7d,
	0x80, 0x4d, 0x7c, 0x4b, 0x03, 0xd1, 0x97, 0x2d, 0xaa, 0x23, 0x76, 0x1a, 0xc7, 0xf5, 0xcc, 0x45,
	0xd4, 0x33, 0x86, 0x48, 0x47, 0x52, 0x0b, 0x7a, 0x27, 0xfd, 0x8c, 0x59, 0xc2, 0x11, 0x53, 0xae,
	0x62, 0x6c, 0x35, 0x0e, 0x73, 0x7e, 0xa9, 0x08, 0xb5, 0x86, 0xa4, 0x72, 0xf4, 0x1e, 0x20, 0xea,
	0x55, 0x36, 0x2a, 0xdb, 0x55, 0x49, 0xb7, 0x1a, 0xcf, 0x72, 0xe6, 0xf4, 0x3a, 0x2e, 0x96, 0xc8,
	0x9c, 0xa1, 0xb5, 0x0e, 0xab, 0x2a, 0x47, 0x6d, 0x0f, 0x76, 0xef, 0x32, 0xf2, 0x73, 0x1a, 0x89,
	0x6b, 0x7f, 0x56, 0x01, 0xdd, 0xab, 0x45, 0xf7, 0x99, 0x49, 0x6b, 0xfc, 0x5b, 0xda, 0x53, 0x28,
	0x77, 0x9c, 0x1f, 0x03, 0x76, 0xd5, 0x75, 0x7c, 0x6a, 0xd2, 0xe0, 0x5a, 0xdc, 0xe8, 0x7b, 0xcf,
	0xd5, 0xd1, 0x1b, 0x38, 0x90, 0xb5, 0x76, 0x20, 0x28, 0xbb, 0x72, 0x46, 0x74, 0xce, 0x11, 0x7f,
	0x8f, 0x05, 0x54, 0x9f, 0xd1, 0x73, 0xc4, 0x0d, 0xef, 0x51, 0x86, 0x03, 0xc1, 0x66, 0x95, 0x47,
	0xc9, 0x19, 0x99, 0xba, 0x3e, 0xa3, 0xc7, 0x5c, 0xdf, 0x61, 0xb3, 0x08, 0x25, 0x8e, 0xd5, 0xe4,
	0x8c, 0x02, 0x8a, 0x5e, 0xc3, 0xbe, 0x24, 0x2d, 0x67, 0xf4, 0x7d, 0x3a, 0xc9, 0xd8, 0xd6, 0x94,
	0xad, 0x18, 0xa2, 0x06, 0x3c, 0x91, 0xa0, 0x33, 0xf1, 0xb8, 0xe9, 0x0c, 0xa9, 0x17, 0xc5, 0x88,
	0x78, 0x65, 0x5d, 0x99, 0x0a, 0x19, 0x3a, 0x83, 0xc7, 0xf2, 0x8f, 0x9c, 0xcb, 0xd0, 0x1e, 0x77,
	0xa7, 0x7e, 0x65, 0x43, 0x59, 0x8a, 0x90, 0x72, 0x64, 0x52, 0xc7, 0x8e, 0x4d, 0xed, 0xc8, 0x23,
	0x54, 0x07, 0x24, 0x37, 0x4a, 0x03, 0xc7, 0x06, 0x50, 0x86, 0x02, 0xa2, 0xf4, 0xf3, 0x0d, 0xc6,
	0xfa, 0x2d, 0xad, 0xcf, 0x11, 0x9d, 0x88, 0x50, 0x3f, 0x14, 0xb4, 0x39, 0x1e, 0x33, 0xca, 0x79,
	0x64, 0xd8, 0x4e, 0x12, 0xdd, 0x47, 0xe8, 0x25, 0xec, 0xc9, 0xb2, 0xd9, 0x68, 0x8d, 0xe7, 0x3e,
	0x7b, 0x49, 0xe9, 0xf3, 0x00, 0xbd, 0x85, 0xa7, 0xaa, 0xd8, 0xf3, 0xb9, 0xdb, 0x9f, 0x06, 0x01,
	0xf5, 0xda, 0x63, 0xed, 0xd9, 0x51, 0x9e, 0x45, 0xf8, 0xf4, 0xa7, 0x01, 0x7b, 0xb9, 0xa7, 0x89,
	0x4e, 0xe0, 0xb9, 0x65, 0xda, 0xe7, 0xe6, 0x65, 0xab, 0x69, 0xda, 0x78, 0x80, 0xbb, 0x7d, 0xbb,
	0xff, 0xb9, 0x87, 0x6d, 0x82, 0x2d, 0x4c, 0x06, 0xf8, 0x63, 0x79, 0x09, 0x1d, 0x41, 0xb5, 0x50,
	0x82, 0x09, 0xb9, 0x24, 0x65, 0x03, 0xd5, 0xe0, 0xa8, 0x90, 0x5f, 0xe0, 0x26, 0xe9, 0xb7, 0x70,
	0xb3, 0x5f, 0x5e, 0x46, 0xc7, 0x70, 0x58, 0xa8, 0x19, 0x60, 0x62, 0xb5, 0x2f, 0xbb, 0xe5, 0x95,
	0xc6, 0x2f, 0x03, 0x36, 0xee, 0xe2, 0xa1, 0x4e, 0x1a, 0x35, 0x7a, 0xc0, 0xf1, 0xe8, 0xa9, 0x2c,
	0x7a, 0xea, 0xd5, 0xc3, 0x87, 0x26, 0xd0, 0x99, 0x81, 0x3e, 0x45, 0x63, 0x32, 0x7d, 0xdc, 0xe8,
	0x68, 0x81, 0x5e, 0xbf, 0xfc, 0xea, 0xc9, 0xc3, 0x5c, 0x4e, 0x86, 0xe1, 0x9a, 0x9a, 0xee, 0xaf,
	0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0x37, 0x2c, 0x76, 0x7e, 0x16, 0x06, 0x00, 0x00,
}
