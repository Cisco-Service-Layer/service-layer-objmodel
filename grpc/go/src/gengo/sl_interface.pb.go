// Code generated by protoc-gen-go.
// source: sl_interface.proto
// DO NOT EDIT!

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The current state of the interface.
type SLInterfaceState int32

const (
	// State unknown.
	SLInterfaceState_SL_IF_STATE_UNKNOWN SLInterfaceState = 0
	// State Operationally down.
	SLInterfaceState_SL_IF_STATE_DOWN SLInterfaceState = 1
	// State Operationally up.
	SLInterfaceState_SL_IF_STATE_UP SLInterfaceState = 2
)

var SLInterfaceState_name = map[int32]string{
	0: "SL_IF_STATE_UNKNOWN",
	1: "SL_IF_STATE_DOWN",
	2: "SL_IF_STATE_UP",
}
var SLInterfaceState_value = map[string]int32{
	"SL_IF_STATE_UNKNOWN": 0,
	"SL_IF_STATE_DOWN":    1,
	"SL_IF_STATE_UP":      2,
}

func (x SLInterfaceState) String() string {
	return proto.EnumName(SLInterfaceState_name, int32(x))
}
func (SLInterfaceState) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

// Interface Event Notification types
type SLInterfaceNotifType int32

const (
	// Reserved. 0x0
	SLInterfaceNotifType_SL_INTERFACE_EVENT_TYPE_RESERVED SLInterfaceNotifType = 0
	// Error - ErrStatus field elaborates on the error. 0x1
	SLInterfaceNotifType_SL_INTERFACE_EVENT_TYPE_ERROR SLInterfaceNotifType = 1
	// Interface attributes and state event. 0x2
	SLInterfaceNotifType_SL_INTERFACE_EVENT_TYPE_INTERFACE_INFO SLInterfaceNotifType = 2
)

var SLInterfaceNotifType_name = map[int32]string{
	0: "SL_INTERFACE_EVENT_TYPE_RESERVED",
	1: "SL_INTERFACE_EVENT_TYPE_ERROR",
	2: "SL_INTERFACE_EVENT_TYPE_INTERFACE_INFO",
}
var SLInterfaceNotifType_value = map[string]int32{
	"SL_INTERFACE_EVENT_TYPE_RESERVED":       0,
	"SL_INTERFACE_EVENT_TYPE_ERROR":          1,
	"SL_INTERFACE_EVENT_TYPE_INTERFACE_INFO": 2,
}

func (x SLInterfaceNotifType) String() string {
	return proto.EnumName(SLInterfaceNotifType_name, int32(x))
}
func (SLInterfaceNotifType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

// Global Interface Registration Message.
// This message is used for interface global registration.
// Clients must register before using any interface service.
type SLInterfaceGlobalsRegMsg struct {
	// Registration Operation.
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,json=oper,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
}

func (m *SLInterfaceGlobalsRegMsg) Reset()                    { *m = SLInterfaceGlobalsRegMsg{} }
func (m *SLInterfaceGlobalsRegMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGlobalsRegMsg) ProtoMessage()               {}
func (*SLInterfaceGlobalsRegMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

// interface registration response message.
// This message is used to convey the result of the interface registration.
type SLInterfaceGlobalsRegMsgRsp struct {
	// Error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,json=errStatus" json:"ErrStatus,omitempty"`
}

func (m *SLInterfaceGlobalsRegMsgRsp) Reset()                    { *m = SLInterfaceGlobalsRegMsgRsp{} }
func (m *SLInterfaceGlobalsRegMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGlobalsRegMsgRsp) ProtoMessage()               {}
func (*SLInterfaceGlobalsRegMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *SLInterfaceGlobalsRegMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

// Global Interface Get message.
// This message is used to query interface global capabilities.
type SLInterfaceGlobalsGetMsg struct {
}

func (m *SLInterfaceGlobalsGetMsg) Reset()                    { *m = SLInterfaceGlobalsGetMsg{} }
func (m *SLInterfaceGlobalsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGlobalsGetMsg) ProtoMessage()               {}
func (*SLInterfaceGlobalsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

// Global interface Get response message.
// This message is used to convey the response to the global capabilities query.
type SLInterfaceGlobalsGetMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,json=errStatus" json:"ErrStatus,omitempty"`
	// Max interface objects within a single batch.
	MaxInterfacesPerBatch uint32 `protobuf:"varint,2,opt,name=MaxInterfacesPerBatch,json=maxInterfacesPerBatch" json:"MaxInterfacesPerBatch,omitempty"`
}

func (m *SLInterfaceGlobalsGetMsgRsp) Reset()                    { *m = SLInterfaceGlobalsGetMsgRsp{} }
func (m *SLInterfaceGlobalsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGlobalsGetMsgRsp) ProtoMessage()               {}
func (*SLInterfaceGlobalsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *SLInterfaceGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

// Global Interface Get stats message.
// This message is used to convey the response to the interface statistics
// query.
type SLInterfaceGlobalsGetStatsMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,json=errStatus" json:"ErrStatus,omitempty"`
	// Global Interface event sequence number.
	// The sequence number is equivalent to a timestamp
	SeqNum uint64 `protobuf:"varint,2,opt,name=SeqNum,json=seqNum" json:"SeqNum,omitempty"`
	// Num Interface notification requests added through the service layer.
	InterfaceNotifCount uint32 `protobuf:"varint,3,opt,name=InterfaceNotifCount,json=interfaceNotifCount" json:"InterfaceNotifCount,omitempty"`
}

func (m *SLInterfaceGlobalsGetStatsMsgRsp) Reset()         { *m = SLInterfaceGlobalsGetStatsMsgRsp{} }
func (m *SLInterfaceGlobalsGetStatsMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLInterfaceGlobalsGetStatsMsgRsp) ProtoMessage()    {}
func (*SLInterfaceGlobalsGetStatsMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor5, []int{4}
}

func (m *SLInterfaceGlobalsGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

// Interface Get message
type SLInterfaceGetMsg struct {
	// Interface key attributes.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLInterface `protobuf:"bytes,1,opt,name=Key,json=key" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount,json=entriesCount" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext,json=getNext" json:"GetNext,omitempty"`
}

func (m *SLInterfaceGetMsg) Reset()                    { *m = SLInterfaceGetMsg{} }
func (m *SLInterfaceGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGetMsg) ProtoMessage()               {}
func (*SLInterfaceGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *SLInterfaceGetMsg) GetKey() *SLInterface {
	if m != nil {
		return m.Key
	}
	return nil
}

// Interface Get Message result.
type SLInterfaceInfoMsg struct {
	// Interface info
	SLIfInfo *SLInterface `protobuf:"bytes,1,opt,name=SLIfInfo,json=sLIfInfo" json:"SLIfInfo,omitempty"`
	// Interface state
	IfState SLInterfaceState `protobuf:"varint,2,opt,name=IfState,json=ifState,enum=service_layer.SLInterfaceState" json:"IfState,omitempty"`
	// Global Interface event sequence number.
	// The sequence number is equivalent to a timestamp
	SeqNum uint64 `protobuf:"varint,3,opt,name=SeqNum,json=seqNum" json:"SeqNum,omitempty"`
}

func (m *SLInterfaceInfoMsg) Reset()                    { *m = SLInterfaceInfoMsg{} }
func (m *SLInterfaceInfoMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceInfoMsg) ProtoMessage()               {}
func (*SLInterfaceInfoMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *SLInterfaceInfoMsg) GetSLIfInfo() *SLInterface {
	if m != nil {
		return m.SLIfInfo
	}
	return nil
}

// Interface Get Message Response.
type SLInterfaceGetMsgRsp struct {
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,json=eof" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,json=errStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLInterfaceInfoMsg `protobuf:"bytes,3,rep,name=Entries,json=entries" json:"Entries,omitempty"`
}

func (m *SLInterfaceGetMsgRsp) Reset()                    { *m = SLInterfaceGetMsgRsp{} }
func (m *SLInterfaceGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGetMsgRsp) ProtoMessage()               {}
func (*SLInterfaceGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *SLInterfaceGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLInterfaceGetMsgRsp) GetEntries() []*SLInterfaceInfoMsg {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Interface Get Notification message.
type SLInterfaceGetNotifMsg struct {
}

func (m *SLInterfaceGetNotifMsg) Reset()                    { *m = SLInterfaceGetNotifMsg{} }
func (m *SLInterfaceGetNotifMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceGetNotifMsg) ProtoMessage()               {}
func (*SLInterfaceGetNotifMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

// Interface Notification Event.
type SLInterfaceNotif struct {
	// Interface Event Notification type
	EventType SLInterfaceNotifType `protobuf:"varint,1,opt,name=EventType,json=eventType,enum=service_layer.SLInterfaceNotifType" json:"EventType,omitempty"`
	// Further info based on EventType
	//
	// Types that are valid to be assigned to Event:
	//	*SLInterfaceNotif_ErrStatus
	//	*SLInterfaceNotif_Info
	Event isSLInterfaceNotif_Event `protobuf_oneof:"Event"`
}

func (m *SLInterfaceNotif) Reset()                    { *m = SLInterfaceNotif{} }
func (m *SLInterfaceNotif) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceNotif) ProtoMessage()               {}
func (*SLInterfaceNotif) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

type isSLInterfaceNotif_Event interface {
	isSLInterfaceNotif_Event()
}

type SLInterfaceNotif_ErrStatus struct {
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,json=errStatus,oneof"`
}
type SLInterfaceNotif_Info struct {
	Info *SLInterfaceInfoMsg `protobuf:"bytes,3,opt,name=Info,json=info,oneof"`
}

func (*SLInterfaceNotif_ErrStatus) isSLInterfaceNotif_Event() {}
func (*SLInterfaceNotif_Info) isSLInterfaceNotif_Event()      {}

func (m *SLInterfaceNotif) GetEvent() isSLInterfaceNotif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLInterfaceNotif) GetErrStatus() *SLErrorStatus {
	if x, ok := m.GetEvent().(*SLInterfaceNotif_ErrStatus); ok {
		return x.ErrStatus
	}
	return nil
}

func (m *SLInterfaceNotif) GetInfo() *SLInterfaceInfoMsg {
	if x, ok := m.GetEvent().(*SLInterfaceNotif_Info); ok {
		return x.Info
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLInterfaceNotif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLInterfaceNotif_OneofMarshaler, _SLInterfaceNotif_OneofUnmarshaler, _SLInterfaceNotif_OneofSizer, []interface{}{
		(*SLInterfaceNotif_ErrStatus)(nil),
		(*SLInterfaceNotif_Info)(nil),
	}
}

func _SLInterfaceNotif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLInterfaceNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLInterfaceNotif_ErrStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrStatus); err != nil {
			return err
		}
	case *SLInterfaceNotif_Info:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLInterfaceNotif.Event has unexpected type %T", x)
	}
	return nil
}

func _SLInterfaceNotif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLInterfaceNotif)
	switch tag {
	case 2: // Event.ErrStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLErrorStatus)
		err := b.DecodeMessage(msg)
		m.Event = &SLInterfaceNotif_ErrStatus{msg}
		return true, err
	case 3: // Event.Info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLInterfaceInfoMsg)
		err := b.DecodeMessage(msg)
		m.Event = &SLInterfaceNotif_Info{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLInterfaceNotif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLInterfaceNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLInterfaceNotif_ErrStatus:
		s := proto.Size(x.ErrStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLInterfaceNotif_Info:
		s := proto.Size(x.Info)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Interface Notification message.
type SLInterfaceNotifMsg struct {
	// Notification Operation.
	Oper SLNotifOp `protobuf:"varint,1,opt,name=Oper,json=oper,enum=service_layer.SLNotifOp" json:"Oper,omitempty"`
	// Interface key attributes.
	Entries []*SLInterface `protobuf:"bytes,2,rep,name=Entries,json=entries" json:"Entries,omitempty"`
}

func (m *SLInterfaceNotifMsg) Reset()                    { *m = SLInterfaceNotifMsg{} }
func (m *SLInterfaceNotifMsg) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceNotifMsg) ProtoMessage()               {}
func (*SLInterfaceNotifMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *SLInterfaceNotifMsg) GetEntries() []*SLInterface {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Interface Notification message result.
type SLInterfaceNotifMsgRes struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,json=errStatus" json:"ErrStatus,omitempty"`
	// Interface key attributes.
	Key *SLInterface `protobuf:"bytes,2,opt,name=Key,json=key" json:"Key,omitempty"`
}

func (m *SLInterfaceNotifMsgRes) Reset()                    { *m = SLInterfaceNotifMsgRes{} }
func (m *SLInterfaceNotifMsgRes) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceNotifMsgRes) ProtoMessage()               {}
func (*SLInterfaceNotifMsgRes) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *SLInterfaceNotifMsgRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLInterfaceNotifMsgRes) GetKey() *SLInterface {
	if m != nil {
		return m.Key
	}
	return nil
}

// Interface Notification message response.
type SLInterfaceNotifMsgRsp struct {
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary,json=statusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLInterfaceNotifMsgRes `protobuf:"bytes,2,rep,name=Results,json=results" json:"Results,omitempty"`
}

func (m *SLInterfaceNotifMsgRsp) Reset()                    { *m = SLInterfaceNotifMsgRsp{} }
func (m *SLInterfaceNotifMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLInterfaceNotifMsgRsp) ProtoMessage()               {}
func (*SLInterfaceNotifMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{12} }

func (m *SLInterfaceNotifMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLInterfaceNotifMsgRsp) GetResults() []*SLInterfaceNotifMsgRes {
	if m != nil {
		return m.Results
	}
	return nil
}

func init() {
	proto.RegisterType((*SLInterfaceGlobalsRegMsg)(nil), "service_layer.SLInterfaceGlobalsRegMsg")
	proto.RegisterType((*SLInterfaceGlobalsRegMsgRsp)(nil), "service_layer.SLInterfaceGlobalsRegMsgRsp")
	proto.RegisterType((*SLInterfaceGlobalsGetMsg)(nil), "service_layer.SLInterfaceGlobalsGetMsg")
	proto.RegisterType((*SLInterfaceGlobalsGetMsgRsp)(nil), "service_layer.SLInterfaceGlobalsGetMsgRsp")
	proto.RegisterType((*SLInterfaceGlobalsGetStatsMsgRsp)(nil), "service_layer.SLInterfaceGlobalsGetStatsMsgRsp")
	proto.RegisterType((*SLInterfaceGetMsg)(nil), "service_layer.SLInterfaceGetMsg")
	proto.RegisterType((*SLInterfaceInfoMsg)(nil), "service_layer.SLInterfaceInfoMsg")
	proto.RegisterType((*SLInterfaceGetMsgRsp)(nil), "service_layer.SLInterfaceGetMsgRsp")
	proto.RegisterType((*SLInterfaceGetNotifMsg)(nil), "service_layer.SLInterfaceGetNotifMsg")
	proto.RegisterType((*SLInterfaceNotif)(nil), "service_layer.SLInterfaceNotif")
	proto.RegisterType((*SLInterfaceNotifMsg)(nil), "service_layer.SLInterfaceNotifMsg")
	proto.RegisterType((*SLInterfaceNotifMsgRes)(nil), "service_layer.SLInterfaceNotifMsgRes")
	proto.RegisterType((*SLInterfaceNotifMsgRsp)(nil), "service_layer.SLInterfaceNotifMsgRsp")
	proto.RegisterEnum("service_layer.SLInterfaceState", SLInterfaceState_name, SLInterfaceState_value)
	proto.RegisterEnum("service_layer.SLInterfaceNotifType", SLInterfaceNotifType_name, SLInterfaceNotifType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for SLInterfaceOper service

type SLInterfaceOperClient interface {
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_REGISTER:
	//     Global Interface registration.
	//     A client Must Register BEFORE interfaces can be modified/queried.
	//
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     Global Interface un-registration.
	//     This call is used to end all interface notifications.
	//     This call cleans up all interface notifications previously requested.
	//
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_EOF:
	//     Interface End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their interfaces.
	SLInterfaceGlobalsRegOp(ctx context.Context, in *SLInterfaceGlobalsRegMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsRegMsgRsp, error)
	// Used to retrieve global Interface info from the server.
	SLInterfaceGlobalsGet(ctx context.Context, in *SLInterfaceGlobalsGetMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsGetMsgRsp, error)
	// Used to retrieve global Interface stats from the server.
	SLInterfaceGlobalsGetStats(ctx context.Context, in *SLInterfaceGlobalsGetMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsGetStatsMsgRsp, error)
	// Retrieve interface attributes and state.
	// This call can be used to "poll" the current state of interfaces.
	SLInterfaceGet(ctx context.Context, in *SLInterfaceGetMsg, opts ...grpc.CallOption) (*SLInterfaceGetMsgRsp, error)
	// This call is used to get a stream of interface notifications.
	// The caller must maintain the GRPC channel as long as
	// there is interest in interface notifications.
	// This call can be used to get "push" notifications for interface info.
	// It is advised that the caller register for notifications before any
	// interfaces are used to avoid any loss of notifications.
	SLInterfaceGetNotifStream(ctx context.Context, in *SLInterfaceGetNotifMsg, opts ...grpc.CallOption) (SLInterfaceOper_SLInterfaceGetNotifStreamClient, error)
	// Used to enable/disable event notifications for a certain interface.
	// By default, all interface events are disabled. The user must enable
	// notifications for the interested interfaces.
	SLInterfaceNotifOp(ctx context.Context, in *SLInterfaceNotifMsg, opts ...grpc.CallOption) (*SLInterfaceNotifMsgRsp, error)
}

type sLInterfaceOperClient struct {
	cc *grpc.ClientConn
}

func NewSLInterfaceOperClient(cc *grpc.ClientConn) SLInterfaceOperClient {
	return &sLInterfaceOperClient{cc}
}

func (c *sLInterfaceOperClient) SLInterfaceGlobalsRegOp(ctx context.Context, in *SLInterfaceGlobalsRegMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsRegMsgRsp, error) {
	out := new(SLInterfaceGlobalsRegMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLInterfaceOper/SLInterfaceGlobalsRegOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLInterfaceOperClient) SLInterfaceGlobalsGet(ctx context.Context, in *SLInterfaceGlobalsGetMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsGetMsgRsp, error) {
	out := new(SLInterfaceGlobalsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLInterfaceOper/SLInterfaceGlobalsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLInterfaceOperClient) SLInterfaceGlobalsGetStats(ctx context.Context, in *SLInterfaceGlobalsGetMsg, opts ...grpc.CallOption) (*SLInterfaceGlobalsGetStatsMsgRsp, error) {
	out := new(SLInterfaceGlobalsGetStatsMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLInterfaceOper/SLInterfaceGlobalsGetStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLInterfaceOperClient) SLInterfaceGet(ctx context.Context, in *SLInterfaceGetMsg, opts ...grpc.CallOption) (*SLInterfaceGetMsgRsp, error) {
	out := new(SLInterfaceGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLInterfaceOper/SLInterfaceGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLInterfaceOperClient) SLInterfaceGetNotifStream(ctx context.Context, in *SLInterfaceGetNotifMsg, opts ...grpc.CallOption) (SLInterfaceOper_SLInterfaceGetNotifStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLInterfaceOper_serviceDesc.Streams[0], c.cc, "/service_layer.SLInterfaceOper/SLInterfaceGetNotifStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLInterfaceOperSLInterfaceGetNotifStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SLInterfaceOper_SLInterfaceGetNotifStreamClient interface {
	Recv() (*SLInterfaceNotif, error)
	grpc.ClientStream
}

type sLInterfaceOperSLInterfaceGetNotifStreamClient struct {
	grpc.ClientStream
}

func (x *sLInterfaceOperSLInterfaceGetNotifStreamClient) Recv() (*SLInterfaceNotif, error) {
	m := new(SLInterfaceNotif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLInterfaceOperClient) SLInterfaceNotifOp(ctx context.Context, in *SLInterfaceNotifMsg, opts ...grpc.CallOption) (*SLInterfaceNotifMsgRsp, error) {
	out := new(SLInterfaceNotifMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLInterfaceOper/SLInterfaceNotifOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SLInterfaceOper service

type SLInterfaceOperServer interface {
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_REGISTER:
	//     Global Interface registration.
	//     A client Must Register BEFORE interfaces can be modified/queried.
	//
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     Global Interface un-registration.
	//     This call is used to end all interface notifications.
	//     This call cleans up all interface notifications previously requested.
	//
	// SLInterfaceGlobalsRegMsg.Oper = SL_REGOP_EOF:
	//     Interface End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their interfaces.
	SLInterfaceGlobalsRegOp(context.Context, *SLInterfaceGlobalsRegMsg) (*SLInterfaceGlobalsRegMsgRsp, error)
	// Used to retrieve global Interface info from the server.
	SLInterfaceGlobalsGet(context.Context, *SLInterfaceGlobalsGetMsg) (*SLInterfaceGlobalsGetMsgRsp, error)
	// Used to retrieve global Interface stats from the server.
	SLInterfaceGlobalsGetStats(context.Context, *SLInterfaceGlobalsGetMsg) (*SLInterfaceGlobalsGetStatsMsgRsp, error)
	// Retrieve interface attributes and state.
	// This call can be used to "poll" the current state of interfaces.
	SLInterfaceGet(context.Context, *SLInterfaceGetMsg) (*SLInterfaceGetMsgRsp, error)
	// This call is used to get a stream of interface notifications.
	// The caller must maintain the GRPC channel as long as
	// there is interest in interface notifications.
	// This call can be used to get "push" notifications for interface info.
	// It is advised that the caller register for notifications before any
	// interfaces are used to avoid any loss of notifications.
	SLInterfaceGetNotifStream(*SLInterfaceGetNotifMsg, SLInterfaceOper_SLInterfaceGetNotifStreamServer) error
	// Used to enable/disable event notifications for a certain interface.
	// By default, all interface events are disabled. The user must enable
	// notifications for the interested interfaces.
	SLInterfaceNotifOp(context.Context, *SLInterfaceNotifMsg) (*SLInterfaceNotifMsgRsp, error)
}

func RegisterSLInterfaceOperServer(s *grpc.Server, srv SLInterfaceOperServer) {
	s.RegisterService(&_SLInterfaceOper_serviceDesc, srv)
}

func _SLInterfaceOper_SLInterfaceGlobalsRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SLInterfaceGlobalsRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SLInterfaceOperServer).SLInterfaceGlobalsRegOp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SLInterfaceOper_SLInterfaceGlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SLInterfaceGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SLInterfaceOperServer).SLInterfaceGlobalsGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SLInterfaceOper_SLInterfaceGlobalsGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SLInterfaceGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SLInterfaceOperServer).SLInterfaceGlobalsGetStats(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SLInterfaceOper_SLInterfaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SLInterfaceGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SLInterfaceOperServer).SLInterfaceGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SLInterfaceOper_SLInterfaceGetNotifStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SLInterfaceGetNotifMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SLInterfaceOperServer).SLInterfaceGetNotifStream(m, &sLInterfaceOperSLInterfaceGetNotifStreamServer{stream})
}

type SLInterfaceOper_SLInterfaceGetNotifStreamServer interface {
	Send(*SLInterfaceNotif) error
	grpc.ServerStream
}

type sLInterfaceOperSLInterfaceGetNotifStreamServer struct {
	grpc.ServerStream
}

func (x *sLInterfaceOperSLInterfaceGetNotifStreamServer) Send(m *SLInterfaceNotif) error {
	return x.ServerStream.SendMsg(m)
}

func _SLInterfaceOper_SLInterfaceNotifOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SLInterfaceNotifMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SLInterfaceOperServer).SLInterfaceNotifOp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _SLInterfaceOper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLInterfaceOper",
	HandlerType: (*SLInterfaceOperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLInterfaceGlobalsRegOp",
			Handler:    _SLInterfaceOper_SLInterfaceGlobalsRegOp_Handler,
		},
		{
			MethodName: "SLInterfaceGlobalsGet",
			Handler:    _SLInterfaceOper_SLInterfaceGlobalsGet_Handler,
		},
		{
			MethodName: "SLInterfaceGlobalsGetStats",
			Handler:    _SLInterfaceOper_SLInterfaceGlobalsGetStats_Handler,
		},
		{
			MethodName: "SLInterfaceGet",
			Handler:    _SLInterfaceOper_SLInterfaceGet_Handler,
		},
		{
			MethodName: "SLInterfaceNotifOp",
			Handler:    _SLInterfaceOper_SLInterfaceNotifOp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLInterfaceGetNotifStream",
			Handler:       _SLInterfaceOper_SLInterfaceGetNotifStream_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor5 = []byte{
	// 822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x4f, 0xdb, 0x4a,
	0x14, 0xc5, 0x71, 0xc0, 0xe1, 0x3e, 0xc2, 0xcb, 0x1b, 0x08, 0xe4, 0xe5, 0xbd, 0x0a, 0x30, 0xa5,
	0xad, 0xa2, 0x8a, 0xa2, 0xb4, 0x6a, 0xd5, 0x0f, 0xa9, 0xe2, 0xc3, 0xa1, 0x11, 0xe0, 0xa0, 0x71,
	0x00, 0xb1, 0xb2, 0x4c, 0x34, 0xa1, 0x51, 0x93, 0x38, 0xf5, 0x38, 0x88, 0xac, 0x2a, 0x75, 0x55,
	0xa9, 0x8b, 0xfe, 0x82, 0xaa, 0xea, 0xae, 0x7f, 0xa8, 0xff, 0xa7, 0x33, 0x63, 0x27, 0xd8, 0x4d,
	0x4c, 0x8c, 0xe8, 0x2e, 0x9e, 0x39, 0xf7, 0xdc, 0x33, 0x67, 0xee, 0xbd, 0x13, 0x40, 0xb4, 0x69,
	0x36, 0xda, 0x2e, 0x71, 0xea, 0x56, 0x8d, 0xac, 0x77, 0x1c, 0xdb, 0xb5, 0x51, 0x9a, 0x12, 0xe7,
	0xa2, 0x51, 0x23, 0x66, 0xd3, 0xea, 0x11, 0x27, 0x9f, 0x65, 0x90, 0x9a, 0xdd, 0x6a, 0xd9, 0x6d,
	0xd3, 0xed, 0x75, 0x08, 0xf5, 0x50, 0x6a, 0x09, 0x72, 0xc6, 0x7e, 0xb9, 0x1f, 0xba, 0xdb, 0xb4,
	0xcf, 0xac, 0x26, 0xc5, 0xe4, 0xfc, 0x80, 0x9e, 0xa3, 0x02, 0x24, 0x2b, 0x1d, 0xe2, 0xe4, 0xa4,
	0x65, 0xe9, 0xc1, 0x6c, 0x71, 0x61, 0x3d, 0x44, 0xb8, 0x6e, 0xec, 0x33, 0x58, 0xa5, 0x83, 0x93,
	0x36, 0xc3, 0xa8, 0xa7, 0xf0, 0x5f, 0x14, 0x0f, 0xa6, 0x1d, 0xf4, 0x02, 0xa6, 0x35, 0xc7, 0x31,
	0x5c, 0xcb, 0xed, 0x52, 0xc1, 0xf7, 0x57, 0xf1, 0xff, 0x21, 0x3e, 0x86, 0xb0, 0x7d, 0x0c, 0x9e,
	0x26, 0x7d, 0xb8, 0x9a, 0x1f, 0x25, 0x71, 0x97, 0xb8, 0x8c, 0x5a, 0xfd, 0x22, 0x8d, 0xca, 0xeb,
	0x6d, 0xde, 0x32, 0x2f, 0x7a, 0x02, 0xd9, 0x03, 0xeb, 0x72, 0xc0, 0x4d, 0x0f, 0x89, 0xb3, 0x65,
	0xb9, 0xb5, 0xb7, 0xb9, 0x04, 0xe3, 0x49, 0xe3, 0x6c, 0x6b, 0xd4, 0xa6, 0xfa, 0x43, 0x82, 0xe5,
	0x91, 0x8a, 0x38, 0x2b, 0xfd, 0x03, 0xb2, 0x16, 0x60, 0xca, 0x20, 0xef, 0xf5, 0x6e, 0x4b, 0xe8,
	0x48, 0xe2, 0x29, 0x2a, 0xbe, 0xd0, 0x06, 0xcc, 0x0d, 0xb2, 0xea, 0xb6, 0xdb, 0xa8, 0x6f, 0xdb,
	0xdd, 0xb6, 0x9b, 0x93, 0x85, 0xd8, 0xb9, 0xc6, 0xf0, 0x96, 0xfa, 0x01, 0xfe, 0x09, 0x2a, 0x15,
	0xa6, 0xa1, 0x87, 0x20, 0xef, 0x91, 0x9e, 0x2f, 0x2a, 0x3f, 0x24, 0x6a, 0x00, 0xc7, 0xf2, 0x3b,
	0xd2, 0x43, 0x2a, 0xcc, 0x68, 0x6d, 0xd7, 0x69, 0x10, 0xea, 0x65, 0xf3, 0xac, 0x99, 0x21, 0x81,
	0x35, 0x94, 0x03, 0x85, 0x71, 0xeb, 0xe4, 0xd2, 0x13, 0x93, 0xc2, 0xca, 0xb9, 0xf7, 0xa9, 0x7e,
	0x93, 0x00, 0x05, 0x28, 0xcb, 0xed, 0xba, 0xcd, 0x25, 0x3c, 0x85, 0x14, 0x5b, 0xad, 0xf3, 0xcf,
	0x18, 0x3a, 0x52, 0xd4, 0xc7, 0xa2, 0xe7, 0xa0, 0x94, 0xeb, 0xdc, 0x25, 0x22, 0x74, 0xcc, 0x16,
	0x97, 0xa2, 0xc3, 0x04, 0x0c, 0x2b, 0x0d, 0x0f, 0x1f, 0x30, 0x55, 0x0e, 0x9a, 0xaa, 0x7e, 0x97,
	0x60, 0x7e, 0xc8, 0x23, 0x7e, 0x83, 0x19, 0x90, 0x35, 0xbb, 0x2e, 0xe4, 0xa5, 0xb0, 0x4c, 0xec,
	0x7a, 0xf8, 0x4e, 0x13, 0x37, 0xbb, 0xd3, 0x97, 0xa0, 0xf8, 0x36, 0xb2, 0xfc, 0x32, 0x8b, 0x5c,
	0x89, 0x56, 0xee, 0xbb, 0x84, 0x15, 0xdf, 0x64, 0x35, 0x07, 0x0b, 0x61, 0x89, 0xe2, 0x8a, 0x79,
	0x77, 0xfc, 0x94, 0x20, 0x13, 0xd8, 0x12, 0xeb, 0x68, 0x93, 0xe9, 0xbc, 0x60, 0xb1, 0x55, 0x36,
	0x05, 0xfc, 0xd6, 0x5e, 0x8d, 0xce, 0x26, 0x62, 0x38, 0x94, 0xc9, 0xed, 0x47, 0xa1, 0x57, 0x37,
	0x3c, 0xea, 0x9b, 0x89, 0xe0, 0x61, 0x9f, 0x41, 0x52, 0x5c, 0xad, 0x2c, 0x02, 0xc7, 0x9f, 0x94,
	0x45, 0x27, 0x1b, 0xec, 0xe7, 0x96, 0x02, 0x93, 0x42, 0xb9, 0xda, 0x83, 0xb9, 0xdf, 0x25, 0x7a,
	0xa5, 0x1b, 0x9c, 0x57, 0xb9, 0x21, 0x62, 0x01, 0xec, 0x4f, 0x2c, 0xd6, 0xde, 0x03, 0xcf, 0x13,
	0xc2, 0xf3, 0xeb, 0x8a, 0x6c, 0x60, 0xf6, 0x47, 0x29, 0xe4, 0x76, 0x3f, 0x37, 0x26, 0xf4, 0x56,
	0x4d, 0xed, 0x77, 0x5d, 0x22, 0x56, 0xd7, 0xa9, 0x5f, 0x23, 0x44, 0xb0, 0xba, 0xdc, 0x82, 0xb4,
	0x47, 0x69, 0x74, 0x5b, 0x2d, 0xcb, 0xe9, 0xc5, 0x12, 0x92, 0xa6, 0xc1, 0x10, 0xf4, 0x1a, 0x14,
	0x76, 0x9e, 0x6e, 0xd3, 0xed, 0x3b, 0xb3, 0x36, 0xa6, 0x3e, 0x3c, 0x03, 0xb0, 0xe2, 0x78, 0x51,
	0x85, 0xa3, 0x50, 0xd9, 0x79, 0x1d, 0xb6, 0xc8, 0xef, 0xcc, 0x2c, 0x97, 0x4c, 0xa3, 0xba, 0x59,
	0xd5, 0xcc, 0x23, 0x7d, 0x4f, 0xaf, 0x9c, 0xe8, 0x99, 0x09, 0x34, 0xcf, 0xc1, 0x57, 0x1b, 0x3b,
	0x7c, 0x55, 0x42, 0x08, 0x66, 0x43, 0xf0, 0xc3, 0x4c, 0xa2, 0xf0, 0x39, 0xdc, 0x8c, 0x83, 0xd2,
	0x44, 0x77, 0xf9, 0xc8, 0x35, 0xcb, 0x7a, 0x55, 0xc3, 0xa5, 0xcd, 0x6d, 0xcd, 0xd4, 0x8e, 0x35,
	0xbd, 0x6a, 0x56, 0x4f, 0x0f, 0x35, 0x13, 0x6b, 0x86, 0x86, 0x8f, 0xb5, 0x1d, 0x96, 0x68, 0x05,
	0xee, 0x44, 0xa1, 0x34, 0x8c, 0x2b, 0x98, 0x65, 0x2d, 0xc0, 0xbd, 0x28, 0xc8, 0xd5, 0x62, 0x59,
	0x2f, 0x55, 0x32, 0x89, 0xe2, 0xa7, 0x49, 0xf8, 0x3b, 0xa0, 0x86, 0x57, 0x1e, 0x6a, 0xc3, 0xe2,
	0xc8, 0x57, 0xb0, 0xd2, 0x41, 0xf7, 0xa3, 0x3d, 0x0c, 0xbd, 0x96, 0xf9, 0x42, 0x4c, 0x20, 0xbf,
	0xed, 0x26, 0x64, 0x47, 0xbe, 0x35, 0x31, 0xb2, 0x79, 0xa3, 0x2c, 0x46, 0xb6, 0xab, 0x99, 0x77,
	0x01, 0xf9, 0xe8, 0x97, 0x2d, 0x7e, 0xca, 0x47, 0x71, 0x80, 0xc1, 0xd7, 0xf2, 0x84, 0xd7, 0x42,
	0x70, 0xc0, 0xa1, 0xe5, 0x6b, 0x28, 0xbc, 0x24, 0xab, 0xe3, 0x10, 0x9c, 0x98, 0xc0, 0xbf, 0x23,
	0x26, 0xa7, 0xe1, 0x3a, 0xc4, 0x6a, 0xa1, 0xb5, 0x6b, 0x19, 0xfa, 0x75, 0x9f, 0x5f, 0x1a, 0xd3,
	0x1b, 0x1b, 0x12, 0x32, 0x43, 0xaf, 0x9c, 0x3f, 0x85, 0x90, 0x3a, 0xbe, 0xa9, 0xf2, 0x71, 0x1a,
	0x8f, 0x76, 0xce, 0xa6, 0xc4, 0x7f, 0xb9, 0xc7, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xae,
	0xcb, 0x0b, 0x07, 0x0a, 0x00, 0x00,
}
