// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_l2_route.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// L2 Route Types that can be programmed by client.
type SLL2RouteType int32

const (
	// Reserved. 0x0
	SLL2RouteType_SL_L2_ROUTE_RESERVED SLL2RouteType = 0
	// Mac-IP route. 0x1
	SLL2RouteType_SL_L2_ROUTE_MAC SLL2RouteType = 1
	// Inclusive Multicast Ethernet Tag (IMET) route. 0x2
	SLL2RouteType_SL_L2_ROUTE_IMET SLL2RouteType = 2
)

var SLL2RouteType_name = map[int32]string{
	0: "SL_L2_ROUTE_RESERVED",
	1: "SL_L2_ROUTE_MAC",
	2: "SL_L2_ROUTE_IMET",
}
var SLL2RouteType_value = map[string]int32{
	"SL_L2_ROUTE_RESERVED": 0,
	"SL_L2_ROUTE_MAC":      1,
	"SL_L2_ROUTE_IMET":     2,
}

func (x SLL2RouteType) String() string {
	return proto.EnumName(SLL2RouteType_name, int32(x))
}
func (SLL2RouteType) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

// L2 Notification types
type SLL2NotifType int32

const (
	// Reserved.
	SLL2NotifType_SL_L2_EVENT_TYPE_RESERVED SLL2NotifType = 0
	// Error - ErrStatus field elaborates on the error.
	// The client can decide to close the stream based on the error.
	SLL2NotifType_SL_L2_EVENT_TYPE_ERROR SLL2NotifType = 1
	// Status of GetNotifMsg.
	// NotifStatus field elaborates on the result
	// If the GetNotifMsg is per-BD and there was an error, only the
	// notification for the BD in the status message is not setup.
	SLL2NotifType_SL_L2_EVENT_TYPE_STATUS SLL2NotifType = 2
	// Start marker - sent before any notification is sent.
	// This is an indication to stale any objects received until now.
	SLL2NotifType_SL_L2_EVENT_TYPE_START_MARKER SLL2NotifType = 3
	// BD configuration notification
	SLL2NotifType_SL_L2_EVENT_TYPE_BD_STATE SLL2NotifType = 4
	// End marker for BD configuration notifications.
	// This is an indication to sweep any staled BD states if present.
	SLL2NotifType_SL_L2_EVENT_TYPE_BD_STATE_END_MARKER SLL2NotifType = 5
	// L2 route
	SLL2NotifType_SL_L2_EVENT_TYPE_ROUTE SLL2NotifType = 6
	// End marker for Route notifications.
	// This is an indication to sweep any staled routes if present.
	SLL2NotifType_SL_L2_EVENT_TYPE_ROUTE_END_MARKER SLL2NotifType = 7
)

var SLL2NotifType_name = map[int32]string{
	0: "SL_L2_EVENT_TYPE_RESERVED",
	1: "SL_L2_EVENT_TYPE_ERROR",
	2: "SL_L2_EVENT_TYPE_STATUS",
	3: "SL_L2_EVENT_TYPE_START_MARKER",
	4: "SL_L2_EVENT_TYPE_BD_STATE",
	5: "SL_L2_EVENT_TYPE_BD_STATE_END_MARKER",
	6: "SL_L2_EVENT_TYPE_ROUTE",
	7: "SL_L2_EVENT_TYPE_ROUTE_END_MARKER",
}
var SLL2NotifType_value = map[string]int32{
	"SL_L2_EVENT_TYPE_RESERVED":            0,
	"SL_L2_EVENT_TYPE_ERROR":               1,
	"SL_L2_EVENT_TYPE_STATUS":              2,
	"SL_L2_EVENT_TYPE_START_MARKER":        3,
	"SL_L2_EVENT_TYPE_BD_STATE":            4,
	"SL_L2_EVENT_TYPE_BD_STATE_END_MARKER": 5,
	"SL_L2_EVENT_TYPE_ROUTE":               6,
	"SL_L2_EVENT_TYPE_ROUTE_END_MARKER":    7,
}

func (x SLL2NotifType) String() string {
	return proto.EnumName(SLL2NotifType_name, int32(x))
}
func (SLL2NotifType) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

// Next Hop types
type SLL2RouteNh_SLL2RouteNhType int32

const (
	// Reserved. 0x0
	SLL2RouteNh_SL_L2_NH_RESERVED SLL2RouteNh_SLL2RouteNhType = 0
	// Interface nexthop. 0x1
	SLL2RouteNh_SL_L2_NH_INTERFACE SLL2RouteNh_SLL2RouteNhType = 1
	// Overlay nexthop. 0x2
	SLL2RouteNh_SL_L2_NH_OVERLAY SLL2RouteNh_SLL2RouteNhType = 2
)

var SLL2RouteNh_SLL2RouteNhType_name = map[int32]string{
	0: "SL_L2_NH_RESERVED",
	1: "SL_L2_NH_INTERFACE",
	2: "SL_L2_NH_OVERLAY",
}
var SLL2RouteNh_SLL2RouteNhType_value = map[string]int32{
	"SL_L2_NH_RESERVED":  0,
	"SL_L2_NH_INTERFACE": 1,
	"SL_L2_NH_OVERLAY":   2,
}

func (x SLL2RouteNh_SLL2RouteNhType) String() string {
	return proto.EnumName(SLL2RouteNh_SLL2RouteNhType_name, int32(x))
}
func (SLL2RouteNh_SLL2RouteNhType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor6, []int{8, 0}
}

// Provider Multicast Service Interface (PMSI) tunnel type.
type SLL2ImetRoute_PMSITunnelType int32

const (
	// No tunnel information present. 0x0
	SLL2ImetRoute_PMSI_NO_TUNNEL SLL2ImetRoute_PMSITunnelType = 0
	// RSVP-TE P2MP LSP. 0x1
	SLL2ImetRoute_PMSI_RSVPP2MP_TUNNEL SLL2ImetRoute_PMSITunnelType = 1
	// mLDP P2MP LSP. 0x2
	SLL2ImetRoute_PMSI_MLDPP2MP_TUNNEL SLL2ImetRoute_PMSITunnelType = 2
	// PIM-SSM Tree. 0x3
	SLL2ImetRoute_PMSI_PIMSSM_TUNNEL SLL2ImetRoute_PMSITunnelType = 3
	// PIM-SM Tree. 0x4
	SLL2ImetRoute_PMSI_PIMSM_TUNNEL SLL2ImetRoute_PMSITunnelType = 4
	// BIDIR-PIM Tree. 0x5
	SLL2ImetRoute_PMSI_PIMBIDIR_TUNNEL SLL2ImetRoute_PMSITunnelType = 5
	// Ingress Replication. 0x6
	SLL2ImetRoute_PMSI_INGREP_TUNNEL SLL2ImetRoute_PMSITunnelType = 6
	// mLDP MP2MP LSP. 0x7
	SLL2ImetRoute_PMSI_MLDPMP2MP_TUNNEL SLL2ImetRoute_PMSITunnelType = 7
)

var SLL2ImetRoute_PMSITunnelType_name = map[int32]string{
	0: "PMSI_NO_TUNNEL",
	1: "PMSI_RSVPP2MP_TUNNEL",
	2: "PMSI_MLDPP2MP_TUNNEL",
	3: "PMSI_PIMSSM_TUNNEL",
	4: "PMSI_PIMSM_TUNNEL",
	5: "PMSI_PIMBIDIR_TUNNEL",
	6: "PMSI_INGREP_TUNNEL",
	7: "PMSI_MLDPMP2MP_TUNNEL",
}
var SLL2ImetRoute_PMSITunnelType_value = map[string]int32{
	"PMSI_NO_TUNNEL":        0,
	"PMSI_RSVPP2MP_TUNNEL":  1,
	"PMSI_MLDPP2MP_TUNNEL":  2,
	"PMSI_PIMSSM_TUNNEL":    3,
	"PMSI_PIMSM_TUNNEL":     4,
	"PMSI_PIMBIDIR_TUNNEL":  5,
	"PMSI_INGREP_TUNNEL":    6,
	"PMSI_MLDPMP2MP_TUNNEL": 7,
}

func (x SLL2ImetRoute_PMSITunnelType) String() string {
	return proto.EnumName(SLL2ImetRoute_PMSITunnelType_name, int32(x))
}
func (SLL2ImetRoute_PMSITunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor6, []int{13, 0}
}

// BD states
type SLL2BdStateInfo_SLL2BdState int32

const (
	// Reserved. 0x0
	SLL2BdStateInfo_SL_L2_BD_STATE_RESERVED SLL2BdStateInfo_SLL2BdState = 0
	// BD Added State.
	// Implies BD is ready for programming and notification request. 0x1
	SLL2BdStateInfo_SL_L2_BD_STATE_ADDED SLL2BdStateInfo_SLL2BdState = 1
	// BD Deleted State.
	// Implies BD has been deleted, all installed routes will be
	// deleted and no further notifications will be sent. 0x2
	SLL2BdStateInfo_SL_L2_BD_STATE_DELETED SLL2BdStateInfo_SLL2BdState = 2
	// BD Replay Needed.
	// Implies the routes in this BD could not be recovered and the
	// client has to replay the routes. 0x3
	SLL2BdStateInfo_SL_L2_BD_STATE_REPLAY_NEEDED SLL2BdStateInfo_SLL2BdState = 3
)

var SLL2BdStateInfo_SLL2BdState_name = map[int32]string{
	0: "SL_L2_BD_STATE_RESERVED",
	1: "SL_L2_BD_STATE_ADDED",
	2: "SL_L2_BD_STATE_DELETED",
	3: "SL_L2_BD_STATE_REPLAY_NEEDED",
}
var SLL2BdStateInfo_SLL2BdState_value = map[string]int32{
	"SL_L2_BD_STATE_RESERVED":      0,
	"SL_L2_BD_STATE_ADDED":         1,
	"SL_L2_BD_STATE_DELETED":       2,
	"SL_L2_BD_STATE_REPLAY_NEEDED": 3,
}

func (x SLL2BdStateInfo_SLL2BdState) String() string {
	return proto.EnumName(SLL2BdStateInfo_SLL2BdState_name, int32(x))
}
func (SLL2BdStateInfo_SLL2BdState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor6, []int{21, 0}
}

// L2 Route Globals Get Message
type SLL2GlobalsGetMsg struct {
}

func (m *SLL2GlobalsGetMsg) Reset()                    { *m = SLL2GlobalsGetMsg{} }
func (m *SLL2GlobalsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2GlobalsGetMsg) ProtoMessage()               {}
func (*SLL2GlobalsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

// L2 Route Globals Get Message Response
type SLL2GlobalsGetMsgRsp struct {
	// Corresponding error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Max BD registration objects within a single BdRegMsg.
	MaxBdRegPerBdRegmsg uint32 `protobuf:"varint,2,opt,name=MaxBdRegPerBdRegmsg" json:"MaxBdRegPerBdRegmsg,omitempty"`
	// Max Route objects within a single RouteMsg.
	MaxRoutePerRoutemsg uint32 `protobuf:"varint,3,opt,name=MaxRoutePerRoutemsg" json:"MaxRoutePerRoutemsg,omitempty"`
}

func (m *SLL2GlobalsGetMsgRsp) Reset()                    { *m = SLL2GlobalsGetMsgRsp{} }
func (m *SLL2GlobalsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLL2GlobalsGetMsgRsp) ProtoMessage()               {}
func (*SLL2GlobalsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

func (m *SLL2GlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLL2GlobalsGetMsgRsp) GetMaxBdRegPerBdRegmsg() uint32 {
	if m != nil {
		return m.MaxBdRegPerBdRegmsg
	}
	return 0
}

func (m *SLL2GlobalsGetMsgRsp) GetMaxRoutePerRoutemsg() uint32 {
	if m != nil {
		return m.MaxRoutePerRoutemsg
	}
	return 0
}

// Global L2 Registration Message
type SLL2RegMsg struct {
	// Registration Operation.
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// Default Admin distance for routes programmed by this application.
	// Range [0-255].
	// If the client does not need to program routes, set this value to 0.
	AdminDistance uint32 `protobuf:"varint,2,opt,name=AdminDistance" json:"AdminDistance,omitempty"`
	// In case Service Layer -> L2RIB connection is lost, this specifies the
	// timeout period after which L2RIB will automatically purge the installed
	// routes, unless the service layer:
	//    1. Re-registers.
	//    2. Replay all routes.
	//    3. And send EOF, before the purge timeout.
	// If the client does not need to program routes, set this value to 0.
	PurgeIntervalSeconds uint32 `protobuf:"varint,3,opt,name=PurgeIntervalSeconds" json:"PurgeIntervalSeconds,omitempty"`
}

func (m *SLL2RegMsg) Reset()                    { *m = SLL2RegMsg{} }
func (m *SLL2RegMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2RegMsg) ProtoMessage()               {}
func (*SLL2RegMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

func (m *SLL2RegMsg) GetOper() SLRegOp {
	if m != nil {
		return m.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (m *SLL2RegMsg) GetAdminDistance() uint32 {
	if m != nil {
		return m.AdminDistance
	}
	return 0
}

func (m *SLL2RegMsg) GetPurgeIntervalSeconds() uint32 {
	if m != nil {
		return m.PurgeIntervalSeconds
	}
	return 0
}

// Global L2 Registration message Response
type SLL2RegMsgRsp struct {
	// Error code.
	RegStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=RegStatus" json:"RegStatus,omitempty"`
}

func (m *SLL2RegMsgRsp) Reset()                    { *m = SLL2RegMsgRsp{} }
func (m *SLL2RegMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLL2RegMsgRsp) ProtoMessage()               {}
func (*SLL2RegMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{3} }

func (m *SLL2RegMsgRsp) GetRegStatus() *SLErrorStatus {
	if m != nil {
		return m.RegStatus
	}
	return nil
}

// L2 Bridge-Domain (BD) Registration Messages
type SLL2BdRegMsg struct {
	// Registration Operation.
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// List of BD names that client wants to register for.
	BdRegName []string `protobuf:"bytes,2,rep,name=BdRegName" json:"BdRegName,omitempty"`
}

func (m *SLL2BdRegMsg) Reset()                    { *m = SLL2BdRegMsg{} }
func (m *SLL2BdRegMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2BdRegMsg) ProtoMessage()               {}
func (*SLL2BdRegMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{4} }

func (m *SLL2BdRegMsg) GetOper() SLRegOp {
	if m != nil {
		return m.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (m *SLL2BdRegMsg) GetBdRegName() []string {
	if m != nil {
		return m.BdRegName
	}
	return nil
}

// BD Registration message Result
type SLL2BdRegRes struct {
	// Corresponding error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// BD Name.
	BdName string `protobuf:"bytes,2,opt,name=BdName" json:"BdName,omitempty"`
}

func (m *SLL2BdRegRes) Reset()                    { *m = SLL2BdRegRes{} }
func (m *SLL2BdRegRes) String() string            { return proto.CompactTextString(m) }
func (*SLL2BdRegRes) ProtoMessage()               {}
func (*SLL2BdRegRes) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{5} }

func (m *SLL2BdRegRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLL2BdRegRes) GetBdName() string {
	if m != nil {
		return m.BdName
	}
	return ""
}

// BD Registration message Response.
type SLL2BdRegMsgRsp struct {
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLL2BdRegRes `protobuf:"bytes,2,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLL2BdRegMsgRsp) Reset()                    { *m = SLL2BdRegMsgRsp{} }
func (m *SLL2BdRegMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLL2BdRegMsgRsp) ProtoMessage()               {}
func (*SLL2BdRegMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{6} }

func (m *SLL2BdRegMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLL2BdRegMsgRsp) GetResults() []*SLL2BdRegRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// Ethernet Segment Identifier (ESI)
type SLL2RouteEsi struct {
	// 10-bytes long ESI value
	Esi []byte `protobuf:"bytes,1,opt,name=Esi,proto3" json:"Esi,omitempty"`
}

func (m *SLL2RouteEsi) Reset()                    { *m = SLL2RouteEsi{} }
func (m *SLL2RouteEsi) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteEsi) ProtoMessage()               {}
func (*SLL2RouteEsi) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{7} }

func (m *SLL2RouteEsi) GetEsi() []byte {
	if m != nil {
		return m.Esi
	}
	return nil
}

// Nexthop info
type SLL2RouteNh struct {
	NhType SLL2RouteNh_SLL2RouteNhType `protobuf:"varint,1,opt,name=NhType,enum=service_layer.SLL2RouteNh_SLL2RouteNhType" json:"NhType,omitempty"`
	// Next Hop data based on type
	//
	// Types that are valid to be assigned to NhData:
	//	*SLL2RouteNh_NhInterface
	//	*SLL2RouteNh_NhOverlay
	NhData isSLL2RouteNh_NhData `protobuf_oneof:"NhData"`
}

func (m *SLL2RouteNh) Reset()                    { *m = SLL2RouteNh{} }
func (m *SLL2RouteNh) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteNh) ProtoMessage()               {}
func (*SLL2RouteNh) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{8} }

type isSLL2RouteNh_NhData interface {
	isSLL2RouteNh_NhData()
}

type SLL2RouteNh_NhInterface struct {
	NhInterface *SLInterface `protobuf:"bytes,2,opt,name=NhInterface,oneof"`
}
type SLL2RouteNh_NhOverlay struct {
	NhOverlay *SLL2OverlayNh `protobuf:"bytes,3,opt,name=NhOverlay,oneof"`
}

func (*SLL2RouteNh_NhInterface) isSLL2RouteNh_NhData() {}
func (*SLL2RouteNh_NhOverlay) isSLL2RouteNh_NhData()   {}

func (m *SLL2RouteNh) GetNhData() isSLL2RouteNh_NhData {
	if m != nil {
		return m.NhData
	}
	return nil
}

func (m *SLL2RouteNh) GetNhType() SLL2RouteNh_SLL2RouteNhType {
	if m != nil {
		return m.NhType
	}
	return SLL2RouteNh_SL_L2_NH_RESERVED
}

func (m *SLL2RouteNh) GetNhInterface() *SLInterface {
	if x, ok := m.GetNhData().(*SLL2RouteNh_NhInterface); ok {
		return x.NhInterface
	}
	return nil
}

func (m *SLL2RouteNh) GetNhOverlay() *SLL2OverlayNh {
	if x, ok := m.GetNhData().(*SLL2RouteNh_NhOverlay); ok {
		return x.NhOverlay
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLL2RouteNh) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLL2RouteNh_OneofMarshaler, _SLL2RouteNh_OneofUnmarshaler, _SLL2RouteNh_OneofSizer, []interface{}{
		(*SLL2RouteNh_NhInterface)(nil),
		(*SLL2RouteNh_NhOverlay)(nil),
	}
}

func _SLL2RouteNh_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLL2RouteNh)
	// NhData
	switch x := m.NhData.(type) {
	case *SLL2RouteNh_NhInterface:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NhInterface); err != nil {
			return err
		}
	case *SLL2RouteNh_NhOverlay:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NhOverlay); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLL2RouteNh.NhData has unexpected type %T", x)
	}
	return nil
}

func _SLL2RouteNh_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLL2RouteNh)
	switch tag {
	case 2: // NhData.NhInterface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLInterface)
		err := b.DecodeMessage(msg)
		m.NhData = &SLL2RouteNh_NhInterface{msg}
		return true, err
	case 3: // NhData.NhOverlay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2OverlayNh)
		err := b.DecodeMessage(msg)
		m.NhData = &SLL2RouteNh_NhOverlay{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLL2RouteNh_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLL2RouteNh)
	// NhData
	switch x := m.NhData.(type) {
	case *SLL2RouteNh_NhInterface:
		s := proto.Size(x.NhInterface)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2RouteNh_NhOverlay:
		s := proto.Size(x.NhOverlay)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Overlay nexthop info
type SLL2OverlayNh struct {
	// IPv4 or IPv6 address
	OverlayNhIp *SLIpAddress `protobuf:"bytes,1,opt,name=OverlayNhIp" json:"OverlayNhIp,omitempty"`
	// Encap type
	OverlayNhEncap SLEncapType `protobuf:"varint,2,opt,name=OverlayNhEncap,enum=service_layer.SLEncapType" json:"OverlayNhEncap,omitempty"`
	// L2 label
	// for encap type MPLS, this will be remote MPLS label
	// for encap type VXLAN, this will be L2 VNI.
	OverlayNhLabel uint32 `protobuf:"varint,3,opt,name=OverlayNhLabel" json:"OverlayNhLabel,omitempty"`
	// L3 label
	// for encap type MPLS, this will be a stack of MPLS labels.
	// for encap type VXLAN, this will be L3 VNI.
	OverlayNhL3Label []uint32 `protobuf:"varint,4,rep,packed,name=OverlayNhL3Label" json:"OverlayNhL3Label,omitempty"`
	// Router MAC
	OverlayNhRouterMac []byte `protobuf:"bytes,5,opt,name=OverlayNhRouterMac,proto3" json:"OverlayNhRouterMac,omitempty"`
}

func (m *SLL2OverlayNh) Reset()                    { *m = SLL2OverlayNh{} }
func (m *SLL2OverlayNh) String() string            { return proto.CompactTextString(m) }
func (*SLL2OverlayNh) ProtoMessage()               {}
func (*SLL2OverlayNh) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{9} }

func (m *SLL2OverlayNh) GetOverlayNhIp() *SLIpAddress {
	if m != nil {
		return m.OverlayNhIp
	}
	return nil
}

func (m *SLL2OverlayNh) GetOverlayNhEncap() SLEncapType {
	if m != nil {
		return m.OverlayNhEncap
	}
	return SLEncapType_SL_ENCAP_RESERVED
}

func (m *SLL2OverlayNh) GetOverlayNhLabel() uint32 {
	if m != nil {
		return m.OverlayNhLabel
	}
	return 0
}

func (m *SLL2OverlayNh) GetOverlayNhL3Label() []uint32 {
	if m != nil {
		return m.OverlayNhL3Label
	}
	return nil
}

func (m *SLL2OverlayNh) GetOverlayNhRouterMac() []byte {
	if m != nil {
		return m.OverlayNhRouterMac
	}
	return nil
}

// MAC route key
type SLL2MacRouteKey struct {
	// Mac address
	MacAddress []byte `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"MacAddress,omitempty"`
	// IP address
	IpAddress *SLIpAddress `protobuf:"bytes,2,opt,name=IpAddress" json:"IpAddress,omitempty"`
}

func (m *SLL2MacRouteKey) Reset()                    { *m = SLL2MacRouteKey{} }
func (m *SLL2MacRouteKey) String() string            { return proto.CompactTextString(m) }
func (*SLL2MacRouteKey) ProtoMessage()               {}
func (*SLL2MacRouteKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{10} }

func (m *SLL2MacRouteKey) GetMacAddress() []byte {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *SLL2MacRouteKey) GetIpAddress() *SLIpAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

// Type 2 EVPN MAC route
type SLL2MacRoute struct {
	// Mac route key
	RouteKey *SLL2MacRouteKey `protobuf:"bytes,1,opt,name=RouteKey" json:"RouteKey,omitempty"`
	// Sequence number
	SequenceNum uint32 `protobuf:"varint,2,opt,name=SequenceNum" json:"SequenceNum,omitempty"`
	// ESI
	MacEsi *SLL2RouteEsi `protobuf:"bytes,3,opt,name=MacEsi" json:"MacEsi,omitempty"`
	// List of NHs for this host
	NextHopList []*SLL2RouteNh `protobuf:"bytes,4,rep,name=NextHopList" json:"NextHopList,omitempty"`
}

func (m *SLL2MacRoute) Reset()                    { *m = SLL2MacRoute{} }
func (m *SLL2MacRoute) String() string            { return proto.CompactTextString(m) }
func (*SLL2MacRoute) ProtoMessage()               {}
func (*SLL2MacRoute) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{11} }

func (m *SLL2MacRoute) GetRouteKey() *SLL2MacRouteKey {
	if m != nil {
		return m.RouteKey
	}
	return nil
}

func (m *SLL2MacRoute) GetSequenceNum() uint32 {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *SLL2MacRoute) GetMacEsi() *SLL2RouteEsi {
	if m != nil {
		return m.MacEsi
	}
	return nil
}

func (m *SLL2MacRoute) GetNextHopList() []*SLL2RouteNh {
	if m != nil {
		return m.NextHopList
	}
	return nil
}

// IMET route key
type SLL2ImetRouteKey struct {
	// Ethernet Tag ID.
	EthTagId uint32 `protobuf:"varint,1,opt,name=EthTagId" json:"EthTagId,omitempty"`
	// Ipv4 or Ipv6 address
	IpAddress *SLIpAddress `protobuf:"bytes,2,opt,name=IpAddress" json:"IpAddress,omitempty"`
}

func (m *SLL2ImetRouteKey) Reset()                    { *m = SLL2ImetRouteKey{} }
func (m *SLL2ImetRouteKey) String() string            { return proto.CompactTextString(m) }
func (*SLL2ImetRouteKey) ProtoMessage()               {}
func (*SLL2ImetRouteKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{12} }

func (m *SLL2ImetRouteKey) GetEthTagId() uint32 {
	if m != nil {
		return m.EthTagId
	}
	return 0
}

func (m *SLL2ImetRouteKey) GetIpAddress() *SLIpAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

// Type-3 EVPN IMET Route
type SLL2ImetRoute struct {
	// IMET Route Key
	RouteKey *SLL2ImetRouteKey `protobuf:"bytes,1,opt,name=RouteKey" json:"RouteKey,omitempty"`
	// Encapsulation type (VXLAN or MPLS)
	EncapType SLEncapType `protobuf:"varint,2,opt,name=EncapType,enum=service_layer.SLEncapType" json:"EncapType,omitempty"`
	// For ENCAP_VXLAN, this field will specify the L2 Virtual Network
	// Identifier (VNI)
	Label          uint32                       `protobuf:"varint,3,opt,name=Label" json:"Label,omitempty"`
	TunnelType     SLL2ImetRoute_PMSITunnelType `protobuf:"varint,4,opt,name=TunnelType,enum=service_layer.SLL2ImetRoute_PMSITunnelType" json:"TunnelType,omitempty"`
	TunnelIdLength uint32                       `protobuf:"varint,5,opt,name=TunnelIdLength" json:"TunnelIdLength,omitempty"`
	// When the type is set to Ingress Replication the Tunnel
	// Identifier carries the unicast tunnel endpoint IP
	// address of the local PE that is to be this PE's receiving
	// endpoint address for the tunnel.
	TunnelIdValue []byte `protobuf:"bytes,6,opt,name=TunnelIdValue,proto3" json:"TunnelIdValue,omitempty"`
}

func (m *SLL2ImetRoute) Reset()                    { *m = SLL2ImetRoute{} }
func (m *SLL2ImetRoute) String() string            { return proto.CompactTextString(m) }
func (*SLL2ImetRoute) ProtoMessage()               {}
func (*SLL2ImetRoute) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{13} }

func (m *SLL2ImetRoute) GetRouteKey() *SLL2ImetRouteKey {
	if m != nil {
		return m.RouteKey
	}
	return nil
}

func (m *SLL2ImetRoute) GetEncapType() SLEncapType {
	if m != nil {
		return m.EncapType
	}
	return SLEncapType_SL_ENCAP_RESERVED
}

func (m *SLL2ImetRoute) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *SLL2ImetRoute) GetTunnelType() SLL2ImetRoute_PMSITunnelType {
	if m != nil {
		return m.TunnelType
	}
	return SLL2ImetRoute_PMSI_NO_TUNNEL
}

func (m *SLL2ImetRoute) GetTunnelIdLength() uint32 {
	if m != nil {
		return m.TunnelIdLength
	}
	return 0
}

func (m *SLL2ImetRoute) GetTunnelIdValue() []byte {
	if m != nil {
		return m.TunnelIdValue
	}
	return nil
}

// L2 route key
type SLL2RouteKey struct {
	// BD name
	BdName string `protobuf:"bytes,1,opt,name=BdName" json:"BdName,omitempty"`
	// L2 Route Type
	Type SLL2RouteType `protobuf:"varint,2,opt,name=Type,enum=service_layer.SLL2RouteType" json:"Type,omitempty"`
	// Further info based on Route Type
	//
	// Types that are valid to be assigned to Event:
	//	*SLL2RouteKey_MacKey
	//	*SLL2RouteKey_ImetKey
	Event isSLL2RouteKey_Event `protobuf_oneof:"Event"`
}

func (m *SLL2RouteKey) Reset()                    { *m = SLL2RouteKey{} }
func (m *SLL2RouteKey) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteKey) ProtoMessage()               {}
func (*SLL2RouteKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{14} }

type isSLL2RouteKey_Event interface {
	isSLL2RouteKey_Event()
}

type SLL2RouteKey_MacKey struct {
	MacKey *SLL2MacRouteKey `protobuf:"bytes,3,opt,name=MacKey,oneof"`
}
type SLL2RouteKey_ImetKey struct {
	ImetKey *SLL2ImetRouteKey `protobuf:"bytes,4,opt,name=ImetKey,oneof"`
}

func (*SLL2RouteKey_MacKey) isSLL2RouteKey_Event()  {}
func (*SLL2RouteKey_ImetKey) isSLL2RouteKey_Event() {}

func (m *SLL2RouteKey) GetEvent() isSLL2RouteKey_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLL2RouteKey) GetBdName() string {
	if m != nil {
		return m.BdName
	}
	return ""
}

func (m *SLL2RouteKey) GetType() SLL2RouteType {
	if m != nil {
		return m.Type
	}
	return SLL2RouteType_SL_L2_ROUTE_RESERVED
}

func (m *SLL2RouteKey) GetMacKey() *SLL2MacRouteKey {
	if x, ok := m.GetEvent().(*SLL2RouteKey_MacKey); ok {
		return x.MacKey
	}
	return nil
}

func (m *SLL2RouteKey) GetImetKey() *SLL2ImetRouteKey {
	if x, ok := m.GetEvent().(*SLL2RouteKey_ImetKey); ok {
		return x.ImetKey
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLL2RouteKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLL2RouteKey_OneofMarshaler, _SLL2RouteKey_OneofUnmarshaler, _SLL2RouteKey_OneofSizer, []interface{}{
		(*SLL2RouteKey_MacKey)(nil),
		(*SLL2RouteKey_ImetKey)(nil),
	}
}

func _SLL2RouteKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLL2RouteKey)
	// Event
	switch x := m.Event.(type) {
	case *SLL2RouteKey_MacKey:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MacKey); err != nil {
			return err
		}
	case *SLL2RouteKey_ImetKey:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImetKey); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLL2RouteKey.Event has unexpected type %T", x)
	}
	return nil
}

func _SLL2RouteKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLL2RouteKey)
	switch tag {
	case 3: // Event.MacKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2MacRouteKey)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2RouteKey_MacKey{msg}
		return true, err
	case 4: // Event.ImetKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2ImetRouteKey)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2RouteKey_ImetKey{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLL2RouteKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLL2RouteKey)
	// Event
	switch x := m.Event.(type) {
	case *SLL2RouteKey_MacKey:
		s := proto.Size(x.MacKey)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2RouteKey_ImetKey:
		s := proto.Size(x.ImetKey)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L2 route
type SLL2Route struct {
	// BD name
	BdName string `protobuf:"bytes,1,opt,name=BdName" json:"BdName,omitempty"`
	// L2 Route Type to be programmed
	Type SLL2RouteType `protobuf:"varint,2,opt,name=Type,enum=service_layer.SLL2RouteType" json:"Type,omitempty"`
	// Further info based on Route Type
	//
	// Types that are valid to be assigned to Event:
	//	*SLL2Route_MacRoute
	//	*SLL2Route_ImetRoute
	Event isSLL2Route_Event `protobuf_oneof:"Event"`
}

func (m *SLL2Route) Reset()                    { *m = SLL2Route{} }
func (m *SLL2Route) String() string            { return proto.CompactTextString(m) }
func (*SLL2Route) ProtoMessage()               {}
func (*SLL2Route) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{15} }

type isSLL2Route_Event interface {
	isSLL2Route_Event()
}

type SLL2Route_MacRoute struct {
	MacRoute *SLL2MacRoute `protobuf:"bytes,3,opt,name=MacRoute,oneof"`
}
type SLL2Route_ImetRoute struct {
	ImetRoute *SLL2ImetRoute `protobuf:"bytes,4,opt,name=ImetRoute,oneof"`
}

func (*SLL2Route_MacRoute) isSLL2Route_Event()  {}
func (*SLL2Route_ImetRoute) isSLL2Route_Event() {}

func (m *SLL2Route) GetEvent() isSLL2Route_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLL2Route) GetBdName() string {
	if m != nil {
		return m.BdName
	}
	return ""
}

func (m *SLL2Route) GetType() SLL2RouteType {
	if m != nil {
		return m.Type
	}
	return SLL2RouteType_SL_L2_ROUTE_RESERVED
}

func (m *SLL2Route) GetMacRoute() *SLL2MacRoute {
	if x, ok := m.GetEvent().(*SLL2Route_MacRoute); ok {
		return x.MacRoute
	}
	return nil
}

func (m *SLL2Route) GetImetRoute() *SLL2ImetRoute {
	if x, ok := m.GetEvent().(*SLL2Route_ImetRoute); ok {
		return x.ImetRoute
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLL2Route) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLL2Route_OneofMarshaler, _SLL2Route_OneofUnmarshaler, _SLL2Route_OneofSizer, []interface{}{
		(*SLL2Route_MacRoute)(nil),
		(*SLL2Route_ImetRoute)(nil),
	}
}

func _SLL2Route_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLL2Route)
	// Event
	switch x := m.Event.(type) {
	case *SLL2Route_MacRoute:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MacRoute); err != nil {
			return err
		}
	case *SLL2Route_ImetRoute:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImetRoute); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLL2Route.Event has unexpected type %T", x)
	}
	return nil
}

func _SLL2Route_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLL2Route)
	switch tag {
	case 3: // Event.MacRoute
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2MacRoute)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Route_MacRoute{msg}
		return true, err
	case 4: // Event.ImetRoute
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2ImetRoute)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Route_ImetRoute{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLL2Route_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLL2Route)
	// Event
	switch x := m.Event.(type) {
	case *SLL2Route_MacRoute:
		s := proto.Size(x.MacRoute)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2Route_ImetRoute:
		s := proto.Size(x.ImetRoute)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Batch of L2 Routes for bulk download
type SLL2RouteMsg struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// Route Object Operations
	Oper SLObjectOp `protobuf:"varint,2,opt,name=Oper,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// List of L2 Routes
	// The list may contain routes from different BDs.
	Routes []*SLL2Route `protobuf:"bytes,3,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *SLL2RouteMsg) Reset()                    { *m = SLL2RouteMsg{} }
func (m *SLL2RouteMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteMsg) ProtoMessage()               {}
func (*SLL2RouteMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{16} }

func (m *SLL2RouteMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLL2RouteMsg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLL2RouteMsg) GetRoutes() []*SLL2Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

// L2 route result, uniquely identified by BD + L2 route key
type SLL2RouteRes struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// L2 Route Key
	RouteKey *SLL2RouteKey `protobuf:"bytes,2,opt,name=RouteKey" json:"RouteKey,omitempty"`
}

func (m *SLL2RouteRes) Reset()                    { *m = SLL2RouteRes{} }
func (m *SLL2RouteRes) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteRes) ProtoMessage()               {}
func (*SLL2RouteRes) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{17} }

func (m *SLL2RouteRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLL2RouteRes) GetRouteKey() *SLL2RouteKey {
	if m != nil {
		return m.RouteKey
	}
	return nil
}

// L2 bulk download response
type SLL2RouteMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,2,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLL2RouteRes `protobuf:"bytes,3,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLL2RouteMsgRsp) Reset()                    { *m = SLL2RouteMsgRsp{} }
func (m *SLL2RouteMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteMsgRsp) ProtoMessage()               {}
func (*SLL2RouteMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{18} }

func (m *SLL2RouteMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLL2RouteMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLL2RouteMsgRsp) GetResults() []*SLL2RouteRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// L2 Get Notifications message.
type SLL2GetNotifMsg struct {
	// Oper = SL_NOTIFOP_ENABLE
	//   This is to enable route notifications
	// Oper = SL_NOTIFOP_DISABLE
	//   This is to disable route notifications
	Oper SLNotifOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLNotifOp" json:"Oper,omitempty"`
	// Correlator. This is used to correlate GetNotifMsg with
	// NotifMsgStatus. The server reflects this field in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator" json:"Correlator,omitempty"`
	// End of file.
	// When set to True, it indicates that the client is done with sending
	// requests for notifications.
	//
	// It is useful when client is sending per-BD notification requests.
	// The client can send this after receiving
	// SL_L2_EVENT_TYPE_BD_STATE_END_MARKER.
	GetNotifEof bool `protobuf:"varint,3,opt,name=GetNotifEof" json:"GetNotifEof,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*SLL2GetNotifMsg_BdAll
	//	*SLL2GetNotifMsg_BdName
	Request isSLL2GetNotifMsg_Request `protobuf_oneof:"Request"`
}

func (m *SLL2GetNotifMsg) Reset()                    { *m = SLL2GetNotifMsg{} }
func (m *SLL2GetNotifMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2GetNotifMsg) ProtoMessage()               {}
func (*SLL2GetNotifMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{19} }

type isSLL2GetNotifMsg_Request interface {
	isSLL2GetNotifMsg_Request()
}

type SLL2GetNotifMsg_BdAll struct {
	BdAll bool `protobuf:"varint,4,opt,name=BdAll,oneof"`
}
type SLL2GetNotifMsg_BdName struct {
	BdName string `protobuf:"bytes,5,opt,name=BdName,oneof"`
}

func (*SLL2GetNotifMsg_BdAll) isSLL2GetNotifMsg_Request()  {}
func (*SLL2GetNotifMsg_BdName) isSLL2GetNotifMsg_Request() {}

func (m *SLL2GetNotifMsg) GetRequest() isSLL2GetNotifMsg_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SLL2GetNotifMsg) GetOper() SLNotifOp {
	if m != nil {
		return m.Oper
	}
	return SLNotifOp_SL_NOTIFOP_RESERVED
}

func (m *SLL2GetNotifMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLL2GetNotifMsg) GetGetNotifEof() bool {
	if m != nil {
		return m.GetNotifEof
	}
	return false
}

func (m *SLL2GetNotifMsg) GetBdAll() bool {
	if x, ok := m.GetRequest().(*SLL2GetNotifMsg_BdAll); ok {
		return x.BdAll
	}
	return false
}

func (m *SLL2GetNotifMsg) GetBdName() string {
	if x, ok := m.GetRequest().(*SLL2GetNotifMsg_BdName); ok {
		return x.BdName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLL2GetNotifMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLL2GetNotifMsg_OneofMarshaler, _SLL2GetNotifMsg_OneofUnmarshaler, _SLL2GetNotifMsg_OneofSizer, []interface{}{
		(*SLL2GetNotifMsg_BdAll)(nil),
		(*SLL2GetNotifMsg_BdName)(nil),
	}
}

func _SLL2GetNotifMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLL2GetNotifMsg)
	// Request
	switch x := m.Request.(type) {
	case *SLL2GetNotifMsg_BdAll:
		t := uint64(0)
		if x.BdAll {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *SLL2GetNotifMsg_BdName:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.BdName)
	case nil:
	default:
		return fmt.Errorf("SLL2GetNotifMsg.Request has unexpected type %T", x)
	}
	return nil
}

func _SLL2GetNotifMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLL2GetNotifMsg)
	switch tag {
	case 4: // Request.BdAll
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Request = &SLL2GetNotifMsg_BdAll{x != 0}
		return true, err
	case 5: // Request.BdName
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Request = &SLL2GetNotifMsg_BdName{x}
		return true, err
	default:
		return false, nil
	}
}

func _SLL2GetNotifMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLL2GetNotifMsg)
	// Request
	switch x := m.Request.(type) {
	case *SLL2GetNotifMsg_BdAll:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *SLL2GetNotifMsg_BdName:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BdName)))
		n += len(x.BdName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// L2 Route notification
type SLL2RouteNotif struct {
	// Route Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// L2 route
	Routes *SLL2Route `protobuf:"bytes,2,opt,name=Routes" json:"Routes,omitempty"`
}

func (m *SLL2RouteNotif) Reset()                    { *m = SLL2RouteNotif{} }
func (m *SLL2RouteNotif) String() string            { return proto.CompactTextString(m) }
func (*SLL2RouteNotif) ProtoMessage()               {}
func (*SLL2RouteNotif) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{20} }

func (m *SLL2RouteNotif) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLL2RouteNotif) GetRoutes() *SLL2Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

// Bridge-Domain (BD) state info
type SLL2BdStateInfo struct {
	// BD name
	BdName  string                      `protobuf:"bytes,1,opt,name=BdName" json:"BdName,omitempty"`
	BdState SLL2BdStateInfo_SLL2BdState `protobuf:"varint,2,opt,name=BdState,enum=service_layer.SLL2BdStateInfo_SLL2BdState" json:"BdState,omitempty"`
}

func (m *SLL2BdStateInfo) Reset()                    { *m = SLL2BdStateInfo{} }
func (m *SLL2BdStateInfo) String() string            { return proto.CompactTextString(m) }
func (*SLL2BdStateInfo) ProtoMessage()               {}
func (*SLL2BdStateInfo) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{21} }

func (m *SLL2BdStateInfo) GetBdName() string {
	if m != nil {
		return m.BdName
	}
	return ""
}

func (m *SLL2BdStateInfo) GetBdState() SLL2BdStateInfo_SLL2BdState {
	if m != nil {
		return m.BdState
	}
	return SLL2BdStateInfo_SL_L2_BD_STATE_RESERVED
}

// L2 Notification Status message
type SLL2NotifStatusMsg struct {
	// Notification Operation in the request
	Oper SLNotifOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLNotifOp" json:"Oper,omitempty"`
	// Correlator in the request.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator" json:"Correlator,omitempty"`
	// BD in the request.
	// This is not set if the request was for all BDs
	BdName string `protobuf:"bytes,3,opt,name=BdName" json:"BdName,omitempty"`
	// The NotifStatus implies one of 2 things:
	// SL_SUCCESS: signifies that the notification request was successful
	// SL_XXX: signifies an error in setting up a notification.
	//  If BdName is passed, it implies that notifications for the BD
	//  will not be sent.
	NotifStatus *SLErrorStatus `protobuf:"bytes,4,opt,name=NotifStatus" json:"NotifStatus,omitempty"`
}

func (m *SLL2NotifStatusMsg) Reset()                    { *m = SLL2NotifStatusMsg{} }
func (m *SLL2NotifStatusMsg) String() string            { return proto.CompactTextString(m) }
func (*SLL2NotifStatusMsg) ProtoMessage()               {}
func (*SLL2NotifStatusMsg) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{22} }

func (m *SLL2NotifStatusMsg) GetOper() SLNotifOp {
	if m != nil {
		return m.Oper
	}
	return SLNotifOp_SL_NOTIFOP_RESERVED
}

func (m *SLL2NotifStatusMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLL2NotifStatusMsg) GetBdName() string {
	if m != nil {
		return m.BdName
	}
	return ""
}

func (m *SLL2NotifStatusMsg) GetNotifStatus() *SLErrorStatus {
	if m != nil {
		return m.NotifStatus
	}
	return nil
}

// L2 Notification.
type SLL2Notif struct {
	// L2 Notification type
	EventType SLL2NotifType `protobuf:"varint,1,opt,name=EventType,enum=service_layer.SLL2NotifType" json:"EventType,omitempty"`
	// Further info based on EventType
	//
	// Types that are valid to be assigned to Event:
	//	*SLL2Notif_ErrStatus
	//	*SLL2Notif_NotifStatus
	//	*SLL2Notif_BdStateInfo
	//	*SLL2Notif_Route
	Event isSLL2Notif_Event `protobuf_oneof:"Event"`
}

func (m *SLL2Notif) Reset()                    { *m = SLL2Notif{} }
func (m *SLL2Notif) String() string            { return proto.CompactTextString(m) }
func (*SLL2Notif) ProtoMessage()               {}
func (*SLL2Notif) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{23} }

type isSLL2Notif_Event interface {
	isSLL2Notif_Event()
}

type SLL2Notif_ErrStatus struct {
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,oneof"`
}
type SLL2Notif_NotifStatus struct {
	NotifStatus *SLL2NotifStatusMsg `protobuf:"bytes,3,opt,name=NotifStatus,oneof"`
}
type SLL2Notif_BdStateInfo struct {
	BdStateInfo *SLL2BdStateInfo `protobuf:"bytes,4,opt,name=BdStateInfo,oneof"`
}
type SLL2Notif_Route struct {
	Route *SLL2RouteNotif `protobuf:"bytes,5,opt,name=Route,oneof"`
}

func (*SLL2Notif_ErrStatus) isSLL2Notif_Event()   {}
func (*SLL2Notif_NotifStatus) isSLL2Notif_Event() {}
func (*SLL2Notif_BdStateInfo) isSLL2Notif_Event() {}
func (*SLL2Notif_Route) isSLL2Notif_Event()       {}

func (m *SLL2Notif) GetEvent() isSLL2Notif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLL2Notif) GetEventType() SLL2NotifType {
	if m != nil {
		return m.EventType
	}
	return SLL2NotifType_SL_L2_EVENT_TYPE_RESERVED
}

func (m *SLL2Notif) GetErrStatus() *SLErrorStatus {
	if x, ok := m.GetEvent().(*SLL2Notif_ErrStatus); ok {
		return x.ErrStatus
	}
	return nil
}

func (m *SLL2Notif) GetNotifStatus() *SLL2NotifStatusMsg {
	if x, ok := m.GetEvent().(*SLL2Notif_NotifStatus); ok {
		return x.NotifStatus
	}
	return nil
}

func (m *SLL2Notif) GetBdStateInfo() *SLL2BdStateInfo {
	if x, ok := m.GetEvent().(*SLL2Notif_BdStateInfo); ok {
		return x.BdStateInfo
	}
	return nil
}

func (m *SLL2Notif) GetRoute() *SLL2RouteNotif {
	if x, ok := m.GetEvent().(*SLL2Notif_Route); ok {
		return x.Route
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLL2Notif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLL2Notif_OneofMarshaler, _SLL2Notif_OneofUnmarshaler, _SLL2Notif_OneofSizer, []interface{}{
		(*SLL2Notif_ErrStatus)(nil),
		(*SLL2Notif_NotifStatus)(nil),
		(*SLL2Notif_BdStateInfo)(nil),
		(*SLL2Notif_Route)(nil),
	}
}

func _SLL2Notif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLL2Notif)
	// Event
	switch x := m.Event.(type) {
	case *SLL2Notif_ErrStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrStatus); err != nil {
			return err
		}
	case *SLL2Notif_NotifStatus:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotifStatus); err != nil {
			return err
		}
	case *SLL2Notif_BdStateInfo:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BdStateInfo); err != nil {
			return err
		}
	case *SLL2Notif_Route:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLL2Notif.Event has unexpected type %T", x)
	}
	return nil
}

func _SLL2Notif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLL2Notif)
	switch tag {
	case 2: // Event.ErrStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLErrorStatus)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Notif_ErrStatus{msg}
		return true, err
	case 3: // Event.NotifStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2NotifStatusMsg)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Notif_NotifStatus{msg}
		return true, err
	case 4: // Event.BdStateInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2BdStateInfo)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Notif_BdStateInfo{msg}
		return true, err
	case 5: // Event.Route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLL2RouteNotif)
		err := b.DecodeMessage(msg)
		m.Event = &SLL2Notif_Route{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLL2Notif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLL2Notif)
	// Event
	switch x := m.Event.(type) {
	case *SLL2Notif_ErrStatus:
		s := proto.Size(x.ErrStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2Notif_NotifStatus:
		s := proto.Size(x.NotifStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2Notif_BdStateInfo:
		s := proto.Size(x.BdStateInfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLL2Notif_Route:
		s := proto.Size(x.Route)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SLL2GlobalsGetMsg)(nil), "service_layer.SLL2GlobalsGetMsg")
	proto.RegisterType((*SLL2GlobalsGetMsgRsp)(nil), "service_layer.SLL2GlobalsGetMsgRsp")
	proto.RegisterType((*SLL2RegMsg)(nil), "service_layer.SLL2RegMsg")
	proto.RegisterType((*SLL2RegMsgRsp)(nil), "service_layer.SLL2RegMsgRsp")
	proto.RegisterType((*SLL2BdRegMsg)(nil), "service_layer.SLL2BdRegMsg")
	proto.RegisterType((*SLL2BdRegRes)(nil), "service_layer.SLL2BdRegRes")
	proto.RegisterType((*SLL2BdRegMsgRsp)(nil), "service_layer.SLL2BdRegMsgRsp")
	proto.RegisterType((*SLL2RouteEsi)(nil), "service_layer.SLL2RouteEsi")
	proto.RegisterType((*SLL2RouteNh)(nil), "service_layer.SLL2RouteNh")
	proto.RegisterType((*SLL2OverlayNh)(nil), "service_layer.SLL2OverlayNh")
	proto.RegisterType((*SLL2MacRouteKey)(nil), "service_layer.SLL2MacRouteKey")
	proto.RegisterType((*SLL2MacRoute)(nil), "service_layer.SLL2MacRoute")
	proto.RegisterType((*SLL2ImetRouteKey)(nil), "service_layer.SLL2ImetRouteKey")
	proto.RegisterType((*SLL2ImetRoute)(nil), "service_layer.SLL2ImetRoute")
	proto.RegisterType((*SLL2RouteKey)(nil), "service_layer.SLL2RouteKey")
	proto.RegisterType((*SLL2Route)(nil), "service_layer.SLL2Route")
	proto.RegisterType((*SLL2RouteMsg)(nil), "service_layer.SLL2RouteMsg")
	proto.RegisterType((*SLL2RouteRes)(nil), "service_layer.SLL2RouteRes")
	proto.RegisterType((*SLL2RouteMsgRsp)(nil), "service_layer.SLL2RouteMsgRsp")
	proto.RegisterType((*SLL2GetNotifMsg)(nil), "service_layer.SLL2GetNotifMsg")
	proto.RegisterType((*SLL2RouteNotif)(nil), "service_layer.SLL2RouteNotif")
	proto.RegisterType((*SLL2BdStateInfo)(nil), "service_layer.SLL2BdStateInfo")
	proto.RegisterType((*SLL2NotifStatusMsg)(nil), "service_layer.SLL2NotifStatusMsg")
	proto.RegisterType((*SLL2Notif)(nil), "service_layer.SLL2Notif")
	proto.RegisterEnum("service_layer.SLL2RouteType", SLL2RouteType_name, SLL2RouteType_value)
	proto.RegisterEnum("service_layer.SLL2NotifType", SLL2NotifType_name, SLL2NotifType_value)
	proto.RegisterEnum("service_layer.SLL2RouteNh_SLL2RouteNhType", SLL2RouteNh_SLL2RouteNhType_name, SLL2RouteNh_SLL2RouteNhType_value)
	proto.RegisterEnum("service_layer.SLL2ImetRoute_PMSITunnelType", SLL2ImetRoute_PMSITunnelType_name, SLL2ImetRoute_PMSITunnelType_value)
	proto.RegisterEnum("service_layer.SLL2BdStateInfo_SLL2BdState", SLL2BdStateInfo_SLL2BdState_name, SLL2BdStateInfo_SLL2BdState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SLL2Oper service

type SLL2OperClient interface {
	// Used to retrieve global L2 info from the server.
	SLL2GlobalsGet(ctx context.Context, in *SLL2GlobalsGetMsg, opts ...grpc.CallOption) (*SLL2GlobalsGetMsgRsp, error)
	// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
	//     Global L2 registration.
	//     A client Must Register BEFORE sending BD registration messages
	//     (to add/update/delete routes) or BEFORE requesting for L2 route
	//     notifications.
	//
	// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
	//     Global L2 un-registration.
	//     This call is used to convey that the client is no longer
	//     interested in programming L2 routes and in receiving L2 route
	//     notifications. All programmed L2 routes will be deleted on the
	//     server and the server will stop sending L2 route notifications.
	//
	// SLL2RegMsg.Oper = SL_REGOP_EOF:
	//     Global L2 End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known
	//     objects and to convey the end of requests for L2 route
	//     notifications.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their routes.
	//
	SLL2RegOp(ctx context.Context, in *SLL2RegMsg, opts ...grpc.CallOption) (*SLL2RegMsgRsp, error)
	// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
	//     BD registration: Sends a list of BD registration messages and
	//     expects a list of registration responses.
	//     A client Must Register a BD BEFORE L2 Routes can be added/modified
	//     in that BD.
	//
	// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     BD un-registration: Sends a list of BD un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer
	//     interested in programming routes in this BD. All installed L2
	//     routes will be lost.
	//
	// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
	//     BD End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects
	//     in that BD.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their routes.
	//
	SLL2BdRegOp(ctx context.Context, in *SLL2BdRegMsg, opts ...grpc.CallOption) (*SLL2BdRegMsgRsp, error)
	// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
	// Route add. Fails if the route already exists.
	//
	// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
	// Route update. Creates or updates the route.
	//
	// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
	// Route delete. The route path is not necessary to delete the route.
	//
	SLL2RouteOp(ctx context.Context, in *SLL2RouteMsg, opts ...grpc.CallOption) (*SLL2RouteMsgRsp, error)
	// Stream adds/updates/deletes of L2 Routes.
	SLL2RouteOpStream(ctx context.Context, opts ...grpc.CallOption) (SLL2Oper_SLL2RouteOpStreamClient, error)
	// This call is used to get a stream of BD state and route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes 3 types of notification requests:
	// 1. Request for BD state notifications only (pass only Oper and
	//    Correlator).
	// 2. Request for BD state and Route notifications in all BDs.
	// 3. Request for Route notifications per-BD.
	//    This should be sent after requesting for BD state notifications
	//    and after receiving BD-ready notification.
	//
	// The success/failure of the notification request is relayed in the
	// SLL2NotifStatusMsg followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	// After all requests are sent, client should send GetNotifEof = TRUE.
	//
	SLL2GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLL2Oper_SLL2GetNotifStreamClient, error)
}

type sLL2OperClient struct {
	cc *grpc.ClientConn
}

func NewSLL2OperClient(cc *grpc.ClientConn) SLL2OperClient {
	return &sLL2OperClient{cc}
}

func (c *sLL2OperClient) SLL2GlobalsGet(ctx context.Context, in *SLL2GlobalsGetMsg, opts ...grpc.CallOption) (*SLL2GlobalsGetMsgRsp, error) {
	out := new(SLL2GlobalsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLL2Oper/SLL2GlobalsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLL2OperClient) SLL2RegOp(ctx context.Context, in *SLL2RegMsg, opts ...grpc.CallOption) (*SLL2RegMsgRsp, error) {
	out := new(SLL2RegMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLL2Oper/SLL2RegOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLL2OperClient) SLL2BdRegOp(ctx context.Context, in *SLL2BdRegMsg, opts ...grpc.CallOption) (*SLL2BdRegMsgRsp, error) {
	out := new(SLL2BdRegMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLL2Oper/SLL2BdRegOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLL2OperClient) SLL2RouteOp(ctx context.Context, in *SLL2RouteMsg, opts ...grpc.CallOption) (*SLL2RouteMsgRsp, error) {
	out := new(SLL2RouteMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLL2Oper/SLL2RouteOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLL2OperClient) SLL2RouteOpStream(ctx context.Context, opts ...grpc.CallOption) (SLL2Oper_SLL2RouteOpStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLL2Oper_serviceDesc.Streams[0], c.cc, "/service_layer.SLL2Oper/SLL2RouteOpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLL2OperSLL2RouteOpStreamClient{stream}
	return x, nil
}

type SLL2Oper_SLL2RouteOpStreamClient interface {
	Send(*SLL2RouteMsg) error
	Recv() (*SLL2RouteMsgRsp, error)
	grpc.ClientStream
}

type sLL2OperSLL2RouteOpStreamClient struct {
	grpc.ClientStream
}

func (x *sLL2OperSLL2RouteOpStreamClient) Send(m *SLL2RouteMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLL2OperSLL2RouteOpStreamClient) Recv() (*SLL2RouteMsgRsp, error) {
	m := new(SLL2RouteMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLL2OperClient) SLL2GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLL2Oper_SLL2GetNotifStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLL2Oper_serviceDesc.Streams[1], c.cc, "/service_layer.SLL2Oper/SLL2GetNotifStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLL2OperSLL2GetNotifStreamClient{stream}
	return x, nil
}

type SLL2Oper_SLL2GetNotifStreamClient interface {
	Send(*SLL2GetNotifMsg) error
	Recv() (*SLL2Notif, error)
	grpc.ClientStream
}

type sLL2OperSLL2GetNotifStreamClient struct {
	grpc.ClientStream
}

func (x *sLL2OperSLL2GetNotifStreamClient) Send(m *SLL2GetNotifMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLL2OperSLL2GetNotifStreamClient) Recv() (*SLL2Notif, error) {
	m := new(SLL2Notif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SLL2Oper service

type SLL2OperServer interface {
	// Used to retrieve global L2 info from the server.
	SLL2GlobalsGet(context.Context, *SLL2GlobalsGetMsg) (*SLL2GlobalsGetMsgRsp, error)
	// SLL2RegMsg.Oper = SL_REGOP_REGISTER:
	//     Global L2 registration.
	//     A client Must Register BEFORE sending BD registration messages
	//     (to add/update/delete routes) or BEFORE requesting for L2 route
	//     notifications.
	//
	// SLL2RegMsg.Oper = SL_REGOP_UNREGISTER:
	//     Global L2 un-registration.
	//     This call is used to convey that the client is no longer
	//     interested in programming L2 routes and in receiving L2 route
	//     notifications. All programmed L2 routes will be deleted on the
	//     server and the server will stop sending L2 route notifications.
	//
	// SLL2RegMsg.Oper = SL_REGOP_EOF:
	//     Global L2 End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known
	//     objects and to convey the end of requests for L2 route
	//     notifications.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their routes.
	//
	SLL2RegOp(context.Context, *SLL2RegMsg) (*SLL2RegMsgRsp, error)
	// SLL2BdRegMsg.Oper = SL_REGOP_REGISTER:
	//     BD registration: Sends a list of BD registration messages and
	//     expects a list of registration responses.
	//     A client Must Register a BD BEFORE L2 Routes can be added/modified
	//     in that BD.
	//
	// SLL2BdRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     BD un-registration: Sends a list of BD un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer
	//     interested in programming routes in this BD. All installed L2
	//     routes will be lost.
	//
	// SLL2BdRegMsg.Oper = SL_REGOP_EOF:
	//     BD End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects
	//     in that BD.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their routes.
	//
	SLL2BdRegOp(context.Context, *SLL2BdRegMsg) (*SLL2BdRegMsgRsp, error)
	// SLL2RouteMsg.Oper = SL_OBJOP_ADD:
	// Route add. Fails if the route already exists.
	//
	// SLL2RouteMsg.Oper = SL_OBJOP_UPDATE:
	// Route update. Creates or updates the route.
	//
	// SLL2RouteMsg.Oper = SL_OBJOP_DELETE:
	// Route delete. The route path is not necessary to delete the route.
	//
	SLL2RouteOp(context.Context, *SLL2RouteMsg) (*SLL2RouteMsgRsp, error)
	// Stream adds/updates/deletes of L2 Routes.
	SLL2RouteOpStream(SLL2Oper_SLL2RouteOpStreamServer) error
	// This call is used to get a stream of BD state and route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes 3 types of notification requests:
	// 1. Request for BD state notifications only (pass only Oper and
	//    Correlator).
	// 2. Request for BD state and Route notifications in all BDs.
	// 3. Request for Route notifications per-BD.
	//    This should be sent after requesting for BD state notifications
	//    and after receiving BD-ready notification.
	//
	// The success/failure of the notification request is relayed in the
	// SLL2NotifStatusMsg followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	// After all requests are sent, client should send GetNotifEof = TRUE.
	//
	SLL2GetNotifStream(SLL2Oper_SLL2GetNotifStreamServer) error
}

func RegisterSLL2OperServer(s *grpc.Server, srv SLL2OperServer) {
	s.RegisterService(&_SLL2Oper_serviceDesc, srv)
}

func _SLL2Oper_SLL2GlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLL2GlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLL2OperServer).SLL2GlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLL2Oper/SLL2GlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLL2OperServer).SLL2GlobalsGet(ctx, req.(*SLL2GlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLL2Oper_SLL2RegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLL2RegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLL2OperServer).SLL2RegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLL2Oper/SLL2RegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLL2OperServer).SLL2RegOp(ctx, req.(*SLL2RegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLL2Oper_SLL2BdRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLL2BdRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLL2OperServer).SLL2BdRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLL2Oper/SLL2BdRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLL2OperServer).SLL2BdRegOp(ctx, req.(*SLL2BdRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLL2Oper_SLL2RouteOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLL2RouteMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLL2OperServer).SLL2RouteOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLL2Oper/SLL2RouteOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLL2OperServer).SLL2RouteOp(ctx, req.(*SLL2RouteMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLL2Oper_SLL2RouteOpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLL2OperServer).SLL2RouteOpStream(&sLL2OperSLL2RouteOpStreamServer{stream})
}

type SLL2Oper_SLL2RouteOpStreamServer interface {
	Send(*SLL2RouteMsgRsp) error
	Recv() (*SLL2RouteMsg, error)
	grpc.ServerStream
}

type sLL2OperSLL2RouteOpStreamServer struct {
	grpc.ServerStream
}

func (x *sLL2OperSLL2RouteOpStreamServer) Send(m *SLL2RouteMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLL2OperSLL2RouteOpStreamServer) Recv() (*SLL2RouteMsg, error) {
	m := new(SLL2RouteMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLL2Oper_SLL2GetNotifStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLL2OperServer).SLL2GetNotifStream(&sLL2OperSLL2GetNotifStreamServer{stream})
}

type SLL2Oper_SLL2GetNotifStreamServer interface {
	Send(*SLL2Notif) error
	Recv() (*SLL2GetNotifMsg, error)
	grpc.ServerStream
}

type sLL2OperSLL2GetNotifStreamServer struct {
	grpc.ServerStream
}

func (x *sLL2OperSLL2GetNotifStreamServer) Send(m *SLL2Notif) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLL2OperSLL2GetNotifStreamServer) Recv() (*SLL2GetNotifMsg, error) {
	m := new(SLL2GetNotifMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLL2Oper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLL2Oper",
	HandlerType: (*SLL2OperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLL2GlobalsGet",
			Handler:    _SLL2Oper_SLL2GlobalsGet_Handler,
		},
		{
			MethodName: "SLL2RegOp",
			Handler:    _SLL2Oper_SLL2RegOp_Handler,
		},
		{
			MethodName: "SLL2BdRegOp",
			Handler:    _SLL2Oper_SLL2BdRegOp_Handler,
		},
		{
			MethodName: "SLL2RouteOp",
			Handler:    _SLL2Oper_SLL2RouteOp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLL2RouteOpStream",
			Handler:       _SLL2Oper_SLL2RouteOpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLL2GetNotifStream",
			Handler:       _SLL2Oper_SLL2GetNotifStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_l2_route.proto",
}

func init() { proto.RegisterFile("sl_l2_route.proto", fileDescriptor6) }

var fileDescriptor6 = []byte{
	// 1670 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xef, 0xfa, 0x25, 0x89, 0x27, 0x4d, 0xfe, 0xe9, 0xf4, 0xe5, 0xef, 0xa4, 0x69, 0x48, 0x97,
	0x82, 0xa2, 0x00, 0x51, 0xe5, 0xaa, 0xe2, 0x55, 0x48, 0x76, 0xbd, 0xb4, 0x26, 0xf6, 0xda, 0x1a,
	0x6f, 0x03, 0x3d, 0x59, 0x9b, 0x78, 0x12, 0x07, 0x6c, 0xaf, 0xbb, 0xbb, 0xae, 0x9a, 0x2b, 0x5c,
	0x11, 0x48, 0x48, 0xf0, 0x29, 0xb8, 0x70, 0xe1, 0xc0, 0x81, 0xcf, 0xc0, 0x01, 0x09, 0x6e, 0x7c,
	0x00, 0xae, 0x7c, 0x00, 0x9e, 0x79, 0xd9, 0xd9, 0xd9, 0x78, 0x37, 0x4d, 0x95, 0x9e, 0xec, 0x79,
	0xde, 0xe6, 0x99, 0x67, 0x7e, 0xcf, 0xcb, 0x2c, 0xba, 0x12, 0x0c, 0x7b, 0xc3, 0x4a, 0xcf, 0xf7,
	0xa6, 0x21, 0xdd, 0x99, 0xf8, 0x5e, 0xe8, 0xe1, 0xa5, 0x80, 0xfa, 0xcf, 0x8e, 0x0f, 0x68, 0x6f,
	0xe8, 0x9e, 0x50, 0x7f, 0xed, 0x3a, 0x48, 0x1c, 0x78, 0xa3, 0x91, 0x37, 0xee, 0x85, 0x27, 0x13,
	0x1a, 0x08, 0x29, 0xf3, 0x2a, 0xba, 0xd2, 0x6d, 0x36, 0x2b, 0x0f, 0x87, 0xde, 0xbe, 0x3b, 0x0c,
	0x1e, 0xd2, 0xb0, 0x15, 0x1c, 0x99, 0xbf, 0x18, 0xe8, 0xda, 0x0c, 0x95, 0x04, 0x13, 0xfc, 0x01,
	0x2a, 0x59, 0xbe, 0xdf, 0x0d, 0xdd, 0x70, 0x1a, 0x94, 0x8d, 0x4d, 0x63, 0x6b, 0xb1, 0xb2, 0xbe,
	0x93, 0xd8, 0x67, 0xa7, 0xdb, 0x04, 0x09, 0x4f, 0xca, 0x90, 0x58, 0x1c, 0xdf, 0x45, 0x57, 0x5b,
	0xee, 0xf3, 0x5a, 0x9f, 0xd0, 0xa3, 0x0e, 0xf5, 0xf9, 0xef, 0x28, 0x38, 0x2a, 0xe7, 0xc0, 0xca,
	0x12, 0x49, 0x63, 0x49, 0x0d, 0xc2, 0xce, 0x04, 0x64, 0xfe, 0xcb, 0x34, 0xf2, 0x4a, 0xe3, 0x34,
	0xcb, 0xfc, 0xde, 0x40, 0x88, 0x39, 0x0e, 0x06, 0xc0, 0x63, 0xbc, 0x8d, 0x0a, 0xed, 0x09, 0xf5,
	0xb9, 0xa7, 0xcb, 0x95, 0x1b, 0x33, 0x9e, 0x82, 0x58, 0x7b, 0x42, 0xb8, 0x0c, 0xbe, 0x83, 0x96,
	0xaa, 0xfd, 0xd1, 0xf1, 0xb8, 0x7e, 0x1c, 0x84, 0xee, 0xf8, 0x80, 0x4a, 0xc7, 0x92, 0x44, 0x5c,
	0x41, 0xd7, 0x3a, 0x53, 0xff, 0x88, 0x36, 0xc6, 0x21, 0xd8, 0x72, 0x87, 0x5d, 0x7a, 0xe0, 0x8d,
	0xfb, 0x81, 0xf4, 0x29, 0x95, 0x67, 0xee, 0xa2, 0xa5, 0xd8, 0x27, 0x19, 0x45, 0x58, 0xbc, 0x4c,
	0x14, 0x95, 0xb8, 0xf9, 0x39, 0xba, 0xcc, 0x8c, 0xf1, 0x18, 0xbd, 0xec, 0x11, 0xd7, 0x51, 0x89,
	0xeb, 0xd9, 0xee, 0x88, 0x1d, 0x2f, 0xbf, 0x55, 0x22, 0x31, 0xc1, 0xdc, 0xd7, 0x2c, 0x13, 0x1a,
	0x5c, 0xe8, 0xae, 0x6f, 0xa0, 0xb9, 0x5a, 0x5f, 0x6e, 0x63, 0xc0, 0x36, 0x72, 0x65, 0x7e, 0x63,
	0xa0, 0xff, 0xe9, 0xee, 0xb3, 0x68, 0xd4, 0x20, 0x3c, 0x5c, 0xab, 0x3b, 0x1d, 0x8d, 0x5c, 0xff,
	0xe4, 0x5c, 0x7b, 0x25, 0x55, 0xf0, 0x7d, 0x34, 0x0f, 0x2e, 0x4f, 0x87, 0x61, 0xc0, 0xcf, 0xb5,
	0x58, 0xb9, 0x39, 0xa3, 0x1d, 0x9f, 0x8c, 0x44, 0xb2, 0xe6, 0xa6, 0x38, 0x32, 0x87, 0x8f, 0x15,
	0x1c, 0xe3, 0x15, 0x94, 0x87, 0x1f, 0xee, 0xc0, 0x65, 0xc2, 0xfe, 0x9a, 0x3f, 0xe7, 0xd0, 0xa2,
	0x12, 0xb1, 0x07, 0xe0, 0xec, 0x9c, 0x3d, 0x70, 0x20, 0x7f, 0x64, 0xc0, 0xb7, 0x53, 0xf6, 0x91,
	0xb2, 0xfa, 0x7f, 0xa6, 0x41, 0xa4, 0x26, 0xfe, 0x18, 0x2d, 0xda, 0x03, 0x0e, 0x92, 0x43, 0x57,
	0xe2, 0x6c, 0xb1, 0xb2, 0x36, 0x63, 0x48, 0x49, 0x3c, 0xba, 0x44, 0x74, 0x05, 0xfc, 0x11, 0x2a,
	0xd9, 0x83, 0xf6, 0x33, 0xea, 0x83, 0x24, 0x07, 0x5e, 0x5a, 0xb0, 0x9a, 0x15, 0x29, 0x61, 0x0f,
	0x40, 0x3f, 0x56, 0x30, 0xf7, 0xc4, 0x0d, 0x68, 0x8e, 0xe1, 0xeb, 0xac, 0x06, 0xf4, 0x9a, 0x95,
	0x9e, 0xfd, 0xa8, 0x47, 0xac, 0xae, 0x45, 0xf6, 0xac, 0xfa, 0xca, 0x25, 0xb8, 0x44, 0xac, 0xc8,
	0x0d, 0xdb, 0xb1, 0xc8, 0x27, 0xd5, 0x07, 0xd6, 0x8a, 0x81, 0xaf, 0xa1, 0x15, 0x45, 0x6f, 0xef,
	0x59, 0xa4, 0x59, 0x7d, 0xb2, 0x92, 0xab, 0x2d, 0xb0, 0xc8, 0xd4, 0xdd, 0xd0, 0x35, 0x7f, 0xc8,
	0x09, 0xc0, 0x2b, 0x07, 0xc0, 0xe3, 0x45, 0xb5, 0x68, 0x4c, 0xe4, 0x05, 0xa7, 0x9c, 0x78, 0x52,
	0xed, 0xf7, 0x7d, 0x1a, 0x04, 0x44, 0x17, 0x87, 0x98, 0x2f, 0xab, 0xa5, 0x35, 0x3e, 0x70, 0x27,
	0x3c, 0x64, 0xcb, 0x29, 0x06, 0x38, 0x97, 0xc7, 0xfa, 0x94, 0x06, 0x7e, 0x53, 0xb3, 0xd1, 0x74,
	0xf7, 0xe9, 0x50, 0x66, 0xec, 0x29, 0x2a, 0xa4, 0xd3, 0x4a, 0x4c, 0xb9, 0x27, 0x24, 0x0b, 0x80,
	0xa8, 0x25, 0x32, 0x43, 0xc7, 0x3b, 0x08, 0x2b, 0x1a, 0x0f, 0xa7, 0xdf, 0x72, 0x0f, 0xca, 0x45,
	0x0e, 0x9e, 0x14, 0x8e, 0xf9, 0xa5, 0x88, 0x3c, 0xfc, 0xe5, 0xb4, 0x5d, 0x7a, 0x82, 0x37, 0x10,
	0x82, 0xa5, 0x3c, 0xb5, 0xc4, 0x9d, 0x46, 0xc1, 0xef, 0xa1, 0x92, 0x0a, 0x4a, 0x36, 0x50, 0x54,
	0xd8, 0x62, 0x61, 0xf3, 0x6f, 0x43, 0x60, 0x3b, 0xda, 0x0d, 0xd2, 0x79, 0x21, 0xda, 0x56, 0x5e,
	0xc0, 0x46, 0x0a, 0x68, 0x34, 0xe7, 0x88, 0x92, 0xc7, 0x9b, 0x90, 0x04, 0xf4, 0xe9, 0x94, 0x42,
	0x05, 0xb4, 0xa7, 0x23, 0x59, 0x19, 0x75, 0x12, 0xbe, 0x87, 0xe6, 0x40, 0x95, 0x25, 0x8f, 0x00,
	0xe4, 0xcd, 0xac, 0xbc, 0x00, 0x11, 0x22, 0x45, 0x19, 0x2c, 0x6c, 0xfa, 0x3c, 0x7c, 0xe4, 0x4d,
	0x9a, 0x50, 0x5f, 0x79, 0x9c, 0xd3, 0xce, 0xa7, 0xc0, 0x4a, 0x74, 0x71, 0x73, 0xc0, 0x60, 0xd8,
	0xac, 0x34, 0x46, 0x34, 0x54, 0x8e, 0xae, 0xa1, 0x05, 0x2b, 0x1c, 0x38, 0xee, 0x51, 0xa3, 0xcf,
	0x0f, 0xb9, 0x44, 0xd4, 0xfa, 0x02, 0xb1, 0xfc, 0xb6, 0x20, 0x00, 0xad, 0xb6, 0xc2, 0x1f, 0xce,
	0x04, 0xf3, 0xb5, 0x14, 0xb7, 0x75, 0xd7, 0xb4, 0x68, 0x82, 0x23, 0x0a, 0xa8, 0xe7, 0x80, 0x72,
	0x2c, 0x0c, 0x99, 0x57, 0xd4, 0xc1, 0x2b, 0x16, 0x78, 0x17, 0x21, 0x67, 0x3a, 0x1e, 0xd3, 0x21,
	0x37, 0x58, 0xe0, 0x06, 0xdf, 0x3a, 0xcb, 0x9d, 0x9d, 0x4e, 0xab, 0xdb, 0x88, 0x55, 0x88, 0xa6,
	0xce, 0x12, 0x45, 0xac, 0x1a, 0xfd, 0x26, 0x1d, 0x1f, 0x85, 0x03, 0x0e, 0x68, 0x48, 0x94, 0x24,
	0x95, 0xb5, 0xcb, 0x88, 0xb2, 0xe7, 0x0e, 0xa7, 0xb4, 0x3c, 0xc7, 0xc1, 0x9b, 0x24, 0x9a, 0x7f,
	0x18, 0x68, 0x39, 0xb9, 0x19, 0xc6, 0x82, 0xd2, 0xb3, 0xdb, 0x3d, 0xe7, 0xb1, 0x6d, 0x5b, 0x4d,
	0xa8, 0x34, 0x65, 0xe8, 0xaa, 0x8c, 0x46, 0xba, 0x7b, 0x9d, 0x4e, 0xa5, 0xd5, 0x89, 0x38, 0x86,
	0xe2, 0xb4, 0x9a, 0xf5, 0x04, 0x27, 0xc7, 0xaa, 0x13, 0xe7, 0x74, 0x1a, 0xad, 0x6e, 0xb7, 0x15,
	0xd1, 0xf3, 0xac, 0x98, 0x29, 0xba, 0x22, 0x17, 0x94, 0x21, 0x20, 0xd7, 0x1a, 0xf5, 0x06, 0x89,
	0x38, 0x45, 0x65, 0xa8, 0x61, 0x3f, 0x24, 0x96, 0xda, 0x60, 0x0e, 0xaf, 0xa2, 0xeb, 0x6a, 0xeb,
	0x96, 0xbe, 0xf7, 0xbc, 0xf9, 0x97, 0xa1, 0x35, 0x0e, 0x76, 0xa5, 0x71, 0xbf, 0x33, 0xf4, 0x7e,
	0x07, 0x13, 0x4c, 0x41, 0xbb, 0xe5, 0xf5, 0x2c, 0x68, 0xf3, 0x5b, 0xe0, 0x92, 0x00, 0x0e, 0x96,
	0x1d, 0x0c, 0x57, 0xf9, 0xf3, 0x24, 0x29, 0xd4, 0x76, 0x29, 0x0f, 0x98, 0x9c, 0x67, 0x37, 0xcc,
	0x54, 0x0b, 0xe7, 0x82, 0x24, 0xe8, 0x46, 0x1a, 0xb5, 0x79, 0x54, 0xb4, 0x9e, 0xd1, 0x71, 0x68,
	0xfe, 0x69, 0xa0, 0x92, 0xf2, 0xeb, 0x15, 0x9e, 0xeb, 0x7d, 0xb4, 0x10, 0xb9, 0x7d, 0x46, 0x89,
	0x88, 0x44, 0xc0, 0x35, 0x25, 0xce, 0xfa, 0x9d, 0x72, 0x5b, 0x1e, 0x6d, 0xfd, 0xac, 0xa3, 0xb1,
	0x7e, 0xa7, 0x16, 0xf1, 0xc9, 0xbe, 0xd3, 0x2f, 0x8d, 0x8d, 0x4e, 0x50, 0x7c, 0x1f, 0x78, 0xbe,
	0x4f, 0x87, 0x6e, 0xe8, 0x89, 0x01, 0xaa, 0x40, 0x34, 0x0a, 0x7e, 0x47, 0x8e, 0x56, 0xe2, 0x90,
	0xab, 0x33, 0x5b, 0xb6, 0xf7, 0xbf, 0xa0, 0x07, 0xa1, 0x9a, 0xae, 0xee, 0xa2, 0x39, 0x6e, 0x9a,
	0x0d, 0x83, 0xac, 0x90, 0x95, 0xb3, 0xa2, 0x42, 0xa4, 0x9c, 0xf9, 0xb5, 0xee, 0xd1, 0x45, 0x47,
	0xae, 0x77, 0xb5, 0x92, 0x94, 0x3b, 0xbb, 0x06, 0x27, 0xca, 0x91, 0xf9, 0x93, 0xa1, 0x4d, 0x04,
	0x72, 0x26, 0x7b, 0x51, 0x68, 0x66, 0x66, 0xb6, 0xdc, 0x85, 0x66, 0xb6, 0x7c, 0xe6, 0xcc, 0x16,
	0x85, 0x26, 0x9e, 0xd9, 0x7e, 0x93, 0xee, 0xc2, 0xa3, 0xc4, 0xf6, 0xc2, 0xe3, 0x43, 0x76, 0x93,
	0x6f, 0x27, 0x86, 0xe0, 0xd9, 0xc0, 0x73, 0x41, 0x75, 0x51, 0xc9, 0xc3, 0xe5, 0x66, 0x0e, 0x07,
	0xdd, 0x2e, 0x32, 0x6e, 0x79, 0x87, 0x1c, 0xad, 0x0b, 0x44, 0x27, 0x41, 0x5a, 0x14, 0x6b, 0xfd,
	0xea, 0x70, 0xc8, 0xd1, 0xb8, 0x00, 0x78, 0x13, 0x4b, 0x28, 0x32, 0x51, 0xba, 0xb0, 0xa2, 0x59,
	0x62, 0xc9, 0x29, 0xd6, 0xb5, 0x12, 0x3b, 0x2c, 0xb4, 0x4b, 0xe8, 0x5b, 0x4f, 0xd1, 0x72, 0xdc,
	0xd3, 0x98, 0x45, 0x05, 0x34, 0xe3, 0x65, 0x81, 0x26, 0xa2, 0xfe, 0x62, 0xa0, 0xfd, 0xab, 0xc6,
	0x6e, 0x76, 0x05, 0xf0, 0x40, 0x39, 0xf4, 0x32, 0x53, 0xbb, 0x8e, 0xe6, 0xa5, 0x98, 0x04, 0xfe,
	0x76, 0xea, 0x28, 0xad, 0x0c, 0xe9, 0x6b, 0x12, 0xa9, 0x9a, 0x5f, 0x19, 0x62, 0x6e, 0x96, 0x6b,
	0x7c, 0x13, 0xfd, 0x5f, 0xcc, 0x8c, 0xb5, 0x7a, 0xaf, 0xeb, 0x54, 0x1d, 0x4b, 0x1f, 0x34, 0xcb,
	0xec, 0xb5, 0x99, 0x60, 0x56, 0xeb, 0x75, 0xe0, 0x18, 0xd0, 0xcf, 0x6f, 0x9c, 0xe2, 0xd4, 0xad,
	0xa6, 0xe5, 0x00, 0x2f, 0x07, 0xd7, 0xb4, 0x3e, 0x63, 0xb2, 0x03, 0xb3, 0x68, 0xcf, 0xb6, 0x2c,
	0xa6, 0x9d, 0x37, 0x7f, 0x35, 0xd8, 0x04, 0xdb, 0xac, 0xf0, 0x28, 0x0b, 0xf0, 0xbd, 0x7a, 0xb4,
	0xc4, 0x71, 0xcc, 0x27, 0xe2, 0xc8, 0xa6, 0xfc, 0x78, 0xdf, 0xcc, 0xba, 0xa5, 0x27, 0x88, 0xae,
	0x60, 0xfe, 0x9e, 0x13, 0x85, 0x58, 0x40, 0x84, 0x55, 0x06, 0x56, 0xc5, 0xb4, 0xa7, 0x47, 0x5a,
	0x0d, 0xe4, 0xc2, 0x72, 0x6a, 0x88, 0xc4, 0x59, 0xfd, 0x8c, 0xab, 0xca, 0x39, 0x12, 0x95, 0xd5,
	0xcf, 0xb8, 0xae, 0x58, 0xc9, 0x73, 0x88, 0xda, 0x7d, 0x3b, 0x6b, 0x6f, 0x15, 0x65, 0xfe, 0x68,
	0x89, 0x29, 0x50, 0x31, 0x16, 0x35, 0xd0, 0xc8, 0x70, 0x6c, 0x9c, 0x0d, 0x2d, 0x66, 0x43, 0x87,
	0xec, 0x7d, 0x54, 0x14, 0x4d, 0xa0, 0xc8, 0xb5, 0x6f, 0x65, 0x4e, 0x8a, 0x6c, 0x5f, 0x96, 0x95,
	0xc9, 0x0e, 0xb0, 0xed, 0xc8, 0x87, 0x78, 0xd4, 0x9a, 0x62, 0xe0, 0x91, 0xf6, 0xe3, 0x24, 0x24,
	0xaf, 0xb2, 0x84, 0x89, 0x39, 0xad, 0xea, 0x03, 0xfd, 0xe1, 0x23, 0x88, 0x8d, 0x96, 0xe5, 0xac,
	0xe4, 0xb6, 0x7f, 0x94, 0xcf, 0x1d, 0x15, 0x7b, 0x7c, 0x0b, 0xad, 0x0a, 0x39, 0x6b, 0xcf, 0xb2,
	0x9d, 0x9e, 0xf3, 0xa4, 0x93, 0xb0, 0xad, 0x40, 0xad, 0xb1, 0x2d, 0x42, 0xda, 0x04, 0xb6, 0x50,
	0x79, 0xa2, 0xf1, 0x18, 0xb8, 0x1f, 0x77, 0x01, 0xf1, 0xb7, 0xd1, 0xad, 0x34, 0x26, 0x71, 0xc0,
	0x3f, 0xb2, 0x6b, 0x11, 0x98, 0x7e, 0xd2, 0xb6, 0x8e, 0xf2, 0x03, 0xa6, 0xa0, 0x2d, 0x74, 0x27,
	0x93, 0xdd, 0xb3, 0xec, 0x7a, 0x64, 0xa8, 0x98, 0xea, 0x24, 0x3f, 0x36, 0x4c, 0x46, 0x6f, 0xa0,
	0xdb, 0xe9, 0x3c, 0xdd, 0xc4, 0x7c, 0xe5, 0x9f, 0x3c, 0x5a, 0xe0, 0xef, 0x40, 0x96, 0x46, 0x9f,
	0x89, 0xaa, 0x17, 0x7f, 0x51, 0xc2, 0x9b, 0x29, 0xd7, 0x97, 0xf8, 0xe0, 0xb4, 0xf6, 0xfa, 0x8b,
	0x24, 0x58, 0xab, 0xaa, 0xcb, 0x79, 0x85, 0x7d, 0xe7, 0xc0, 0xab, 0x69, 0x90, 0xe0, 0x5f, 0x1a,
	0xd6, 0xd6, 0x33, 0x59, 0xcc, 0xca, 0xa7, 0x51, 0xb9, 0x12, 0x76, 0x32, 0x3f, 0x1f, 0x30, 0x4b,
	0x1b, 0x67, 0x30, 0x35, 0x5b, 0x1c, 0x66, 0x19, 0xb6, 0xa2, 0x5e, 0x9b, 0x6a, 0x4b, 0x6f, 0xc4,
	0x8e, 0xf8, 0x3c, 0x27, 0x6d, 0x75, 0x43, 0x9f, 0xba, 0xa3, 0x0b, 0x59, 0xdc, 0x32, 0xee, 0x1a,
	0x98, 0x88, 0xba, 0x18, 0xb5, 0x34, 0x69, 0x36, 0x4d, 0x53, 0xeb, 0xb2, 0x6b, 0xe5, 0xac, 0xa4,
	0x67, 0x36, 0xf7, 0xe7, 0xf8, 0xf7, 0xc4, 0x7b, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xb2,
	0xe5, 0xa3, 0x8a, 0x14, 0x00, 0x00,
}
