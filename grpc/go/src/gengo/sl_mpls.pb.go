// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_mpls.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// MPLS label actions.
type SlLabelAction int32

const (
	// Reserved. 0x0
	SlLabelAction_SL_LABEL_ACTION_RESERVED SlLabelAction = 0
	// Swap. 0x1
	// Swap outer label and forward.
	// Used at tunnel midpoint for swapping labels.
	SlLabelAction_SL_LABEL_ACTION_SWAP SlLabelAction = 1
	// Pop and forward. 0x2
	// Pop outer label and forward.
	// Used for per CE and per prefix label disposition at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_FORWARD SlLabelAction = 2
	// Pop and lookup IPv4. 0x3
	// Pop and lookup the IPv4 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4 SlLabelAction = 3
	// Pop and lookup IPv6. 0x4
	// Pop and lookup the IPv6 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6 SlLabelAction = 4
	// Pop and lookup. 0x5
	// Pop and lookup the next header in the packet (MPLS, IPv4, IPv6) in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP SlLabelAction = 5
)

var SlLabelAction_name = map[int32]string{
	0: "SL_LABEL_ACTION_RESERVED",
	1: "SL_LABEL_ACTION_SWAP",
	2: "SL_LABEL_ACTION_POP_AND_FORWARD",
	3: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4",
	4: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6",
	5: "SL_LABEL_ACTION_POP_AND_LOOKUP",
}
var SlLabelAction_value = map[string]int32{
	"SL_LABEL_ACTION_RESERVED":            0,
	"SL_LABEL_ACTION_SWAP":                1,
	"SL_LABEL_ACTION_POP_AND_FORWARD":     2,
	"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4": 3,
	"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6": 4,
	"SL_LABEL_ACTION_POP_AND_LOOKUP":      5,
}

func (x SlLabelAction) String() string {
	return proto.EnumName(SlLabelAction_name, int32(x))
}
func (SlLabelAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

// Label Block Types
type SLMplsLabelBlockType int32

const (
	// Reserved. 0x0
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_RESERVED SLMplsLabelBlockType = 0
	// Segment Routing Global Block (SRGB) Block Type. 0x1
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_SRGB SLMplsLabelBlockType = 1
	// Class Based Forwarding (CBF) Block Type. 0x2
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_CBF SLMplsLabelBlockType = 2
)

var SLMplsLabelBlockType_name = map[int32]string{
	0: "SL_MPLS_LABEL_BLOCK_TYPE_RESERVED",
	1: "SL_MPLS_LABEL_BLOCK_TYPE_SRGB",
	2: "SL_MPLS_LABEL_BLOCK_TYPE_CBF",
}
var SLMplsLabelBlockType_value = map[string]int32{
	"SL_MPLS_LABEL_BLOCK_TYPE_RESERVED": 0,
	"SL_MPLS_LABEL_BLOCK_TYPE_SRGB":     1,
	"SL_MPLS_LABEL_BLOCK_TYPE_CBF":      2,
}

func (x SLMplsLabelBlockType) String() string {
	return proto.EnumName(SLMplsLabelBlockType_name, int32(x))
}
func (SLMplsLabelBlockType) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

// MPLS Label block key.
// This message is used to relay the label block key attributes.
type SLMplsLabelBlockKey struct {
	// Starting label value of the block.
	StartLabel uint32 `protobuf:"varint,1,opt,name=StartLabel" json:"StartLabel,omitempty"`
	// Label block size.
	// Block size should be <= SLServerResponse.MaxLabelsPerBlock
	LabelBlockSize uint32 `protobuf:"varint,2,opt,name=LabelBlockSize" json:"LabelBlockSize,omitempty"`
	// Label block type. See definition of SlMplsLabelBlockType for valid values.
	// If none specified, defaults to SL_MPLS_LABEL_BLOCK_TYPE_SRGB.
	BlockType SLMplsLabelBlockType `protobuf:"varint,3,opt,name=BlockType,enum=service_layer.SLMplsLabelBlockType" json:"BlockType,omitempty"`
	// Label block client name as configured e.g. through CLI.
	// Client name is ignored if BlockType is not SL_MPLS_LABEL_BLOCK_TYPE_CBF.
	ClientName string `protobuf:"bytes,4,opt,name=ClientName" json:"ClientName,omitempty"`
}

func (m *SLMplsLabelBlockKey) Reset()                    { *m = SLMplsLabelBlockKey{} }
func (m *SLMplsLabelBlockKey) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockKey) ProtoMessage()               {}
func (*SLMplsLabelBlockKey) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

func (m *SLMplsLabelBlockKey) GetStartLabel() uint32 {
	if m != nil {
		return m.StartLabel
	}
	return 0
}

func (m *SLMplsLabelBlockKey) GetLabelBlockSize() uint32 {
	if m != nil {
		return m.LabelBlockSize
	}
	return 0
}

func (m *SLMplsLabelBlockKey) GetBlockType() SLMplsLabelBlockType {
	if m != nil {
		return m.BlockType
	}
	return SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_RESERVED
}

func (m *SLMplsLabelBlockKey) GetClientName() string {
	if m != nil {
		return m.ClientName
	}
	return ""
}

// MPLS Label block batch reservation message.
// This message is used to send a batch of label block requests.
// The Oper attributes indicates add or delete operations.
type SLMplsLabelBlockMsg struct {
	// MPLS Label Block Operations.
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// List of label blocks requests.
	// List size should be <= SLServerResponse.MaxLabelBlocksPerRequest
	MplsBlocks []*SLMplsLabelBlockKey `protobuf:"bytes,2,rep,name=MplsBlocks" json:"MplsBlocks,omitempty"`
}

func (m *SLMplsLabelBlockMsg) Reset()                    { *m = SLMplsLabelBlockMsg{} }
func (m *SLMplsLabelBlockMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsg) ProtoMessage()               {}
func (*SLMplsLabelBlockMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

func (m *SLMplsLabelBlockMsg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLMplsLabelBlockMsg) GetMplsBlocks() []*SLMplsLabelBlockKey {
	if m != nil {
		return m.MplsBlocks
	}
	return nil
}

// MPLS Label block reservation result.
// This message is used to convey the result status corresponding to
// the label block operation.
type SLMplsLabelBlockMsgRes struct {
	// Corresponding error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Key for which the error code is reported.
	Key *SLMplsLabelBlockKey `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *SLMplsLabelBlockMsgRes) Reset()                    { *m = SLMplsLabelBlockMsgRes{} }
func (m *SLMplsLabelBlockMsgRes) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsgRes) ProtoMessage()               {}
func (*SLMplsLabelBlockMsgRes) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{2} }

func (m *SLMplsLabelBlockMsgRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsLabelBlockMsgRes) GetKey() *SLMplsLabelBlockKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// MPLS Label block batch reservation response.
// This message is used to convey a summary status for the batch operation.
// If there are errors encountered, the Results field would indicate which
// label block reservation failed.
type SLMplsLabelBlockMsgRsp struct {
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLMplsLabelBlockMsgRes `protobuf:"bytes,2,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLMplsLabelBlockMsgRsp) Reset()                    { *m = SLMplsLabelBlockMsgRsp{} }
func (m *SLMplsLabelBlockMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsgRsp) ProtoMessage()               {}
func (*SLMplsLabelBlockMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{3} }

func (m *SLMplsLabelBlockMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLMplsLabelBlockMsgRsp) GetResults() []*SLMplsLabelBlockMsgRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// MPLS Label Block Get Message
// This message is used to query previous label block reservations.
type SLMplsLabelBlockGetMsg struct {
	// MPLS Label Block key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsLabelBlockKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext" json:"GetNext,omitempty"`
}

func (m *SLMplsLabelBlockGetMsg) Reset()                    { *m = SLMplsLabelBlockGetMsg{} }
func (m *SLMplsLabelBlockGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockGetMsg) ProtoMessage()               {}
func (*SLMplsLabelBlockGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{4} }

func (m *SLMplsLabelBlockGetMsg) GetKey() *SLMplsLabelBlockKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsLabelBlockGetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLMplsLabelBlockGetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// MPLS Label Block get message response
// This message is the response to the label block query.
type SLMplsLabelBlockGetMsgRsp struct {
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLMplsLabelBlockKey `protobuf:"bytes,3,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLMplsLabelBlockGetMsgRsp) Reset()                    { *m = SLMplsLabelBlockGetMsgRsp{} }
func (m *SLMplsLabelBlockGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockGetMsgRsp) ProtoMessage()               {}
func (*SLMplsLabelBlockGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{5} }

func (m *SLMplsLabelBlockGetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLMplsLabelBlockGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsLabelBlockGetMsgRsp) GetEntries() []*SLMplsLabelBlockKey {
	if m != nil {
		return m.Entries
	}
	return nil
}

// MPLS Registration message.
type SlMplsReg struct {
	// In case the Service Layer -> LSD connection is lost, this specifies the
	// timeout period after which LSD will automatically purge the installed
	// ILMs, unless the service layer:
	//    1. Sends MPLS Registration message
	//    2. Replays all label blocks and ILMs
	//    3. and sends MPLS EOF message
	// Similarly, in the event of an RP Switchover the ILMs must be replayed
	// within the purge interval.
	// Purge timer is ignored for all registration messages except for
	// SL_REGOP_REGISTER
	PurgeIntervalSeconds uint32 `protobuf:"varint,1,opt,name=PurgeIntervalSeconds" json:"PurgeIntervalSeconds,omitempty"`
}

func (m *SlMplsReg) Reset()                    { *m = SlMplsReg{} }
func (m *SlMplsReg) String() string            { return proto.CompactTextString(m) }
func (*SlMplsReg) ProtoMessage()               {}
func (*SlMplsReg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{6} }

func (m *SlMplsReg) GetPurgeIntervalSeconds() uint32 {
	if m != nil {
		return m.PurgeIntervalSeconds
	}
	return 0
}

// MPLS Registration message.
// This message is used for MPLS global registration. Clients must register
// before using any MPLS service.
type SLMplsRegMsg struct {
	// Registration Operation
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// Registration Message
	RegMsg *SlMplsReg `protobuf:"bytes,2,opt,name=RegMsg" json:"RegMsg,omitempty"`
}

func (m *SLMplsRegMsg) Reset()                    { *m = SLMplsRegMsg{} }
func (m *SLMplsRegMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsRegMsg) ProtoMessage()               {}
func (*SLMplsRegMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{7} }

func (m *SLMplsRegMsg) GetOper() SLRegOp {
	if m != nil {
		return m.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (m *SLMplsRegMsg) GetRegMsg() *SlMplsReg {
	if m != nil {
		return m.RegMsg
	}
	return nil
}

// MPLS Registration response message.
// This message is used to convey the result of the MPLS registration.
type SLMplsRegMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
}

func (m *SLMplsRegMsgRsp) Reset()                    { *m = SLMplsRegMsgRsp{} }
func (m *SLMplsRegMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsRegMsgRsp) ProtoMessage()               {}
func (*SLMplsRegMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{8} }

func (m *SLMplsRegMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

// MPLS Get Global Info message.
// This message is used to query MPLS global capabilities.
type SLMplsGetMsg struct {
}

func (m *SLMplsGetMsg) Reset()                    { *m = SLMplsGetMsg{} }
func (m *SLMplsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsGetMsg) ProtoMessage()               {}
func (*SLMplsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{9} }

// MPLS Get Global Info response message.
// This message is used to convey the response to the global capabilities query.
type SLMplsGetMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Maximum labels that can be allocated/freed per label block.
	MaxLabelsPerBlock uint32 `protobuf:"varint,2,opt,name=MaxLabelsPerBlock" json:"MaxLabelsPerBlock,omitempty"`
	// Maximum label blocks that can be allocated/freed per MplsLabelBlockMsg
	MaxLabelblocksPerLabelblockmsg uint32 `protobuf:"varint,3,opt,name=MaxLabelblocksPerLabelblockmsg" json:"MaxLabelblocksPerLabelblockmsg,omitempty"`
	// Minimum label value that can be reserved on the platform.
	// MplsLabelBlockKey.StartLabel >= MinStartLabel
	MinStartLabel uint32 `protobuf:"varint,4,opt,name=MinStartLabel" json:"MinStartLabel,omitempty"`
	// Label table size for the platform.
	// MplsLabelBlockKey.StartLabel <= LabelTableSize
	LabelTableSize uint32 `protobuf:"varint,5,opt,name=LabelTableSize" json:"LabelTableSize,omitempty"`
	// Max ILM objects within a single IlmMsg message.
	MaxIlmPerIlmmsg uint32 `protobuf:"varint,6,opt,name=MaxIlmPerIlmmsg" json:"MaxIlmPerIlmmsg,omitempty"`
	// Maximum paths per ILM.
	MaxPathsPerIlm uint32 `protobuf:"varint,7,opt,name=MaxPathsPerIlm" json:"MaxPathsPerIlm,omitempty"`
}

func (m *SLMplsGetMsgRsp) Reset()                    { *m = SLMplsGetMsgRsp{} }
func (m *SLMplsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsGetMsgRsp) ProtoMessage()               {}
func (*SLMplsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{10} }

func (m *SLMplsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsGetMsgRsp) GetMaxLabelsPerBlock() uint32 {
	if m != nil {
		return m.MaxLabelsPerBlock
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxLabelblocksPerLabelblockmsg() uint32 {
	if m != nil {
		return m.MaxLabelblocksPerLabelblockmsg
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMinStartLabel() uint32 {
	if m != nil {
		return m.MinStartLabel
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetLabelTableSize() uint32 {
	if m != nil {
		return m.LabelTableSize
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxIlmPerIlmmsg() uint32 {
	if m != nil {
		return m.MaxIlmPerIlmmsg
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxPathsPerIlm() uint32 {
	if m != nil {
		return m.MaxPathsPerIlm
	}
	return 0
}

// MPLS Get Global Stats response message.
// This message is used to convey the response to the MPLS statistics query.
type SLMplsGetStatsMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Num of label blocks created.
	LabelBlockCount uint32 `protobuf:"varint,2,opt,name=LabelBlockCount" json:"LabelBlockCount,omitempty"`
	// Num ILMs added through the service layer.
	IlmCount uint32 `protobuf:"varint,3,opt,name=IlmCount" json:"IlmCount,omitempty"`
}

func (m *SLMplsGetStatsMsgRsp) Reset()                    { *m = SLMplsGetStatsMsgRsp{} }
func (m *SLMplsGetStatsMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsGetStatsMsgRsp) ProtoMessage()               {}
func (*SLMplsGetStatsMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{11} }

func (m *SLMplsGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsGetStatsMsgRsp) GetLabelBlockCount() uint32 {
	if m != nil {
		return m.LabelBlockCount
	}
	return 0
}

func (m *SLMplsGetStatsMsgRsp) GetIlmCount() uint32 {
	if m != nil {
		return m.IlmCount
	}
	return 0
}

// MPLS Path (or NHLFE) information.
// This message holds the ILM path attributes.
type SLMplsPath struct {
	// One of IPv4 or IPv6 address
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress" json:"NexthopAddress,omitempty"`
	// Next hop interface.
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface" json:"NexthopInterface,omitempty"`
	// ECMP load weight metric
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric" json:"LoadMetric,omitempty"`
	// VRF name
	VrfName string `protobuf:"bytes,4,opt,name=VrfName" json:"VrfName,omitempty"`
	// Associated MPLS incoming label's action.
	// The label action dictates what to do with the incoming label.
	// Possible actions are:
	//  - SL_LABEL_ACTION_SWAP: SWAP the incoming label with the
	//      specified LabelStack (see below), and forward the packet.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_FORWARD: Pop the label, and forward the
	//      packet to the specified nexthop.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_LOOKUP: Pop the label, and lookup the
	//      packet's next header's address in the specified VrfName.
	//      Path attributes: VrfName.
	Action SlLabelAction `protobuf:"varint,5,opt,name=Action,enum=service_layer.SlLabelAction" json:"Action,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//    1. Primary. The path is the main path to carry traffic.
	//    2. Protected. A primary path with a configured backup path.
	//    3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//    1. Pure Primary i.e. Not Protected and is not a Backup.
	//       => PathId is optional. ProtectedPathBitmap = 0x0
	//    2. Primary and Protected. Path is not a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0x0
	//    3. Primary and Not Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    4. Primary and Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    5. Pure Backup. Protection is not allowed for backup paths.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//            || |-- path 4
	//            ||-- path 5
	//            |-- path 6
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used for backup MPLS path with more than one label,
	// Typically associated with the PQ routers and remote Loop Free
	// Alternatives.
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress" json:"RemoteAddress,omitempty"`
}

func (m *SLMplsPath) Reset()                    { *m = SLMplsPath{} }
func (m *SLMplsPath) String() string            { return proto.CompactTextString(m) }
func (*SLMplsPath) ProtoMessage()               {}
func (*SLMplsPath) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{12} }

func (m *SLMplsPath) GetNexthopAddress() *SLIpAddress {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *SLMplsPath) GetNexthopInterface() *SLInterface {
	if m != nil {
		return m.NexthopInterface
	}
	return nil
}

func (m *SLMplsPath) GetLoadMetric() uint32 {
	if m != nil {
		return m.LoadMetric
	}
	return 0
}

func (m *SLMplsPath) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLMplsPath) GetAction() SlLabelAction {
	if m != nil {
		return m.Action
	}
	return SlLabelAction_SL_LABEL_ACTION_RESERVED
}

func (m *SLMplsPath) GetPathId() uint32 {
	if m != nil {
		return m.PathId
	}
	return 0
}

func (m *SLMplsPath) GetProtectedPathBitmap() []uint64 {
	if m != nil {
		return m.ProtectedPathBitmap
	}
	return nil
}

func (m *SLMplsPath) GetLabelStack() []uint32 {
	if m != nil {
		return m.LabelStack
	}
	return nil
}

func (m *SLMplsPath) GetRemoteAddress() []*SLIpAddress {
	if m != nil {
		return m.RemoteAddress
	}
	return nil
}

// MPLS ILM entry's key.
// This message defines the Incoming Label Map key attributes.
type SLMplsIlmKey struct {
	// Incoming local label.
	LocalLabel uint32 `protobuf:"varint,1,opt,name=LocalLabel" json:"LocalLabel,omitempty"`
	// Either Exp bits or CoS forwarding class.
	SlMplsCosVal *SLMplsCos `protobuf:"bytes,2,opt,name=SlMplsCosVal" json:"SlMplsCosVal,omitempty"`
}

func (m *SLMplsIlmKey) Reset()                    { *m = SLMplsIlmKey{} }
func (m *SLMplsIlmKey) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmKey) ProtoMessage()               {}
func (*SLMplsIlmKey) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{13} }

func (m *SLMplsIlmKey) GetLocalLabel() uint32 {
	if m != nil {
		return m.LocalLabel
	}
	return 0
}

func (m *SLMplsIlmKey) GetSlMplsCosVal() *SLMplsCos {
	if m != nil {
		return m.SlMplsCosVal
	}
	return nil
}

// MPLS ILM entry's CoS value
// This message contains either EXP bits or a forwarding class
type SLMplsCos struct {
	// Types that are valid to be assigned to Value:
	//	*SLMplsCos_Exp
	//	*SLMplsCos_DefaultElspPath
	//	*SLMplsCos_ForwardingClass
	Value isSLMplsCos_Value `protobuf_oneof:"value"`
}

func (m *SLMplsCos) Reset()                    { *m = SLMplsCos{} }
func (m *SLMplsCos) String() string            { return proto.CompactTextString(m) }
func (*SLMplsCos) ProtoMessage()               {}
func (*SLMplsCos) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{14} }

type isSLMplsCos_Value interface {
	isSLMplsCos_Value()
}

type SLMplsCos_Exp struct {
	Exp uint32 `protobuf:"varint,1,opt,name=Exp,oneof"`
}
type SLMplsCos_DefaultElspPath struct {
	DefaultElspPath bool `protobuf:"varint,2,opt,name=DefaultElspPath,oneof"`
}
type SLMplsCos_ForwardingClass struct {
	ForwardingClass uint32 `protobuf:"varint,3,opt,name=ForwardingClass,oneof"`
}

func (*SLMplsCos_Exp) isSLMplsCos_Value()             {}
func (*SLMplsCos_DefaultElspPath) isSLMplsCos_Value() {}
func (*SLMplsCos_ForwardingClass) isSLMplsCos_Value() {}

func (m *SLMplsCos) GetValue() isSLMplsCos_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SLMplsCos) GetExp() uint32 {
	if x, ok := m.GetValue().(*SLMplsCos_Exp); ok {
		return x.Exp
	}
	return 0
}

func (m *SLMplsCos) GetDefaultElspPath() bool {
	if x, ok := m.GetValue().(*SLMplsCos_DefaultElspPath); ok {
		return x.DefaultElspPath
	}
	return false
}

func (m *SLMplsCos) GetForwardingClass() uint32 {
	if x, ok := m.GetValue().(*SLMplsCos_ForwardingClass); ok {
		return x.ForwardingClass
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLMplsCos) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLMplsCos_OneofMarshaler, _SLMplsCos_OneofUnmarshaler, _SLMplsCos_OneofSizer, []interface{}{
		(*SLMplsCos_Exp)(nil),
		(*SLMplsCos_DefaultElspPath)(nil),
		(*SLMplsCos_ForwardingClass)(nil),
	}
}

func _SLMplsCos_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLMplsCos)
	// value
	switch x := m.Value.(type) {
	case *SLMplsCos_Exp:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Exp))
	case *SLMplsCos_DefaultElspPath:
		t := uint64(0)
		if x.DefaultElspPath {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *SLMplsCos_ForwardingClass:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ForwardingClass))
	case nil:
	default:
		return fmt.Errorf("SLMplsCos.Value has unexpected type %T", x)
	}
	return nil
}

func _SLMplsCos_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLMplsCos)
	switch tag {
	case 1: // value.Exp
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &SLMplsCos_Exp{uint32(x)}
		return true, err
	case 2: // value.DefaultElspPath
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &SLMplsCos_DefaultElspPath{x != 0}
		return true, err
	case 3: // value.ForwardingClass
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &SLMplsCos_ForwardingClass{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _SLMplsCos_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLMplsCos)
	// value
	switch x := m.Value.(type) {
	case *SLMplsCos_Exp:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Exp))
	case *SLMplsCos_DefaultElspPath:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *SLMplsCos_ForwardingClass:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ForwardingClass))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MPLS ILM entry.
// This messages defines an ILM entry.
type SLMplsIlmEntry struct {
	// ILM Key.
	Key *SLMplsIlmKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// List of path (NHLFE) information.
	Paths []*SLMplsPath `protobuf:"bytes,2,rep,name=Paths" json:"Paths,omitempty"`
}

func (m *SLMplsIlmEntry) Reset()                    { *m = SLMplsIlmEntry{} }
func (m *SLMplsIlmEntry) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmEntry) ProtoMessage()               {}
func (*SLMplsIlmEntry) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{15} }

func (m *SLMplsIlmEntry) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsIlmEntry) GetPaths() []*SLMplsPath {
	if m != nil {
		return m.Paths
	}
	return nil
}

// A batch of MPLS ILM entries.
// This message is used to send a batch of ILM entries.
type SLMplsIlmMsg struct {
	// MPLS Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator" json:"Correlator,omitempty"`
	// List of ILM entries
	MplsIlms []*SLMplsIlmEntry `protobuf:"bytes,3,rep,name=MplsIlms" json:"MplsIlms,omitempty"`
}

func (m *SLMplsIlmMsg) Reset()                    { *m = SLMplsIlmMsg{} }
func (m *SLMplsIlmMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmMsg) ProtoMessage()               {}
func (*SLMplsIlmMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{16} }

func (m *SLMplsIlmMsg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLMplsIlmMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmMsg) GetMplsIlms() []*SLMplsIlmEntry {
	if m != nil {
		return m.MplsIlms
	}
	return nil
}

// MPLS ILM result.
// This message is used to convey the result of the ILM entry operation.
type SLMplsIlmRes struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// ILM Key.
	Key *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *SLMplsIlmRes) Reset()                    { *m = SLMplsIlmRes{} }
func (m *SLMplsIlmRes) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmRes) ProtoMessage()               {}
func (*SLMplsIlmRes) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{17} }

func (m *SLMplsIlmRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsIlmRes) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// MPLS ILM batch response.
// This message is used to convey the result of the ILM batch operation.
type SLMplsIlmMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,2,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLMplsIlmRes `protobuf:"bytes,3,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLMplsIlmMsgRsp) Reset()                    { *m = SLMplsIlmMsgRsp{} }
func (m *SLMplsIlmMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmMsgRsp) ProtoMessage()               {}
func (*SLMplsIlmMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{18} }

func (m *SLMplsIlmMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLMplsIlmMsgRsp) GetResults() []*SLMplsIlmRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// MPLS ILM Get Message
// This message is used to query the attributes of an ILM entry.
type SLMplsIlmGetMsg struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// MPLS ILM key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,3,opt,name=EntriesCount" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,4,opt,name=GetNext" json:"GetNext,omitempty"`
}

func (m *SLMplsIlmGetMsg) Reset()                    { *m = SLMplsIlmGetMsg{} }
func (m *SLMplsIlmGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmGetMsg) ProtoMessage()               {}
func (*SLMplsIlmGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{19} }

func (m *SLMplsIlmGetMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmGetMsg) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsIlmGetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLMplsIlmGetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// MPLS ILM Get Message Response.
type SLMplsIlmGetMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,2,opt,name=Eof" json:"Eof,omitempty"`
	// Status of the Get operation.
	ErrStatus *SLErrorStatus `protobuf:"bytes,3,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLMplsIlmEntry `protobuf:"bytes,4,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLMplsIlmGetMsgRsp) Reset()                    { *m = SLMplsIlmGetMsgRsp{} }
func (m *SLMplsIlmGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLMplsIlmGetMsgRsp) ProtoMessage()               {}
func (*SLMplsIlmGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{20} }

func (m *SLMplsIlmGetMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmGetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLMplsIlmGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsIlmGetMsgRsp) GetEntries() []*SLMplsIlmEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*SLMplsLabelBlockKey)(nil), "service_layer.SLMplsLabelBlockKey")
	proto.RegisterType((*SLMplsLabelBlockMsg)(nil), "service_layer.SLMplsLabelBlockMsg")
	proto.RegisterType((*SLMplsLabelBlockMsgRes)(nil), "service_layer.SLMplsLabelBlockMsgRes")
	proto.RegisterType((*SLMplsLabelBlockMsgRsp)(nil), "service_layer.SLMplsLabelBlockMsgRsp")
	proto.RegisterType((*SLMplsLabelBlockGetMsg)(nil), "service_layer.SLMplsLabelBlockGetMsg")
	proto.RegisterType((*SLMplsLabelBlockGetMsgRsp)(nil), "service_layer.SLMplsLabelBlockGetMsgRsp")
	proto.RegisterType((*SlMplsReg)(nil), "service_layer.SlMplsReg")
	proto.RegisterType((*SLMplsRegMsg)(nil), "service_layer.SLMplsRegMsg")
	proto.RegisterType((*SLMplsRegMsgRsp)(nil), "service_layer.SLMplsRegMsgRsp")
	proto.RegisterType((*SLMplsGetMsg)(nil), "service_layer.SLMplsGetMsg")
	proto.RegisterType((*SLMplsGetMsgRsp)(nil), "service_layer.SLMplsGetMsgRsp")
	proto.RegisterType((*SLMplsGetStatsMsgRsp)(nil), "service_layer.SLMplsGetStatsMsgRsp")
	proto.RegisterType((*SLMplsPath)(nil), "service_layer.SLMplsPath")
	proto.RegisterType((*SLMplsIlmKey)(nil), "service_layer.SLMplsIlmKey")
	proto.RegisterType((*SLMplsCos)(nil), "service_layer.SLMplsCos")
	proto.RegisterType((*SLMplsIlmEntry)(nil), "service_layer.SLMplsIlmEntry")
	proto.RegisterType((*SLMplsIlmMsg)(nil), "service_layer.SLMplsIlmMsg")
	proto.RegisterType((*SLMplsIlmRes)(nil), "service_layer.SLMplsIlmRes")
	proto.RegisterType((*SLMplsIlmMsgRsp)(nil), "service_layer.SLMplsIlmMsgRsp")
	proto.RegisterType((*SLMplsIlmGetMsg)(nil), "service_layer.SLMplsIlmGetMsg")
	proto.RegisterType((*SLMplsIlmGetMsgRsp)(nil), "service_layer.SLMplsIlmGetMsgRsp")
	proto.RegisterEnum("service_layer.SlLabelAction", SlLabelAction_name, SlLabelAction_value)
	proto.RegisterEnum("service_layer.SLMplsLabelBlockType", SLMplsLabelBlockType_name, SLMplsLabelBlockType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SLMplsOper service

type SLMplsOperClient interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error)
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error)
}

type sLMplsOperClient struct {
	cc *grpc.ClientConn
}

func NewSLMplsOperClient(cc *grpc.ClientConn) SLMplsOperClient {
	return &sLMplsOperClient{cc}
}

func (c *sLMplsOperClient) SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error) {
	out := new(SLMplsRegMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsRegOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error) {
	out := new(SLMplsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error) {
	out := new(SLMplsGetStatsMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGetStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error) {
	out := new(SLMplsLabelBlockMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error) {
	out := new(SLMplsLabelBlockGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error) {
	out := new(SLMplsIlmMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error) {
	out := new(SLMplsIlmGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLMplsOper_serviceDesc.Streams[0], c.cc, "/service_layer.SLMplsOper/SLMplsIlmOpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmOpStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmOpStreamClient interface {
	Send(*SLMplsIlmMsg) error
	Recv() (*SLMplsIlmMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmOpStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Send(m *SLMplsIlmMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Recv() (*SLMplsIlmMsgRsp, error) {
	m := new(SLMplsIlmMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLMplsOperClient) SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLMplsOper_serviceDesc.Streams[1], c.cc, "/service_layer.SLMplsOper/SLMplsIlmGetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmGetStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmGetStreamClient interface {
	Send(*SLMplsIlmGetMsg) error
	Recv() (*SLMplsIlmGetMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmGetStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Send(m *SLMplsIlmGetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Recv() (*SLMplsIlmGetMsgRsp, error) {
	m := new(SLMplsIlmGetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SLMplsOper service

type SLMplsOperServer interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error
}

func RegisterSLMplsOperServer(s *grpc.Server, srv SLMplsOperServer) {
	s.RegisterService(&_SLMplsOper_serviceDesc, srv)
}

func _SLMplsOper_SLMplsRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, req.(*SLMplsRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, req.(*SLMplsLabelBlockMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, req.(*SLMplsLabelBlockGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, req.(*SLMplsIlmMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, req.(*SLMplsIlmGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmOpStream(&sLMplsOperSLMplsIlmOpStreamServer{stream})
}

type SLMplsOper_SLMplsIlmOpStreamServer interface {
	Send(*SLMplsIlmMsgRsp) error
	Recv() (*SLMplsIlmMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmOpStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Send(m *SLMplsIlmMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Recv() (*SLMplsIlmMsg, error) {
	m := new(SLMplsIlmMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLMplsOper_SLMplsIlmGetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmGetStream(&sLMplsOperSLMplsIlmGetStreamServer{stream})
}

type SLMplsOper_SLMplsIlmGetStreamServer interface {
	Send(*SLMplsIlmGetMsgRsp) error
	Recv() (*SLMplsIlmGetMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmGetStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Send(m *SLMplsIlmGetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Recv() (*SLMplsIlmGetMsg, error) {
	m := new(SLMplsIlmGetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLMplsOper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLMplsOper",
	HandlerType: (*SLMplsOperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLMplsRegOp",
			Handler:    _SLMplsOper_SLMplsRegOp_Handler,
		},
		{
			MethodName: "SLMplsGet",
			Handler:    _SLMplsOper_SLMplsGet_Handler,
		},
		{
			MethodName: "SLMplsGetStats",
			Handler:    _SLMplsOper_SLMplsGetStats_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockOp",
			Handler:    _SLMplsOper_SLMplsLabelBlockOp_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockGet",
			Handler:    _SLMplsOper_SLMplsLabelBlockGet_Handler,
		},
		{
			MethodName: "SLMplsIlmOp",
			Handler:    _SLMplsOper_SLMplsIlmOp_Handler,
		},
		{
			MethodName: "SLMplsIlmGet",
			Handler:    _SLMplsOper_SLMplsIlmGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLMplsIlmOpStream",
			Handler:       _SLMplsOper_SLMplsIlmOpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLMplsIlmGetStream",
			Handler:       _SLMplsOper_SLMplsIlmGetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_mpls.proto",
}

func init() { proto.RegisterFile("sl_mpls.proto", fileDescriptor7) }

var fileDescriptor7 = []byte{
	// 1380 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcf, 0x73, 0xdb, 0x44,
	0x14, 0xae, 0x6c, 0xe7, 0xd7, 0x6b, 0xed, 0xb8, 0xdb, 0xd2, 0x51, 0x43, 0x1b, 0x5c, 0x85, 0x82,
	0x27, 0x43, 0x4b, 0x27, 0x14, 0x18, 0x98, 0xce, 0x14, 0xdb, 0x71, 0x52, 0x13, 0x3b, 0x16, 0xab,
	0x90, 0x0e, 0xc3, 0x41, 0xa3, 0xd8, 0x1b, 0xd7, 0x74, 0x65, 0x69, 0x56, 0xeb, 0x12, 0x73, 0x62,
	0x38, 0x31, 0x0c, 0x17, 0x6e, 0x5c, 0xe0, 0xca, 0x85, 0x23, 0x37, 0x2e, 0xfc, 0x2d, 0xf0, 0x8f,
	0x30, 0xbb, 0x92, 0x2c, 0xc9, 0xb6, 0x62, 0x87, 0x70, 0xf3, 0xbe, 0xfd, 0xde, 0xdb, 0x6f, 0xbf,
	0x7d, 0xfb, 0xf6, 0xc9, 0x90, 0xf7, 0xa8, 0x69, 0xbb, 0xd4, 0x7b, 0xe8, 0x32, 0x87, 0x3b, 0x28,
	0xef, 0x11, 0xf6, 0xaa, 0xdf, 0x21, 0x26, 0xb5, 0x46, 0x84, 0x6d, 0xbc, 0xe6, 0x51, 0xb3, 0xe3,
	0xd8, 0xb6, 0x33, 0x30, 0xf9, 0xc8, 0x25, 0x01, 0x4a, 0xfb, 0x4b, 0x81, 0x1b, 0x46, 0xb3, 0xe5,
	0x52, 0xaf, 0x69, 0x9d, 0x10, 0x5a, 0xa5, 0x4e, 0xe7, 0xe5, 0x01, 0x19, 0xa1, 0x4d, 0x00, 0x83,
	0x5b, 0x8c, 0x4b, 0xab, 0xaa, 0x94, 0x94, 0x72, 0x1e, 0xc7, 0x2c, 0xe8, 0x2d, 0x28, 0x44, 0x0e,
	0x46, 0xff, 0x1b, 0xa2, 0x66, 0x24, 0x66, 0xc2, 0x8a, 0x2a, 0xb0, 0x26, 0x07, 0x47, 0x23, 0x97,
	0xa8, 0xd9, 0x92, 0x52, 0x2e, 0xec, 0x6c, 0x3d, 0x4c, 0x30, 0x7b, 0x38, 0xb9, 0xbc, 0x80, 0xe2,
	0xc8, 0x4b, 0x50, 0xa9, 0xd1, 0x3e, 0x19, 0xf0, 0x43, 0xcb, 0x26, 0x6a, 0xae, 0xa4, 0x94, 0xd7,
	0x70, 0xcc, 0xa2, 0x7d, 0x3f, 0x63, 0x0b, 0x2d, 0xaf, 0x87, 0x1e, 0x40, 0xae, 0xed, 0x12, 0x26,
	0xc9, 0x17, 0x76, 0x6e, 0x4f, 0xad, 0xda, 0x3e, 0xf9, 0x8a, 0x74, 0x78, 0xdb, 0xc5, 0x12, 0x86,
	0xaa, 0x00, 0x22, 0x86, 0x74, 0xf7, 0xd4, 0x4c, 0x29, 0x5b, 0xbe, 0xba, 0xa3, 0xcd, 0xa1, 0x7a,
	0x40, 0x46, 0x38, 0xe6, 0xa5, 0xfd, 0xa0, 0xc0, 0xad, 0x19, 0x54, 0x30, 0xf1, 0xd0, 0xc7, 0xb0,
	0x56, 0x67, 0xcc, 0xe0, 0x16, 0x1f, 0x7a, 0x92, 0xd2, 0xd5, 0x9d, 0x3b, 0x53, 0xd1, 0xeb, 0x8c,
	0x39, 0x01, 0x06, 0x47, 0x70, 0xf4, 0x18, 0xb2, 0x07, 0x64, 0x24, 0x15, 0x5e, 0x8c, 0x93, 0x80,
	0x6b, 0xbf, 0xa4, 0x90, 0xf1, 0x5c, 0x54, 0x85, 0xbc, 0x1f, 0xda, 0x18, 0xda, 0xb6, 0xc5, 0x46,
	0x0b, 0x11, 0x4a, 0xba, 0xa0, 0xa7, 0xb0, 0x82, 0x89, 0x37, 0xa4, 0x3c, 0x14, 0xeb, 0xfe, 0x1c,
	0x62, 0xbe, 0x10, 0x38, 0xf4, 0xd2, 0x7e, 0x9c, 0xc1, 0x6f, 0x9f, 0x70, 0x71, 0x74, 0xc1, 0x86,
	0x95, 0x0b, 0x6d, 0x18, 0x69, 0x70, 0xad, 0x3e, 0xe0, 0xac, 0x4f, 0xbc, 0x9a, 0x33, 0x1c, 0xf0,
	0x20, 0x23, 0x13, 0x36, 0xa4, 0xc2, 0xca, 0x3e, 0xe1, 0x87, 0xe4, 0x8c, 0xcb, 0x6c, 0x5c, 0xc5,
	0xe1, 0x50, 0xfb, 0x4d, 0x81, 0xdb, 0xb3, 0xe9, 0x08, 0xc5, 0x8a, 0x90, 0xad, 0x3b, 0xa7, 0x92,
	0xd1, 0x2a, 0x16, 0x3f, 0x93, 0x07, 0x9a, 0xb9, 0xd8, 0x81, 0x3e, 0x81, 0x95, 0x80, 0x95, 0x9a,
	0x5d, 0x38, 0xd1, 0x42, 0x17, 0xed, 0x29, 0xac, 0x19, 0x54, 0xcc, 0x63, 0xd2, 0x43, 0x3b, 0x70,
	0x53, 0x1f, 0xb2, 0x1e, 0x69, 0x0c, 0x38, 0x61, 0xaf, 0x2c, 0x6a, 0x90, 0x8e, 0x33, 0xe8, 0x7a,
	0xc1, 0x95, 0x9d, 0x39, 0xa7, 0x51, 0xb8, 0xe6, 0x2f, 0x80, 0x49, 0x4f, 0xc8, 0xbd, 0x9d, 0xb8,
	0x29, 0xb7, 0xa6, 0xb8, 0x60, 0xd2, 0x1b, 0x5f, 0x93, 0x47, 0xb0, 0xec, 0x7b, 0x05, 0x7b, 0x56,
	0x27, 0xd1, 0x21, 0x33, 0x1c, 0xe0, 0xb4, 0x16, 0xac, 0xc7, 0x57, 0x13, 0x6a, 0x5e, 0xe2, 0x32,
	0x68, 0x85, 0x90, 0xbc, 0x7f, 0x38, 0xda, 0x3f, 0x99, 0x30, 0x7e, 0x74, 0x5a, 0x97, 0xb9, 0x6c,
	0xef, 0xc0, 0xf5, 0x96, 0x75, 0x26, 0xa5, 0xf7, 0x74, 0xc2, 0xa4, 0xfc, 0x41, 0x2a, 0x4d, 0x4f,
	0xa0, 0x3d, 0xd8, 0x0c, 0x8d, 0x27, 0xb2, 0x06, 0xe8, 0x84, 0x45, 0x23, 0xdb, 0xeb, 0xc9, 0x34,
	0xcb, 0xe3, 0x39, 0x28, 0xf4, 0x26, 0xe4, 0x5b, 0xfd, 0x41, 0xac, 0xe4, 0xe6, 0xa4, 0x5b, 0xd2,
	0x38, 0xae, 0xba, 0x47, 0xd6, 0x09, 0x25, 0xb2, 0xea, 0x2e, 0xc5, 0xaa, 0xee, 0xd8, 0x8a, 0xca,
	0xb0, 0xde, 0xb2, 0xce, 0x1a, 0xd4, 0xd6, 0x09, 0x6b, 0x50, 0x5b, 0xd0, 0x58, 0x96, 0xc0, 0x49,
	0xb3, 0x88, 0xd8, 0xb2, 0xce, 0x74, 0x8b, 0xbf, 0xf0, 0x7c, 0xa3, 0xba, 0xe2, 0x47, 0x4c, 0x5a,
	0xb5, 0x9f, 0x15, 0xb8, 0x39, 0x56, 0x59, 0x28, 0xe5, 0xfd, 0x0f, 0x52, 0x97, 0x61, 0x3d, 0x4a,
	0xf1, 0xf8, 0x9d, 0x9d, 0x34, 0xa3, 0x0d, 0x58, 0x6d, 0x50, 0xdb, 0x87, 0xf8, 0x82, 0x8e, 0xc7,
	0xda, 0x1f, 0x59, 0x00, 0x9f, 0x9a, 0x20, 0x8c, 0xaa, 0x50, 0x10, 0xf7, 0xf9, 0x85, 0xe3, 0x56,
	0xba, 0x5d, 0x46, 0xbc, 0x90, 0xd5, 0xc6, 0x14, 0xab, 0x46, 0x88, 0xc0, 0x13, 0x1e, 0x68, 0x0f,
	0x8a, 0x81, 0x45, 0x5e, 0x9d, 0x53, 0xab, 0x43, 0x82, 0x74, 0x9f, 0x11, 0x25, 0x44, 0xe0, 0x29,
	0x1f, 0xf1, 0x74, 0x35, 0x1d, 0xab, 0xdb, 0x22, 0x9c, 0xf5, 0x3b, 0x01, 0xf1, 0x98, 0x45, 0x54,
	0xa3, 0x63, 0x76, 0x1a, 0x7b, 0xd7, 0xc2, 0x21, 0x7a, 0x0c, 0xcb, 0x95, 0x0e, 0xef, 0x3b, 0x03,
	0x79, 0xc2, 0x85, 0x69, 0x4d, 0xa9, 0x94, 0xc8, 0xc7, 0xe0, 0x00, 0x8b, 0x6e, 0xc1, 0xb2, 0xd0,
	0xa0, 0xd1, 0x0d, 0x8e, 0x3b, 0x18, 0xa1, 0x47, 0x70, 0x43, 0x67, 0x0e, 0x27, 0x1d, 0x4e, 0xba,
	0xc2, 0x54, 0xed, 0x73, 0xdb, 0x72, 0xd5, 0x95, 0x52, 0xb6, 0x9c, 0xc3, 0xb3, 0xa6, 0x24, 0x73,
	0xb1, 0x80, 0xc1, 0xad, 0xce, 0x4b, 0x75, 0xb5, 0x94, 0x95, 0xcc, 0xc7, 0x16, 0xf4, 0x09, 0xe4,
	0x31, 0xb1, 0x1d, 0x4e, 0x42, 0x91, 0xd7, 0x64, 0x1d, 0x3b, 0x4f, 0xe4, 0xa4, 0x43, 0x54, 0x84,
	0x1a, 0xd4, 0x0e, 0x3a, 0x8e, 0xa6, 0xd3, 0xb1, 0x68, 0xa2, 0xe3, 0x88, 0x2c, 0xe8, 0x09, 0x5c,
	0xf3, 0x6b, 0x4b, 0xcd, 0xf1, 0x8e, 0x2d, 0x9a, 0x56, 0x7e, 0x9a, 0x01, 0x04, 0x27, 0xd0, 0xda,
	0xb7, 0x0a, 0xac, 0x8d, 0xe7, 0x10, 0x82, 0x6c, 0xfd, 0xcc, 0xf5, 0x17, 0x79, 0x76, 0x05, 0x8b,
	0x01, 0xda, 0x86, 0xf5, 0x5d, 0x72, 0x6a, 0x0d, 0x29, 0xaf, 0x53, 0xcf, 0x15, 0x52, 0xc8, 0x25,
	0x56, 0x9f, 0x5d, 0xc1, 0x93, 0x13, 0x02, 0xbb, 0xe7, 0xb0, 0xaf, 0x2d, 0xd6, 0xed, 0x0f, 0x7a,
	0x35, 0x6a, 0x79, 0x9e, 0x7f, 0xb8, 0x02, 0x3b, 0x31, 0x51, 0x5d, 0x81, 0xa5, 0x57, 0x16, 0x1d,
	0x12, 0xcd, 0x85, 0xc2, 0x78, 0xc3, 0xa2, 0x94, 0x8f, 0xd0, 0x83, 0xf8, 0x33, 0xf7, 0xfa, 0xcc,
	0x9d, 0xf8, 0xe2, 0xf8, 0xef, 0xdb, 0xbb, 0xb0, 0x24, 0xaf, 0x64, 0xf0, 0xde, 0xde, 0x9e, 0xe9,
	0x20, 0x10, 0xd8, 0xc7, 0x89, 0x4b, 0x1b, 0x69, 0xfc, 0x1f, 0x5a, 0x22, 0xd1, 0x79, 0x39, 0x8c,
	0x11, 0x6a, 0x71, 0x87, 0x49, 0x35, 0x72, 0x38, 0x66, 0x41, 0x1f, 0xc1, 0x6a, 0x10, 0x3c, 0x7c,
	0xc7, 0xee, 0xa6, 0x6d, 0x42, 0x6e, 0x18, 0x8f, 0xe1, 0xda, 0x28, 0xc6, 0xec, 0xb2, 0xed, 0xd1,
	0x83, 0x78, 0x7b, 0x34, 0x57, 0x46, 0xed, 0x77, 0x25, 0x7c, 0x30, 0x7c, 0x55, 0x44, 0x15, 0x4b,
	0xee, 0x54, 0x99, 0xda, 0xe9, 0x54, 0xc3, 0x94, 0xb9, 0x78, 0xc3, 0xf4, 0x7e, 0xd4, 0x30, 0xf9,
	0x62, 0xa5, 0x52, 0x4d, 0xb4, 0x49, 0xbf, 0xc6, 0xe9, 0x06, 0xfd, 0xd1, 0x3c, 0xba, 0x17, 0x53,
	0x64, 0xaa, 0x71, 0xca, 0x9e, 0xdf, 0x38, 0xe5, 0x92, 0x8d, 0xd3, 0x9f, 0x0a, 0xa0, 0x09, 0x82,
	0x8b, 0x48, 0x1a, 0x74, 0x54, 0x99, 0x94, 0x8e, 0x2a, 0x7b, 0xb1, 0x1c, 0xf8, 0x30, 0xea, 0xa8,
	0x72, 0x8b, 0x64, 0x62, 0x88, 0xde, 0xfe, 0x5b, 0x81, 0x7c, 0xa2, 0x98, 0xa2, 0x3b, 0xa0, 0x1a,
	0x4d, 0xb3, 0x59, 0xa9, 0xd6, 0x9b, 0x66, 0xa5, 0x76, 0xd4, 0x68, 0x1f, 0x9a, 0xb8, 0x6e, 0xd4,
	0xf1, 0x71, 0x7d, 0xb7, 0x78, 0x05, 0xa9, 0xe2, 0x1d, 0x4c, 0xce, 0x1a, 0xcf, 0x2b, 0x7a, 0x51,
	0x41, 0x5b, 0xf0, 0xc6, 0xe4, 0x8c, 0xde, 0xd6, 0xcd, 0xca, 0xe1, 0xae, 0xb9, 0xd7, 0xc6, 0xcf,
	0x2b, 0x78, 0xb7, 0x98, 0x41, 0x6f, 0xc3, 0x56, 0x1a, 0xa8, 0xd9, 0x6e, 0x1f, 0x7c, 0xae, 0x9b,
	0x0d, 0xfd, 0xf8, 0x71, 0x31, 0xbb, 0x18, 0xf0, 0x83, 0x62, 0x0e, 0x69, 0xb0, 0x79, 0x3e, 0xb0,
	0xb8, 0xb4, 0xfd, 0xdd, 0xf8, 0xf5, 0x4e, 0x7e, 0x66, 0xa1, 0xfb, 0x70, 0xcf, 0x68, 0x9a, 0x2d,
	0xbd, 0x69, 0x04, 0x11, 0xaa, 0xcd, 0x76, 0xed, 0xc0, 0x3c, 0xfa, 0x42, 0xaf, 0xc7, 0x37, 0x7d,
	0x0f, 0xee, 0xa6, 0xc2, 0x0c, 0xbc, 0x5f, 0x2d, 0x2a, 0xa8, 0x04, 0x77, 0x52, 0x21, 0xb5, 0xea,
	0x5e, 0x31, 0xb3, 0xf3, 0xd3, 0x72, 0xf8, 0x4e, 0xcb, 0xe2, 0xf2, 0x29, 0x5c, 0x1d, 0xb7, 0x85,
	0x6d, 0x17, 0xcd, 0xce, 0x52, 0xbf, 0x65, 0xdc, 0xd8, 0x3c, 0x67, 0x52, 0xe4, 0xda, 0xb3, 0xb0,
	0xb8, 0xef, 0x13, 0x9e, 0x12, 0xc9, 0x4f, 0xcc, 0x94, 0x48, 0x51, 0xd6, 0xe2, 0xb0, 0x48, 0x87,
	0x6d, 0xce, 0xf9, 0xe1, 0xb6, 0xd2, 0x26, 0xe3, 0x2d, 0x92, 0x19, 0xde, 0x8f, 0x48, 0xfc, 0xb6,
	0x8b, 0xb4, 0xf9, 0x9f, 0x4b, 0x1b, 0x8b, 0x7c, 0x52, 0x79, 0x2e, 0x3a, 0x9d, 0xfe, 0x00, 0x16,
	0x42, 0xcc, 0xf3, 0x0e, 0xf6, 0x50, 0x5e, 0x08, 0x26, 0xd6, 0x19, 0x1f, 0x59, 0x83, 0xda, 0xa9,
	0x47, 0xe6, 0x17, 0xd5, 0x14, 0xa1, 0xa3, 0x8a, 0xfb, 0x59, 0xec, 0x01, 0x10, 0x64, 0x53, 0xf1,
	0x01, 0xcb, 0x7b, 0xe7, 0xcf, 0x8b, 0x90, 0x47, 0x70, 0x3d, 0x46, 0xcf, 0xe0, 0x8c, 0x58, 0xf6,
	0xa5, 0x48, 0x96, 0x95, 0x47, 0x0a, 0xfa, 0x32, 0x59, 0xdd, 0x82, 0xb0, 0x97, 0xa7, 0x2b, 0x82,
	0x9f, 0x2c, 0xcb, 0x7f, 0x61, 0xde, 0xfb, 0x37, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x6d, 0x11, 0x5b,
	0xbc, 0x11, 0x00, 0x00,
}
