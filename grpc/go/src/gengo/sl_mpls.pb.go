// @file
// @brief RPC proto file for MPLS types.
//
// ----------------------------------------------------------------
//  Copyright (c) 2019 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

//@defgroup MPLS
//@brief MPLS service definitions.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0-devel
// 	protoc        v3.12.1
// source: sl_mpls.proto

package service_layer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MPLS label actions.
type SlLabelAction int32

const (
	// Reserved. 0x0
	SlLabelAction_SL_LABEL_ACTION_RESERVED SlLabelAction = 0
	// Swap. 0x1
	// Swap outer label and forward.
	// Used at tunnel midpoint for swapping labels.
	SlLabelAction_SL_LABEL_ACTION_SWAP SlLabelAction = 1
	// Pop and forward. 0x2
	// Pop outer label and forward.
	// Used for per CE and per prefix label disposition at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_FORWARD SlLabelAction = 2
	// Pop and lookup IPv4. 0x3
	// Pop and lookup the IPv4 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4 SlLabelAction = 3
	// Pop and lookup IPv6. 0x4
	// Pop and lookup the IPv6 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6 SlLabelAction = 4
	// Pop and lookup. 0x5
	// Pop and lookup the next header in the packet (MPLS, IPv4, IPv6) in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP SlLabelAction = 5
)

// Enum value maps for SlLabelAction.
var (
	SlLabelAction_name = map[int32]string{
		0: "SL_LABEL_ACTION_RESERVED",
		1: "SL_LABEL_ACTION_SWAP",
		2: "SL_LABEL_ACTION_POP_AND_FORWARD",
		3: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4",
		4: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6",
		5: "SL_LABEL_ACTION_POP_AND_LOOKUP",
	}
	SlLabelAction_value = map[string]int32{
		"SL_LABEL_ACTION_RESERVED":            0,
		"SL_LABEL_ACTION_SWAP":                1,
		"SL_LABEL_ACTION_POP_AND_FORWARD":     2,
		"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4": 3,
		"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6": 4,
		"SL_LABEL_ACTION_POP_AND_LOOKUP":      5,
	}
)

func (x SlLabelAction) Enum() *SlLabelAction {
	p := new(SlLabelAction)
	*p = x
	return p
}

func (x SlLabelAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SlLabelAction) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_mpls_proto_enumTypes[0].Descriptor()
}

func (SlLabelAction) Type() protoreflect.EnumType {
	return &file_sl_mpls_proto_enumTypes[0]
}

func (x SlLabelAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SlLabelAction.Descriptor instead.
func (SlLabelAction) EnumDescriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{0}
}

// Label Block Types
type SLMplsLabelBlockType int32

const (
	// Reserved. 0x0
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_RESERVED SLMplsLabelBlockType = 0
	// Segment Routing Global Block (SRGB) Block Type. 0x1
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_SRGB SLMplsLabelBlockType = 1
	// Class Based Forwarding (CBF) Block Type. 0x2
	SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_CBF SLMplsLabelBlockType = 2
)

// Enum value maps for SLMplsLabelBlockType.
var (
	SLMplsLabelBlockType_name = map[int32]string{
		0: "SL_MPLS_LABEL_BLOCK_TYPE_RESERVED",
		1: "SL_MPLS_LABEL_BLOCK_TYPE_SRGB",
		2: "SL_MPLS_LABEL_BLOCK_TYPE_CBF",
	}
	SLMplsLabelBlockType_value = map[string]int32{
		"SL_MPLS_LABEL_BLOCK_TYPE_RESERVED": 0,
		"SL_MPLS_LABEL_BLOCK_TYPE_SRGB":     1,
		"SL_MPLS_LABEL_BLOCK_TYPE_CBF":      2,
	}
)

func (x SLMplsLabelBlockType) Enum() *SLMplsLabelBlockType {
	p := new(SLMplsLabelBlockType)
	*p = x
	return p
}

func (x SLMplsLabelBlockType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLMplsLabelBlockType) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_mpls_proto_enumTypes[1].Descriptor()
}

func (SLMplsLabelBlockType) Type() protoreflect.EnumType {
	return &file_sl_mpls_proto_enumTypes[1]
}

func (x SLMplsLabelBlockType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLMplsLabelBlockType.Descriptor instead.
func (SLMplsLabelBlockType) EnumDescriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{1}
}

// MPLS Label block key.
// This message is used to relay the label block key attributes.
type SLMplsLabelBlockKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Starting label value of the block.
	StartLabel uint32 `protobuf:"varint,1,opt,name=StartLabel,proto3" json:"StartLabel,omitempty"`
	// Label block size.
	// Block size should be <= SLServerResponse.MaxLabelsPerBlock
	LabelBlockSize uint32 `protobuf:"varint,2,opt,name=LabelBlockSize,proto3" json:"LabelBlockSize,omitempty"`
	// Label block type. See definition of SlMplsLabelBlockType for valid values.
	// If none specified, defaults to SL_MPLS_LABEL_BLOCK_TYPE_SRGB.
	BlockType SLMplsLabelBlockType `protobuf:"varint,3,opt,name=BlockType,proto3,enum=service_layer.SLMplsLabelBlockType" json:"BlockType,omitempty"`
	// Label block client name as configured e.g. through CLI.
	// Client name is ignored if BlockType is not SL_MPLS_LABEL_BLOCK_TYPE_CBF.
	ClientName string `protobuf:"bytes,4,opt,name=ClientName,proto3" json:"ClientName,omitempty"`
}

func (x *SLMplsLabelBlockKey) Reset() {
	*x = SLMplsLabelBlockKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockKey) ProtoMessage() {}

func (x *SLMplsLabelBlockKey) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockKey.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockKey) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{0}
}

func (x *SLMplsLabelBlockKey) GetStartLabel() uint32 {
	if x != nil {
		return x.StartLabel
	}
	return 0
}

func (x *SLMplsLabelBlockKey) GetLabelBlockSize() uint32 {
	if x != nil {
		return x.LabelBlockSize
	}
	return 0
}

func (x *SLMplsLabelBlockKey) GetBlockType() SLMplsLabelBlockType {
	if x != nil {
		return x.BlockType
	}
	return SLMplsLabelBlockType_SL_MPLS_LABEL_BLOCK_TYPE_RESERVED
}

func (x *SLMplsLabelBlockKey) GetClientName() string {
	if x != nil {
		return x.ClientName
	}
	return ""
}

// MPLS Label block batch reservation message.
// This message is used to send a batch of label block requests.
// The Oper attributes indicates add or delete operations.
type SLMplsLabelBlockMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// MPLS Label Block Operations.
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// List of label blocks requests.
	// List size should be <= SLServerResponse.MaxLabelBlocksPerRequest
	MplsBlocks []*SLMplsLabelBlockKey `protobuf:"bytes,2,rep,name=MplsBlocks,proto3" json:"MplsBlocks,omitempty"`
}

func (x *SLMplsLabelBlockMsg) Reset() {
	*x = SLMplsLabelBlockMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockMsg) ProtoMessage() {}

func (x *SLMplsLabelBlockMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockMsg.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{1}
}

func (x *SLMplsLabelBlockMsg) GetOper() SLObjectOp {
	if x != nil {
		return x.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (x *SLMplsLabelBlockMsg) GetMplsBlocks() []*SLMplsLabelBlockKey {
	if x != nil {
		return x.MplsBlocks
	}
	return nil
}

// MPLS Label block reservation result.
// This message is used to convey the result status corresponding to
// the label block operation.
type SLMplsLabelBlockMsgRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Key for which the error code is reported.
	Key *SLMplsLabelBlockKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
}

func (x *SLMplsLabelBlockMsgRes) Reset() {
	*x = SLMplsLabelBlockMsgRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockMsgRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockMsgRes) ProtoMessage() {}

func (x *SLMplsLabelBlockMsgRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockMsgRes.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockMsgRes) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{2}
}

func (x *SLMplsLabelBlockMsgRes) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsLabelBlockMsgRes) GetKey() *SLMplsLabelBlockKey {
	if x != nil {
		return x.Key
	}
	return nil
}

// MPLS Label block batch reservation response.
// This message is used to convey a summary status for the batch operation.
// If there are errors encountered, the Results field would indicate which
// label block reservation failed.
type SLMplsLabelBlockMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLMplsLabelBlockMsgRes `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLMplsLabelBlockMsgRsp) Reset() {
	*x = SLMplsLabelBlockMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockMsgRsp) ProtoMessage() {}

func (x *SLMplsLabelBlockMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{3}
}

func (x *SLMplsLabelBlockMsgRsp) GetStatusSummary() *SLErrorStatus {
	if x != nil {
		return x.StatusSummary
	}
	return nil
}

func (x *SLMplsLabelBlockMsgRsp) GetResults() []*SLMplsLabelBlockMsgRes {
	if x != nil {
		return x.Results
	}
	return nil
}

// MPLS Label Block Get Message
// This message is used to query previous label block reservations.
type SLMplsLabelBlockGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// MPLS Label Block key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsLabelBlockKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
}

func (x *SLMplsLabelBlockGetMsg) Reset() {
	*x = SLMplsLabelBlockGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockGetMsg) ProtoMessage() {}

func (x *SLMplsLabelBlockGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockGetMsg.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{4}
}

func (x *SLMplsLabelBlockGetMsg) GetKey() *SLMplsLabelBlockKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLMplsLabelBlockGetMsg) GetEntriesCount() uint32 {
	if x != nil {
		return x.EntriesCount
	}
	return 0
}

func (x *SLMplsLabelBlockGetMsg) GetGetNext() bool {
	if x != nil {
		return x.GetNext
	}
	return false
}

// MPLS Label Block get message response
// This message is the response to the label block query.
type SLMplsLabelBlockGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLMplsLabelBlockKey `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLMplsLabelBlockGetMsgRsp) Reset() {
	*x = SLMplsLabelBlockGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsLabelBlockGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsLabelBlockGetMsgRsp) ProtoMessage() {}

func (x *SLMplsLabelBlockGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsLabelBlockGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsLabelBlockGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{5}
}

func (x *SLMplsLabelBlockGetMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLMplsLabelBlockGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsLabelBlockGetMsgRsp) GetEntries() []*SLMplsLabelBlockKey {
	if x != nil {
		return x.Entries
	}
	return nil
}

// MPLS Registration message.
type SlMplsReg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// In case the Service Layer -> LSD connection is lost, this specifies the
	// timeout period after which LSD will automatically purge the installed
	// ILMs, unless the service layer:
	//    1. Sends MPLS Registration message
	//    2. Replays all label blocks and ILMs
	//    3. and sends MPLS EOF message
	// Similarly, in the event of an RP Switchover the ILMs must be replayed
	// within the purge interval.
	// Purge timer is ignored for all registration messages except for
	// SL_REGOP_REGISTER
	PurgeIntervalSeconds uint32 `protobuf:"varint,1,opt,name=PurgeIntervalSeconds,proto3" json:"PurgeIntervalSeconds,omitempty"`
}

func (x *SlMplsReg) Reset() {
	*x = SlMplsReg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SlMplsReg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlMplsReg) ProtoMessage() {}

func (x *SlMplsReg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlMplsReg.ProtoReflect.Descriptor instead.
func (*SlMplsReg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{6}
}

func (x *SlMplsReg) GetPurgeIntervalSeconds() uint32 {
	if x != nil {
		return x.PurgeIntervalSeconds
	}
	return 0
}

// MPLS Registration message.
// This message is used for MPLS global registration. Clients must register
// before using any MPLS service.
type SLMplsRegMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Registration Operation
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// Registration Message
	RegMsg *SlMplsReg `protobuf:"bytes,2,opt,name=RegMsg,proto3" json:"RegMsg,omitempty"`
}

func (x *SLMplsRegMsg) Reset() {
	*x = SLMplsRegMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsRegMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsRegMsg) ProtoMessage() {}

func (x *SLMplsRegMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsRegMsg.ProtoReflect.Descriptor instead.
func (*SLMplsRegMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{7}
}

func (x *SLMplsRegMsg) GetOper() SLRegOp {
	if x != nil {
		return x.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (x *SLMplsRegMsg) GetRegMsg() *SlMplsReg {
	if x != nil {
		return x.RegMsg
	}
	return nil
}

// MPLS Registration response message.
// This message is used to convey the result of the MPLS registration.
type SLMplsRegMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
}

func (x *SLMplsRegMsgRsp) Reset() {
	*x = SLMplsRegMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsRegMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsRegMsgRsp) ProtoMessage() {}

func (x *SLMplsRegMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsRegMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsRegMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{8}
}

func (x *SLMplsRegMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

// MPLS Get Global Info message.
// This message is used to query MPLS global capabilities.
type SLMplsGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLMplsGetMsg) Reset() {
	*x = SLMplsGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsGetMsg) ProtoMessage() {}

func (x *SLMplsGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsGetMsg.ProtoReflect.Descriptor instead.
func (*SLMplsGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{9}
}

// MPLS Get Global Info response message.
// This message is used to convey the response to the global capabilities query.
type SLMplsGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Maximum labels that can be allocated/freed per label block.
	MaxLabelsPerBlock uint32 `protobuf:"varint,2,opt,name=MaxLabelsPerBlock,proto3" json:"MaxLabelsPerBlock,omitempty"`
	// Maximum label blocks that can be allocated/freed per MplsLabelBlockMsg
	MaxLabelblocksPerLabelblockmsg uint32 `protobuf:"varint,3,opt,name=MaxLabelblocksPerLabelblockmsg,proto3" json:"MaxLabelblocksPerLabelblockmsg,omitempty"`
	// Minimum label value that can be reserved on the platform.
	// MplsLabelBlockKey.StartLabel >= MinStartLabel
	MinStartLabel uint32 `protobuf:"varint,4,opt,name=MinStartLabel,proto3" json:"MinStartLabel,omitempty"`
	// Label table size for the platform.
	// MplsLabelBlockKey.StartLabel <= LabelTableSize
	LabelTableSize uint32 `protobuf:"varint,5,opt,name=LabelTableSize,proto3" json:"LabelTableSize,omitempty"`
	// Max ILM objects within a single IlmMsg message.
	MaxIlmPerIlmmsg uint32 `protobuf:"varint,6,opt,name=MaxIlmPerIlmmsg,proto3" json:"MaxIlmPerIlmmsg,omitempty"`
	// Maximum paths per ILM.
	MaxPathsPerIlm uint32 `protobuf:"varint,7,opt,name=MaxPathsPerIlm,proto3" json:"MaxPathsPerIlm,omitempty"`
}

func (x *SLMplsGetMsgRsp) Reset() {
	*x = SLMplsGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsGetMsgRsp) ProtoMessage() {}

func (x *SLMplsGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{10}
}

func (x *SLMplsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsGetMsgRsp) GetMaxLabelsPerBlock() uint32 {
	if x != nil {
		return x.MaxLabelsPerBlock
	}
	return 0
}

func (x *SLMplsGetMsgRsp) GetMaxLabelblocksPerLabelblockmsg() uint32 {
	if x != nil {
		return x.MaxLabelblocksPerLabelblockmsg
	}
	return 0
}

func (x *SLMplsGetMsgRsp) GetMinStartLabel() uint32 {
	if x != nil {
		return x.MinStartLabel
	}
	return 0
}

func (x *SLMplsGetMsgRsp) GetLabelTableSize() uint32 {
	if x != nil {
		return x.LabelTableSize
	}
	return 0
}

func (x *SLMplsGetMsgRsp) GetMaxIlmPerIlmmsg() uint32 {
	if x != nil {
		return x.MaxIlmPerIlmmsg
	}
	return 0
}

func (x *SLMplsGetMsgRsp) GetMaxPathsPerIlm() uint32 {
	if x != nil {
		return x.MaxPathsPerIlm
	}
	return 0
}

// MPLS Get Global Stats response message.
// This message is used to convey the response to the MPLS statistics query.
type SLMplsGetStatsMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Num of label blocks created.
	LabelBlockCount uint32 `protobuf:"varint,2,opt,name=LabelBlockCount,proto3" json:"LabelBlockCount,omitempty"`
	// Num ILMs added through the service layer.
	IlmCount uint32 `protobuf:"varint,3,opt,name=IlmCount,proto3" json:"IlmCount,omitempty"`
}

func (x *SLMplsGetStatsMsgRsp) Reset() {
	*x = SLMplsGetStatsMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsGetStatsMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsGetStatsMsgRsp) ProtoMessage() {}

func (x *SLMplsGetStatsMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsGetStatsMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsGetStatsMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{11}
}

func (x *SLMplsGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsGetStatsMsgRsp) GetLabelBlockCount() uint32 {
	if x != nil {
		return x.LabelBlockCount
	}
	return 0
}

func (x *SLMplsGetStatsMsgRsp) GetIlmCount() uint32 {
	if x != nil {
		return x.IlmCount
	}
	return 0
}

// MPLS Path (or NHLFE) information.
// This message holds the ILM path attributes.
type SLMplsPath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// One of IPv4 or IPv6 address
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress,proto3" json:"NexthopAddress,omitempty"`
	// Next hop interface.
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface,proto3" json:"NexthopInterface,omitempty"`
	// ECMP load weight metric
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric,proto3" json:"LoadMetric,omitempty"`
	// VRF name
	VrfName string `protobuf:"bytes,4,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Associated MPLS incoming label's action.
	// The label action dictates what to do with the incoming label.
	// Possible actions are:
	//  - SL_LABEL_ACTION_SWAP: SWAP the incoming label with the
	//      specified LabelStack (see below), and forward the packet.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_FORWARD: Pop the label, and forward the
	//      packet to the specified nexthop.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_LOOKUP: Pop the label, and lookup the
	//      packet's next header's address in the specified VrfName.
	//      Path attributes: VrfName.
	Action SlLabelAction `protobuf:"varint,5,opt,name=Action,proto3,enum=service_layer.SlLabelAction" json:"Action,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//    1. Primary. The path is the main path to carry traffic.
	//    2. Protected. A primary path with a configured backup path.
	//    3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//    1. Pure Primary i.e. Not Protected and is not a Backup.
	//       => PathId is optional. ProtectedPathBitmap = 0x0
	//    2. Primary and Protected. Path is not a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0x0
	//    3. Primary and Not Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    4. Primary and Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    5. Pure Backup. Protection is not allowed for backup paths.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId,proto3" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//            || |-- path 4
	//            ||-- path 5
	//            |-- path 6
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap,proto3" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack,proto3" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used for backup MPLS path with more than one label,
	// Typically associated with the PQ routers and remote Loop Free
	// Alternatives.
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress,proto3" json:"RemoteAddress,omitempty"`
}

func (x *SLMplsPath) Reset() {
	*x = SLMplsPath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsPath) ProtoMessage() {}

func (x *SLMplsPath) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsPath.ProtoReflect.Descriptor instead.
func (*SLMplsPath) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{12}
}

func (x *SLMplsPath) GetNexthopAddress() *SLIpAddress {
	if x != nil {
		return x.NexthopAddress
	}
	return nil
}

func (x *SLMplsPath) GetNexthopInterface() *SLInterface {
	if x != nil {
		return x.NexthopInterface
	}
	return nil
}

func (x *SLMplsPath) GetLoadMetric() uint32 {
	if x != nil {
		return x.LoadMetric
	}
	return 0
}

func (x *SLMplsPath) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLMplsPath) GetAction() SlLabelAction {
	if x != nil {
		return x.Action
	}
	return SlLabelAction_SL_LABEL_ACTION_RESERVED
}

func (x *SLMplsPath) GetPathId() uint32 {
	if x != nil {
		return x.PathId
	}
	return 0
}

func (x *SLMplsPath) GetProtectedPathBitmap() []uint64 {
	if x != nil {
		return x.ProtectedPathBitmap
	}
	return nil
}

func (x *SLMplsPath) GetLabelStack() []uint32 {
	if x != nil {
		return x.LabelStack
	}
	return nil
}

func (x *SLMplsPath) GetRemoteAddress() []*SLIpAddress {
	if x != nil {
		return x.RemoteAddress
	}
	return nil
}

// MPLS ILM entry's key.
// This message defines the Incoming Label Map key attributes.
type SLMplsIlmKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Incoming local label.
	LocalLabel uint32 `protobuf:"varint,1,opt,name=LocalLabel,proto3" json:"LocalLabel,omitempty"`
	// Either Exp bits or CoS forwarding class.
	SlMplsCosVal *SLMplsCos `protobuf:"bytes,2,opt,name=SlMplsCosVal,proto3" json:"SlMplsCosVal,omitempty"`
}

func (x *SLMplsIlmKey) Reset() {
	*x = SLMplsIlmKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmKey) ProtoMessage() {}

func (x *SLMplsIlmKey) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmKey.ProtoReflect.Descriptor instead.
func (*SLMplsIlmKey) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{13}
}

func (x *SLMplsIlmKey) GetLocalLabel() uint32 {
	if x != nil {
		return x.LocalLabel
	}
	return 0
}

func (x *SLMplsIlmKey) GetSlMplsCosVal() *SLMplsCos {
	if x != nil {
		return x.SlMplsCosVal
	}
	return nil
}

// MPLS ILM entry's CoS value
// This message contains either EXP bits or a forwarding class
type SLMplsCos struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Value:
	//	*SLMplsCos_Exp
	//	*SLMplsCos_DefaultElspPath
	//	*SLMplsCos_ForwardingClass
	Value isSLMplsCos_Value `protobuf_oneof:"value"`
}

func (x *SLMplsCos) Reset() {
	*x = SLMplsCos{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsCos) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsCos) ProtoMessage() {}

func (x *SLMplsCos) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsCos.ProtoReflect.Descriptor instead.
func (*SLMplsCos) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{14}
}

func (m *SLMplsCos) GetValue() isSLMplsCos_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (x *SLMplsCos) GetExp() uint32 {
	if x, ok := x.GetValue().(*SLMplsCos_Exp); ok {
		return x.Exp
	}
	return 0
}

func (x *SLMplsCos) GetDefaultElspPath() bool {
	if x, ok := x.GetValue().(*SLMplsCos_DefaultElspPath); ok {
		return x.DefaultElspPath
	}
	return false
}

func (x *SLMplsCos) GetForwardingClass() uint32 {
	if x, ok := x.GetValue().(*SLMplsCos_ForwardingClass); ok {
		return x.ForwardingClass
	}
	return 0
}

type isSLMplsCos_Value interface {
	isSLMplsCos_Value()
}

type SLMplsCos_Exp struct {
	// LSB 3 bits with valid range <0-7>
	// this is used to configure E-LSPs (see RFC 3270)
	Exp uint32 `protobuf:"varint,1,opt,name=Exp,proto3,oneof"`
}

type SLMplsCos_DefaultElspPath struct {
	// Flag to indicate that this is also an E-LSP entry and all paths
	// will be using this default path
	DefaultElspPath bool `protobuf:"varint,2,opt,name=DefaultElspPath,proto3,oneof"`
}

type SLMplsCos_ForwardingClass struct {
	// forwarding class with valid range <0-7>
	ForwardingClass uint32 `protobuf:"varint,3,opt,name=ForwardingClass,proto3,oneof"`
}

func (*SLMplsCos_Exp) isSLMplsCos_Value() {}

func (*SLMplsCos_DefaultElspPath) isSLMplsCos_Value() {}

func (*SLMplsCos_ForwardingClass) isSLMplsCos_Value() {}

// MPLS ILM entry.
// This messages defines an ILM entry.
type SLMplsIlmEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ILM Key.
	Key *SLMplsIlmKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// List of path (NHLFE) information.
	Paths []*SLMplsPath `protobuf:"bytes,2,rep,name=Paths,proto3" json:"Paths,omitempty"`
}

func (x *SLMplsIlmEntry) Reset() {
	*x = SLMplsIlmEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmEntry) ProtoMessage() {}

func (x *SLMplsIlmEntry) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmEntry.ProtoReflect.Descriptor instead.
func (*SLMplsIlmEntry) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{15}
}

func (x *SLMplsIlmEntry) GetKey() *SLMplsIlmKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLMplsIlmEntry) GetPaths() []*SLMplsPath {
	if x != nil {
		return x.Paths
	}
	return nil
}

// A batch of MPLS ILM entries.
// This message is used to send a batch of ILM entries.
type SLMplsIlmMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// MPLS Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// List of ILM entries
	MplsIlms []*SLMplsIlmEntry `protobuf:"bytes,3,rep,name=MplsIlms,proto3" json:"MplsIlms,omitempty"`
}

func (x *SLMplsIlmMsg) Reset() {
	*x = SLMplsIlmMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmMsg) ProtoMessage() {}

func (x *SLMplsIlmMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmMsg.ProtoReflect.Descriptor instead.
func (*SLMplsIlmMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{16}
}

func (x *SLMplsIlmMsg) GetOper() SLObjectOp {
	if x != nil {
		return x.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (x *SLMplsIlmMsg) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLMplsIlmMsg) GetMplsIlms() []*SLMplsIlmEntry {
	if x != nil {
		return x.MplsIlms
	}
	return nil
}

// MPLS ILM result.
// This message is used to convey the result of the ILM entry operation.
type SLMplsIlmRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// ILM Key.
	Key *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
}

func (x *SLMplsIlmRes) Reset() {
	*x = SLMplsIlmRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmRes) ProtoMessage() {}

func (x *SLMplsIlmRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmRes.ProtoReflect.Descriptor instead.
func (*SLMplsIlmRes) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{17}
}

func (x *SLMplsIlmRes) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsIlmRes) GetKey() *SLMplsIlmKey {
	if x != nil {
		return x.Key
	}
	return nil
}

// MPLS ILM batch response.
// This message is used to convey the result of the ILM batch operation.
type SLMplsIlmMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,2,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLMplsIlmRes `protobuf:"bytes,3,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLMplsIlmMsgRsp) Reset() {
	*x = SLMplsIlmMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmMsgRsp) ProtoMessage() {}

func (x *SLMplsIlmMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsIlmMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{18}
}

func (x *SLMplsIlmMsgRsp) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLMplsIlmMsgRsp) GetStatusSummary() *SLErrorStatus {
	if x != nil {
		return x.StatusSummary
	}
	return nil
}

func (x *SLMplsIlmMsgRsp) GetResults() []*SLMplsIlmRes {
	if x != nil {
		return x.Results
	}
	return nil
}

// MPLS ILM Get Message
// This message is used to query the attributes of an ILM entry.
type SLMplsIlmGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// MPLS ILM key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,3,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,4,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
}

func (x *SLMplsIlmGetMsg) Reset() {
	*x = SLMplsIlmGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmGetMsg) ProtoMessage() {}

func (x *SLMplsIlmGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmGetMsg.ProtoReflect.Descriptor instead.
func (*SLMplsIlmGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{19}
}

func (x *SLMplsIlmGetMsg) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLMplsIlmGetMsg) GetKey() *SLMplsIlmKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLMplsIlmGetMsg) GetEntriesCount() uint32 {
	if x != nil {
		return x.EntriesCount
	}
	return 0
}

func (x *SLMplsIlmGetMsg) GetGetNext() bool {
	if x != nil {
		return x.GetNext
	}
	return false
}

// MPLS ILM Get Message Response.
type SLMplsIlmGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,2,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation.
	ErrStatus *SLErrorStatus `protobuf:"bytes,3,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLMplsIlmEntry `protobuf:"bytes,4,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLMplsIlmGetMsgRsp) Reset() {
	*x = SLMplsIlmGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_mpls_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLMplsIlmGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLMplsIlmGetMsgRsp) ProtoMessage() {}

func (x *SLMplsIlmGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_mpls_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLMplsIlmGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLMplsIlmGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_mpls_proto_rawDescGZIP(), []int{20}
}

func (x *SLMplsIlmGetMsgRsp) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLMplsIlmGetMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLMplsIlmGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLMplsIlmGetMsgRsp) GetEntries() []*SLMplsIlmEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

var File_sl_mpls_proto protoreflect.FileDescriptor

var file_sl_mpls_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x73, 0x6c, 0x5f, 0x6d, 0x70, 0x6c, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x1a, 0x15,
	0x73, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc0, 0x01, 0x0a, 0x13, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73,
	0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a,
	0x0a, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x26, 0x0a,
	0x0e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63,
	0x6b, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x41, 0x0a, 0x09, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x54, 0x79,
	0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x43, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x88, 0x01, 0x0a, 0x13, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4d, 0x73, 0x67,
	0x12, 0x2d, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12,
	0x42, 0x0a, 0x0a, 0x4d, 0x70, 0x6c, 0x73, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x4b, 0x65, 0x79, 0x52, 0x0a, 0x4d, 0x70, 0x6c, 0x73, 0x42, 0x6c, 0x6f,
	0x63, 0x6b, 0x73, 0x22, 0x8a, 0x01, 0x0a, 0x16, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x12, 0x3a,
	0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x34, 0x0a, 0x03, 0x4b, 0x65,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79,
	0x22, 0x9d, 0x01, 0x0a, 0x16, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c,
	0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x42, 0x0a, 0x0d, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12,
	0x3f, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x25, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63,
	0x6b, 0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x52, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73,
	0x22, 0x8c, 0x01, 0x0a, 0x16, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c,
	0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x34, 0x0a, 0x03, 0x4b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65,
	0x79, 0x12, 0x22, 0x0a, 0x0c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x22,
	0xa7, 0x01, 0x0a, 0x19, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x10, 0x0a,
	0x03, 0x45, 0x6f, 0x66, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f, 0x66, 0x12,
	0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3c, 0x0a, 0x07, 0x45,
	0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4b, 0x65, 0x79,
	0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x3f, 0x0a, 0x09, 0x53, 0x6c, 0x4d,
	0x70, 0x6c, 0x73, 0x52, 0x65, 0x67, 0x12, 0x32, 0x0a, 0x14, 0x50, 0x75, 0x72, 0x67, 0x65, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x14, 0x50, 0x75, 0x72, 0x67, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x22, 0x6c, 0x0a, 0x0c, 0x53, 0x4c,
	0x4d, 0x70, 0x6c, 0x73, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x12, 0x2a, 0x0a, 0x04, 0x4f, 0x70,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x65, 0x67, 0x4f, 0x70,
	0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x30, 0x0a, 0x06, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x6c, 0x4d, 0x70, 0x6c, 0x73, 0x52, 0x65, 0x67,
	0x52, 0x06, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x22, 0x4d, 0x0a, 0x0f, 0x53, 0x4c, 0x4d, 0x70,
	0x6c, 0x73, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x3a, 0x0a, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x0e, 0x0a, 0x0c, 0x53, 0x4c, 0x4d, 0x70, 0x6c,
	0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x22, 0xe3, 0x02, 0x0a, 0x0f, 0x53, 0x4c, 0x4d, 0x70,
	0x6c, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x3a, 0x0a, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2c, 0x0a, 0x11, 0x4d, 0x61, 0x78, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x73, 0x50, 0x65, 0x72, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x11, 0x4d, 0x61, 0x78, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x50, 0x65, 0x72,
	0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x46, 0x0a, 0x1e, 0x4d, 0x61, 0x78, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x50, 0x65, 0x72, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x1e, 0x4d,
	0x61, 0x78, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x50, 0x65, 0x72,
	0x4c, 0x61, 0x62, 0x65, 0x6c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x6d, 0x73, 0x67, 0x12, 0x24, 0x0a,
	0x0d, 0x4d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x4d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x12, 0x26, 0x0a, 0x0e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x54, 0x61, 0x62, 0x6c,
	0x65, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x28, 0x0a, 0x0f, 0x4d,
	0x61, 0x78, 0x49, 0x6c, 0x6d, 0x50, 0x65, 0x72, 0x49, 0x6c, 0x6d, 0x6d, 0x73, 0x67, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x4d, 0x61, 0x78, 0x49, 0x6c, 0x6d, 0x50, 0x65, 0x72, 0x49,
	0x6c, 0x6d, 0x6d, 0x73, 0x67, 0x12, 0x26, 0x0a, 0x0e, 0x4d, 0x61, 0x78, 0x50, 0x61, 0x74, 0x68,
	0x73, 0x50, 0x65, 0x72, 0x49, 0x6c, 0x6d, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x4d,
	0x61, 0x78, 0x50, 0x61, 0x74, 0x68, 0x73, 0x50, 0x65, 0x72, 0x49, 0x6c, 0x6d, 0x22, 0x98, 0x01,
	0x0a, 0x14, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73,
	0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x28, 0x0a, 0x0f, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
	0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08,
	0x49, 0x6c, 0x6d, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08,
	0x49, 0x6c, 0x6d, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xb4, 0x03, 0x0a, 0x0a, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x50, 0x61, 0x74, 0x68, 0x12, 0x42, 0x0a, 0x0e, 0x4e, 0x65, 0x78, 0x74, 0x68,
	0x6f, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0e, 0x4e, 0x65, 0x78,
	0x74, 0x68, 0x6f, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x46, 0x0a, 0x10, 0x4e,
	0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
	0x65, 0x52, 0x10, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66,
	0x61, 0x63, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74, 0x72, 0x69,
	0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x34, 0x0a,
	0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x6c,
	0x4c, 0x61, 0x62, 0x65, 0x6c, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x41, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x12, 0x30, 0x0a, 0x13, 0x50,
	0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d,
	0x61, 0x70, 0x18, 0x07, 0x20, 0x03, 0x28, 0x04, 0x52, 0x13, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63,
	0x74, 0x65, 0x64, 0x50, 0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x12, 0x1e, 0x0a,
	0x0a, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x18, 0x08, 0x20, 0x03, 0x28,
	0x0d, 0x52, 0x0a, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x12, 0x40, 0x0a,
	0x0d, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x09,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x52, 0x0d, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22,
	0x6c, 0x0a, 0x0c, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4b, 0x65, 0x79, 0x12,
	0x1e, 0x0a, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12,
	0x3c, 0x0a, 0x0c, 0x53, 0x6c, 0x4d, 0x70, 0x6c, 0x73, 0x43, 0x6f, 0x73, 0x56, 0x61, 0x6c, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x43, 0x6f, 0x73, 0x52,
	0x0c, 0x53, 0x6c, 0x4d, 0x70, 0x6c, 0x73, 0x43, 0x6f, 0x73, 0x56, 0x61, 0x6c, 0x22, 0x80, 0x01,
	0x0a, 0x09, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x43, 0x6f, 0x73, 0x12, 0x12, 0x0a, 0x03, 0x45,
	0x78, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x03, 0x45, 0x78, 0x70, 0x12,
	0x2a, 0x0a, 0x0f, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x45, 0x6c, 0x73, 0x70, 0x50, 0x61,
	0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x0f, 0x44, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x45, 0x6c, 0x73, 0x70, 0x50, 0x61, 0x74, 0x68, 0x12, 0x2a, 0x0a, 0x0f, 0x46,
	0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x0f, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69,
	0x6e, 0x67, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x42, 0x07, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x22, 0x70, 0x0a, 0x0e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x12, 0x2d, 0x0a, 0x03, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65,
	0x79, 0x12, 0x2f, 0x0a, 0x05, 0x50, 0x61, 0x74, 0x68, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x50, 0x61, 0x74, 0x68, 0x52, 0x05, 0x50, 0x61, 0x74,
	0x68, 0x73, 0x22, 0x98, 0x01, 0x0a, 0x0c, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d,
	0x4d, 0x73, 0x67, 0x12, 0x2d, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70,
	0x65, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x39, 0x0a, 0x08, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x52, 0x08, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x73, 0x22, 0x79, 0x0a,
	0x0c, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x52, 0x65, 0x73, 0x12, 0x3a, 0x0a,
	0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09,
	0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2d, 0x0a, 0x03, 0x4b, 0x65, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d,
	0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x22, 0xac, 0x01, 0x0a, 0x0f, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x1e, 0x0a, 0x0a,
	0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x42, 0x0a, 0x0d,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79,
	0x12, 0x35, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x52, 0x65, 0x73, 0x52, 0x07,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0x9e, 0x01, 0x0a, 0x0f, 0x53, 0x4c, 0x4d, 0x70,
	0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x43,
	0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x2d, 0x0a, 0x03, 0x4b,
	0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49,
	0x6c, 0x6d, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x22, 0x0a, 0x0c, 0x45, 0x6e,
	0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18,
	0x0a, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x22, 0xbb, 0x01, 0x0a, 0x12, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12,
	0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12,
	0x10, 0x0a, 0x03, 0x45, 0x6f, 0x66, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f,
	0x66, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x37, 0x0a,
	0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x45,
	0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x2a, 0xe2, 0x01, 0x0a, 0x0d, 0x53, 0x6c, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x18, 0x53, 0x4c, 0x5f, 0x4c,
	0x41, 0x42, 0x45, 0x4c, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x53, 0x45,
	0x52, 0x56, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x53, 0x4c, 0x5f, 0x4c, 0x41, 0x42,
	0x45, 0x4c, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x57, 0x41, 0x50, 0x10, 0x01,
	0x12, 0x23, 0x0a, 0x1f, 0x53, 0x4c, 0x5f, 0x4c, 0x41, 0x42, 0x45, 0x4c, 0x5f, 0x41, 0x43, 0x54,
	0x49, 0x4f, 0x4e, 0x5f, 0x50, 0x4f, 0x50, 0x5f, 0x41, 0x4e, 0x44, 0x5f, 0x46, 0x4f, 0x52, 0x57,
	0x41, 0x52, 0x44, 0x10, 0x02, 0x12, 0x27, 0x0a, 0x23, 0x53, 0x4c, 0x5f, 0x4c, 0x41, 0x42, 0x45,
	0x4c, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x50, 0x4f, 0x50, 0x5f, 0x41, 0x4e, 0x44,
	0x5f, 0x4c, 0x4f, 0x4f, 0x4b, 0x55, 0x50, 0x5f, 0x49, 0x50, 0x56, 0x34, 0x10, 0x03, 0x12, 0x27,
	0x0a, 0x23, 0x53, 0x4c, 0x5f, 0x4c, 0x41, 0x42, 0x45, 0x4c, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f,
	0x4e, 0x5f, 0x50, 0x4f, 0x50, 0x5f, 0x41, 0x4e, 0x44, 0x5f, 0x4c, 0x4f, 0x4f, 0x4b, 0x55, 0x50,
	0x5f, 0x49, 0x50, 0x56, 0x36, 0x10, 0x04, 0x12, 0x22, 0x0a, 0x1e, 0x53, 0x4c, 0x5f, 0x4c, 0x41,
	0x42, 0x45, 0x4c, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x50, 0x4f, 0x50, 0x5f, 0x41,
	0x4e, 0x44, 0x5f, 0x4c, 0x4f, 0x4f, 0x4b, 0x55, 0x50, 0x10, 0x05, 0x2a, 0x82, 0x01, 0x0a, 0x14,
	0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x25, 0x0a, 0x21, 0x53, 0x4c, 0x5f, 0x4d, 0x50, 0x4c, 0x53, 0x5f,
	0x4c, 0x41, 0x42, 0x45, 0x4c, 0x5f, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x44, 0x10, 0x00, 0x12, 0x21, 0x0a, 0x1d, 0x53,
	0x4c, 0x5f, 0x4d, 0x50, 0x4c, 0x53, 0x5f, 0x4c, 0x41, 0x42, 0x45, 0x4c, 0x5f, 0x42, 0x4c, 0x4f,
	0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x52, 0x47, 0x42, 0x10, 0x01, 0x12, 0x20,
	0x0a, 0x1c, 0x53, 0x4c, 0x5f, 0x4d, 0x50, 0x4c, 0x53, 0x5f, 0x4c, 0x41, 0x42, 0x45, 0x4c, 0x5f,
	0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43, 0x42, 0x46, 0x10, 0x02,
	0x32, 0x91, 0x06, 0x0a, 0x0a, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4f, 0x70, 0x65, 0x72, 0x12,
	0x4a, 0x0a, 0x0b, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x52, 0x65, 0x67, 0x4f, 0x70, 0x12, 0x1b,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x1a, 0x1e, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70,
	0x6c, 0x73, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x48, 0x0a, 0x09, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47,
	0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x4d,
	0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x52, 0x0a, 0x0e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47,
	0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47, 0x65,
	0x74, 0x4d, 0x73, 0x67, 0x1a, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x53, 0x74,
	0x61, 0x74, 0x73, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x5f, 0x0a, 0x12, 0x53, 0x4c, 0x4d,
	0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4f, 0x70, 0x12,
	0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
	0x4d, 0x73, 0x67, 0x1a, 0x25, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x66, 0x0a, 0x13, 0x53, 0x4c,
	0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x47, 0x65,
	0x74, 0x12, 0x25, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f,
	0x63, 0x6b, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x28, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52,
	0x73, 0x70, 0x12, 0x4a, 0x0a, 0x0b, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4f,
	0x70, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4d, 0x73, 0x67, 0x1a, 0x1e,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x51,
	0x0a, 0x0c, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x12, 0x1e,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x21,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73,
	0x70, 0x12, 0x54, 0x0a, 0x11, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4f, 0x70,
	0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d,
	0x4d, 0x73, 0x67, 0x1a, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x4d, 0x73, 0x67,
	0x52, 0x73, 0x70, 0x28, 0x01, 0x30, 0x01, 0x12, 0x5b, 0x0a, 0x12, 0x53, 0x4c, 0x4d, 0x70, 0x6c,
	0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x1e, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x21, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x4d, 0x70, 0x6c, 0x73, 0x49, 0x6c, 0x6d, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70,
	0x28, 0x01, 0x30, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_mpls_proto_rawDescOnce sync.Once
	file_sl_mpls_proto_rawDescData = file_sl_mpls_proto_rawDesc
)

func file_sl_mpls_proto_rawDescGZIP() []byte {
	file_sl_mpls_proto_rawDescOnce.Do(func() {
		file_sl_mpls_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_mpls_proto_rawDescData)
	})
	return file_sl_mpls_proto_rawDescData
}

var file_sl_mpls_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_sl_mpls_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_sl_mpls_proto_goTypes = []interface{}{
	(SlLabelAction)(0),                // 0: service_layer.SlLabelAction
	(SLMplsLabelBlockType)(0),         // 1: service_layer.SLMplsLabelBlockType
	(*SLMplsLabelBlockKey)(nil),       // 2: service_layer.SLMplsLabelBlockKey
	(*SLMplsLabelBlockMsg)(nil),       // 3: service_layer.SLMplsLabelBlockMsg
	(*SLMplsLabelBlockMsgRes)(nil),    // 4: service_layer.SLMplsLabelBlockMsgRes
	(*SLMplsLabelBlockMsgRsp)(nil),    // 5: service_layer.SLMplsLabelBlockMsgRsp
	(*SLMplsLabelBlockGetMsg)(nil),    // 6: service_layer.SLMplsLabelBlockGetMsg
	(*SLMplsLabelBlockGetMsgRsp)(nil), // 7: service_layer.SLMplsLabelBlockGetMsgRsp
	(*SlMplsReg)(nil),                 // 8: service_layer.SlMplsReg
	(*SLMplsRegMsg)(nil),              // 9: service_layer.SLMplsRegMsg
	(*SLMplsRegMsgRsp)(nil),           // 10: service_layer.SLMplsRegMsgRsp
	(*SLMplsGetMsg)(nil),              // 11: service_layer.SLMplsGetMsg
	(*SLMplsGetMsgRsp)(nil),           // 12: service_layer.SLMplsGetMsgRsp
	(*SLMplsGetStatsMsgRsp)(nil),      // 13: service_layer.SLMplsGetStatsMsgRsp
	(*SLMplsPath)(nil),                // 14: service_layer.SLMplsPath
	(*SLMplsIlmKey)(nil),              // 15: service_layer.SLMplsIlmKey
	(*SLMplsCos)(nil),                 // 16: service_layer.SLMplsCos
	(*SLMplsIlmEntry)(nil),            // 17: service_layer.SLMplsIlmEntry
	(*SLMplsIlmMsg)(nil),              // 18: service_layer.SLMplsIlmMsg
	(*SLMplsIlmRes)(nil),              // 19: service_layer.SLMplsIlmRes
	(*SLMplsIlmMsgRsp)(nil),           // 20: service_layer.SLMplsIlmMsgRsp
	(*SLMplsIlmGetMsg)(nil),           // 21: service_layer.SLMplsIlmGetMsg
	(*SLMplsIlmGetMsgRsp)(nil),        // 22: service_layer.SLMplsIlmGetMsgRsp
	(SLObjectOp)(0),                   // 23: service_layer.SLObjectOp
	(*SLErrorStatus)(nil),             // 24: service_layer.SLErrorStatus
	(SLRegOp)(0),                      // 25: service_layer.SLRegOp
	(*SLIpAddress)(nil),               // 26: service_layer.SLIpAddress
	(*SLInterface)(nil),               // 27: service_layer.SLInterface
}
var file_sl_mpls_proto_depIdxs = []int32{
	1,  // 0: service_layer.SLMplsLabelBlockKey.BlockType:type_name -> service_layer.SLMplsLabelBlockType
	23, // 1: service_layer.SLMplsLabelBlockMsg.Oper:type_name -> service_layer.SLObjectOp
	2,  // 2: service_layer.SLMplsLabelBlockMsg.MplsBlocks:type_name -> service_layer.SLMplsLabelBlockKey
	24, // 3: service_layer.SLMplsLabelBlockMsgRes.ErrStatus:type_name -> service_layer.SLErrorStatus
	2,  // 4: service_layer.SLMplsLabelBlockMsgRes.Key:type_name -> service_layer.SLMplsLabelBlockKey
	24, // 5: service_layer.SLMplsLabelBlockMsgRsp.StatusSummary:type_name -> service_layer.SLErrorStatus
	4,  // 6: service_layer.SLMplsLabelBlockMsgRsp.Results:type_name -> service_layer.SLMplsLabelBlockMsgRes
	2,  // 7: service_layer.SLMplsLabelBlockGetMsg.Key:type_name -> service_layer.SLMplsLabelBlockKey
	24, // 8: service_layer.SLMplsLabelBlockGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	2,  // 9: service_layer.SLMplsLabelBlockGetMsgRsp.Entries:type_name -> service_layer.SLMplsLabelBlockKey
	25, // 10: service_layer.SLMplsRegMsg.Oper:type_name -> service_layer.SLRegOp
	8,  // 11: service_layer.SLMplsRegMsg.RegMsg:type_name -> service_layer.SlMplsReg
	24, // 12: service_layer.SLMplsRegMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	24, // 13: service_layer.SLMplsGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	24, // 14: service_layer.SLMplsGetStatsMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	26, // 15: service_layer.SLMplsPath.NexthopAddress:type_name -> service_layer.SLIpAddress
	27, // 16: service_layer.SLMplsPath.NexthopInterface:type_name -> service_layer.SLInterface
	0,  // 17: service_layer.SLMplsPath.Action:type_name -> service_layer.SlLabelAction
	26, // 18: service_layer.SLMplsPath.RemoteAddress:type_name -> service_layer.SLIpAddress
	16, // 19: service_layer.SLMplsIlmKey.SlMplsCosVal:type_name -> service_layer.SLMplsCos
	15, // 20: service_layer.SLMplsIlmEntry.Key:type_name -> service_layer.SLMplsIlmKey
	14, // 21: service_layer.SLMplsIlmEntry.Paths:type_name -> service_layer.SLMplsPath
	23, // 22: service_layer.SLMplsIlmMsg.Oper:type_name -> service_layer.SLObjectOp
	17, // 23: service_layer.SLMplsIlmMsg.MplsIlms:type_name -> service_layer.SLMplsIlmEntry
	24, // 24: service_layer.SLMplsIlmRes.ErrStatus:type_name -> service_layer.SLErrorStatus
	15, // 25: service_layer.SLMplsIlmRes.Key:type_name -> service_layer.SLMplsIlmKey
	24, // 26: service_layer.SLMplsIlmMsgRsp.StatusSummary:type_name -> service_layer.SLErrorStatus
	19, // 27: service_layer.SLMplsIlmMsgRsp.Results:type_name -> service_layer.SLMplsIlmRes
	15, // 28: service_layer.SLMplsIlmGetMsg.Key:type_name -> service_layer.SLMplsIlmKey
	24, // 29: service_layer.SLMplsIlmGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	17, // 30: service_layer.SLMplsIlmGetMsgRsp.Entries:type_name -> service_layer.SLMplsIlmEntry
	9,  // 31: service_layer.SLMplsOper.SLMplsRegOp:input_type -> service_layer.SLMplsRegMsg
	11, // 32: service_layer.SLMplsOper.SLMplsGet:input_type -> service_layer.SLMplsGetMsg
	11, // 33: service_layer.SLMplsOper.SLMplsGetStats:input_type -> service_layer.SLMplsGetMsg
	3,  // 34: service_layer.SLMplsOper.SLMplsLabelBlockOp:input_type -> service_layer.SLMplsLabelBlockMsg
	6,  // 35: service_layer.SLMplsOper.SLMplsLabelBlockGet:input_type -> service_layer.SLMplsLabelBlockGetMsg
	18, // 36: service_layer.SLMplsOper.SLMplsIlmOp:input_type -> service_layer.SLMplsIlmMsg
	21, // 37: service_layer.SLMplsOper.SLMplsIlmGet:input_type -> service_layer.SLMplsIlmGetMsg
	18, // 38: service_layer.SLMplsOper.SLMplsIlmOpStream:input_type -> service_layer.SLMplsIlmMsg
	21, // 39: service_layer.SLMplsOper.SLMplsIlmGetStream:input_type -> service_layer.SLMplsIlmGetMsg
	10, // 40: service_layer.SLMplsOper.SLMplsRegOp:output_type -> service_layer.SLMplsRegMsgRsp
	12, // 41: service_layer.SLMplsOper.SLMplsGet:output_type -> service_layer.SLMplsGetMsgRsp
	13, // 42: service_layer.SLMplsOper.SLMplsGetStats:output_type -> service_layer.SLMplsGetStatsMsgRsp
	5,  // 43: service_layer.SLMplsOper.SLMplsLabelBlockOp:output_type -> service_layer.SLMplsLabelBlockMsgRsp
	7,  // 44: service_layer.SLMplsOper.SLMplsLabelBlockGet:output_type -> service_layer.SLMplsLabelBlockGetMsgRsp
	20, // 45: service_layer.SLMplsOper.SLMplsIlmOp:output_type -> service_layer.SLMplsIlmMsgRsp
	22, // 46: service_layer.SLMplsOper.SLMplsIlmGet:output_type -> service_layer.SLMplsIlmGetMsgRsp
	20, // 47: service_layer.SLMplsOper.SLMplsIlmOpStream:output_type -> service_layer.SLMplsIlmMsgRsp
	22, // 48: service_layer.SLMplsOper.SLMplsIlmGetStream:output_type -> service_layer.SLMplsIlmGetMsgRsp
	40, // [40:49] is the sub-list for method output_type
	31, // [31:40] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_sl_mpls_proto_init() }
func file_sl_mpls_proto_init() {
	if File_sl_mpls_proto != nil {
		return
	}
	file_sl_common_types_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_mpls_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockMsgRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsLabelBlockGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SlMplsReg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsRegMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsRegMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsGetStatsMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsPath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsCos); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_mpls_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLMplsIlmGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_sl_mpls_proto_msgTypes[14].OneofWrappers = []interface{}{
		(*SLMplsCos_Exp)(nil),
		(*SLMplsCos_DefaultElspPath)(nil),
		(*SLMplsCos_ForwardingClass)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_mpls_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_sl_mpls_proto_goTypes,
		DependencyIndexes: file_sl_mpls_proto_depIdxs,
		EnumInfos:         file_sl_mpls_proto_enumTypes,
		MessageInfos:      file_sl_mpls_proto_msgTypes,
	}.Build()
	File_sl_mpls_proto = out.File
	file_sl_mpls_proto_rawDesc = nil
	file_sl_mpls_proto_goTypes = nil
	file_sl_mpls_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SLMplsOperClient is the client API for SLMplsOper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLMplsOperClient interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error)
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error)
}

type sLMplsOperClient struct {
	cc grpc.ClientConnInterface
}

func NewSLMplsOperClient(cc grpc.ClientConnInterface) SLMplsOperClient {
	return &sLMplsOperClient{cc}
}

func (c *sLMplsOperClient) SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error) {
	out := new(SLMplsRegMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsRegOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error) {
	out := new(SLMplsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error) {
	out := new(SLMplsGetStatsMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error) {
	out := new(SLMplsLabelBlockMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error) {
	out := new(SLMplsLabelBlockGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error) {
	out := new(SLMplsIlmMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error) {
	out := new(SLMplsIlmGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLMplsOper_serviceDesc.Streams[0], "/service_layer.SLMplsOper/SLMplsIlmOpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmOpStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmOpStreamClient interface {
	Send(*SLMplsIlmMsg) error
	Recv() (*SLMplsIlmMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmOpStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Send(m *SLMplsIlmMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Recv() (*SLMplsIlmMsgRsp, error) {
	m := new(SLMplsIlmMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLMplsOperClient) SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLMplsOper_serviceDesc.Streams[1], "/service_layer.SLMplsOper/SLMplsIlmGetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmGetStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmGetStreamClient interface {
	Send(*SLMplsIlmGetMsg) error
	Recv() (*SLMplsIlmGetMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmGetStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Send(m *SLMplsIlmGetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Recv() (*SLMplsIlmGetMsgRsp, error) {
	m := new(SLMplsIlmGetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLMplsOperServer is the server API for SLMplsOper service.
type SLMplsOperServer interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error
}

// UnimplementedSLMplsOperServer can be embedded to have forward compatible implementations.
type UnimplementedSLMplsOperServer struct {
}

func (*UnimplementedSLMplsOperServer) SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsRegOp not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsGet not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsGetStats not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsLabelBlockOp not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsLabelBlockGet not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsIlmOp not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsIlmGet not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLMplsIlmOpStream not implemented")
}
func (*UnimplementedSLMplsOperServer) SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLMplsIlmGetStream not implemented")
}

func RegisterSLMplsOperServer(s *grpc.Server, srv SLMplsOperServer) {
	s.RegisterService(&_SLMplsOper_serviceDesc, srv)
}

func _SLMplsOper_SLMplsRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, req.(*SLMplsRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, req.(*SLMplsLabelBlockMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, req.(*SLMplsLabelBlockGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, req.(*SLMplsIlmMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, req.(*SLMplsIlmGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmOpStream(&sLMplsOperSLMplsIlmOpStreamServer{stream})
}

type SLMplsOper_SLMplsIlmOpStreamServer interface {
	Send(*SLMplsIlmMsgRsp) error
	Recv() (*SLMplsIlmMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmOpStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Send(m *SLMplsIlmMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Recv() (*SLMplsIlmMsg, error) {
	m := new(SLMplsIlmMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLMplsOper_SLMplsIlmGetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmGetStream(&sLMplsOperSLMplsIlmGetStreamServer{stream})
}

type SLMplsOper_SLMplsIlmGetStreamServer interface {
	Send(*SLMplsIlmGetMsgRsp) error
	Recv() (*SLMplsIlmGetMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmGetStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Send(m *SLMplsIlmGetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Recv() (*SLMplsIlmGetMsg, error) {
	m := new(SLMplsIlmGetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLMplsOper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLMplsOper",
	HandlerType: (*SLMplsOperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLMplsRegOp",
			Handler:    _SLMplsOper_SLMplsRegOp_Handler,
		},
		{
			MethodName: "SLMplsGet",
			Handler:    _SLMplsOper_SLMplsGet_Handler,
		},
		{
			MethodName: "SLMplsGetStats",
			Handler:    _SLMplsOper_SLMplsGetStats_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockOp",
			Handler:    _SLMplsOper_SLMplsLabelBlockOp_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockGet",
			Handler:    _SLMplsOper_SLMplsLabelBlockGet_Handler,
		},
		{
			MethodName: "SLMplsIlmOp",
			Handler:    _SLMplsOper_SLMplsIlmOp_Handler,
		},
		{
			MethodName: "SLMplsIlmGet",
			Handler:    _SLMplsOper_SLMplsIlmGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLMplsIlmOpStream",
			Handler:       _SLMplsOper_SLMplsIlmOpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLMplsIlmGetStream",
			Handler:       _SLMplsOper_SLMplsIlmGetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_mpls.proto",
}
