// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.18.3
// source: sl_mpls.proto

package service_layer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SLMplsOperClient is the client API for SLMplsOper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SLMplsOperClient interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//
	//	Global MPLS registration.
	//	A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//
	//	Global MPLS un-registration.
	//	This call is used to end all MPLS notifications and unregister any
	//	interest in MPLS object configuration.
	//	This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//
	//	MPLS End Of File.
	//	After Registration, the client is expected to send an EOF
	//	message to convey the end of replay of the client's known objects.
	//	This is especially useful under certain restart scenarios when the
	//	client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//
	//	Add a contiguous label block.
	//	Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//
	//	Delete a contiguous label block.
	//	Delete request may fail if the block is in use or the keys don't
	//	match the keys used on add.
	SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//
	//	Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//
	//	Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//
	//	Delete incoming label map entry.
	SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//
	//	Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//
	//	Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//
	//	Delete incoming label map entry.
	SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error)
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error)
}

type sLMplsOperClient struct {
	cc grpc.ClientConnInterface
}

func NewSLMplsOperClient(cc grpc.ClientConnInterface) SLMplsOperClient {
	return &sLMplsOperClient{cc}
}

func (c *sLMplsOperClient) SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error) {
	out := new(SLMplsRegMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsRegOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error) {
	out := new(SLMplsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error) {
	out := new(SLMplsGetStatsMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error) {
	out := new(SLMplsLabelBlockMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error) {
	out := new(SLMplsLabelBlockGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error) {
	out := new(SLMplsIlmMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error) {
	out := new(SLMplsIlmGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &SLMplsOper_ServiceDesc.Streams[0], "/service_layer.SLMplsOper/SLMplsIlmOpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmOpStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmOpStreamClient interface {
	Send(*SLMplsIlmMsg) error
	Recv() (*SLMplsIlmMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmOpStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Send(m *SLMplsIlmMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Recv() (*SLMplsIlmMsgRsp, error) {
	m := new(SLMplsIlmMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLMplsOperClient) SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &SLMplsOper_ServiceDesc.Streams[1], "/service_layer.SLMplsOper/SLMplsIlmGetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmGetStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmGetStreamClient interface {
	Send(*SLMplsIlmGetMsg) error
	Recv() (*SLMplsIlmGetMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmGetStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Send(m *SLMplsIlmGetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Recv() (*SLMplsIlmGetMsgRsp, error) {
	m := new(SLMplsIlmGetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLMplsOperServer is the server API for SLMplsOper service.
// All implementations must embed UnimplementedSLMplsOperServer
// for forward compatibility
type SLMplsOperServer interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//
	//	Global MPLS registration.
	//	A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//
	//	Global MPLS un-registration.
	//	This call is used to end all MPLS notifications and unregister any
	//	interest in MPLS object configuration.
	//	This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//
	//	MPLS End Of File.
	//	After Registration, the client is expected to send an EOF
	//	message to convey the end of replay of the client's known objects.
	//	This is especially useful under certain restart scenarios when the
	//	client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//
	//	Add a contiguous label block.
	//	Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//
	//	Delete a contiguous label block.
	//	Delete request may fail if the block is in use or the keys don't
	//	match the keys used on add.
	SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//
	//	Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//
	//	Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//
	//	Delete incoming label map entry.
	SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//
	//	Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//
	//	Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//
	//	Delete incoming label map entry.
	SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error
	mustEmbedUnimplementedSLMplsOperServer()
}

// UnimplementedSLMplsOperServer must be embedded to have forward compatible implementations.
type UnimplementedSLMplsOperServer struct {
}

func (UnimplementedSLMplsOperServer) SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsRegOp not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsGet not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsGetStats not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsLabelBlockOp not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsLabelBlockGet not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsIlmOp not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLMplsIlmGet not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLMplsIlmOpStream not implemented")
}
func (UnimplementedSLMplsOperServer) SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLMplsIlmGetStream not implemented")
}
func (UnimplementedSLMplsOperServer) mustEmbedUnimplementedSLMplsOperServer() {}

// UnsafeSLMplsOperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SLMplsOperServer will
// result in compilation errors.
type UnsafeSLMplsOperServer interface {
	mustEmbedUnimplementedSLMplsOperServer()
}

func RegisterSLMplsOperServer(s grpc.ServiceRegistrar, srv SLMplsOperServer) {
	s.RegisterService(&SLMplsOper_ServiceDesc, srv)
}

func _SLMplsOper_SLMplsRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, req.(*SLMplsRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, req.(*SLMplsLabelBlockMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, req.(*SLMplsLabelBlockGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, req.(*SLMplsIlmMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, req.(*SLMplsIlmGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmOpStream(&sLMplsOperSLMplsIlmOpStreamServer{stream})
}

type SLMplsOper_SLMplsIlmOpStreamServer interface {
	Send(*SLMplsIlmMsgRsp) error
	Recv() (*SLMplsIlmMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmOpStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Send(m *SLMplsIlmMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Recv() (*SLMplsIlmMsg, error) {
	m := new(SLMplsIlmMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLMplsOper_SLMplsIlmGetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmGetStream(&sLMplsOperSLMplsIlmGetStreamServer{stream})
}

type SLMplsOper_SLMplsIlmGetStreamServer interface {
	Send(*SLMplsIlmGetMsgRsp) error
	Recv() (*SLMplsIlmGetMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmGetStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Send(m *SLMplsIlmGetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Recv() (*SLMplsIlmGetMsg, error) {
	m := new(SLMplsIlmGetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLMplsOper_ServiceDesc is the grpc.ServiceDesc for SLMplsOper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SLMplsOper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLMplsOper",
	HandlerType: (*SLMplsOperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLMplsRegOp",
			Handler:    _SLMplsOper_SLMplsRegOp_Handler,
		},
		{
			MethodName: "SLMplsGet",
			Handler:    _SLMplsOper_SLMplsGet_Handler,
		},
		{
			MethodName: "SLMplsGetStats",
			Handler:    _SLMplsOper_SLMplsGetStats_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockOp",
			Handler:    _SLMplsOper_SLMplsLabelBlockOp_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockGet",
			Handler:    _SLMplsOper_SLMplsLabelBlockGet_Handler,
		},
		{
			MethodName: "SLMplsIlmOp",
			Handler:    _SLMplsOper_SLMplsIlmOp_Handler,
		},
		{
			MethodName: "SLMplsIlmGet",
			Handler:    _SLMplsOper_SLMplsIlmGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLMplsIlmOpStream",
			Handler:       _SLMplsOper_SLMplsIlmOpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLMplsIlmGetStream",
			Handler:       _SLMplsOper_SLMplsIlmGetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_mpls.proto",
}
