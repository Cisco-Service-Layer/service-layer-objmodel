// @file
// @brief Client RPC proto file for Policy RPCs.
// Declares calls for adding, deleting, updating the policies
// and apply, unapply policies from interfaces.
//
// ----------------------------------------------------------------
//  Copyright (c) 2024 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v3.18.3
// source: sl_policy.proto

package service_layer

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Policy Object Operations.
type SLPolicyObjectOp int32

const (
	// Reserved. 0x0
	SLPolicyObjectOp_SL_OBJOP_POLICY_RESERVED SLPolicyObjectOp = 0
	// Policy Add. 0x1
	SLPolicyObjectOp_SL_OBJOP_POLICY_ADD SLPolicyObjectOp = 1
	// Policy Delete. 0x2
	SLPolicyObjectOp_SL_OBJOP_POLICY_DELETE SLPolicyObjectOp = 2
	// Rule Add. 0x3
	SLPolicyObjectOp_SL_OBJOP_RULE_ADD SLPolicyObjectOp = 3
	// Rule Delete. 0x4
	SLPolicyObjectOp_SL_OBJOP_RULE_DELETE SLPolicyObjectOp = 4
	// Policy Apply. 0x5
	SLPolicyObjectOp_SL_OBJOP_POLICY_APPLY SLPolicyObjectOp = 5
	// Policy UnApply. 0x6
	SLPolicyObjectOp_SL_OBJOP_POLICY_UNAPPLY SLPolicyObjectOp = 6
)

// Enum value maps for SLPolicyObjectOp.
var (
	SLPolicyObjectOp_name = map[int32]string{
		0: "SL_OBJOP_POLICY_RESERVED",
		1: "SL_OBJOP_POLICY_ADD",
		2: "SL_OBJOP_POLICY_DELETE",
		3: "SL_OBJOP_RULE_ADD",
		4: "SL_OBJOP_RULE_DELETE",
		5: "SL_OBJOP_POLICY_APPLY",
		6: "SL_OBJOP_POLICY_UNAPPLY",
	}
	SLPolicyObjectOp_value = map[string]int32{
		"SL_OBJOP_POLICY_RESERVED": 0,
		"SL_OBJOP_POLICY_ADD":      1,
		"SL_OBJOP_POLICY_DELETE":   2,
		"SL_OBJOP_RULE_ADD":        3,
		"SL_OBJOP_RULE_DELETE":     4,
		"SL_OBJOP_POLICY_APPLY":    5,
		"SL_OBJOP_POLICY_UNAPPLY":  6,
	}
)

func (x SLPolicyObjectOp) Enum() *SLPolicyObjectOp {
	p := new(SLPolicyObjectOp)
	*p = x
	return p
}

func (x SLPolicyObjectOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLPolicyObjectOp) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_policy_proto_enumTypes[0].Descriptor()
}

func (SLPolicyObjectOp) Type() protoreflect.EnumType {
	return &file_sl_policy_proto_enumTypes[0]
}

func (x SLPolicyObjectOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLPolicyObjectOp.Descriptor instead.
func (SLPolicyObjectOp) EnumDescriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{0}
}

// Policy types supported
type SLPolicyType int32

const (
	// Reserved, 0x0
	SLPolicyType_SL_PM_PTYPE_RESERVED SLPolicyType = 0
	// PBR type policy
	SLPolicyType_SL_PM_PTYPE_PBR SLPolicyType = 1
)

// Enum value maps for SLPolicyType.
var (
	SLPolicyType_name = map[int32]string{
		0: "SL_PM_PTYPE_RESERVED",
		1: "SL_PM_PTYPE_PBR",
	}
	SLPolicyType_value = map[string]int32{
		"SL_PM_PTYPE_RESERVED": 0,
		"SL_PM_PTYPE_PBR":      1,
	}
)

func (x SLPolicyType) Enum() *SLPolicyType {
	p := new(SLPolicyType)
	*p = x
	return p
}

func (x SLPolicyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLPolicyType) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_policy_proto_enumTypes[1].Descriptor()
}

func (SLPolicyType) Type() protoreflect.EnumType {
	return &file_sl_policy_proto_enumTypes[1]
}

func (x SLPolicyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLPolicyType.Descriptor instead.
func (SLPolicyType) EnumDescriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{1}
}

// Direction of policy apply
// Only ingress supported for pbr policies
type SLApplyDirection int32

const (
	// Reserved, 0x0
	SLApplyDirection_SL_APPLY_TYPE_RESERVED SLApplyDirection = 0
	// Ingress direction, 0x1
	SLApplyDirection_SL_APPLY_DIRECTION_INGRESS SLApplyDirection = 1
)

// Enum value maps for SLApplyDirection.
var (
	SLApplyDirection_name = map[int32]string{
		0: "SL_APPLY_TYPE_RESERVED",
		1: "SL_APPLY_DIRECTION_INGRESS",
	}
	SLApplyDirection_value = map[string]int32{
		"SL_APPLY_TYPE_RESERVED":     0,
		"SL_APPLY_DIRECTION_INGRESS": 1,
	}
)

func (x SLApplyDirection) Enum() *SLApplyDirection {
	p := new(SLApplyDirection)
	*p = x
	return p
}

func (x SLApplyDirection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLApplyDirection) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_policy_proto_enumTypes[2].Descriptor()
}

func (SLApplyDirection) Type() protoreflect.EnumType {
	return &file_sl_policy_proto_enumTypes[2]
}

func (x SLApplyDirection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLApplyDirection.Descriptor instead.
func (SLApplyDirection) EnumDescriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{2}
}

type SLPolicyOpMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy object operation
	Oper SLPolicyObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLPolicyObjectOp" json:"Oper,omitempty"`
	// Unique OperationID sent by the client
	// to correlate the responses. Operation Id
	// should be monotonically increasing for
	// the life of the client.
	OperationID uint64 `protobuf:"varint,2,opt,name=OperationID,proto3" json:"OperationID,omitempty"`
	// List of policy entries
	Policies []*SLPolicyEntry `protobuf:"bytes,3,rep,name=Policies,proto3" json:"Policies,omitempty"`
}

func (x *SLPolicyOpMsg) Reset() {
	*x = SLPolicyOpMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyOpMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyOpMsg) ProtoMessage() {}

func (x *SLPolicyOpMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyOpMsg.ProtoReflect.Descriptor instead.
func (*SLPolicyOpMsg) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{0}
}

func (x *SLPolicyOpMsg) GetOper() SLPolicyObjectOp {
	if x != nil {
		return x.Oper
	}
	return SLPolicyObjectOp_SL_OBJOP_POLICY_RESERVED
}

func (x *SLPolicyOpMsg) GetOperationID() uint64 {
	if x != nil {
		return x.OperationID
	}
	return 0
}

func (x *SLPolicyOpMsg) GetPolicies() []*SLPolicyEntry {
	if x != nil {
		return x.Policies
	}
	return nil
}

// Policy-map object
type SLPolicyEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy unique key identifier
	Key *SLPolicyKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Types that are assignable to SLPolicyObjectList:
	//
	//	*SLPolicyEntry_Rules
	//	*SLPolicyEntry_Intfs
	SLPolicyObjectList isSLPolicyEntry_SLPolicyObjectList `protobuf_oneof:"SLPolicyObjectList"`
}

func (x *SLPolicyEntry) Reset() {
	*x = SLPolicyEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyEntry) ProtoMessage() {}

func (x *SLPolicyEntry) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyEntry.ProtoReflect.Descriptor instead.
func (*SLPolicyEntry) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{1}
}

func (x *SLPolicyEntry) GetKey() *SLPolicyKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (m *SLPolicyEntry) GetSLPolicyObjectList() isSLPolicyEntry_SLPolicyObjectList {
	if m != nil {
		return m.SLPolicyObjectList
	}
	return nil
}

func (x *SLPolicyEntry) GetRules() *PolicyRuleList {
	if x, ok := x.GetSLPolicyObjectList().(*SLPolicyEntry_Rules); ok {
		return x.Rules
	}
	return nil
}

func (x *SLPolicyEntry) GetIntfs() *PolicyIntfList {
	if x, ok := x.GetSLPolicyObjectList().(*SLPolicyEntry_Intfs); ok {
		return x.Intfs
	}
	return nil
}

type isSLPolicyEntry_SLPolicyObjectList interface {
	isSLPolicyEntry_SLPolicyObjectList()
}

type SLPolicyEntry_Rules struct {
	Rules *PolicyRuleList `protobuf:"bytes,2,opt,name=Rules,proto3,oneof"`
}

type SLPolicyEntry_Intfs struct {
	Intfs *PolicyIntfList `protobuf:"bytes,3,opt,name=Intfs,proto3,oneof"`
}

func (*SLPolicyEntry_Rules) isSLPolicyEntry_SLPolicyObjectList() {}

func (*SLPolicyEntry_Intfs) isSLPolicyEntry_SLPolicyObjectList() {}

// List of rules
type PolicyRuleList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PolicyRules []*SLPolicyRule `protobuf:"bytes,1,rep,name=PolicyRules,proto3" json:"PolicyRules,omitempty"`
}

func (x *PolicyRuleList) Reset() {
	*x = PolicyRuleList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PolicyRuleList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyRuleList) ProtoMessage() {}

func (x *PolicyRuleList) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyRuleList.ProtoReflect.Descriptor instead.
func (*PolicyRuleList) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{2}
}

func (x *PolicyRuleList) GetPolicyRules() []*SLPolicyRule {
	if x != nil {
		return x.PolicyRules
	}
	return nil
}

// List of interfaces
type PolicyIntfList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PolicyIntfs []*SLPolicyIntf `protobuf:"bytes,1,rep,name=PolicyIntfs,proto3" json:"PolicyIntfs,omitempty"`
}

func (x *PolicyIntfList) Reset() {
	*x = PolicyIntfList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PolicyIntfList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyIntfList) ProtoMessage() {}

func (x *PolicyIntfList) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyIntfList.ProtoReflect.Descriptor instead.
func (*PolicyIntfList) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{3}
}

func (x *PolicyIntfList) GetPolicyIntfs() []*SLPolicyIntf {
	if x != nil {
		return x.PolicyIntfs
	}
	return nil
}

type SLPolicyKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name of the policy
	PolicyName string `protobuf:"bytes,1,opt,name=PolicyName,proto3" json:"PolicyName,omitempty"`
	// PolicyType
	Type SLPolicyType `protobuf:"varint,2,opt,name=Type,proto3,enum=service_layer.SLPolicyType" json:"Type,omitempty"`
}

func (x *SLPolicyKey) Reset() {
	*x = SLPolicyKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyKey) ProtoMessage() {}

func (x *SLPolicyKey) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyKey.ProtoReflect.Descriptor instead.
func (*SLPolicyKey) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{4}
}

func (x *SLPolicyKey) GetPolicyName() string {
	if x != nil {
		return x.PolicyName
	}
	return ""
}

func (x *SLPolicyKey) GetType() SLPolicyType {
	if x != nil {
		return x.Type
	}
	return SLPolicyType_SL_PM_PTYPE_RESERVED
}

// Each rule in a policy is associated with a
// Rule name - that identifies a rule
// Priority - priority of the rule within the policy
// Match - Contains at least one or more match criteria.
// Packet is a match if ALL the fields in the packet match
// the criteria. Atleast one rule MUST be present for
// the packet to match.
// Action - Contains at least one or more action. Action
// applied on the packet that matches the rule. Atleast
// one action MUST be present for the match criteria
// under a rule.
type SLPolicyRule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name of the rule referenced in the policy object
	RuleName string `protobuf:"bytes,1,opt,name=RuleName,proto3" json:"RuleName,omitempty"`
	// Priority of the rule within the policy
	PriorityStr string `protobuf:"bytes,2,opt,name=PriorityStr,proto3" json:"PriorityStr,omitempty"`
	// Defines the match criteria under this rule
	Match *SLRuleMatch `protobuf:"bytes,3,opt,name=Match,proto3" json:"Match,omitempty"`
	// Action associated with this rule
	Action *SLRuleAction `protobuf:"bytes,4,opt,name=Action,proto3" json:"Action,omitempty"`
}

func (x *SLPolicyRule) Reset() {
	*x = SLPolicyRule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyRule) ProtoMessage() {}

func (x *SLPolicyRule) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyRule.ProtoReflect.Descriptor instead.
func (*SLPolicyRule) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{5}
}

func (x *SLPolicyRule) GetRuleName() string {
	if x != nil {
		return x.RuleName
	}
	return ""
}

func (x *SLPolicyRule) GetPriorityStr() string {
	if x != nil {
		return x.PriorityStr
	}
	return ""
}

func (x *SLPolicyRule) GetMatch() *SLRuleMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *SLPolicyRule) GetAction() *SLRuleAction {
	if x != nil {
		return x.Action
	}
	return nil
}

// Attributes to match within a rule in a policy.
// All specified values in the message MUST be
// matched by the packet for application of the
// specified action.
type SLRuleMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Encapsulate all different values of dscp supported
	Dscp *SLDscpMatch `protobuf:"bytes,1,opt,name=Dscp,proto3" json:"Dscp,omitempty"`
	// Match on PathGroup Identifier
	// The path group belongs to the same VRF as the policy entry.
	PathGroup *SLPathGroupRefKey `protobuf:"bytes,2,opt,name=PathGroup,proto3" json:"PathGroup,omitempty"`
}

func (x *SLRuleMatch) Reset() {
	*x = SLRuleMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRuleMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRuleMatch) ProtoMessage() {}

func (x *SLRuleMatch) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRuleMatch.ProtoReflect.Descriptor instead.
func (*SLRuleMatch) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{6}
}

func (x *SLRuleMatch) GetDscp() *SLDscpMatch {
	if x != nil {
		return x.Dscp
	}
	return nil
}

func (x *SLRuleMatch) GetPathGroup() *SLPathGroupRefKey {
	if x != nil {
		return x.PathGroup
	}
	return nil
}

// Dscp match type
// Oneof is used here for future extensibility
type SLDscpMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Dscp:
	//
	//	*SLDscpMatch_DscpValue
	Dscp isSLDscpMatch_Dscp `protobuf_oneof:"Dscp"`
}

func (x *SLDscpMatch) Reset() {
	*x = SLDscpMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLDscpMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLDscpMatch) ProtoMessage() {}

func (x *SLDscpMatch) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLDscpMatch.ProtoReflect.Descriptor instead.
func (*SLDscpMatch) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{7}
}

func (m *SLDscpMatch) GetDscp() isSLDscpMatch_Dscp {
	if m != nil {
		return m.Dscp
	}
	return nil
}

func (x *SLDscpMatch) GetDscpValue() uint32 {
	if x, ok := x.GetDscp().(*SLDscpMatch_DscpValue); ok {
		return x.DscpValue
	}
	return 0
}

type isSLDscpMatch_Dscp interface {
	isSLDscpMatch_Dscp()
}

type SLDscpMatch_DscpValue struct {
	// Single dscp value
	DscpValue uint32 `protobuf:"varint,1,opt,name=DscpValue,proto3,oneof"`
}

func (*SLDscpMatch_DscpValue) isSLDscpMatch_Dscp() {}

// Action applied on the packet that matches a rule.
type SLRuleAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// PathGroup where packet will be forwarded.
	// The path group belongs to the same VRF as the policy entry.
	PathGroup *SLPathGroupRefKey `protobuf:"bytes,1,opt,name=PathGroup,proto3" json:"PathGroup,omitempty"`
	// Enable Stats counter
	EnableStatsCounter bool `protobuf:"varint,2,opt,name=EnableStatsCounter,proto3" json:"EnableStatsCounter,omitempty"`
}

func (x *SLRuleAction) Reset() {
	*x = SLRuleAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRuleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRuleAction) ProtoMessage() {}

func (x *SLRuleAction) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRuleAction.ProtoReflect.Descriptor instead.
func (*SLRuleAction) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{8}
}

func (x *SLRuleAction) GetPathGroup() *SLPathGroupRefKey {
	if x != nil {
		return x.PathGroup
	}
	return nil
}

func (x *SLRuleAction) GetEnableStatsCounter() bool {
	if x != nil {
		return x.EnableStatsCounter
	}
	return false
}

// Policy intf object
type SLPolicyIntf struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Interface on which the policy is applied/unapplied
	Key *SLInterface `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Policy Apply Direction
	IntfDir SLApplyDirection `protobuf:"varint,2,opt,name=IntfDir,proto3,enum=service_layer.SLApplyDirection" json:"IntfDir,omitempty"`
}

func (x *SLPolicyIntf) Reset() {
	*x = SLPolicyIntf{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyIntf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyIntf) ProtoMessage() {}

func (x *SLPolicyIntf) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyIntf.ProtoReflect.Descriptor instead.
func (*SLPolicyIntf) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{9}
}

func (x *SLPolicyIntf) GetKey() *SLInterface {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLPolicyIntf) GetIntfDir() SLApplyDirection {
	if x != nil {
		return x.IntfDir
	}
	return SLApplyDirection_SL_APPLY_TYPE_RESERVED
}

type SLPolicyOpRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy object operation for which the response is sent
	OperationID uint64         `protobuf:"varint,1,opt,name=OperationID,proto3" json:"OperationID,omitempty"`
	Results     []*SLPolicyRes `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLPolicyOpRsp) Reset() {
	*x = SLPolicyOpRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyOpRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyOpRsp) ProtoMessage() {}

func (x *SLPolicyOpRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyOpRsp.ProtoReflect.Descriptor instead.
func (*SLPolicyOpRsp) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{10}
}

func (x *SLPolicyOpRsp) GetOperationID() uint64 {
	if x != nil {
		return x.OperationID
	}
	return 0
}

func (x *SLPolicyOpRsp) GetResults() []*SLPolicyRes {
	if x != nil {
		return x.Results
	}
	return nil
}

type SLPolicyRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy unique key identifier
	Key *SLPolicyKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Types that are assignable to SLPolicyOpStatus:
	//
	//	*SLPolicyRes_PolicyStatus
	//	*SLPolicyRes_RulesStatus
	//	*SLPolicyRes_IntfStatus
	SLPolicyOpStatus isSLPolicyRes_SLPolicyOpStatus `protobuf_oneof:"SLPolicyOpStatus"`
}

func (x *SLPolicyRes) Reset() {
	*x = SLPolicyRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyRes) ProtoMessage() {}

func (x *SLPolicyRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyRes.ProtoReflect.Descriptor instead.
func (*SLPolicyRes) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{11}
}

func (x *SLPolicyRes) GetKey() *SLPolicyKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (m *SLPolicyRes) GetSLPolicyOpStatus() isSLPolicyRes_SLPolicyOpStatus {
	if m != nil {
		return m.SLPolicyOpStatus
	}
	return nil
}

func (x *SLPolicyRes) GetPolicyStatus() *SLErrorStatus {
	if x, ok := x.GetSLPolicyOpStatus().(*SLPolicyRes_PolicyStatus); ok {
		return x.PolicyStatus
	}
	return nil
}

func (x *SLPolicyRes) GetRulesStatus() *SLPolicyRuleStatusList {
	if x, ok := x.GetSLPolicyOpStatus().(*SLPolicyRes_RulesStatus); ok {
		return x.RulesStatus
	}
	return nil
}

func (x *SLPolicyRes) GetIntfStatus() *SLPolicyIntfStatusList {
	if x, ok := x.GetSLPolicyOpStatus().(*SLPolicyRes_IntfStatus); ok {
		return x.IntfStatus
	}
	return nil
}

type isSLPolicyRes_SLPolicyOpStatus interface {
	isSLPolicyRes_SLPolicyOpStatus()
}

type SLPolicyRes_PolicyStatus struct {
	// Status of policy level operations
	// like policy add and policy delete
	PolicyStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=PolicyStatus,proto3,oneof"`
}

type SLPolicyRes_RulesStatus struct {
	// Status of rule operations on a policy
	RulesStatus *SLPolicyRuleStatusList `protobuf:"bytes,3,opt,name=RulesStatus,proto3,oneof"`
}

type SLPolicyRes_IntfStatus struct {
	// Status of interface operations on a
	// policy
	IntfStatus *SLPolicyIntfStatusList `protobuf:"bytes,4,opt,name=IntfStatus,proto3,oneof"`
}

func (*SLPolicyRes_PolicyStatus) isSLPolicyRes_SLPolicyOpStatus() {}

func (*SLPolicyRes_RulesStatus) isSLPolicyRes_SLPolicyOpStatus() {}

func (*SLPolicyRes_IntfStatus) isSLPolicyRes_SLPolicyOpStatus() {}

type SLPolicyRuleStatusList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RulesStatus []*SLPolicyRuleStatus `protobuf:"bytes,1,rep,name=RulesStatus,proto3" json:"RulesStatus,omitempty"`
}

func (x *SLPolicyRuleStatusList) Reset() {
	*x = SLPolicyRuleStatusList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyRuleStatusList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyRuleStatusList) ProtoMessage() {}

func (x *SLPolicyRuleStatusList) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyRuleStatusList.ProtoReflect.Descriptor instead.
func (*SLPolicyRuleStatusList) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{12}
}

func (x *SLPolicyRuleStatusList) GetRulesStatus() []*SLPolicyRuleStatus {
	if x != nil {
		return x.RulesStatus
	}
	return nil
}

type SLPolicyIntfStatusList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	IntfsStatus []*SLPolicyIntfStatus `protobuf:"bytes,1,rep,name=IntfsStatus,proto3" json:"IntfsStatus,omitempty"`
}

func (x *SLPolicyIntfStatusList) Reset() {
	*x = SLPolicyIntfStatusList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyIntfStatusList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyIntfStatusList) ProtoMessage() {}

func (x *SLPolicyIntfStatusList) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyIntfStatusList.ProtoReflect.Descriptor instead.
func (*SLPolicyIntfStatusList) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{13}
}

func (x *SLPolicyIntfStatusList) GetIntfsStatus() []*SLPolicyIntfStatus {
	if x != nil {
		return x.IntfsStatus
	}
	return nil
}

type SLPolicyRuleStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RuleName string         `protobuf:"bytes,1,opt,name=RuleName,proto3" json:"RuleName,omitempty"`
	Status   *SLErrorStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (x *SLPolicyRuleStatus) Reset() {
	*x = SLPolicyRuleStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyRuleStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyRuleStatus) ProtoMessage() {}

func (x *SLPolicyRuleStatus) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyRuleStatus.ProtoReflect.Descriptor instead.
func (*SLPolicyRuleStatus) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{14}
}

func (x *SLPolicyRuleStatus) GetRuleName() string {
	if x != nil {
		return x.RuleName
	}
	return ""
}

func (x *SLPolicyRuleStatus) GetStatus() *SLErrorStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type SLPolicyIntfStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Intf   *SLInterface   `protobuf:"bytes,1,opt,name=Intf,proto3" json:"Intf,omitempty"`
	Status *SLErrorStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (x *SLPolicyIntfStatus) Reset() {
	*x = SLPolicyIntfStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyIntfStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyIntfStatus) ProtoMessage() {}

func (x *SLPolicyIntfStatus) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyIntfStatus.ProtoReflect.Descriptor instead.
func (*SLPolicyIntfStatus) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{15}
}

func (x *SLPolicyIntfStatus) GetIntf() *SLInterface {
	if x != nil {
		return x.Intf
	}
	return nil
}

func (x *SLPolicyIntfStatus) GetStatus() *SLErrorStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// Get all the policies and the interfaces where it is applied
type SLPolicyGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLPolicyGetMsg) Reset() {
	*x = SLPolicyGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyGetMsg) ProtoMessage() {}

func (x *SLPolicyGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyGetMsg.ProtoReflect.Descriptor instead.
func (*SLPolicyGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{16}
}

// List of policies, rules and the interfaces where it is applied
type SLPolicyInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Policy unique key identifier
	Key *SLPolicyKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// List of rules
	PolicyRules []*SLPolicyRule `protobuf:"bytes,2,rep,name=PolicyRules,proto3" json:"PolicyRules,omitempty"`
	// List of interfaces
	PolicyIntfs []*SLPolicyIntf `protobuf:"bytes,3,rep,name=PolicyIntfs,proto3" json:"PolicyIntfs,omitempty"`
}

func (x *SLPolicyInfo) Reset() {
	*x = SLPolicyInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyInfo) ProtoMessage() {}

func (x *SLPolicyInfo) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyInfo.ProtoReflect.Descriptor instead.
func (*SLPolicyInfo) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{17}
}

func (x *SLPolicyInfo) GetKey() *SLPolicyKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLPolicyInfo) GetPolicyRules() []*SLPolicyRule {
	if x != nil {
		return x.PolicyRules
	}
	return nil
}

func (x *SLPolicyInfo) GetPolicyIntfs() []*SLPolicyIntf {
	if x != nil {
		return x.PolicyIntfs
	}
	return nil
}

type SLPolicyGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Status of the policy get operation
	PolicyCfgOpStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=PolicyCfgOpStatus,proto3" json:"PolicyCfgOpStatus,omitempty"`
	// List of Policy info. It will be empty incase of failure
	PolicyObjs []*SLPolicyInfo `protobuf:"bytes,2,rep,name=PolicyObjs,proto3" json:"PolicyObjs,omitempty"`
}

func (x *SLPolicyGetMsgRsp) Reset() {
	*x = SLPolicyGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyGetMsgRsp) ProtoMessage() {}

func (x *SLPolicyGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLPolicyGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{18}
}

func (x *SLPolicyGetMsgRsp) GetPolicyCfgOpStatus() *SLErrorStatus {
	if x != nil {
		return x.PolicyCfgOpStatus
	}
	return nil
}

func (x *SLPolicyGetMsgRsp) GetPolicyObjs() []*SLPolicyInfo {
	if x != nil {
		return x.PolicyObjs
	}
	return nil
}

// Policy Global Get Capabilities Message
type SLPolicyGlobalGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLPolicyGlobalGetMsg) Reset() {
	*x = SLPolicyGlobalGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyGlobalGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyGlobalGetMsg) ProtoMessage() {}

func (x *SLPolicyGlobalGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyGlobalGetMsg.ProtoReflect.Descriptor instead.
func (*SLPolicyGlobalGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{19}
}

// Policy Global Get Capabilities Message Response
type SLPolicyGlobalGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Max number of policies supported
	MaxPolicies uint32 `protobuf:"varint,2,opt,name=MaxPolicies,proto3" json:"MaxPolicies,omitempty"`
	// Max Rules supported within a policy
	MaxRules uint32 `protobuf:"varint,3,opt,name=MaxRules,proto3" json:"MaxRules,omitempty"`
}

func (x *SLPolicyGlobalGetMsgRsp) Reset() {
	*x = SLPolicyGlobalGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_policy_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLPolicyGlobalGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLPolicyGlobalGetMsgRsp) ProtoMessage() {}

func (x *SLPolicyGlobalGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_policy_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLPolicyGlobalGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLPolicyGlobalGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_policy_proto_rawDescGZIP(), []int{20}
}

func (x *SLPolicyGlobalGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLPolicyGlobalGetMsgRsp) GetMaxPolicies() uint32 {
	if x != nil {
		return x.MaxPolicies
	}
	return 0
}

func (x *SLPolicyGlobalGetMsgRsp) GetMaxRules() uint32 {
	if x != nil {
		return x.MaxRules
	}
	return 0
}

var File_sl_policy_proto protoreflect.FileDescriptor

var file_sl_policy_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x73, 0x6c, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x1a, 0x15, 0x73, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa0, 0x01, 0x0a, 0x0d, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x4d, 0x73, 0x67, 0x12, 0x33, 0x0a, 0x04, 0x4f, 0x70, 0x65,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x20,
	0x0a, 0x0b, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0b, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44,
	0x12, 0x38, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x22, 0xc1, 0x01, 0x0a, 0x0d, 0x53,
	0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x2c, 0x0a, 0x03,
	0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x35, 0x0a, 0x05, 0x52, 0x75,
	0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x75, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x05, 0x52, 0x75, 0x6c, 0x65,
	0x73, 0x12, 0x35, 0x0a, 0x05, 0x49, 0x6e, 0x74, 0x66, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x4c, 0x69, 0x73, 0x74, 0x48,
	0x00, 0x52, 0x05, 0x49, 0x6e, 0x74, 0x66, 0x73, 0x42, 0x14, 0x0a, 0x12, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x22, 0x4f,
	0x0a, 0x0e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74,
	0x12, 0x3d, 0x0a, 0x0b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75,
	0x6c, 0x65, 0x52, 0x0b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22,
	0x4f, 0x0a, 0x0e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x4c, 0x69, 0x73,
	0x74, 0x12, 0x3d, 0x0a, 0x0b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,
	0x6e, 0x74, 0x66, 0x52, 0x0b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x73,
	0x22, 0x5e, 0x0a, 0x0b, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4b, 0x65, 0x79, 0x12,
	0x1e, 0x0a, 0x0a, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0a, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x2f, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x54, 0x79, 0x70, 0x65,
	0x22, 0xb3, 0x01, 0x0a, 0x0c, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c,
	0x65, 0x12, 0x1a, 0x0a, 0x08, 0x52, 0x75, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x52, 0x75, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a,
	0x0b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x53, 0x74, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x53, 0x74, 0x72, 0x12,
	0x30, 0x0a, 0x05, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x52, 0x75, 0x6c, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x05, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x12, 0x33, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7d, 0x0a, 0x0b, 0x53, 0x4c, 0x52, 0x75, 0x6c, 0x65,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x2e, 0x0a, 0x04, 0x44, 0x73, 0x63, 0x70, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x44, 0x73, 0x63, 0x70, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52,
	0x04, 0x44, 0x73, 0x63, 0x70, 0x12, 0x3e, 0x0a, 0x09, 0x50, 0x61, 0x74, 0x68, 0x47, 0x72, 0x6f,
	0x75, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x61, 0x74, 0x68, 0x47,
	0x72, 0x6f, 0x75, 0x70, 0x52, 0x65, 0x66, 0x4b, 0x65, 0x79, 0x52, 0x09, 0x50, 0x61, 0x74, 0x68,
	0x47, 0x72, 0x6f, 0x75, 0x70, 0x22, 0x35, 0x0a, 0x0b, 0x53, 0x4c, 0x44, 0x73, 0x63, 0x70, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x12, 0x1e, 0x0a, 0x09, 0x44, 0x73, 0x63, 0x70, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x09, 0x44, 0x73, 0x63, 0x70, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x42, 0x06, 0x0a, 0x04, 0x44, 0x73, 0x63, 0x70, 0x22, 0x7e, 0x0a, 0x0c,
	0x53, 0x4c, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3e, 0x0a, 0x09,
	0x50, 0x61, 0x74, 0x68, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x20, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x50, 0x61, 0x74, 0x68, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x52, 0x65, 0x66, 0x4b, 0x65,
	0x79, 0x52, 0x09, 0x50, 0x61, 0x74, 0x68, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x2e, 0x0a, 0x12,
	0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,
	0x53, 0x74, 0x61, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x77, 0x0a, 0x0c,
	0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x12, 0x2c, 0x0a, 0x03,
	0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x66, 0x61, 0x63, 0x65, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x39, 0x0a, 0x07, 0x49, 0x6e,
	0x74, 0x66, 0x44, 0x69, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x41, 0x70,
	0x70, 0x6c, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x49, 0x6e,
	0x74, 0x66, 0x44, 0x69, 0x72, 0x22, 0x67, 0x0a, 0x0d, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x4f, 0x70, 0x52, 0x73, 0x70, 0x12, 0x20, 0x0a, 0x0b, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x4f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x12, 0x34, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75,
	0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x65, 0x73, 0x52, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0xa7,
	0x02, 0x0a, 0x0b, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x73, 0x12, 0x2c,
	0x0a, 0x03, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x42, 0x0a, 0x0c,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x48, 0x00, 0x52, 0x0c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x49, 0x0a, 0x0b, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75,
	0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0b,
	0x52, 0x75, 0x6c, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x47, 0x0a, 0x0a, 0x49,
	0x6e, 0x74, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x49, 0x6e, 0x74, 0x66, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x42, 0x12, 0x0a, 0x10, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x4f, 0x70, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x5d, 0x0a, 0x16, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4c, 0x69,
	0x73, 0x74, 0x12, 0x43, 0x0a, 0x0b, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0b, 0x52, 0x75, 0x6c, 0x65,
	0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x5d, 0x0a, 0x16, 0x53, 0x4c, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4c, 0x69, 0x73,
	0x74, 0x12, 0x43, 0x0a, 0x0b, 0x49, 0x6e, 0x74, 0x66, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,
	0x6e, 0x74, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0b, 0x49, 0x6e, 0x74, 0x66, 0x73,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x66, 0x0a, 0x12, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08,
	0x52, 0x75, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x52, 0x75, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x7a,
	0x0a, 0x12, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x04, 0x49, 0x6e, 0x74, 0x66, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x52, 0x04,
	0x49, 0x6e, 0x74, 0x66, 0x12, 0x34, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x10, 0x0a, 0x0e, 0x53, 0x4c,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x22, 0xba, 0x01, 0x0a,
	0x0c, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a,
	0x03, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x3d, 0x0a, 0x0b, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0b, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x3d, 0x0a, 0x0b, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x52, 0x0b, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x74, 0x66, 0x73, 0x22, 0x9c, 0x01, 0x0a, 0x11, 0x53, 0x4c,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12,
	0x4a, 0x0a, 0x11, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x43, 0x66, 0x67, 0x4f, 0x70, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72,
	0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x11, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x43, 0x66, 0x67, 0x4f, 0x70, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3b, 0x0a, 0x0a, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x62, 0x6a, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0a, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x4f, 0x62, 0x6a, 0x73, 0x22, 0x16, 0x0a, 0x14, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67,
	0x22, 0x93, 0x01, 0x0a, 0x17, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x6c, 0x6f,
	0x62, 0x61, 0x6c, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x3a, 0x0a, 0x09,
	0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x4d, 0x61, 0x78, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x4d,
	0x61, 0x78, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x4d, 0x61,
	0x78, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x4d, 0x61,
	0x78, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x2a, 0xce, 0x01, 0x0a, 0x10, 0x53, 0x4c, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x12, 0x1c, 0x0a, 0x18, 0x53,
	0x4c, 0x5f, 0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x52,
	0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x44, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x53, 0x4c, 0x5f,
	0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x41, 0x44, 0x44,
	0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x53, 0x4c, 0x5f, 0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x50,
	0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x02, 0x12, 0x15,
	0x0a, 0x11, 0x53, 0x4c, 0x5f, 0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x52, 0x55, 0x4c, 0x45, 0x5f,
	0x41, 0x44, 0x44, 0x10, 0x03, 0x12, 0x18, 0x0a, 0x14, 0x53, 0x4c, 0x5f, 0x4f, 0x42, 0x4a, 0x4f,
	0x50, 0x5f, 0x52, 0x55, 0x4c, 0x45, 0x5f, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x04, 0x12,
	0x19, 0x0a, 0x15, 0x53, 0x4c, 0x5f, 0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x50, 0x4f, 0x4c, 0x49,
	0x43, 0x59, 0x5f, 0x41, 0x50, 0x50, 0x4c, 0x59, 0x10, 0x05, 0x12, 0x1b, 0x0a, 0x17, 0x53, 0x4c,
	0x5f, 0x4f, 0x42, 0x4a, 0x4f, 0x50, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x55, 0x4e,
	0x41, 0x50, 0x50, 0x4c, 0x59, 0x10, 0x06, 0x2a, 0x3d, 0x0a, 0x0c, 0x53, 0x4c, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x14, 0x53, 0x4c, 0x5f, 0x50, 0x4d,
	0x5f, 0x50, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x44, 0x10,
	0x00, 0x12, 0x13, 0x0a, 0x0f, 0x53, 0x4c, 0x5f, 0x50, 0x4d, 0x5f, 0x50, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x50, 0x42, 0x52, 0x10, 0x01, 0x2a, 0x4e, 0x0a, 0x10, 0x53, 0x4c, 0x41, 0x70, 0x70, 0x6c,
	0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x16, 0x53, 0x4c,
	0x5f, 0x41, 0x50, 0x50, 0x4c, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x45,
	0x52, 0x56, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1e, 0x0a, 0x1a, 0x53, 0x4c, 0x5f, 0x41, 0x50, 0x50,
	0x4c, 0x59, 0x5f, 0x44, 0x49, 0x52, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x49, 0x4e, 0x47,
	0x52, 0x45, 0x53, 0x53, 0x10, 0x01, 0x32, 0x88, 0x02, 0x0a, 0x08, 0x53, 0x4c, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x12, 0x48, 0x0a, 0x0a, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f,
	0x70, 0x12, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x4d, 0x73, 0x67, 0x1a,
	0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x52, 0x73, 0x70, 0x12, 0x50, 0x0a,
	0x0b, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x65, 0x74, 0x12, 0x1d, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x20, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x30, 0x01, 0x12,
	0x60, 0x0a, 0x11, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x6c, 0x6f, 0x62, 0x61,
	0x6c, 0x47, 0x65, 0x74, 0x12, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x47, 0x6c, 0x6f,
	0x62, 0x61, 0x6c, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x26, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73,
	0x70, 0x42, 0x51, 0x5a, 0x4f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x43, 0x69, 0x73, 0x63, 0x6f, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2d, 0x6f, 0x62, 0x6a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x3b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_policy_proto_rawDescOnce sync.Once
	file_sl_policy_proto_rawDescData = file_sl_policy_proto_rawDesc
)

func file_sl_policy_proto_rawDescGZIP() []byte {
	file_sl_policy_proto_rawDescOnce.Do(func() {
		file_sl_policy_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_policy_proto_rawDescData)
	})
	return file_sl_policy_proto_rawDescData
}

var file_sl_policy_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_sl_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_sl_policy_proto_goTypes = []interface{}{
	(SLPolicyObjectOp)(0),           // 0: service_layer.SLPolicyObjectOp
	(SLPolicyType)(0),               // 1: service_layer.SLPolicyType
	(SLApplyDirection)(0),           // 2: service_layer.SLApplyDirection
	(*SLPolicyOpMsg)(nil),           // 3: service_layer.SLPolicyOpMsg
	(*SLPolicyEntry)(nil),           // 4: service_layer.SLPolicyEntry
	(*PolicyRuleList)(nil),          // 5: service_layer.PolicyRuleList
	(*PolicyIntfList)(nil),          // 6: service_layer.PolicyIntfList
	(*SLPolicyKey)(nil),             // 7: service_layer.SLPolicyKey
	(*SLPolicyRule)(nil),            // 8: service_layer.SLPolicyRule
	(*SLRuleMatch)(nil),             // 9: service_layer.SLRuleMatch
	(*SLDscpMatch)(nil),             // 10: service_layer.SLDscpMatch
	(*SLRuleAction)(nil),            // 11: service_layer.SLRuleAction
	(*SLPolicyIntf)(nil),            // 12: service_layer.SLPolicyIntf
	(*SLPolicyOpRsp)(nil),           // 13: service_layer.SLPolicyOpRsp
	(*SLPolicyRes)(nil),             // 14: service_layer.SLPolicyRes
	(*SLPolicyRuleStatusList)(nil),  // 15: service_layer.SLPolicyRuleStatusList
	(*SLPolicyIntfStatusList)(nil),  // 16: service_layer.SLPolicyIntfStatusList
	(*SLPolicyRuleStatus)(nil),      // 17: service_layer.SLPolicyRuleStatus
	(*SLPolicyIntfStatus)(nil),      // 18: service_layer.SLPolicyIntfStatus
	(*SLPolicyGetMsg)(nil),          // 19: service_layer.SLPolicyGetMsg
	(*SLPolicyInfo)(nil),            // 20: service_layer.SLPolicyInfo
	(*SLPolicyGetMsgRsp)(nil),       // 21: service_layer.SLPolicyGetMsgRsp
	(*SLPolicyGlobalGetMsg)(nil),    // 22: service_layer.SLPolicyGlobalGetMsg
	(*SLPolicyGlobalGetMsgRsp)(nil), // 23: service_layer.SLPolicyGlobalGetMsgRsp
	(*SLPathGroupRefKey)(nil),       // 24: service_layer.SLPathGroupRefKey
	(*SLInterface)(nil),             // 25: service_layer.SLInterface
	(*SLErrorStatus)(nil),           // 26: service_layer.SLErrorStatus
}
var file_sl_policy_proto_depIdxs = []int32{
	0,  // 0: service_layer.SLPolicyOpMsg.Oper:type_name -> service_layer.SLPolicyObjectOp
	4,  // 1: service_layer.SLPolicyOpMsg.Policies:type_name -> service_layer.SLPolicyEntry
	7,  // 2: service_layer.SLPolicyEntry.Key:type_name -> service_layer.SLPolicyKey
	5,  // 3: service_layer.SLPolicyEntry.Rules:type_name -> service_layer.PolicyRuleList
	6,  // 4: service_layer.SLPolicyEntry.Intfs:type_name -> service_layer.PolicyIntfList
	8,  // 5: service_layer.PolicyRuleList.PolicyRules:type_name -> service_layer.SLPolicyRule
	12, // 6: service_layer.PolicyIntfList.PolicyIntfs:type_name -> service_layer.SLPolicyIntf
	1,  // 7: service_layer.SLPolicyKey.Type:type_name -> service_layer.SLPolicyType
	9,  // 8: service_layer.SLPolicyRule.Match:type_name -> service_layer.SLRuleMatch
	11, // 9: service_layer.SLPolicyRule.Action:type_name -> service_layer.SLRuleAction
	10, // 10: service_layer.SLRuleMatch.Dscp:type_name -> service_layer.SLDscpMatch
	24, // 11: service_layer.SLRuleMatch.PathGroup:type_name -> service_layer.SLPathGroupRefKey
	24, // 12: service_layer.SLRuleAction.PathGroup:type_name -> service_layer.SLPathGroupRefKey
	25, // 13: service_layer.SLPolicyIntf.Key:type_name -> service_layer.SLInterface
	2,  // 14: service_layer.SLPolicyIntf.IntfDir:type_name -> service_layer.SLApplyDirection
	14, // 15: service_layer.SLPolicyOpRsp.Results:type_name -> service_layer.SLPolicyRes
	7,  // 16: service_layer.SLPolicyRes.Key:type_name -> service_layer.SLPolicyKey
	26, // 17: service_layer.SLPolicyRes.PolicyStatus:type_name -> service_layer.SLErrorStatus
	15, // 18: service_layer.SLPolicyRes.RulesStatus:type_name -> service_layer.SLPolicyRuleStatusList
	16, // 19: service_layer.SLPolicyRes.IntfStatus:type_name -> service_layer.SLPolicyIntfStatusList
	17, // 20: service_layer.SLPolicyRuleStatusList.RulesStatus:type_name -> service_layer.SLPolicyRuleStatus
	18, // 21: service_layer.SLPolicyIntfStatusList.IntfsStatus:type_name -> service_layer.SLPolicyIntfStatus
	26, // 22: service_layer.SLPolicyRuleStatus.Status:type_name -> service_layer.SLErrorStatus
	25, // 23: service_layer.SLPolicyIntfStatus.Intf:type_name -> service_layer.SLInterface
	26, // 24: service_layer.SLPolicyIntfStatus.Status:type_name -> service_layer.SLErrorStatus
	7,  // 25: service_layer.SLPolicyInfo.Key:type_name -> service_layer.SLPolicyKey
	8,  // 26: service_layer.SLPolicyInfo.PolicyRules:type_name -> service_layer.SLPolicyRule
	12, // 27: service_layer.SLPolicyInfo.PolicyIntfs:type_name -> service_layer.SLPolicyIntf
	26, // 28: service_layer.SLPolicyGetMsgRsp.PolicyCfgOpStatus:type_name -> service_layer.SLErrorStatus
	20, // 29: service_layer.SLPolicyGetMsgRsp.PolicyObjs:type_name -> service_layer.SLPolicyInfo
	26, // 30: service_layer.SLPolicyGlobalGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	3,  // 31: service_layer.SLPolicy.SLPolicyOp:input_type -> service_layer.SLPolicyOpMsg
	19, // 32: service_layer.SLPolicy.SLPolicyGet:input_type -> service_layer.SLPolicyGetMsg
	22, // 33: service_layer.SLPolicy.SLPolicyGlobalGet:input_type -> service_layer.SLPolicyGlobalGetMsg
	13, // 34: service_layer.SLPolicy.SLPolicyOp:output_type -> service_layer.SLPolicyOpRsp
	21, // 35: service_layer.SLPolicy.SLPolicyGet:output_type -> service_layer.SLPolicyGetMsgRsp
	23, // 36: service_layer.SLPolicy.SLPolicyGlobalGet:output_type -> service_layer.SLPolicyGlobalGetMsgRsp
	34, // [34:37] is the sub-list for method output_type
	31, // [31:34] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_sl_policy_proto_init() }
func file_sl_policy_proto_init() {
	if File_sl_policy_proto != nil {
		return
	}
	file_sl_common_types_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_policy_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyOpMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PolicyRuleList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PolicyIntfList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyRule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRuleMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLDscpMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRuleAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyIntf); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyOpRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyRuleStatusList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyIntfStatusList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyRuleStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyIntfStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyGlobalGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_policy_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLPolicyGlobalGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_sl_policy_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*SLPolicyEntry_Rules)(nil),
		(*SLPolicyEntry_Intfs)(nil),
	}
	file_sl_policy_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*SLDscpMatch_DscpValue)(nil),
	}
	file_sl_policy_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*SLPolicyRes_PolicyStatus)(nil),
		(*SLPolicyRes_RulesStatus)(nil),
		(*SLPolicyRes_IntfStatus)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_policy_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_sl_policy_proto_goTypes,
		DependencyIndexes: file_sl_policy_proto_depIdxs,
		EnumInfos:         file_sl_policy_proto_enumTypes,
		MessageInfos:      file_sl_policy_proto_msgTypes,
	}.Build()
	File_sl_policy_proto = out.File
	file_sl_policy_proto_rawDesc = nil
	file_sl_policy_proto_goTypes = nil
	file_sl_policy_proto_depIdxs = nil
}
