// @file
// @brief Client RPC proto file for common route types.
// This file defines common route features, including the Prefix,
// VRF information, path information, administrative distance, and
// default route status for a route object.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016, 2023 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

//@defgroup Route
//@brief Route service definitions.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v3.18.3
// source: sl_route_common.proto

package service_layer

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// L3 Event Notification types
type SLNotifType int32

const (
	// Reserved. 0x0
	SLNotifType_SL_EVENT_TYPE_RESERVED SLNotifType = 0
	// Error - ErrStatus field elaborates on the error.
	// The client can decide to close the stream based on the error. 0x1
	SLNotifType_SL_EVENT_TYPE_ERROR SLNotifType = 1
	// Status of GetNotifMsg per VRF.
	// NotifStatus field elaborates on the result.
	// If there is an error, only the notification for the VRF in the
	// status message is not setup. 0x2
	SLNotifType_SL_EVENT_TYPE_STATUS SLNotifType = 2
	// Route Notification. 0x3
	SLNotifType_SL_EVENT_TYPE_ROUTE SLNotifType = 3
	// Start marker per VRF - sent before any ROUTE notification is sent.
	// This is an indication to stale any objects received until now. 0x4
	SLNotifType_SL_EVENT_TYPE_START_MARKER SLNotifType = 4
	// End marker per VRF - sent after all ROUTE notifications are sent.
	// This is an indication to sweep any stale objects, if present. 0x5
	SLNotifType_SL_EVENT_TYPE_END_MARKER SLNotifType = 5
	// VRF Add/Update/Delete Notification. 0x6
	SLNotifType_SL_EVENT_TYPE_VRF SLNotifType = 6
)

// Enum value maps for SLNotifType.
var (
	SLNotifType_name = map[int32]string{
		0: "SL_EVENT_TYPE_RESERVED",
		1: "SL_EVENT_TYPE_ERROR",
		2: "SL_EVENT_TYPE_STATUS",
		3: "SL_EVENT_TYPE_ROUTE",
		4: "SL_EVENT_TYPE_START_MARKER",
		5: "SL_EVENT_TYPE_END_MARKER",
		6: "SL_EVENT_TYPE_VRF",
	}
	SLNotifType_value = map[string]int32{
		"SL_EVENT_TYPE_RESERVED":     0,
		"SL_EVENT_TYPE_ERROR":        1,
		"SL_EVENT_TYPE_STATUS":       2,
		"SL_EVENT_TYPE_ROUTE":        3,
		"SL_EVENT_TYPE_START_MARKER": 4,
		"SL_EVENT_TYPE_END_MARKER":   5,
		"SL_EVENT_TYPE_VRF":          6,
	}
)

func (x SLNotifType) Enum() *SLNotifType {
	p := new(SLNotifType)
	*p = x
	return p
}

func (x SLNotifType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLNotifType) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_route_common_proto_enumTypes[0].Descriptor()
}

func (SLNotifType) Type() protoreflect.EnumType {
	return &file_sl_route_common_proto_enumTypes[0]
}

func (x SLNotifType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLNotifType.Descriptor instead.
func (SLNotifType) EnumDescriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{0}
}

// Route Globals Get Message
type SLRouteGlobalsGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLRouteGlobalsGetMsg) Reset() {
	*x = SLRouteGlobalsGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalsGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalsGetMsg) ProtoMessage() {}

func (x *SLRouteGlobalsGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalsGetMsg.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalsGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{0}
}

// Route Globals Get Message Response
type SLRouteGlobalsGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Max VrfReg objects within a single VrfRegMsg message.
	MaxVrfregPerVrfregmsg uint32 `protobuf:"varint,2,opt,name=MaxVrfregPerVrfregmsg,proto3" json:"MaxVrfregPerVrfregmsg,omitempty"`
	// Max Route objects within a single RouteMsg message.
	MaxRoutePerRoutemsg uint32 `protobuf:"varint,3,opt,name=MaxRoutePerRoutemsg,proto3" json:"MaxRoutePerRoutemsg,omitempty"`
}

func (x *SLRouteGlobalsGetMsgRsp) Reset() {
	*x = SLRouteGlobalsGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalsGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalsGetMsgRsp) ProtoMessage() {}

func (x *SLRouteGlobalsGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalsGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalsGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{1}
}

func (x *SLRouteGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRouteGlobalsGetMsgRsp) GetMaxVrfregPerVrfregmsg() uint32 {
	if x != nil {
		return x.MaxVrfregPerVrfregmsg
	}
	return 0
}

func (x *SLRouteGlobalsGetMsgRsp) GetMaxRoutePerRoutemsg() uint32 {
	if x != nil {
		return x.MaxRoutePerRoutemsg
	}
	return 0
}

// Route Global Stats Get Message
type SLRouteGlobalStatsGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLRouteGlobalStatsGetMsg) Reset() {
	*x = SLRouteGlobalStatsGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalStatsGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalStatsGetMsg) ProtoMessage() {}

func (x *SLRouteGlobalStatsGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalStatsGetMsg.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalStatsGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{2}
}

// Route Global Stats Get Message Response
type SLRouteGlobalStatsGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Num VRFs registered through the service layer.
	VrfCount uint32 `protobuf:"varint,2,opt,name=VrfCount,proto3" json:"VrfCount,omitempty"`
	// Num Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,3,opt,name=RouteCount,proto3" json:"RouteCount,omitempty"`
}

func (x *SLRouteGlobalStatsGetMsgRsp) Reset() {
	*x = SLRouteGlobalStatsGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalStatsGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalStatsGetMsgRsp) ProtoMessage() {}

func (x *SLRouteGlobalStatsGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalStatsGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalStatsGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{3}
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetVrfCount() uint32 {
	if x != nil {
		return x.VrfCount
	}
	return 0
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetRouteCount() uint32 {
	if x != nil {
		return x.RouteCount
	}
	return 0
}

// VRF Registration message
type SLVrfReg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF Name.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Default Admin distance for routes programmed by this application
	// Range [0-255]
	// This default value is used if route objects' AdminDistance is 0.
	// Refer to SLRouteCommon
	AdminDistance uint32 `protobuf:"varint,2,opt,name=AdminDistance,proto3" json:"AdminDistance,omitempty"`
	// In case the Service Layer -> RIB connection is lost, this specifies the
	// timeout period after which RIB will automatically purge the installed
	// routes, unless the service layer:
	//  1. Re-registers (VRF)
	//  2. Replay all routes
	//  3. And send EOF, before the purge timeout
	VrfPurgeIntervalSeconds uint32 `protobuf:"varint,3,opt,name=VrfPurgeIntervalSeconds,proto3" json:"VrfPurgeIntervalSeconds,omitempty"`
}

func (x *SLVrfReg) Reset() {
	*x = SLVrfReg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfReg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfReg) ProtoMessage() {}

func (x *SLVrfReg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfReg.ProtoReflect.Descriptor instead.
func (*SLVrfReg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{4}
}

func (x *SLVrfReg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVrfReg) GetAdminDistance() uint32 {
	if x != nil {
		return x.AdminDistance
	}
	return 0
}

func (x *SLVrfReg) GetVrfPurgeIntervalSeconds() uint32 {
	if x != nil {
		return x.VrfPurgeIntervalSeconds
	}
	return 0
}

// VRF Registration messages.
type SLVrfRegMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Registration Operation
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// List of VRF registrations
	VrfRegMsgs []*SLVrfReg `protobuf:"bytes,2,rep,name=VrfRegMsgs,proto3" json:"VrfRegMsgs,omitempty"`
}

func (x *SLVrfRegMsg) Reset() {
	*x = SLVrfRegMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsg) ProtoMessage() {}

func (x *SLVrfRegMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsg.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{5}
}

func (x *SLVrfRegMsg) GetOper() SLRegOp {
	if x != nil {
		return x.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (x *SLVrfRegMsg) GetVrfRegMsgs() []*SLVrfReg {
	if x != nil {
		return x.VrfRegMsgs
	}
	return nil
}

// VRF Registration message Result
type SLVrfRegMsgRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// VRF Name
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
}

func (x *SLVrfRegMsgRes) Reset() {
	*x = SLVrfRegMsgRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsgRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsgRes) ProtoMessage() {}

func (x *SLVrfRegMsgRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsgRes.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsgRes) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{6}
}

func (x *SLVrfRegMsgRes) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVrfRegMsgRes) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

// VRF Registration message Response.
type SLVrfRegMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	//  1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//     In this case, the Results list is empty.
	//  2. SL_SOME_ERR: signifies that the operation failed for one or more
	//     entries. In this case, Results holds the result for
	//     each individual entry in the bulk.
	//  3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//     In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLVrfRegMsgRes `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLVrfRegMsgRsp) Reset() {
	*x = SLVrfRegMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsgRsp) ProtoMessage() {}

func (x *SLVrfRegMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{7}
}

func (x *SLVrfRegMsgRsp) GetStatusSummary() *SLErrorStatus {
	if x != nil {
		return x.StatusSummary
	}
	return nil
}

func (x *SLVrfRegMsgRsp) GetResults() []*SLVrfRegMsgRes {
	if x != nil {
		return x.Results
	}
	return nil
}

// VRF Get Message
type SLVrfRegGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF name (key).
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//
	//	request up to 'EntriesCount' entries starting from the key
	//
	// If GetNext is TRUE, or if the key exact match is not found:
	//
	//	request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
}

func (x *SLVrfRegGetMsg) Reset() {
	*x = SLVrfRegGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegGetMsg) ProtoMessage() {}

func (x *SLVrfRegGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegGetMsg.ProtoReflect.Descriptor instead.
func (*SLVrfRegGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{8}
}

func (x *SLVrfRegGetMsg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVrfRegGetMsg) GetEntriesCount() uint32 {
	if x != nil {
		return x.EntriesCount
	}
	return 0
}

func (x *SLVrfRegGetMsg) GetGetNext() bool {
	if x != nil {
		return x.GetNext
	}
	return false
}

// VRF Get Message Response
type SLVrfRegGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVrfReg `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLVrfRegGetMsgRsp) Reset() {
	*x = SLVrfRegGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegGetMsgRsp) ProtoMessage() {}

func (x *SLVrfRegGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVrfRegGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{9}
}

func (x *SLVrfRegGetMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLVrfRegGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVrfRegGetMsgRsp) GetEntries() []*SLVrfReg {
	if x != nil {
		return x.Entries
	}
	return nil
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF name as key
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Num VRF Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,2,opt,name=RouteCount,proto3" json:"RouteCount,omitempty"`
}

func (x *SLVRFGetStatsMsgRes) Reset() {
	*x = SLVRFGetStatsMsgRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVRFGetStatsMsgRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVRFGetStatsMsgRes) ProtoMessage() {}

func (x *SLVRFGetStatsMsgRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVRFGetStatsMsgRes.ProtoReflect.Descriptor instead.
func (*SLVRFGetStatsMsgRes) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{10}
}

func (x *SLVRFGetStatsMsgRes) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVRFGetStatsMsgRes) GetRouteCount() uint32 {
	if x != nil {
		return x.RouteCount
	}
	return 0
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get Stats operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get Stats operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVRFGetStatsMsgRes `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLVRFGetStatsMsgRsp) Reset() {
	*x = SLVRFGetStatsMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVRFGetStatsMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVRFGetStatsMsgRsp) ProtoMessage() {}

func (x *SLVRFGetStatsMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVRFGetStatsMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVRFGetStatsMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{11}
}

func (x *SLVRFGetStatsMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLVRFGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVRFGetStatsMsgRsp) GetEntries() []*SLVRFGetStatsMsgRes {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Common Get Notifications message
type SLRouteGetNotifMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Oper = SL_NOTIFOP_ENABLE
	//
	//	This is to enable route notifications in a VRF
	//
	// Oper = SL_NOTIFOP_DISABLE
	//
	//	This is to disable route notifications in a VRF
	Oper SLNotifOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLNotifOp" json:"Oper,omitempty"`
	// Correlator. This is used to correlate SLRouteGetNotifMsg with
	// SLRouteNotifStatus. The server reflects this field in the reply.
	// A client can send a SLRouteGetNotifMsg with the Correlator only.
	// Once accepted and reply is sent, VRF notifications are sent.
	// This is useful if a client wants to receive VRF notifications
	// (SLVrfNotif) only and is not interested in receiving route
	// notifications (SLRoutev4NotifRoute/SLRoutev6NotifRoute) from any VRF.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// Vrf that the client is interested in.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Source Protocol.
	// Only routes with specified source protocol and protocol tag will be
	// notified.
	// Contact Cisco for supported protocol string names.
	SrcProto string `protobuf:"bytes,4,opt,name=SrcProto,proto3" json:"SrcProto,omitempty"`
	// Source Protocol Tag. This can be empty if N/A.
	// Contact Cisco for supported protocol tags.
	SrcProtoTag string `protobuf:"bytes,5,opt,name=SrcProtoTag,proto3" json:"SrcProtoTag,omitempty"`
}

func (x *SLRouteGetNotifMsg) Reset() {
	*x = SLRouteGetNotifMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGetNotifMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGetNotifMsg) ProtoMessage() {}

func (x *SLRouteGetNotifMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGetNotifMsg.ProtoReflect.Descriptor instead.
func (*SLRouteGetNotifMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{12}
}

func (x *SLRouteGetNotifMsg) GetOper() SLNotifOp {
	if x != nil {
		return x.Oper
	}
	return SLNotifOp_SL_NOTIFOP_RESERVED
}

func (x *SLRouteGetNotifMsg) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRouteGetNotifMsg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRouteGetNotifMsg) GetSrcProto() string {
	if x != nil {
		return x.SrcProto
	}
	return ""
}

func (x *SLRouteGetNotifMsg) GetSrcProtoTag() string {
	if x != nil {
		return x.SrcProtoTag
	}
	return ""
}

// Common Route Notification Status message
type SLRouteNotifStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator in the request.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// Vrf in the request.
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// The NotifStatus implies one of 2 things:
	// SL_SUCCESS: signifies that the notification request was successful
	// SL_XXX: signifies an error in setting up a notification for the Vrf.
	//
	//	Implies that notifications for this VRF will not be sent.
	NotifStatus *SLErrorStatus `protobuf:"bytes,3,opt,name=NotifStatus,proto3" json:"NotifStatus,omitempty"`
}

func (x *SLRouteNotifStatus) Reset() {
	*x = SLRouteNotifStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteNotifStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteNotifStatus) ProtoMessage() {}

func (x *SLRouteNotifStatus) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteNotifStatus.ProtoReflect.Descriptor instead.
func (*SLRouteNotifStatus) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{13}
}

func (x *SLRouteNotifStatus) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRouteNotifStatus) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRouteNotifStatus) GetNotifStatus() *SLErrorStatus {
	if x != nil {
		return x.NotifStatus
	}
	return nil
}

// Common Marker Notification message
type SLRouteNotifMarker struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Vrf that this notification message applies to.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
}

func (x *SLRouteNotifMarker) Reset() {
	*x = SLRouteNotifMarker{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteNotifMarker) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteNotifMarker) ProtoMessage() {}

func (x *SLRouteNotifMarker) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteNotifMarker.ProtoReflect.Descriptor instead.
func (*SLRouteNotifMarker) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{14}
}

func (x *SLRouteNotifMarker) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

// Common Vrf Notification message
type SLVrfNotif struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Vrf that this notification message applies to.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Status of this Vrf: add/update/delete.
	Status SLObjectOp `protobuf:"varint,2,opt,name=Status,proto3,enum=service_layer.SLObjectOp" json:"Status,omitempty"`
}

func (x *SLVrfNotif) Reset() {
	*x = SLVrfNotif{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfNotif) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfNotif) ProtoMessage() {}

func (x *SLVrfNotif) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfNotif.ProtoReflect.Descriptor instead.
func (*SLVrfNotif) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{15}
}

func (x *SLVrfNotif) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVrfNotif) GetStatus() SLObjectOp {
	if x != nil {
		return x.Status
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

// Common IPv4/IPv6 route attributes.
type SLRouteCommon struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Adminstrative distance of the route. [0-255].
	// RIB uses this field to break the tie when multiple
	// sources install the same route.
	// Lower distance is preferred over higher distance.
	// The per route object admin distance overrides the default's admin
	// distance set at VRF registration. see SLVrfReg
	AdminDistance uint32 `protobuf:"varint,1,opt,name=AdminDistance,proto3" json:"AdminDistance,omitempty"`
	// Local label associated with this route.
	// This is an optional field that can be used to simulatenously setup an
	// ILM entry (e.g. head end of an MPLS LSP) for the same route.
	// This is especially useful when setting up an MPLS LSP (a /32-route
	// towards the remote LSP peer e.g. 2.2.2.2/32) which is required for MPLS
	// VPN labeled routes.
	//
	// Note: MPLS VPN labeled routes can resolve only on:
	//   - /32-routes with valid LocalLabel and a valid egress MPLS path label
	LocalLabel uint32 `protobuf:"varint,2,opt,name=LocalLabel,proto3" json:"LocalLabel,omitempty"`
	// Route Tag.
	// Routes are usually tagged to prevent loops during redistribution between
	// protocols.
	Tag uint32 `protobuf:"varint,3,opt,name=Tag,proto3" json:"Tag,omitempty"`
	// Source Protocol.
	// For redistributed messages via notification stream only,
	// ignored otherwise.
	// Contact Cisco for supported protocol string names.
	SrcProto string `protobuf:"bytes,4,opt,name=SrcProto,proto3" json:"SrcProto,omitempty"`
	// Source Protocol Tag. This can be empty if N/A.
	// For redistributed messages via notification stream only,
	// ignored otherwise.
	// Contact Cisco for supported protocol tags.
	SrcProtoTag string `protobuf:"bytes,5,opt,name=SrcProtoTag,proto3" json:"SrcProtoTag,omitempty"`
	// Route Flags.
	// Flags to control programming of the route to Routing Information Base.
	// Each flag is indicated as a bit field. Supported values are:
	// 0x1 - This route takes precedence over a route learnt by LDP.
	Flags uint32 `protobuf:"varint,6,opt,name=Flags,proto3" json:"Flags,omitempty"`
}

func (x *SLRouteCommon) Reset() {
	*x = SLRouteCommon{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteCommon) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteCommon) ProtoMessage() {}

func (x *SLRouteCommon) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteCommon.ProtoReflect.Descriptor instead.
func (*SLRouteCommon) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{16}
}

func (x *SLRouteCommon) GetAdminDistance() uint32 {
	if x != nil {
		return x.AdminDistance
	}
	return 0
}

func (x *SLRouteCommon) GetLocalLabel() uint32 {
	if x != nil {
		return x.LocalLabel
	}
	return 0
}

func (x *SLRouteCommon) GetTag() uint32 {
	if x != nil {
		return x.Tag
	}
	return 0
}

func (x *SLRouteCommon) GetSrcProto() string {
	if x != nil {
		return x.SrcProto
	}
	return ""
}

func (x *SLRouteCommon) GetSrcProtoTag() string {
	if x != nil {
		return x.SrcProtoTag
	}
	return ""
}

func (x *SLRouteCommon) GetFlags() uint32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

// Attributes for constructing VxLAN encapsulation for a IP packet.
type SLVxLANPath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Virtual network identifier. Client must set a valid non-zero idenifier.
	VNI uint32 `protobuf:"varint,1,opt,name=VNI,proto3" json:"VNI,omitempty"`
	// Source MAC address is optional.
	SourceMacAddress []byte `protobuf:"bytes,2,opt,name=SourceMacAddress,proto3" json:"SourceMacAddress,omitempty"`
	// Destination MAC address is optional.
	DestMacAddress []byte `protobuf:"bytes,3,opt,name=DestMacAddress,proto3" json:"DestMacAddress,omitempty"`
	// Tunnel Source or Local IP address is mandatory.
	SrcIpAddress *SLIpAddress `protobuf:"bytes,4,opt,name=SrcIpAddress,proto3" json:"SrcIpAddress,omitempty"`
	// Tunnel Destination or Remote IP address is mandatory.
	DestIpAddress *SLIpAddress `protobuf:"bytes,5,opt,name=DestIpAddress,proto3" json:"DestIpAddress,omitempty"`
}

func (x *SLVxLANPath) Reset() {
	*x = SLVxLANPath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVxLANPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVxLANPath) ProtoMessage() {}

func (x *SLVxLANPath) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVxLANPath.ProtoReflect.Descriptor instead.
func (*SLVxLANPath) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{17}
}

func (x *SLVxLANPath) GetVNI() uint32 {
	if x != nil {
		return x.VNI
	}
	return 0
}

func (x *SLVxLANPath) GetSourceMacAddress() []byte {
	if x != nil {
		return x.SourceMacAddress
	}
	return nil
}

func (x *SLVxLANPath) GetDestMacAddress() []byte {
	if x != nil {
		return x.DestMacAddress
	}
	return nil
}

func (x *SLVxLANPath) GetSrcIpAddress() *SLIpAddress {
	if x != nil {
		return x.SrcIpAddress
	}
	return nil
}

func (x *SLVxLANPath) GetDestIpAddress() *SLIpAddress {
	if x != nil {
		return x.DestIpAddress
	}
	return nil
}

// Route Path attributes.
//
// FRR Note:
// Failover from primary to backup is based on the trigger used (e.g.
// link down, BFD, etc.). Revertion is mainly timeout based. The timeout
// value is platform specific and is not configurable.
type SLRoutePath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// One of IPv4 or IPv6 address
	// For ENCAP_VXLAN, this field is not supported and will be ignored
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress,proto3" json:"NexthopAddress,omitempty"`
	// Outgoing interface name for the path.
	// For ENCAP_VXLAN, this field is not supported and will be ignored
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface,proto3" json:"NexthopInterface,omitempty"`
	// Load metric for this path.
	// Used for equal/unequal cost load balancing of traffic distribution.
	// For equal cost load balancing, all paths associated with the
	// route must have LoadMetric value of 0. For unequal cost load
	// balancing, all paths must have non-zero LoadMetricvalue, otherwise
	// system defaults to equal cost load balancing.
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric,proto3" json:"LoadMetric,omitempty"`
	// Path VRF name. This field is used ONLY if the path is in a different
	// VRF than the route (e.g. VPN cases)
	VrfName string `protobuf:"bytes,4,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Route Metric.
	// The metric is typically based on information like load, hop count,
	// MTU, reliability of the path, etc.
	Metric uint32 `protobuf:"varint,5,opt,name=Metric,proto3" json:"Metric,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//  1. Primary. The path is the main path to carry traffic.
	//  2. Protected. A primary path with a configured backup path.
	//  3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//  1. Pure Primary i.e. Not Protected and is not a Backup.
	//     => PathId is optional. ProtectedPathBitmap = 0x0
	//  2. Primary and Protected. Path is not a Backup.
	//     => PathId is mandatory. ProtectedPathBitmap = 0x0
	//  3. Primary and Not Protected. Path is also a Backup.
	//     => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//  4. Primary and Protected. Path is also a Backup.
	//     => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//  5. Pure Backup. Protection is not allowed for backup paths.
	//     => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId,proto3" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//
	//	|| |-- path 4
	//	||-- path 5
	//	|-- path 6
	//
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap,proto3" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack,proto3" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used only for backup MPLS path with more than one label
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress,proto3" json:"RemoteAddress,omitempty"`
	// Encapsulation type (VXLAN or MPLS)
	EncapType SLEncapType `protobuf:"varint,10,opt,name=EncapType,proto3,enum=service_layer.SLEncapType" json:"EncapType,omitempty"`
	// VTEP (VxLAN tunnel end point) router MAC address.
	// A unique system MAC address that other VTEPs can use for inter-VNI
	// routing. The router MAC address is used as the inner destination MAC
	// address for routed VXLAN packet. If this attribute
	// is set, route can be only be signalled via BGP for EVPN use and
	// local tunnel endpoint is not created.
	//
	// This field and VxLANPath are mutually exclusive. This field
	// is deprecated and will eventually be removed.
	VtepRouterMacAddress []byte `protobuf:"bytes,11,opt,name=VtepRouterMacAddress,proto3" json:"VtepRouterMacAddress,omitempty"`
	// Create L3 VxLAN tunnel endpoint. Apply VxLAN encapsulation
	// on the IP packet.
	VxLANPath *SLVxLANPath `protobuf:"bytes,12,opt,name=VxLANPath,proto3" json:"VxLANPath,omitempty"`
}

func (x *SLRoutePath) Reset() {
	*x = SLRoutePath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutePath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutePath) ProtoMessage() {}

func (x *SLRoutePath) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutePath.ProtoReflect.Descriptor instead.
func (*SLRoutePath) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{18}
}

func (x *SLRoutePath) GetNexthopAddress() *SLIpAddress {
	if x != nil {
		return x.NexthopAddress
	}
	return nil
}

func (x *SLRoutePath) GetNexthopInterface() *SLInterface {
	if x != nil {
		return x.NexthopInterface
	}
	return nil
}

func (x *SLRoutePath) GetLoadMetric() uint32 {
	if x != nil {
		return x.LoadMetric
	}
	return 0
}

func (x *SLRoutePath) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutePath) GetMetric() uint32 {
	if x != nil {
		return x.Metric
	}
	return 0
}

func (x *SLRoutePath) GetPathId() uint32 {
	if x != nil {
		return x.PathId
	}
	return 0
}

func (x *SLRoutePath) GetProtectedPathBitmap() []uint64 {
	if x != nil {
		return x.ProtectedPathBitmap
	}
	return nil
}

func (x *SLRoutePath) GetLabelStack() []uint32 {
	if x != nil {
		return x.LabelStack
	}
	return nil
}

func (x *SLRoutePath) GetRemoteAddress() []*SLIpAddress {
	if x != nil {
		return x.RemoteAddress
	}
	return nil
}

func (x *SLRoutePath) GetEncapType() SLEncapType {
	if x != nil {
		return x.EncapType
	}
	return SLEncapType_SL_ENCAP_RESERVED
}

func (x *SLRoutePath) GetVtepRouterMacAddress() []byte {
	if x != nil {
		return x.VtepRouterMacAddress
	}
	return nil
}

func (x *SLRoutePath) GetVxLANPath() *SLVxLANPath {
	if x != nil {
		return x.VxLANPath
	}
	return nil
}

var File_sl_route_common_proto protoreflect.FileDescriptor

var file_sl_route_common_proto_rawDesc = []byte{
	0x0a, 0x15, 0x73, 0x6c, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x1a, 0x15, 0x73, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x16, 0x0a,
	0x14, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x47,
	0x65, 0x74, 0x4d, 0x73, 0x67, 0x22, 0xbd, 0x01, 0x0a, 0x17, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73,
	0x70, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x34, 0x0a,
	0x15, 0x4d, 0x61, 0x78, 0x56, 0x72, 0x66, 0x72, 0x65, 0x67, 0x50, 0x65, 0x72, 0x56, 0x72, 0x66,
	0x72, 0x65, 0x67, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x15, 0x4d, 0x61,
	0x78, 0x56, 0x72, 0x66, 0x72, 0x65, 0x67, 0x50, 0x65, 0x72, 0x56, 0x72, 0x66, 0x72, 0x65, 0x67,
	0x6d, 0x73, 0x67, 0x12, 0x30, 0x0a, 0x13, 0x4d, 0x61, 0x78, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50,
	0x65, 0x72, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x13, 0x4d, 0x61, 0x78, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50, 0x65, 0x72, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x6d, 0x73, 0x67, 0x22, 0x1a, 0x0a, 0x18, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73,
	0x67, 0x22, 0x95, 0x01, 0x0a, 0x1b, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f,
	0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73,
	0x70, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a,
	0x08, 0x56, 0x72, 0x66, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x08, 0x56, 0x72, 0x66, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x84, 0x01, 0x0a, 0x08, 0x53, 0x4c,
	0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x24, 0x0a, 0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69,
	0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x38, 0x0a, 0x17, 0x56, 0x72, 0x66, 0x50, 0x75, 0x72,
	0x67, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x17, 0x56, 0x72, 0x66, 0x50, 0x75, 0x72, 0x67,
	0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73,
	0x22, 0x72, 0x0a, 0x0b, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x12,
	0x2a, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x52, 0x65, 0x67, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x37, 0x0a, 0x0a, 0x56,
	0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x17, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x52, 0x0a, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67,
	0x4d, 0x73, 0x67, 0x73, 0x22, 0x66, 0x0a, 0x0e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67,
	0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x8d, 0x01, 0x0a,
	0x0e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12,
	0x42, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d,
	0x61, 0x72, 0x79, 0x12, 0x37, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67,
	0x52, 0x65, 0x73, 0x52, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0x68, 0x0a, 0x0e,
	0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x18,
	0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x45, 0x6e, 0x74, 0x72,
	0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c,
	0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07,
	0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x47,
	0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x22, 0x94, 0x01, 0x0a, 0x11, 0x53, 0x4c, 0x56, 0x72, 0x66,
	0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x10, 0x0a, 0x03,
	0x45, 0x6f, 0x66, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f, 0x66, 0x12, 0x3a,
	0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x31, 0x0a, 0x07, 0x45, 0x6e,
	0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x72,
	0x66, 0x52, 0x65, 0x67, 0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x4f, 0x0a,
	0x13, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4d, 0x73,
	0x67, 0x52, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1e,
	0x0a, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xa1,
	0x01, 0x0a, 0x13, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73,
	0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x45, 0x6f, 0x66, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f, 0x66, 0x12, 0x3a, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x3c, 0x0a, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74, 0x53, 0x74,
	0x61, 0x74, 0x73, 0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x22, 0xba, 0x01, 0x0a, 0x12, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x65,
	0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x4d, 0x73, 0x67, 0x12, 0x2c, 0x0a, 0x04, 0x4f, 0x70, 0x65,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x4f,
	0x70, 0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65,
	0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72,
	0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61,
	0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x1a, 0x0a, 0x08, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x20, 0x0a,
	0x0b, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0b, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x67, 0x22,
	0x8e, 0x01, 0x0a, 0x12, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c,
	0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72,
	0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x3e, 0x0a, 0x0b, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x52, 0x0b, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x22, 0x2e, 0x0a, 0x12, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66,
	0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65,
	0x22, 0x59, 0x0a, 0x0a, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x12, 0x18,
	0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x31, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4f, 0x62, 0x6a, 0x65, 0x63,
	0x74, 0x4f, 0x70, 0x52, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xbb, 0x01, 0x0a, 0x0d,
	0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x12, 0x24, 0x0a,
	0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x74, 0x61,
	0x6e, 0x63, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61, 0x62, 0x65,
	0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61,
	0x62, 0x65, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x54, 0x61, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x54, 0x61, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x20, 0x0a, 0x0b, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x67,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x53, 0x72, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x54, 0x61, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x05, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x22, 0xf5, 0x01, 0x0a, 0x0b, 0x53, 0x4c,
	0x56, 0x78, 0x4c, 0x41, 0x4e, 0x50, 0x61, 0x74, 0x68, 0x12, 0x10, 0x0a, 0x03, 0x56, 0x4e, 0x49,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x56, 0x4e, 0x49, 0x12, 0x2a, 0x0a, 0x10, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x61, 0x63,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x26, 0x0a, 0x0e, 0x44, 0x65, 0x73, 0x74, 0x4d,
	0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0e, 0x44, 0x65, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x3e, 0x0a, 0x0c, 0x53, 0x72, 0x63, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x52, 0x0c, 0x53, 0x72, 0x63, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x40, 0x0a, 0x0d, 0x44, 0x65, 0x73, 0x74, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x0d, 0x44, 0x65, 0x73, 0x74, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x22, 0xbf, 0x04, 0x0a, 0x0b, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50, 0x61, 0x74,
	0x68, 0x12, 0x42, 0x0a, 0x0e, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0e, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x46, 0x0a, 0x10, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70,
	0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x52, 0x10, 0x4e, 0x65, 0x78,
	0x74, 0x68, 0x6f, 0x70, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x12, 0x1e, 0x0a,
	0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x18, 0x0a,
	0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69,
	0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12,
	0x16, 0x0a, 0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x12, 0x30, 0x0a, 0x13, 0x50, 0x72, 0x6f, 0x74, 0x65,
	0x63, 0x74, 0x65, 0x64, 0x50, 0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x18, 0x07,
	0x20, 0x03, 0x28, 0x04, 0x52, 0x13, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50,
	0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x12, 0x1e, 0x0a, 0x0a, 0x4c, 0x61, 0x62,
	0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0a, 0x4c,
	0x61, 0x62, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x12, 0x40, 0x0a, 0x0d, 0x52, 0x65, 0x6d,
	0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0d, 0x52, 0x65,
	0x6d, 0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x38, 0x0a, 0x09, 0x45,
	0x6e, 0x63, 0x61, 0x70, 0x54, 0x79, 0x70, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x45, 0x6e, 0x63, 0x61,
	0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x32, 0x0a, 0x14, 0x56, 0x74, 0x65, 0x70, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x72, 0x4d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x14, 0x56, 0x74, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x4d,
	0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x38, 0x0a, 0x09, 0x56, 0x78, 0x4c,
	0x41, 0x4e, 0x50, 0x61, 0x74, 0x68, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56,
	0x78, 0x4c, 0x41, 0x4e, 0x50, 0x61, 0x74, 0x68, 0x52, 0x09, 0x56, 0x78, 0x4c, 0x41, 0x4e, 0x50,
	0x61, 0x74, 0x68, 0x2a, 0xca, 0x01, 0x0a, 0x0b, 0x53, 0x4c, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x53, 0x4c, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x44, 0x10, 0x00, 0x12,
	0x17, 0x0a, 0x13, 0x53, 0x4c, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x01, 0x12, 0x18, 0x0a, 0x14, 0x53, 0x4c, 0x5f, 0x45,
	0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
	0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x53, 0x4c, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x10, 0x03, 0x12, 0x1e, 0x0a, 0x1a, 0x53,
	0x4c, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x54, 0x41,
	0x52, 0x54, 0x5f, 0x4d, 0x41, 0x52, 0x4b, 0x45, 0x52, 0x10, 0x04, 0x12, 0x1c, 0x0a, 0x18, 0x53,
	0x4c, 0x5f, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x45, 0x4e, 0x44,
	0x5f, 0x4d, 0x41, 0x52, 0x4b, 0x45, 0x52, 0x10, 0x05, 0x12, 0x15, 0x0a, 0x11, 0x53, 0x4c, 0x5f,
	0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x52, 0x46, 0x10, 0x06,
	0x42, 0x51, 0x5a, 0x4f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43,
	0x69, 0x73, 0x63, 0x6f, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2d, 0x6f, 0x62, 0x6a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x73, 0x3b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_route_common_proto_rawDescOnce sync.Once
	file_sl_route_common_proto_rawDescData = file_sl_route_common_proto_rawDesc
)

func file_sl_route_common_proto_rawDescGZIP() []byte {
	file_sl_route_common_proto_rawDescOnce.Do(func() {
		file_sl_route_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_route_common_proto_rawDescData)
	})
	return file_sl_route_common_proto_rawDescData
}

var file_sl_route_common_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_sl_route_common_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_sl_route_common_proto_goTypes = []interface{}{
	(SLNotifType)(0),                    // 0: service_layer.SLNotifType
	(*SLRouteGlobalsGetMsg)(nil),        // 1: service_layer.SLRouteGlobalsGetMsg
	(*SLRouteGlobalsGetMsgRsp)(nil),     // 2: service_layer.SLRouteGlobalsGetMsgRsp
	(*SLRouteGlobalStatsGetMsg)(nil),    // 3: service_layer.SLRouteGlobalStatsGetMsg
	(*SLRouteGlobalStatsGetMsgRsp)(nil), // 4: service_layer.SLRouteGlobalStatsGetMsgRsp
	(*SLVrfReg)(nil),                    // 5: service_layer.SLVrfReg
	(*SLVrfRegMsg)(nil),                 // 6: service_layer.SLVrfRegMsg
	(*SLVrfRegMsgRes)(nil),              // 7: service_layer.SLVrfRegMsgRes
	(*SLVrfRegMsgRsp)(nil),              // 8: service_layer.SLVrfRegMsgRsp
	(*SLVrfRegGetMsg)(nil),              // 9: service_layer.SLVrfRegGetMsg
	(*SLVrfRegGetMsgRsp)(nil),           // 10: service_layer.SLVrfRegGetMsgRsp
	(*SLVRFGetStatsMsgRes)(nil),         // 11: service_layer.SLVRFGetStatsMsgRes
	(*SLVRFGetStatsMsgRsp)(nil),         // 12: service_layer.SLVRFGetStatsMsgRsp
	(*SLRouteGetNotifMsg)(nil),          // 13: service_layer.SLRouteGetNotifMsg
	(*SLRouteNotifStatus)(nil),          // 14: service_layer.SLRouteNotifStatus
	(*SLRouteNotifMarker)(nil),          // 15: service_layer.SLRouteNotifMarker
	(*SLVrfNotif)(nil),                  // 16: service_layer.SLVrfNotif
	(*SLRouteCommon)(nil),               // 17: service_layer.SLRouteCommon
	(*SLVxLANPath)(nil),                 // 18: service_layer.SLVxLANPath
	(*SLRoutePath)(nil),                 // 19: service_layer.SLRoutePath
	(*SLErrorStatus)(nil),               // 20: service_layer.SLErrorStatus
	(SLRegOp)(0),                        // 21: service_layer.SLRegOp
	(SLNotifOp)(0),                      // 22: service_layer.SLNotifOp
	(SLObjectOp)(0),                     // 23: service_layer.SLObjectOp
	(*SLIpAddress)(nil),                 // 24: service_layer.SLIpAddress
	(*SLInterface)(nil),                 // 25: service_layer.SLInterface
	(SLEncapType)(0),                    // 26: service_layer.SLEncapType
}
var file_sl_route_common_proto_depIdxs = []int32{
	20, // 0: service_layer.SLRouteGlobalsGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	20, // 1: service_layer.SLRouteGlobalStatsGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	21, // 2: service_layer.SLVrfRegMsg.Oper:type_name -> service_layer.SLRegOp
	5,  // 3: service_layer.SLVrfRegMsg.VrfRegMsgs:type_name -> service_layer.SLVrfReg
	20, // 4: service_layer.SLVrfRegMsgRes.ErrStatus:type_name -> service_layer.SLErrorStatus
	20, // 5: service_layer.SLVrfRegMsgRsp.StatusSummary:type_name -> service_layer.SLErrorStatus
	7,  // 6: service_layer.SLVrfRegMsgRsp.Results:type_name -> service_layer.SLVrfRegMsgRes
	20, // 7: service_layer.SLVrfRegGetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	5,  // 8: service_layer.SLVrfRegGetMsgRsp.Entries:type_name -> service_layer.SLVrfReg
	20, // 9: service_layer.SLVRFGetStatsMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	11, // 10: service_layer.SLVRFGetStatsMsgRsp.Entries:type_name -> service_layer.SLVRFGetStatsMsgRes
	22, // 11: service_layer.SLRouteGetNotifMsg.Oper:type_name -> service_layer.SLNotifOp
	20, // 12: service_layer.SLRouteNotifStatus.NotifStatus:type_name -> service_layer.SLErrorStatus
	23, // 13: service_layer.SLVrfNotif.Status:type_name -> service_layer.SLObjectOp
	24, // 14: service_layer.SLVxLANPath.SrcIpAddress:type_name -> service_layer.SLIpAddress
	24, // 15: service_layer.SLVxLANPath.DestIpAddress:type_name -> service_layer.SLIpAddress
	24, // 16: service_layer.SLRoutePath.NexthopAddress:type_name -> service_layer.SLIpAddress
	25, // 17: service_layer.SLRoutePath.NexthopInterface:type_name -> service_layer.SLInterface
	24, // 18: service_layer.SLRoutePath.RemoteAddress:type_name -> service_layer.SLIpAddress
	26, // 19: service_layer.SLRoutePath.EncapType:type_name -> service_layer.SLEncapType
	18, // 20: service_layer.SLRoutePath.VxLANPath:type_name -> service_layer.SLVxLANPath
	21, // [21:21] is the sub-list for method output_type
	21, // [21:21] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_sl_route_common_proto_init() }
func file_sl_route_common_proto_init() {
	if File_sl_route_common_proto != nil {
		return
	}
	file_sl_common_types_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_route_common_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalsGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalsGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalStatsGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalStatsGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfReg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsgRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVRFGetStatsMsgRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVRFGetStatsMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGetNotifMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteNotifStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteNotifMarker); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfNotif); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteCommon); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVxLANPath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutePath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_route_common_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sl_route_common_proto_goTypes,
		DependencyIndexes: file_sl_route_common_proto_depIdxs,
		EnumInfos:         file_sl_route_common_proto_enumTypes,
		MessageInfos:      file_sl_route_common_proto_msgTypes,
	}.Build()
	File_sl_route_common_proto = out.File
	file_sl_route_common_proto_rawDesc = nil
	file_sl_route_common_proto_goTypes = nil
	file_sl_route_common_proto_depIdxs = nil
}
