// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_route_common.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// L3 Event Notification types
type SLNotifType int32

const (
	// Reserved. 0x0
	SLNotifType_SL_EVENT_TYPE_RESERVED SLNotifType = 0
	// Error - ErrStatus field elaborates on the error.
	// The client can decide to close the stream based on the error. 0x1
	SLNotifType_SL_EVENT_TYPE_ERROR SLNotifType = 1
	// Status of GetNotifMsg per VRF.
	// NotifStatus field elaborates on the result.
	// If there is an error, only the notification for the VRF in the
	// status message is not setup. 0x2
	SLNotifType_SL_EVENT_TYPE_STATUS SLNotifType = 2
	// Route Notification. 0x3
	SLNotifType_SL_EVENT_TYPE_ROUTE SLNotifType = 3
	// Start marker per VRF - sent before any ROUTE notification is sent.
	// This is an indication to stale any objects received until now. 0x4
	SLNotifType_SL_EVENT_TYPE_START_MARKER SLNotifType = 4
	// End marker per VRF - sent after all ROUTE notifications are sent.
	// This is an indication to sweep any stale objects, if present. 0x5
	SLNotifType_SL_EVENT_TYPE_END_MARKER SLNotifType = 5
	// VRF Add/Update/Delete Notification. 0x6
	SLNotifType_SL_EVENT_TYPE_VRF SLNotifType = 6
)

var SLNotifType_name = map[int32]string{
	0: "SL_EVENT_TYPE_RESERVED",
	1: "SL_EVENT_TYPE_ERROR",
	2: "SL_EVENT_TYPE_STATUS",
	3: "SL_EVENT_TYPE_ROUTE",
	4: "SL_EVENT_TYPE_START_MARKER",
	5: "SL_EVENT_TYPE_END_MARKER",
	6: "SL_EVENT_TYPE_VRF",
}
var SLNotifType_value = map[string]int32{
	"SL_EVENT_TYPE_RESERVED":     0,
	"SL_EVENT_TYPE_ERROR":        1,
	"SL_EVENT_TYPE_STATUS":       2,
	"SL_EVENT_TYPE_ROUTE":        3,
	"SL_EVENT_TYPE_START_MARKER": 4,
	"SL_EVENT_TYPE_END_MARKER":   5,
	"SL_EVENT_TYPE_VRF":          6,
}

func (x SLNotifType) String() string {
	return proto.EnumName(SLNotifType_name, int32(x))
}
func (SLNotifType) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

// Route Globals Get Message
type SLRouteGlobalsGetMsg struct {
}

func (m *SLRouteGlobalsGetMsg) Reset()                    { *m = SLRouteGlobalsGetMsg{} }
func (m *SLRouteGlobalsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLRouteGlobalsGetMsg) ProtoMessage()               {}
func (*SLRouteGlobalsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

// Route Globals Get Message Response
type SLRouteGlobalsGetMsgRsp struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Max VrfReg objects within a single VrfRegMsg message.
	MaxVrfregPerVrfregmsg uint32 `protobuf:"varint,2,opt,name=MaxVrfregPerVrfregmsg" json:"MaxVrfregPerVrfregmsg,omitempty"`
	// Max Route objects within a single RouteMsg message.
	MaxRoutePerRoutemsg uint32 `protobuf:"varint,3,opt,name=MaxRoutePerRoutemsg" json:"MaxRoutePerRoutemsg,omitempty"`
}

func (m *SLRouteGlobalsGetMsgRsp) Reset()                    { *m = SLRouteGlobalsGetMsgRsp{} }
func (m *SLRouteGlobalsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLRouteGlobalsGetMsgRsp) ProtoMessage()               {}
func (*SLRouteGlobalsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

func (m *SLRouteGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLRouteGlobalsGetMsgRsp) GetMaxVrfregPerVrfregmsg() uint32 {
	if m != nil {
		return m.MaxVrfregPerVrfregmsg
	}
	return 0
}

func (m *SLRouteGlobalsGetMsgRsp) GetMaxRoutePerRoutemsg() uint32 {
	if m != nil {
		return m.MaxRoutePerRoutemsg
	}
	return 0
}

// Route Global Stats Get Message
type SLRouteGlobalStatsGetMsg struct {
}

func (m *SLRouteGlobalStatsGetMsg) Reset()                    { *m = SLRouteGlobalStatsGetMsg{} }
func (m *SLRouteGlobalStatsGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLRouteGlobalStatsGetMsg) ProtoMessage()               {}
func (*SLRouteGlobalStatsGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{2} }

// Route Global Stats Get Message Response
type SLRouteGlobalStatsGetMsgRsp struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Num VRFs registered through the service layer.
	VrfCount uint32 `protobuf:"varint,2,opt,name=VrfCount" json:"VrfCount,omitempty"`
	// Num Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,3,opt,name=RouteCount" json:"RouteCount,omitempty"`
}

func (m *SLRouteGlobalStatsGetMsgRsp) Reset()                    { *m = SLRouteGlobalStatsGetMsgRsp{} }
func (m *SLRouteGlobalStatsGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLRouteGlobalStatsGetMsgRsp) ProtoMessage()               {}
func (*SLRouteGlobalStatsGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{3} }

func (m *SLRouteGlobalStatsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLRouteGlobalStatsGetMsgRsp) GetVrfCount() uint32 {
	if m != nil {
		return m.VrfCount
	}
	return 0
}

func (m *SLRouteGlobalStatsGetMsgRsp) GetRouteCount() uint32 {
	if m != nil {
		return m.RouteCount
	}
	return 0
}

// VRF Registration message
type SLVrfReg struct {
	// VRF Name.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
	// Default Admin distance for routes programmed by this application
	// Range [0-255]
	// This default value is used if route objects' AdminDistance is 0.
	// Refer to SLRouteCommon
	AdminDistance uint32 `protobuf:"varint,2,opt,name=AdminDistance" json:"AdminDistance,omitempty"`
	// In case the Service Layer -> RIB connection is lost, this specifies the
	// timeout period after which RIB will automatically purge the installed
	// routes, unless the service layer:
	//    1. Re-registers (VRF)
	//    2. Replay all routes
	//    3. And send EOF, before the purge timeout
	VrfPurgeIntervalSeconds uint32 `protobuf:"varint,3,opt,name=VrfPurgeIntervalSeconds" json:"VrfPurgeIntervalSeconds,omitempty"`
}

func (m *SLVrfReg) Reset()                    { *m = SLVrfReg{} }
func (m *SLVrfReg) String() string            { return proto.CompactTextString(m) }
func (*SLVrfReg) ProtoMessage()               {}
func (*SLVrfReg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{4} }

func (m *SLVrfReg) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLVrfReg) GetAdminDistance() uint32 {
	if m != nil {
		return m.AdminDistance
	}
	return 0
}

func (m *SLVrfReg) GetVrfPurgeIntervalSeconds() uint32 {
	if m != nil {
		return m.VrfPurgeIntervalSeconds
	}
	return 0
}

// VRF Registration messages.
type SLVrfRegMsg struct {
	// Registration Operation
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	// List of VRF registrations
	VrfRegMsgs []*SLVrfReg `protobuf:"bytes,2,rep,name=VrfRegMsgs" json:"VrfRegMsgs,omitempty"`
}

func (m *SLVrfRegMsg) Reset()                    { *m = SLVrfRegMsg{} }
func (m *SLVrfRegMsg) String() string            { return proto.CompactTextString(m) }
func (*SLVrfRegMsg) ProtoMessage()               {}
func (*SLVrfRegMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{5} }

func (m *SLVrfRegMsg) GetOper() SLRegOp {
	if m != nil {
		return m.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (m *SLVrfRegMsg) GetVrfRegMsgs() []*SLVrfReg {
	if m != nil {
		return m.VrfRegMsgs
	}
	return nil
}

// VRF Registration message Result
type SLVrfRegMsgRes struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// VRF Name
	VrfName string `protobuf:"bytes,2,opt,name=VrfName" json:"VrfName,omitempty"`
}

func (m *SLVrfRegMsgRes) Reset()                    { *m = SLVrfRegMsgRes{} }
func (m *SLVrfRegMsgRes) String() string            { return proto.CompactTextString(m) }
func (*SLVrfRegMsgRes) ProtoMessage()               {}
func (*SLVrfRegMsgRes) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{6} }

func (m *SLVrfRegMsgRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLVrfRegMsgRes) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

// VRF Registration message Response.
type SLVrfRegMsgRsp struct {
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLVrfRegMsgRes `protobuf:"bytes,2,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLVrfRegMsgRsp) Reset()                    { *m = SLVrfRegMsgRsp{} }
func (m *SLVrfRegMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLVrfRegMsgRsp) ProtoMessage()               {}
func (*SLVrfRegMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{7} }

func (m *SLVrfRegMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLVrfRegMsgRsp) GetResults() []*SLVrfRegMsgRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// VRF Get Message
type SLVrfRegGetMsg struct {
	// VRF name (key).
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext" json:"GetNext,omitempty"`
}

func (m *SLVrfRegGetMsg) Reset()                    { *m = SLVrfRegGetMsg{} }
func (m *SLVrfRegGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLVrfRegGetMsg) ProtoMessage()               {}
func (*SLVrfRegGetMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{8} }

func (m *SLVrfRegGetMsg) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLVrfRegGetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLVrfRegGetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// VRF Get Message Response
type SLVrfRegGetMsgRsp struct {
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVrfReg `protobuf:"bytes,3,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLVrfRegGetMsgRsp) Reset()                    { *m = SLVrfRegGetMsgRsp{} }
func (m *SLVrfRegGetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLVrfRegGetMsgRsp) ProtoMessage()               {}
func (*SLVrfRegGetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{9} }

func (m *SLVrfRegGetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLVrfRegGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLVrfRegGetMsgRsp) GetEntries() []*SLVrfReg {
	if m != nil {
		return m.Entries
	}
	return nil
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRes struct {
	// VRF name as key
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
	// Num VRF Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,2,opt,name=RouteCount" json:"RouteCount,omitempty"`
}

func (m *SLVRFGetStatsMsgRes) Reset()                    { *m = SLVRFGetStatsMsgRes{} }
func (m *SLVRFGetStatsMsgRes) String() string            { return proto.CompactTextString(m) }
func (*SLVRFGetStatsMsgRes) ProtoMessage()               {}
func (*SLVRFGetStatsMsgRes) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{10} }

func (m *SLVRFGetStatsMsgRes) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLVRFGetStatsMsgRes) GetRouteCount() uint32 {
	if m != nil {
		return m.RouteCount
	}
	return 0
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRsp struct {
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof" json:"Eof,omitempty"`
	// Status of the Get Stats operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get Stats operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVRFGetStatsMsgRes `protobuf:"bytes,3,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLVRFGetStatsMsgRsp) Reset()                    { *m = SLVRFGetStatsMsgRsp{} }
func (m *SLVRFGetStatsMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLVRFGetStatsMsgRsp) ProtoMessage()               {}
func (*SLVRFGetStatsMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{11} }

func (m *SLVRFGetStatsMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLVRFGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLVRFGetStatsMsgRsp) GetEntries() []*SLVRFGetStatsMsgRes {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Common Get Notifications message
type SLRouteGetNotifMsg struct {
	// Oper = SL_NOTIFOP_ENABLE
	//   This is to enable route notifications in a VRF
	// Oper = SL_NOTIFOP_DISABLE
	//   This is to disable route notifications in a VRF
	Oper SLNotifOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLNotifOp" json:"Oper,omitempty"`
	// Correlator. This is used to correlate SLRouteGetNotifMsg with
	// SLRouteNotifStatus. The server reflects this field in the reply.
	// A client can send a SLRouteGetNotifMsg with the Correlator only.
	// Once accepted and reply is sent, VRF notifications are sent.
	// This is useful if a client wants to receive VRF notifications
	// (SLVrfNotif) only and is not interested in receiving route
	// notifications (SLRoutev4NotifRoute/SLRoutev6NotifRoute) from any VRF.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator" json:"Correlator,omitempty"`
	// Vrf that the client is interested in.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName" json:"VrfName,omitempty"`
	// Source Protocol.
	// Only routes with specified source protocol and protocol tag will be
	// notified.
	// Contact Cisco for supported protocol string names.
	SrcProto string `protobuf:"bytes,4,opt,name=SrcProto" json:"SrcProto,omitempty"`
	// Source Protocol Tag. This can be empty if N/A.
	// Contact Cisco for supported protocol tags.
	SrcProtoTag string `protobuf:"bytes,5,opt,name=SrcProtoTag" json:"SrcProtoTag,omitempty"`
}

func (m *SLRouteGetNotifMsg) Reset()                    { *m = SLRouteGetNotifMsg{} }
func (m *SLRouteGetNotifMsg) String() string            { return proto.CompactTextString(m) }
func (*SLRouteGetNotifMsg) ProtoMessage()               {}
func (*SLRouteGetNotifMsg) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{12} }

func (m *SLRouteGetNotifMsg) GetOper() SLNotifOp {
	if m != nil {
		return m.Oper
	}
	return SLNotifOp_SL_NOTIFOP_RESERVED
}

func (m *SLRouteGetNotifMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRouteGetNotifMsg) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRouteGetNotifMsg) GetSrcProto() string {
	if m != nil {
		return m.SrcProto
	}
	return ""
}

func (m *SLRouteGetNotifMsg) GetSrcProtoTag() string {
	if m != nil {
		return m.SrcProtoTag
	}
	return ""
}

// Common Route Notification Status message
type SLRouteNotifStatus struct {
	// Correlator in the request.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// Vrf in the request.
	VrfName string `protobuf:"bytes,2,opt,name=VrfName" json:"VrfName,omitempty"`
	// The NotifStatus implies one of 2 things:
	// SL_SUCCESS: signifies that the notification request was successful
	// SL_XXX: signifies an error in setting up a notification for the Vrf.
	//  Implies that notifications for this VRF will not be sent.
	NotifStatus *SLErrorStatus `protobuf:"bytes,3,opt,name=NotifStatus" json:"NotifStatus,omitempty"`
}

func (m *SLRouteNotifStatus) Reset()                    { *m = SLRouteNotifStatus{} }
func (m *SLRouteNotifStatus) String() string            { return proto.CompactTextString(m) }
func (*SLRouteNotifStatus) ProtoMessage()               {}
func (*SLRouteNotifStatus) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{13} }

func (m *SLRouteNotifStatus) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRouteNotifStatus) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRouteNotifStatus) GetNotifStatus() *SLErrorStatus {
	if m != nil {
		return m.NotifStatus
	}
	return nil
}

// Common Marker Notification message
type SLRouteNotifMarker struct {
	// Vrf that this notification message applies to.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
}

func (m *SLRouteNotifMarker) Reset()                    { *m = SLRouteNotifMarker{} }
func (m *SLRouteNotifMarker) String() string            { return proto.CompactTextString(m) }
func (*SLRouteNotifMarker) ProtoMessage()               {}
func (*SLRouteNotifMarker) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{14} }

func (m *SLRouteNotifMarker) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

// Common Vrf Notification message
type SLVrfNotif struct {
	// Vrf that this notification message applies to.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
	// Status of this Vrf: add/update/delete.
	Status SLObjectOp `protobuf:"varint,2,opt,name=Status,enum=service_layer.SLObjectOp" json:"Status,omitempty"`
}

func (m *SLVrfNotif) Reset()                    { *m = SLVrfNotif{} }
func (m *SLVrfNotif) String() string            { return proto.CompactTextString(m) }
func (*SLVrfNotif) ProtoMessage()               {}
func (*SLVrfNotif) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{15} }

func (m *SLVrfNotif) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLVrfNotif) GetStatus() SLObjectOp {
	if m != nil {
		return m.Status
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

// Common IPv4/IPv6 route attributes.
type SLRouteCommon struct {
	// Adminstrative distance of the route. [0-255].
	// RIB uses this field to break the tie when multiple
	// sources install the same route.
	// Lower distance is preferred over higher distance.
	// The per route object admin distance overrides the default's admin
	// distance set at VRF registration. see SLVrfReg
	AdminDistance uint32 `protobuf:"varint,1,opt,name=AdminDistance" json:"AdminDistance,omitempty"`
	// Local label associated with this route.
	// This is an optional field that can be used to simulatenously setup an
	// ILM entry (e.g. head end of an MPLS LSP) for the same route.
	// This is especially useful when setting up an MPLS LSP (a /32-route
	// towards the remote LSP peer e.g. 2.2.2.2/32) which is required for MPLS
	// VPN labeled routes.
	//
	// Note: MPLS VPN labeled routes can resolve only on:
	//    - /32-routes with valid LocalLabel and a valid egress MPLS path label
	LocalLabel uint32 `protobuf:"varint,2,opt,name=LocalLabel" json:"LocalLabel,omitempty"`
	// Route Tag.
	// Routes are usually tagged to prevent loops during redistribution between
	// protocols.
	Tag uint32 `protobuf:"varint,3,opt,name=Tag" json:"Tag,omitempty"`
	// Source Protocol.
	// For redistributed messages via notification stream only,
	// ignored otherwise.
	// Contact Cisco for supported protocol string names.
	SrcProto string `protobuf:"bytes,4,opt,name=SrcProto" json:"SrcProto,omitempty"`
	// Source Protocol Tag. This can be empty if N/A.
	// For redistributed messages via notification stream only,
	// ignored otherwise.
	// Contact Cisco for supported protocol tags.
	SrcProtoTag string `protobuf:"bytes,5,opt,name=SrcProtoTag" json:"SrcProtoTag,omitempty"`
}

func (m *SLRouteCommon) Reset()                    { *m = SLRouteCommon{} }
func (m *SLRouteCommon) String() string            { return proto.CompactTextString(m) }
func (*SLRouteCommon) ProtoMessage()               {}
func (*SLRouteCommon) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{16} }

func (m *SLRouteCommon) GetAdminDistance() uint32 {
	if m != nil {
		return m.AdminDistance
	}
	return 0
}

func (m *SLRouteCommon) GetLocalLabel() uint32 {
	if m != nil {
		return m.LocalLabel
	}
	return 0
}

func (m *SLRouteCommon) GetTag() uint32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *SLRouteCommon) GetSrcProto() string {
	if m != nil {
		return m.SrcProto
	}
	return ""
}

func (m *SLRouteCommon) GetSrcProtoTag() string {
	if m != nil {
		return m.SrcProtoTag
	}
	return ""
}

// Route Path attributes.
//
// FRR Note:
// Failover from primary to backup is based on the trigger used (e.g.
// link down, BFD, etc.). Revertion is mainly timeout based. The timeout
// value is platform specific and is not configurable.
type SLRoutePath struct {
	// One of IPv4 or IPv6 address
	// For ENCAP_VXLAN, this will specify the tunnel end point IP
	// address.
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress" json:"NexthopAddress,omitempty"`
	// Outgoing interface name for the path.
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface" json:"NexthopInterface,omitempty"`
	// Load metric for this path.
	// Used for equal/unequal cost load balancing of traffic distribution.
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric" json:"LoadMetric,omitempty"`
	// Path VRF name. This field is used ONLY if the path is in a different
	// VRF than the route (e.g. VPN cases)
	// For ENCAP_VXLAN, this field can be used to specify the VRF where
	// the tunnel end point IP address resides ("default" will be assumed
	// if not specified).
	VrfName string `protobuf:"bytes,4,opt,name=VrfName" json:"VrfName,omitempty"`
	// Route Metric.
	// The metric is typically based on information like load, hop count,
	// MTU, reliability of the path, etc.
	Metric uint32 `protobuf:"varint,5,opt,name=Metric" json:"Metric,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//    1. Primary. The path is the main path to carry traffic.
	//    2. Protected. A primary path with a configured backup path.
	//    3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//    1. Pure Primary i.e. Not Protected and is not a Backup.
	//       => PathId is optional. ProtectedPathBitmap = 0x0
	//    2. Primary and Protected. Path is not a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0x0
	//    3. Primary and Not Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    4. Primary and Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    5. Pure Backup. Protection is not allowed for backup paths.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//            || |-- path 4
	//            ||-- path 5
	//            |-- path 6
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack or VxLAN Virtual Network Identifier.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	// For ENCAP_VXLAN, this field will specify the Virtual Network
	// Identifier (VNI)
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used only for backup MPLS path with more than one label
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress" json:"RemoteAddress,omitempty"`
	// Encapsulation type (VXLAN or MPLS)
	EncapType SLEncapType `protobuf:"varint,10,opt,name=EncapType,enum=service_layer.SLEncapType" json:"EncapType,omitempty"`
	// VTEP (VxLAN tunnel end point) router MAC address.
	// A unique system MAC address that other VTEPs can use for inter-VNI
	// routing. The router MAC address is used as the inner destination MAC
	// address for routed VXLAN packet.
	// Used for ENCAP_VXLAN (mandatory) only.
	VtepRouterMacAddress []byte `protobuf:"bytes,11,opt,name=VtepRouterMacAddress,proto3" json:"VtepRouterMacAddress,omitempty"`
}

func (m *SLRoutePath) Reset()                    { *m = SLRoutePath{} }
func (m *SLRoutePath) String() string            { return proto.CompactTextString(m) }
func (*SLRoutePath) ProtoMessage()               {}
func (*SLRoutePath) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{17} }

func (m *SLRoutePath) GetNexthopAddress() *SLIpAddress {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *SLRoutePath) GetNexthopInterface() *SLInterface {
	if m != nil {
		return m.NexthopInterface
	}
	return nil
}

func (m *SLRoutePath) GetLoadMetric() uint32 {
	if m != nil {
		return m.LoadMetric
	}
	return 0
}

func (m *SLRoutePath) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutePath) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *SLRoutePath) GetPathId() uint32 {
	if m != nil {
		return m.PathId
	}
	return 0
}

func (m *SLRoutePath) GetProtectedPathBitmap() []uint64 {
	if m != nil {
		return m.ProtectedPathBitmap
	}
	return nil
}

func (m *SLRoutePath) GetLabelStack() []uint32 {
	if m != nil {
		return m.LabelStack
	}
	return nil
}

func (m *SLRoutePath) GetRemoteAddress() []*SLIpAddress {
	if m != nil {
		return m.RemoteAddress
	}
	return nil
}

func (m *SLRoutePath) GetEncapType() SLEncapType {
	if m != nil {
		return m.EncapType
	}
	return SLEncapType_SL_ENCAP_RESERVED
}

func (m *SLRoutePath) GetVtepRouterMacAddress() []byte {
	if m != nil {
		return m.VtepRouterMacAddress
	}
	return nil
}

func init() {
	proto.RegisterType((*SLRouteGlobalsGetMsg)(nil), "service_layer.SLRouteGlobalsGetMsg")
	proto.RegisterType((*SLRouteGlobalsGetMsgRsp)(nil), "service_layer.SLRouteGlobalsGetMsgRsp")
	proto.RegisterType((*SLRouteGlobalStatsGetMsg)(nil), "service_layer.SLRouteGlobalStatsGetMsg")
	proto.RegisterType((*SLRouteGlobalStatsGetMsgRsp)(nil), "service_layer.SLRouteGlobalStatsGetMsgRsp")
	proto.RegisterType((*SLVrfReg)(nil), "service_layer.SLVrfReg")
	proto.RegisterType((*SLVrfRegMsg)(nil), "service_layer.SLVrfRegMsg")
	proto.RegisterType((*SLVrfRegMsgRes)(nil), "service_layer.SLVrfRegMsgRes")
	proto.RegisterType((*SLVrfRegMsgRsp)(nil), "service_layer.SLVrfRegMsgRsp")
	proto.RegisterType((*SLVrfRegGetMsg)(nil), "service_layer.SLVrfRegGetMsg")
	proto.RegisterType((*SLVrfRegGetMsgRsp)(nil), "service_layer.SLVrfRegGetMsgRsp")
	proto.RegisterType((*SLVRFGetStatsMsgRes)(nil), "service_layer.SLVRFGetStatsMsgRes")
	proto.RegisterType((*SLVRFGetStatsMsgRsp)(nil), "service_layer.SLVRFGetStatsMsgRsp")
	proto.RegisterType((*SLRouteGetNotifMsg)(nil), "service_layer.SLRouteGetNotifMsg")
	proto.RegisterType((*SLRouteNotifStatus)(nil), "service_layer.SLRouteNotifStatus")
	proto.RegisterType((*SLRouteNotifMarker)(nil), "service_layer.SLRouteNotifMarker")
	proto.RegisterType((*SLVrfNotif)(nil), "service_layer.SLVrfNotif")
	proto.RegisterType((*SLRouteCommon)(nil), "service_layer.SLRouteCommon")
	proto.RegisterType((*SLRoutePath)(nil), "service_layer.SLRoutePath")
	proto.RegisterEnum("service_layer.SLNotifType", SLNotifType_name, SLNotifType_value)
}

func init() { proto.RegisterFile("sl_route_common.proto", fileDescriptor7) }

var fileDescriptor7 = []byte{
	// 993 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xc6, 0x49, 0x9a, 0xa6, 0xa7, 0x9b, 0x2a, 0xcc, 0xf6, 0xc7, 0x84, 0x05, 0xad, 0x2c, 0x2e,
	0xd0, 0x0a, 0x55, 0x6c, 0x41, 0x02, 0x21, 0x84, 0xe8, 0x6e, 0xbd, 0xab, 0x8a, 0xa4, 0xa9, 0xc6,
	0xd9, 0x4a, 0x7b, 0x15, 0x4d, 0x9c, 0x49, 0x1a, 0x36, 0x8e, 0xad, 0xf1, 0x04, 0xb5, 0xf7, 0x70,
	0x09, 0x57, 0xf0, 0x00, 0x5c, 0xf0, 0x12, 0x48, 0xbc, 0x00, 0x4f, 0xc5, 0x99, 0xb1, 0x9d, 0x78,
	0x6a, 0x27, 0x80, 0xba, 0x57, 0xf1, 0x9c, 0xf3, 0x9d, 0x39, 0xdf, 0xf9, 0x9d, 0xc0, 0x41, 0x3c,
	0x1b, 0x88, 0x70, 0x21, 0xf9, 0xc0, 0x0f, 0x83, 0x20, 0x9c, 0x1f, 0x47, 0x22, 0x94, 0x21, 0x69,
	0xc6, 0x5c, 0xfc, 0x30, 0xf5, 0xf9, 0x60, 0xc6, 0x6e, 0xb9, 0x68, 0x2b, 0x54, 0xa2, 0x1f, 0xc8,
	0xdb, 0x88, 0xc7, 0x09, 0xca, 0x39, 0x84, 0x7d, 0xaf, 0x43, 0x95, 0xf5, 0xcb, 0x59, 0x38, 0x64,
	0xb3, 0xf8, 0x25, 0x97, 0xdd, 0x78, 0xe2, 0xfc, 0x65, 0xc1, 0x51, 0x99, 0x82, 0xc6, 0x11, 0xf9,
	0x0a, 0x76, 0x5c, 0x21, 0x3c, 0xc9, 0xe4, 0x22, 0xb6, 0xad, 0xc7, 0xd6, 0xc7, 0xbb, 0x27, 0x8f,
	0x8e, 0x0d, 0x6f, 0xc7, 0x5e, 0x07, 0x11, 0x61, 0x8a, 0xa1, 0x2b, 0x38, 0xf9, 0x1c, 0x0e, 0xba,
	0xec, 0xe6, 0x4a, 0x8c, 0x05, 0x9f, 0x5c, 0x72, 0x91, 0x7c, 0x04, 0xf1, 0xc4, 0xae, 0xe0, 0x3d,
	0x4d, 0x5a, 0xae, 0x24, 0x9f, 0xc2, 0x43, 0x54, 0x68, 0x36, 0x28, 0xd7, 0xbf, 0xca, 0xa6, 0xaa,
	0x6d, 0xca, 0x54, 0x4e, 0x1b, 0x6c, 0x83, 0xbe, 0x72, 0x9f, 0xc5, 0xf6, 0x9b, 0x05, 0xef, 0xaf,
	0x53, 0xde, 0x37, 0xbe, 0x36, 0x34, 0x90, 0xf6, 0xf3, 0x70, 0x31, 0x97, 0x69, 0x48, 0xcb, 0x33,
	0xf9, 0x10, 0x40, 0x3b, 0x4d, 0xb4, 0x09, 0xf9, 0x9c, 0xc4, 0xf9, 0xd1, 0x82, 0x86, 0xd7, 0x41,
	0x38, 0xe5, 0x13, 0x62, 0xc3, 0x36, 0x7e, 0x5d, 0xb0, 0x80, 0x6b, 0x0a, 0x3b, 0x34, 0x3b, 0x92,
	0x8f, 0xa0, 0x79, 0x3a, 0x0a, 0xa6, 0xf3, 0xb3, 0x69, 0x2c, 0xd9, 0xdc, 0xe7, 0xa9, 0x1f, 0x53,
	0x48, 0xbe, 0x84, 0x23, 0x34, 0xb8, 0x5c, 0x88, 0x09, 0x3f, 0x9f, 0x4b, 0x24, 0x8f, 0x61, 0x72,
	0x3f, 0x9c, 0x8f, 0xe2, 0xd4, 0xf3, 0x3a, 0xb5, 0x23, 0x60, 0x37, 0x63, 0x81, 0x09, 0x21, 0x4f,
	0xa0, 0xd6, 0x8b, 0xb8, 0xd0, 0x2c, 0xf6, 0x4e, 0x0e, 0x0b, 0x89, 0x40, 0x58, 0x2f, 0xa2, 0x1a,
	0x43, 0xbe, 0x00, 0x58, 0x1a, 0xc6, 0xc8, 0xab, 0x8a, 0xa9, 0x3b, 0x2a, 0x58, 0x24, 0x10, 0x9a,
	0x83, 0x3a, 0x63, 0xd8, 0xcb, 0xf9, 0xa4, 0x3c, 0xbe, 0x57, 0x11, 0x72, 0xb9, 0xab, 0x18, 0xb9,
	0x73, 0x7e, 0xb6, 0x4c, 0x47, 0x58, 0xed, 0x67, 0xd0, 0x4c, 0xcc, 0xbc, 0x45, 0x10, 0x30, 0x71,
	0xfb, 0x9f, 0x9c, 0x99, 0x26, 0x18, 0xf7, 0x36, 0x72, 0x5e, 0xcc, 0x64, 0x16, 0xf4, 0x07, 0x6b,
	0x82, 0x4e, 0x82, 0xa3, 0x19, 0xda, 0xb9, 0x5e, 0xd1, 0x49, 0xfa, 0x6f, 0x43, 0xdd, 0x1d, 0x78,
	0xe0, 0xce, 0xa5, 0x98, 0xf2, 0x38, 0xdf, 0x5e, 0x86, 0x4c, 0x59, 0xe3, 0x3d, 0x17, 0xfc, 0x26,
	0xe9, 0xaf, 0x06, 0xcd, 0x8e, 0xce, 0xaf, 0x16, 0xbc, 0x6b, 0xba, 0x52, 0xc1, 0xb7, 0xa0, 0xea,
	0x86, 0x63, 0xed, 0xa9, 0x41, 0xd5, 0xa7, 0x99, 0xf7, 0xca, 0xff, 0xcb, 0xfb, 0x53, 0xd8, 0x4e,
	0xd9, 0xa0, 0xf7, 0x8d, 0xb5, 0xcf, 0x70, 0x4e, 0x0f, 0x1e, 0xa2, 0x90, 0xbe, 0x40, 0x4a, 0x7a,
	0x0a, 0xd3, 0xea, 0xaf, 0xcf, 0x82, 0x39, 0x44, 0x95, 0xc2, 0x10, 0xfd, 0x6e, 0x95, 0xdc, 0xf8,
	0xd6, 0x23, 0xfd, 0xfa, 0x6e, 0xa4, 0x4e, 0x31, 0xd2, 0xbb, 0x41, 0xad, 0x82, 0xfe, 0xd3, 0x02,
	0x92, 0x2d, 0x20, 0x2c, 0x4f, 0x28, 0xa7, 0x63, 0x55, 0xfa, 0x4f, 0x8c, 0x49, 0xb3, 0x0b, 0x37,
	0x6a, 0xe0, 0x72, 0xd6, 0x30, 0x11, 0xcf, 0x43, 0x21, 0xf8, 0x8c, 0xc9, 0x50, 0x68, 0xfe, 0x35,
	0x9a, 0x93, 0xe4, 0x53, 0x58, 0x35, 0x53, 0x88, 0x3b, 0xca, 0x13, 0xfe, 0xa5, 0xda, 0xff, 0x76,
	0x4d, 0xab, 0x96, 0x67, 0xf2, 0x18, 0x87, 0x3f, 0xfd, 0xee, 0xb3, 0x89, 0xbd, 0xa5, 0xd5, 0x79,
	0x91, 0xf3, 0xcb, 0x8a, 0xbc, 0x26, 0x94, 0x66, 0xc4, 0xa4, 0x63, 0x6d, 0xa2, 0x63, 0xce, 0x24,
	0xf9, 0x06, 0x76, 0x73, 0x17, 0x69, 0xb2, 0xff, 0x56, 0x89, 0xbc, 0x81, 0x73, 0x6c, 0xf2, 0xe9,
	0x32, 0xf1, 0x86, 0x8b, 0xf5, 0x1d, 0xe4, 0xbc, 0x06, 0xd0, 0x7d, 0xa8, 0xd1, 0x1b, 0x3a, 0xed,
	0x29, 0xd4, 0x73, 0xcd, 0xb1, 0x77, 0xf2, 0x5e, 0x81, 0x52, 0x6f, 0xf8, 0x3d, 0xf7, 0x25, 0x56,
	0x24, 0x05, 0x3a, 0x7f, 0x58, 0xb8, 0x4c, 0x3a, 0x69, 0x37, 0xaa, 0xb7, 0xb6, 0xb8, 0xac, 0xad,
	0xb2, 0x65, 0x8d, 0xc9, 0xeb, 0x84, 0x3e, 0x9b, 0x75, 0xd8, 0x90, 0xcf, 0xb2, 0xa6, 0x5e, 0x49,
	0x54, 0xf3, 0xaa, 0x6a, 0x24, 0x8b, 0x5b, 0x7d, 0xde, 0xb3, 0x86, 0x3f, 0xd5, 0xd4, 0x8e, 0x4f,
	0x1e, 0x4d, 0x26, 0xaf, 0x71, 0x07, 0xee, 0xa9, 0x25, 0x71, 0x1d, 0x46, 0xa7, 0xa3, 0x91, 0xe0,
	0x71, 0xb6, 0x71, 0xdb, 0x85, 0x90, 0xcf, 0x33, 0x04, 0xbd, 0x63, 0x41, 0x5e, 0x40, 0x2b, 0x95,
	0xe8, 0x07, 0x65, 0xcc, 0xd2, 0x97, 0xa9, 0xf4, 0x96, 0x0c, 0x41, 0x0b, 0x36, 0x49, 0x2e, 0xd8,
	0xa8, 0xcb, 0x71, 0x56, 0xfc, 0xec, 0x95, 0x5c, 0x49, 0xf2, 0x05, 0xab, 0x99, 0x05, 0x3b, 0x84,
	0x7a, 0x6a, 0xb5, 0xa5, 0xad, 0xd2, 0x93, 0x92, 0xab, 0x28, 0xcf, 0x47, 0x76, 0x3d, 0x91, 0x27,
	0x27, 0xf5, 0xaf, 0x42, 0x65, 0x04, 0x4b, 0xc8, 0x47, 0x4a, 0xf4, 0x6c, 0x2a, 0x03, 0x16, 0xd9,
	0xdb, 0x38, 0xd0, 0x35, 0x5a, 0xa6, 0xd2, 0xdc, 0x54, 0x41, 0xb0, 0xdc, 0xfe, 0x1b, 0xbb, 0x81,
	0x40, 0xc5, 0x6d, 0x29, 0x21, 0xdf, 0x42, 0x93, 0xf2, 0x00, 0xed, 0xb2, 0x34, 0xee, 0xe8, 0xe5,
	0xb0, 0x29, 0x8d, 0xa6, 0x01, 0x3e, 0xdb, 0x3b, 0xee, 0xdc, 0x67, 0x51, 0x1f, 0xff, 0xa3, 0xd9,
	0xa0, 0xfb, 0xae, 0x68, 0xbd, 0x44, 0xd0, 0x15, 0x98, 0x9c, 0xc0, 0xfe, 0x95, 0xe4, 0x91, 0x2e,
	0xaa, 0xe8, 0x32, 0x3f, 0xa3, 0xb0, 0x8b, 0x97, 0x3c, 0xa0, 0xa5, 0xba, 0x27, 0x7f, 0x5b, 0xaa,
	0x0f, 0xf4, 0x20, 0xe8, 0x3b, 0xda, 0x70, 0xe8, 0x75, 0x06, 0xee, 0x95, 0x7b, 0xd1, 0x1f, 0xf4,
	0x5f, 0x5f, 0xba, 0x03, 0xea, 0x7a, 0x2e, 0xbd, 0x72, 0xcf, 0x5a, 0xef, 0x90, 0x23, 0xb5, 0x57,
	0xf3, 0x3a, 0x97, 0xd2, 0x1e, 0x6d, 0x59, 0x58, 0x90, 0x7d, 0x53, 0xe1, 0xf5, 0x4f, 0xfb, 0xaf,
	0xbc, 0x56, 0xa5, 0x68, 0x42, 0x7b, 0xaf, 0xfa, 0x6e, 0xab, 0x8a, 0x79, 0x6c, 0x17, 0x4c, 0x68,
	0x7f, 0xd0, 0x3d, 0xa5, 0xdf, 0xb9, 0xb4, 0x55, 0x23, 0x8f, 0xd4, 0xbf, 0x37, 0xc3, 0xd7, 0xc5,
	0x59, 0xa6, 0xdd, 0x22, 0x07, 0xea, 0x25, 0xcb, 0x6b, 0x71, 0xd5, 0xb6, 0xea, 0xc3, 0xba, 0xfe,
	0x47, 0xfb, 0xd9, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x63, 0xba, 0xe9, 0x5a, 0x10, 0x0b, 0x00,
	0x00,
}
