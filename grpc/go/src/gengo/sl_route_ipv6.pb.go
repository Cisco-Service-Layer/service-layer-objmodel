// @file
// @brief Server RPC proto file for IPv6.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016 by cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0-devel
// 	protoc        v3.12.1
// source: sl_route_ipv6.proto

package service_layer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// IPv6 route
type SLRoutev6 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IPv6 Prefix
	//0:: - ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
	Prefix []byte `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length [0-128]
	PrefixLen uint32 `protobuf:"varint,2,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// Common route attributes
	RouteCommon *SLRouteCommon `protobuf:"bytes,3,opt,name=RouteCommon,proto3" json:"RouteCommon,omitempty"`
	// List of route paths for a particular route.
	// Specifying more than one path is allowed for ECMP/UCMP cases
	PathList []*SLRoutePath `protobuf:"bytes,4,rep,name=PathList,proto3" json:"PathList,omitempty"`
}

func (x *SLRoutev6) Reset() {
	*x = SLRoutev6{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6) ProtoMessage() {}

func (x *SLRoutev6) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6.ProtoReflect.Descriptor instead.
func (*SLRoutev6) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{0}
}

func (x *SLRoutev6) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *SLRoutev6) GetPrefixLen() uint32 {
	if x != nil {
		return x.PrefixLen
	}
	return 0
}

func (x *SLRoutev6) GetRouteCommon() *SLRouteCommon {
	if x != nil {
		return x.RouteCommon
	}
	return nil
}

func (x *SLRoutev6) GetPathList() []*SLRoutePath {
	if x != nil {
		return x.PathList
	}
	return nil
}

// List of routes for bulk download
type SLRoutev6Msg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Route Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// VRF name.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// List of routes for the VRF specified above
	Routes []*SLRoutev6 `protobuf:"bytes,4,rep,name=Routes,proto3" json:"Routes,omitempty"`
}

func (x *SLRoutev6Msg) Reset() {
	*x = SLRoutev6Msg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6Msg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6Msg) ProtoMessage() {}

func (x *SLRoutev6Msg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6Msg.ProtoReflect.Descriptor instead.
func (*SLRoutev6Msg) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{1}
}

func (x *SLRoutev6Msg) GetOper() SLObjectOp {
	if x != nil {
		return x.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (x *SLRoutev6Msg) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRoutev6Msg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutev6Msg) GetRoutes() []*SLRoutev6 {
	if x != nil {
		return x.Routes
	}
	return nil
}

// IPv6 route result, uniquely identified by the Prefix/PrefixLen pair
type SLRoutev6Res struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// IPv6 Prefix
	Prefix []byte `protobuf:"bytes,2,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length, [0-32]
	PrefixLen uint32 `protobuf:"varint,3,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
}

func (x *SLRoutev6Res) Reset() {
	*x = SLRoutev6Res{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6Res) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6Res) ProtoMessage() {}

func (x *SLRoutev6Res) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6Res.ProtoReflect.Descriptor instead.
func (*SLRoutev6Res) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{2}
}

func (x *SLRoutev6Res) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRoutev6Res) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *SLRoutev6Res) GetPrefixLen() uint32 {
	if x != nil {
		return x.PrefixLen
	}
	return 0
}

// IPv6 bulk route result status
type SLRoutev6MsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// VRF name (matches the VRF name of the original operation)
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,3,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLRoutev6Res `protobuf:"bytes,4,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLRoutev6MsgRsp) Reset() {
	*x = SLRoutev6MsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6MsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6MsgRsp) ProtoMessage() {}

func (x *SLRoutev6MsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6MsgRsp.ProtoReflect.Descriptor instead.
func (*SLRoutev6MsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{3}
}

func (x *SLRoutev6MsgRsp) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRoutev6MsgRsp) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutev6MsgRsp) GetStatusSummary() *SLErrorStatus {
	if x != nil {
		return x.StatusSummary
	}
	return nil
}

func (x *SLRoutev6MsgRsp) GetResults() []*SLRoutev6Res {
	if x != nil {
		return x.Results
	}
	return nil
}

// Used to retrieve route attributes
type SLRoutev6GetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// VRF name.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// IPv6 Prefix
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length, [0-32]
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,5,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,6,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
}

func (x *SLRoutev6GetMsg) Reset() {
	*x = SLRoutev6GetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6GetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6GetMsg) ProtoMessage() {}

func (x *SLRoutev6GetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6GetMsg.ProtoReflect.Descriptor instead.
func (*SLRoutev6GetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{4}
}

func (x *SLRoutev6GetMsg) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRoutev6GetMsg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutev6GetMsg) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *SLRoutev6GetMsg) GetPrefixLen() uint32 {
	if x != nil {
		return x.PrefixLen
	}
	return 0
}

func (x *SLRoutev6GetMsg) GetEntriesCount() uint32 {
	if x != nil {
		return x.EntriesCount
	}
	return 0
}

func (x *SLRoutev6GetMsg) GetGetNext() bool {
	if x != nil {
		return x.GetNext
	}
	return false
}

// Gt Route message response
type SLRoutev6GetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,2,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// VRF name.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,4,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLRoutev6 `protobuf:"bytes,5,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLRoutev6GetMsgRsp) Reset() {
	*x = SLRoutev6GetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6GetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6GetMsgRsp) ProtoMessage() {}

func (x *SLRoutev6GetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6GetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLRoutev6GetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{5}
}

func (x *SLRoutev6GetMsgRsp) GetCorrelator() uint64 {
	if x != nil {
		return x.Correlator
	}
	return 0
}

func (x *SLRoutev6GetMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLRoutev6GetMsgRsp) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutev6GetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRoutev6GetMsgRsp) GetEntries() []*SLRoutev6 {
	if x != nil {
		return x.Entries
	}
	return nil
}

// IPv6 Route notification
type SLRoutev6NotifRoute struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF name.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// IPv6 routes
	Entries []*SLRoutev6 `protobuf:"bytes,2,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLRoutev6NotifRoute) Reset() {
	*x = SLRoutev6NotifRoute{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6NotifRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6NotifRoute) ProtoMessage() {}

func (x *SLRoutev6NotifRoute) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6NotifRoute.ProtoReflect.Descriptor instead.
func (*SLRoutev6NotifRoute) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{6}
}

func (x *SLRoutev6NotifRoute) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutev6NotifRoute) GetEntries() []*SLRoutev6 {
	if x != nil {
		return x.Entries
	}
	return nil
}

// IPv6 notification message
type SLRoutev6Notif struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Event Type
	EventType SLNotifType `protobuf:"varint,1,opt,name=EventType,proto3,enum=service_layer.SLNotifType" json:"EventType,omitempty"`
	// Further info based on EventType
	//
	// Types that are assignable to Event:
	//	*SLRoutev6Notif_ErrStatus
	//	*SLRoutev6Notif_NotifStatus
	//	*SLRoutev6Notif_Route
	//	*SLRoutev6Notif_Marker
	//	*SLRoutev6Notif_Vrf
	Event isSLRoutev6Notif_Event `protobuf_oneof:"Event"`
}

func (x *SLRoutev6Notif) Reset() {
	*x = SLRoutev6Notif{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_ipv6_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutev6Notif) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutev6Notif) ProtoMessage() {}

func (x *SLRoutev6Notif) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_ipv6_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutev6Notif.ProtoReflect.Descriptor instead.
func (*SLRoutev6Notif) Descriptor() ([]byte, []int) {
	return file_sl_route_ipv6_proto_rawDescGZIP(), []int{7}
}

func (x *SLRoutev6Notif) GetEventType() SLNotifType {
	if x != nil {
		return x.EventType
	}
	return SLNotifType_SL_EVENT_TYPE_RESERVED
}

func (m *SLRoutev6Notif) GetEvent() isSLRoutev6Notif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (x *SLRoutev6Notif) GetErrStatus() *SLErrorStatus {
	if x, ok := x.GetEvent().(*SLRoutev6Notif_ErrStatus); ok {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRoutev6Notif) GetNotifStatus() *SLRouteNotifStatus {
	if x, ok := x.GetEvent().(*SLRoutev6Notif_NotifStatus); ok {
		return x.NotifStatus
	}
	return nil
}

func (x *SLRoutev6Notif) GetRoute() *SLRoutev6NotifRoute {
	if x, ok := x.GetEvent().(*SLRoutev6Notif_Route); ok {
		return x.Route
	}
	return nil
}

func (x *SLRoutev6Notif) GetMarker() *SLRouteNotifMarker {
	if x, ok := x.GetEvent().(*SLRoutev6Notif_Marker); ok {
		return x.Marker
	}
	return nil
}

func (x *SLRoutev6Notif) GetVrf() *SLVrfNotif {
	if x, ok := x.GetEvent().(*SLRoutev6Notif_Vrf); ok {
		return x.Vrf
	}
	return nil
}

type isSLRoutev6Notif_Event interface {
	isSLRoutev6Notif_Event()
}

type SLRoutev6Notif_ErrStatus struct {
	// case EventType == SL_EVENT_TYPE_ERROR:
	//    => This field carries error info, if any error occurs during
	//       notification stream setup.
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3,oneof"`
}

type SLRoutev6Notif_NotifStatus struct {
	// case EventType == SL_EVENT_TYPE_STATUS:
	//    => This field carries the status of the GetNotifMsg request.
	NotifStatus *SLRouteNotifStatus `protobuf:"bytes,3,opt,name=NotifStatus,proto3,oneof"`
}

type SLRoutev6Notif_Route struct {
	// case EventType == SL_EVENT_TYPE_ROUTE:
	//    => This field carries the v6 route
	Route *SLRoutev6NotifRoute `protobuf:"bytes,4,opt,name=Route,proto3,oneof"`
}

type SLRoutev6Notif_Marker struct {
	// case EventType == SL_EVENT_TYPE_START_MARKER:
	// case EventType == SL_EVENT_TYPE_END_MARKER:
	//    => This field carries the start marker and end marker per-VRF.
	Marker *SLRouteNotifMarker `protobuf:"bytes,5,opt,name=Marker,proto3,oneof"`
}

type SLRoutev6Notif_Vrf struct {
	// case EventType == SL_EVENT_TYPE_VRF:
	Vrf *SLVrfNotif `protobuf:"bytes,6,opt,name=Vrf,proto3,oneof"`
}

func (*SLRoutev6Notif_ErrStatus) isSLRoutev6Notif_Event() {}

func (*SLRoutev6Notif_NotifStatus) isSLRoutev6Notif_Event() {}

func (*SLRoutev6Notif_Route) isSLRoutev6Notif_Event() {}

func (*SLRoutev6Notif_Marker) isSLRoutev6Notif_Event() {}

func (*SLRoutev6Notif_Vrf) isSLRoutev6Notif_Event() {}

var File_sl_route_ipv6_proto protoreflect.FileDescriptor

var file_sl_route_ipv6_proto_rawDesc = []byte{
	0x0a, 0x13, 0x73, 0x6c, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x70, 0x76, 0x36, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x1a, 0x15, 0x73, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x5f,
	0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x15, 0x73, 0x6c, 0x5f,
	0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xb9, 0x01, 0x0a, 0x09, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36,
	0x12, 0x16, 0x0a, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x1c, 0x0a, 0x09, 0x50, 0x72, 0x65, 0x66,
	0x69, 0x78, 0x4c, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x50, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x12, 0x3e, 0x0a, 0x0b, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f,
	0x75, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x52, 0x0b, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x12, 0x36, 0x0a, 0x08, 0x50, 0x61, 0x74, 0x68, 0x4c, 0x69,
	0x73, 0x74, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x50, 0x61, 0x74, 0x68, 0x52, 0x08, 0x50, 0x61, 0x74, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x22, 0xa9,
	0x01, 0x0a, 0x0c, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4d, 0x73, 0x67, 0x12,
	0x2d, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x1e,
	0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x18,
	0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x30, 0x0a, 0x06, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x76, 0x36, 0x52, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x80, 0x01, 0x0a, 0x0c, 0x53,
	0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x52, 0x65, 0x73, 0x12, 0x3a, 0x0a, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69,
	0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12,
	0x1c, 0x0a, 0x09, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x09, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x22, 0xc6, 0x01,
	0x0a, 0x0f, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4d, 0x73, 0x67, 0x52, 0x73,
	0x70, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f,
	0x72, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x42, 0x0a, 0x0d, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12,
	0x35, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x52, 0x65, 0x73, 0x52, 0x07, 0x52,
	0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0xbf, 0x01, 0x0a, 0x0f, 0x53, 0x4c, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x76, 0x36, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6f,
	0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a,
	0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72,
	0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x1c, 0x0a, 0x09,
	0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x09, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x45, 0x6e,
	0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18,
	0x0a, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x07, 0x47, 0x65, 0x74, 0x4e, 0x65, 0x78, 0x74, 0x22, 0xd0, 0x01, 0x0a, 0x12, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12,
	0x1e, 0x0a, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0a, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x12,
	0x10, 0x0a, 0x03, 0x45, 0x6f, 0x66, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f,
	0x66, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x3a, 0x0a, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x32, 0x0a, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x76, 0x36, 0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x63, 0x0a, 0x13, 0x53,
	0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x32, 0x0a, 0x07,
	0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x22, 0x80, 0x03, 0x0a, 0x0e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4e, 0x6f,
	0x74, 0x69, 0x66, 0x12, 0x38, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x09, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x3c, 0x0a,
	0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00,
	0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x45, 0x0a, 0x0b, 0x4e,
	0x6f, 0x74, 0x69, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x0b, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x3a, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4e, 0x6f, 0x74, 0x69, 0x66,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x48, 0x00, 0x52, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x3b,
	0x0a, 0x06, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x4d, 0x61, 0x72, 0x6b, 0x65,
	0x72, 0x48, 0x00, 0x52, 0x06, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x2d, 0x0a, 0x03, 0x56,
	0x72, 0x66, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x4e, 0x6f,
	0x74, 0x69, 0x66, 0x48, 0x00, 0x52, 0x03, 0x56, 0x72, 0x66, 0x42, 0x07, 0x0a, 0x05, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x32, 0x98, 0x07, 0x0a, 0x0d, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76,
	0x36, 0x4f, 0x70, 0x65, 0x72, 0x12, 0x62, 0x0a, 0x13, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x76, 0x36, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x12, 0x23, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73,
	0x67, 0x1a, 0x26, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x6e, 0x0a, 0x17, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74,
	0x73, 0x47, 0x65, 0x74, 0x12, 0x27, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62,
	0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x2a, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x4e, 0x0a, 0x11, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4f, 0x70, 0x12, 0x1a,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x1a, 0x1d, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66,
	0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x55, 0x0a, 0x12, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x12,
	0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x20,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70,
	0x12, 0x59, 0x0a, 0x14, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x56, 0x72, 0x66,
	0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65,
	0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x22, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74,
	0x53, 0x74, 0x61, 0x74, 0x73, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x4a, 0x0a, 0x0b, 0x53,
	0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4f, 0x70, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x76, 0x36, 0x4d, 0x73, 0x67, 0x1a, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76,
	0x36, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x51, 0x0a, 0x0c, 0x53, 0x4c, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x76, 0x36, 0x47, 0x65, 0x74, 0x12, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76,
	0x36, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76,
	0x36, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x54, 0x0a, 0x11, 0x53, 0x4c,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4f, 0x70, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12,
	0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4d, 0x73, 0x67, 0x1a, 0x1e, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x28, 0x01, 0x30, 0x01,
	0x12, 0x5b, 0x0a, 0x12, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x47, 0x65, 0x74,
	0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x1a, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x28, 0x01, 0x30, 0x01, 0x12, 0x5f, 0x0a,
	0x17, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x76, 0x36, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74,
	0x69, 0x66, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x4d, 0x73, 0x67, 0x1a, 0x1d, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x52, 0x6f,
	0x75, 0x74, 0x65, 0x76, 0x36, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x28, 0x01, 0x30, 0x01, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_route_ipv6_proto_rawDescOnce sync.Once
	file_sl_route_ipv6_proto_rawDescData = file_sl_route_ipv6_proto_rawDesc
)

func file_sl_route_ipv6_proto_rawDescGZIP() []byte {
	file_sl_route_ipv6_proto_rawDescOnce.Do(func() {
		file_sl_route_ipv6_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_route_ipv6_proto_rawDescData)
	})
	return file_sl_route_ipv6_proto_rawDescData
}

var file_sl_route_ipv6_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_sl_route_ipv6_proto_goTypes = []interface{}{
	(*SLRoutev6)(nil),                   // 0: service_layer.SLRoutev6
	(*SLRoutev6Msg)(nil),                // 1: service_layer.SLRoutev6Msg
	(*SLRoutev6Res)(nil),                // 2: service_layer.SLRoutev6Res
	(*SLRoutev6MsgRsp)(nil),             // 3: service_layer.SLRoutev6MsgRsp
	(*SLRoutev6GetMsg)(nil),             // 4: service_layer.SLRoutev6GetMsg
	(*SLRoutev6GetMsgRsp)(nil),          // 5: service_layer.SLRoutev6GetMsgRsp
	(*SLRoutev6NotifRoute)(nil),         // 6: service_layer.SLRoutev6NotifRoute
	(*SLRoutev6Notif)(nil),              // 7: service_layer.SLRoutev6Notif
	(*SLRouteCommon)(nil),               // 8: service_layer.SLRouteCommon
	(*SLRoutePath)(nil),                 // 9: service_layer.SLRoutePath
	(SLObjectOp)(0),                     // 10: service_layer.SLObjectOp
	(*SLErrorStatus)(nil),               // 11: service_layer.SLErrorStatus
	(SLNotifType)(0),                    // 12: service_layer.SLNotifType
	(*SLRouteNotifStatus)(nil),          // 13: service_layer.SLRouteNotifStatus
	(*SLRouteNotifMarker)(nil),          // 14: service_layer.SLRouteNotifMarker
	(*SLVrfNotif)(nil),                  // 15: service_layer.SLVrfNotif
	(*SLRouteGlobalsGetMsg)(nil),        // 16: service_layer.SLRouteGlobalsGetMsg
	(*SLRouteGlobalStatsGetMsg)(nil),    // 17: service_layer.SLRouteGlobalStatsGetMsg
	(*SLVrfRegMsg)(nil),                 // 18: service_layer.SLVrfRegMsg
	(*SLVrfRegGetMsg)(nil),              // 19: service_layer.SLVrfRegGetMsg
	(*SLRouteGetNotifMsg)(nil),          // 20: service_layer.SLRouteGetNotifMsg
	(*SLRouteGlobalsGetMsgRsp)(nil),     // 21: service_layer.SLRouteGlobalsGetMsgRsp
	(*SLRouteGlobalStatsGetMsgRsp)(nil), // 22: service_layer.SLRouteGlobalStatsGetMsgRsp
	(*SLVrfRegMsgRsp)(nil),              // 23: service_layer.SLVrfRegMsgRsp
	(*SLVrfRegGetMsgRsp)(nil),           // 24: service_layer.SLVrfRegGetMsgRsp
	(*SLVRFGetStatsMsgRsp)(nil),         // 25: service_layer.SLVRFGetStatsMsgRsp
}
var file_sl_route_ipv6_proto_depIdxs = []int32{
	8,  // 0: service_layer.SLRoutev6.RouteCommon:type_name -> service_layer.SLRouteCommon
	9,  // 1: service_layer.SLRoutev6.PathList:type_name -> service_layer.SLRoutePath
	10, // 2: service_layer.SLRoutev6Msg.Oper:type_name -> service_layer.SLObjectOp
	0,  // 3: service_layer.SLRoutev6Msg.Routes:type_name -> service_layer.SLRoutev6
	11, // 4: service_layer.SLRoutev6Res.ErrStatus:type_name -> service_layer.SLErrorStatus
	11, // 5: service_layer.SLRoutev6MsgRsp.StatusSummary:type_name -> service_layer.SLErrorStatus
	2,  // 6: service_layer.SLRoutev6MsgRsp.Results:type_name -> service_layer.SLRoutev6Res
	11, // 7: service_layer.SLRoutev6GetMsgRsp.ErrStatus:type_name -> service_layer.SLErrorStatus
	0,  // 8: service_layer.SLRoutev6GetMsgRsp.Entries:type_name -> service_layer.SLRoutev6
	0,  // 9: service_layer.SLRoutev6NotifRoute.Entries:type_name -> service_layer.SLRoutev6
	12, // 10: service_layer.SLRoutev6Notif.EventType:type_name -> service_layer.SLNotifType
	11, // 11: service_layer.SLRoutev6Notif.ErrStatus:type_name -> service_layer.SLErrorStatus
	13, // 12: service_layer.SLRoutev6Notif.NotifStatus:type_name -> service_layer.SLRouteNotifStatus
	6,  // 13: service_layer.SLRoutev6Notif.Route:type_name -> service_layer.SLRoutev6NotifRoute
	14, // 14: service_layer.SLRoutev6Notif.Marker:type_name -> service_layer.SLRouteNotifMarker
	15, // 15: service_layer.SLRoutev6Notif.Vrf:type_name -> service_layer.SLVrfNotif
	16, // 16: service_layer.SLRoutev6Oper.SLRoutev6GlobalsGet:input_type -> service_layer.SLRouteGlobalsGetMsg
	17, // 17: service_layer.SLRoutev6Oper.SLRoutev6GlobalStatsGet:input_type -> service_layer.SLRouteGlobalStatsGetMsg
	18, // 18: service_layer.SLRoutev6Oper.SLRoutev6VrfRegOp:input_type -> service_layer.SLVrfRegMsg
	19, // 19: service_layer.SLRoutev6Oper.SLRoutev6VrfRegGet:input_type -> service_layer.SLVrfRegGetMsg
	19, // 20: service_layer.SLRoutev6Oper.SLRoutev6VrfGetStats:input_type -> service_layer.SLVrfRegGetMsg
	1,  // 21: service_layer.SLRoutev6Oper.SLRoutev6Op:input_type -> service_layer.SLRoutev6Msg
	4,  // 22: service_layer.SLRoutev6Oper.SLRoutev6Get:input_type -> service_layer.SLRoutev6GetMsg
	1,  // 23: service_layer.SLRoutev6Oper.SLRoutev6OpStream:input_type -> service_layer.SLRoutev6Msg
	4,  // 24: service_layer.SLRoutev6Oper.SLRoutev6GetStream:input_type -> service_layer.SLRoutev6GetMsg
	20, // 25: service_layer.SLRoutev6Oper.SLRoutev6GetNotifStream:input_type -> service_layer.SLRouteGetNotifMsg
	21, // 26: service_layer.SLRoutev6Oper.SLRoutev6GlobalsGet:output_type -> service_layer.SLRouteGlobalsGetMsgRsp
	22, // 27: service_layer.SLRoutev6Oper.SLRoutev6GlobalStatsGet:output_type -> service_layer.SLRouteGlobalStatsGetMsgRsp
	23, // 28: service_layer.SLRoutev6Oper.SLRoutev6VrfRegOp:output_type -> service_layer.SLVrfRegMsgRsp
	24, // 29: service_layer.SLRoutev6Oper.SLRoutev6VrfRegGet:output_type -> service_layer.SLVrfRegGetMsgRsp
	25, // 30: service_layer.SLRoutev6Oper.SLRoutev6VrfGetStats:output_type -> service_layer.SLVRFGetStatsMsgRsp
	3,  // 31: service_layer.SLRoutev6Oper.SLRoutev6Op:output_type -> service_layer.SLRoutev6MsgRsp
	5,  // 32: service_layer.SLRoutev6Oper.SLRoutev6Get:output_type -> service_layer.SLRoutev6GetMsgRsp
	3,  // 33: service_layer.SLRoutev6Oper.SLRoutev6OpStream:output_type -> service_layer.SLRoutev6MsgRsp
	5,  // 34: service_layer.SLRoutev6Oper.SLRoutev6GetStream:output_type -> service_layer.SLRoutev6GetMsgRsp
	7,  // 35: service_layer.SLRoutev6Oper.SLRoutev6GetNotifStream:output_type -> service_layer.SLRoutev6Notif
	26, // [26:36] is the sub-list for method output_type
	16, // [16:26] is the sub-list for method input_type
	16, // [16:16] is the sub-list for extension type_name
	16, // [16:16] is the sub-list for extension extendee
	0,  // [0:16] is the sub-list for field type_name
}

func init() { file_sl_route_ipv6_proto_init() }
func file_sl_route_ipv6_proto_init() {
	if File_sl_route_ipv6_proto != nil {
		return
	}
	file_sl_common_types_proto_init()
	file_sl_route_common_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_route_ipv6_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6Msg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6Res); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6MsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6GetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6GetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6NotifRoute); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_ipv6_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutev6Notif); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_sl_route_ipv6_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*SLRoutev6Notif_ErrStatus)(nil),
		(*SLRoutev6Notif_NotifStatus)(nil),
		(*SLRoutev6Notif_Route)(nil),
		(*SLRoutev6Notif_Marker)(nil),
		(*SLRoutev6Notif_Vrf)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_route_ipv6_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_sl_route_ipv6_proto_goTypes,
		DependencyIndexes: file_sl_route_ipv6_proto_depIdxs,
		MessageInfos:      file_sl_route_ipv6_proto_msgTypes,
	}.Build()
	File_sl_route_ipv6_proto = out.File
	file_sl_route_ipv6_proto_rawDesc = nil
	file_sl_route_ipv6_proto_goTypes = nil
	file_sl_route_ipv6_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SLRoutev6OperClient is the client API for SLRoutev6Oper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLRoutev6OperClient interface {
	// Used to retrieve Global Route information
	SLRoutev6GlobalsGet(ctx context.Context, in *SLRouteGlobalsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalsGetMsgRsp, error)
	// Used to retrieve Global Route Stats
	SLRoutev6GlobalStatsGet(ctx context.Context, in *SLRouteGlobalStatsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalStatsGetMsgRsp, error)
	// SLVrfRegMsg.Oper = SL_REGOP_REGISTER:
	//     VRF registration: Sends a list of VRF registration messages
	//     and expects a list of registration responses.
	//     A client Must Register a VRF BEFORE routes can be added/modified in
	//    the associated VRF.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     VRF Un-registeration: Sends a list of VRF un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer interested
	//     in this VRF. All previously installed routes would be lost.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_EOF:
	//     VRF End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their Routes.
	SLRoutev6VrfRegOp(ctx context.Context, in *SLVrfRegMsg, opts ...grpc.CallOption) (*SLVrfRegMsgRsp, error)
	// VRF get. Used to retrieve VRF attributes from the server.
	SLRoutev6VrfRegGet(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVrfRegGetMsgRsp, error)
	// Used to retrieve VRF Stats from the server.
	SLRoutev6VrfGetStats(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVRFGetStatsMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6Op(ctx context.Context, in *SLRoutev6Msg, opts ...grpc.CallOption) (*SLRoutev6MsgRsp, error)
	// Retrieves route attributes.
	SLRoutev6Get(ctx context.Context, in *SLRoutev6GetMsg, opts ...grpc.CallOption) (*SLRoutev6GetMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6OpStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6OpStreamClient, error)
	// Retrieves route attributes.
	SLRoutev6GetStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetStreamClient, error)
	// This call is used to get a stream of route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes a stream of per-VRF notification requests.
	// The success/failure of the notification request is relayed in the
	// SLRouteNotifStatus followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	SLRoutev6GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetNotifStreamClient, error)
}

type sLRoutev6OperClient struct {
	cc grpc.ClientConnInterface
}

func NewSLRoutev6OperClient(cc grpc.ClientConnInterface) SLRoutev6OperClient {
	return &sLRoutev6OperClient{cc}
}

func (c *sLRoutev6OperClient) SLRoutev6GlobalsGet(ctx context.Context, in *SLRouteGlobalsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalsGetMsgRsp, error) {
	out := new(SLRouteGlobalsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6GlobalsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GlobalStatsGet(ctx context.Context, in *SLRouteGlobalStatsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalStatsGetMsgRsp, error) {
	out := new(SLRouteGlobalStatsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6GlobalStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfRegOp(ctx context.Context, in *SLVrfRegMsg, opts ...grpc.CallOption) (*SLVrfRegMsgRsp, error) {
	out := new(SLVrfRegMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfRegGet(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVrfRegGetMsgRsp, error) {
	out := new(SLVrfRegGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfGetStats(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVRFGetStatsMsgRsp, error) {
	out := new(SLVRFGetStatsMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfGetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6Op(ctx context.Context, in *SLRoutev6Msg, opts ...grpc.CallOption) (*SLRoutev6MsgRsp, error) {
	out := new(SLRoutev6MsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6Op", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6Get(ctx context.Context, in *SLRoutev6GetMsg, opts ...grpc.CallOption) (*SLRoutev6GetMsgRsp, error) {
	out := new(SLRoutev6GetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6OpStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6OpStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[0], "/service_layer.SLRoutev6Oper/SLRoutev6OpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6OpStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6OpStreamClient interface {
	Send(*SLRoutev6Msg) error
	Recv() (*SLRoutev6MsgRsp, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6OpStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6OpStreamClient) Send(m *SLRoutev6Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6OpStreamClient) Recv() (*SLRoutev6MsgRsp, error) {
	m := new(SLRoutev6MsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GetStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[1], "/service_layer.SLRoutev6Oper/SLRoutev6GetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6GetStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6GetStreamClient interface {
	Send(*SLRoutev6GetMsg) error
	Recv() (*SLRoutev6GetMsgRsp, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6GetStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6GetStreamClient) Send(m *SLRoutev6GetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetStreamClient) Recv() (*SLRoutev6GetMsgRsp, error) {
	m := new(SLRoutev6GetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetNotifStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[2], "/service_layer.SLRoutev6Oper/SLRoutev6GetNotifStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6GetNotifStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6GetNotifStreamClient interface {
	Send(*SLRouteGetNotifMsg) error
	Recv() (*SLRoutev6Notif, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6GetNotifStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamClient) Send(m *SLRouteGetNotifMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamClient) Recv() (*SLRoutev6Notif, error) {
	m := new(SLRoutev6Notif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLRoutev6OperServer is the server API for SLRoutev6Oper service.
type SLRoutev6OperServer interface {
	// Used to retrieve Global Route information
	SLRoutev6GlobalsGet(context.Context, *SLRouteGlobalsGetMsg) (*SLRouteGlobalsGetMsgRsp, error)
	// Used to retrieve Global Route Stats
	SLRoutev6GlobalStatsGet(context.Context, *SLRouteGlobalStatsGetMsg) (*SLRouteGlobalStatsGetMsgRsp, error)
	// SLVrfRegMsg.Oper = SL_REGOP_REGISTER:
	//     VRF registration: Sends a list of VRF registration messages
	//     and expects a list of registration responses.
	//     A client Must Register a VRF BEFORE routes can be added/modified in
	//    the associated VRF.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     VRF Un-registeration: Sends a list of VRF un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer interested
	//     in this VRF. All previously installed routes would be lost.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_EOF:
	//     VRF End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their Routes.
	SLRoutev6VrfRegOp(context.Context, *SLVrfRegMsg) (*SLVrfRegMsgRsp, error)
	// VRF get. Used to retrieve VRF attributes from the server.
	SLRoutev6VrfRegGet(context.Context, *SLVrfRegGetMsg) (*SLVrfRegGetMsgRsp, error)
	// Used to retrieve VRF Stats from the server.
	SLRoutev6VrfGetStats(context.Context, *SLVrfRegGetMsg) (*SLVRFGetStatsMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6Op(context.Context, *SLRoutev6Msg) (*SLRoutev6MsgRsp, error)
	// Retrieves route attributes.
	SLRoutev6Get(context.Context, *SLRoutev6GetMsg) (*SLRoutev6GetMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6OpStream(SLRoutev6Oper_SLRoutev6OpStreamServer) error
	// Retrieves route attributes.
	SLRoutev6GetStream(SLRoutev6Oper_SLRoutev6GetStreamServer) error
	// This call is used to get a stream of route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes a stream of per-VRF notification requests.
	// The success/failure of the notification request is relayed in the
	// SLRouteNotifStatus followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	SLRoutev6GetNotifStream(SLRoutev6Oper_SLRoutev6GetNotifStreamServer) error
}

// UnimplementedSLRoutev6OperServer can be embedded to have forward compatible implementations.
type UnimplementedSLRoutev6OperServer struct {
}

func (*UnimplementedSLRoutev6OperServer) SLRoutev6GlobalsGet(context.Context, *SLRouteGlobalsGetMsg) (*SLRouteGlobalsGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6GlobalsGet not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6GlobalStatsGet(context.Context, *SLRouteGlobalStatsGetMsg) (*SLRouteGlobalStatsGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6GlobalStatsGet not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6VrfRegOp(context.Context, *SLVrfRegMsg) (*SLVrfRegMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6VrfRegOp not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6VrfRegGet(context.Context, *SLVrfRegGetMsg) (*SLVrfRegGetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6VrfRegGet not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6VrfGetStats(context.Context, *SLVrfRegGetMsg) (*SLVRFGetStatsMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6VrfGetStats not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6Op(context.Context, *SLRoutev6Msg) (*SLRoutev6MsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6Op not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6Get(context.Context, *SLRoutev6GetMsg) (*SLRoutev6GetMsgRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SLRoutev6Get not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6OpStream(SLRoutev6Oper_SLRoutev6OpStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLRoutev6OpStream not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6GetStream(SLRoutev6Oper_SLRoutev6GetStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLRoutev6GetStream not implemented")
}
func (*UnimplementedSLRoutev6OperServer) SLRoutev6GetNotifStream(SLRoutev6Oper_SLRoutev6GetNotifStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SLRoutev6GetNotifStream not implemented")
}

func RegisterSLRoutev6OperServer(s *grpc.Server, srv SLRoutev6OperServer) {
	s.RegisterService(&_SLRoutev6Oper_serviceDesc, srv)
}

func _SLRoutev6Oper_SLRoutev6GlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRouteGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6GlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalsGet(ctx, req.(*SLRouteGlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6GlobalStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRouteGlobalStatsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6GlobalStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalStatsGet(ctx, req.(*SLRouteGlobalStatsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegOp(ctx, req.(*SLVrfRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfRegGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegGet(ctx, req.(*SLVrfRegGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfGetStats(ctx, req.(*SLVrfRegGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6Op_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRoutev6Msg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6Op(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6Op",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6Op(ctx, req.(*SLRoutev6Msg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRoutev6GetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6Get(ctx, req.(*SLRoutev6GetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6OpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6OpStream(&sLRoutev6OperSLRoutev6OpStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6OpStreamServer interface {
	Send(*SLRoutev6MsgRsp) error
	Recv() (*SLRoutev6Msg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6OpStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6OpStreamServer) Send(m *SLRoutev6MsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6OpStreamServer) Recv() (*SLRoutev6Msg, error) {
	m := new(SLRoutev6Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLRoutev6Oper_SLRoutev6GetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6GetStream(&sLRoutev6OperSLRoutev6GetStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6GetStreamServer interface {
	Send(*SLRoutev6GetMsgRsp) error
	Recv() (*SLRoutev6GetMsg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6GetStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6GetStreamServer) Send(m *SLRoutev6GetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetStreamServer) Recv() (*SLRoutev6GetMsg, error) {
	m := new(SLRoutev6GetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLRoutev6Oper_SLRoutev6GetNotifStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6GetNotifStream(&sLRoutev6OperSLRoutev6GetNotifStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6GetNotifStreamServer interface {
	Send(*SLRoutev6Notif) error
	Recv() (*SLRouteGetNotifMsg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6GetNotifStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamServer) Send(m *SLRoutev6Notif) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamServer) Recv() (*SLRouteGetNotifMsg, error) {
	m := new(SLRouteGetNotifMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLRoutev6Oper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLRoutev6Oper",
	HandlerType: (*SLRoutev6OperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLRoutev6GlobalsGet",
			Handler:    _SLRoutev6Oper_SLRoutev6GlobalsGet_Handler,
		},
		{
			MethodName: "SLRoutev6GlobalStatsGet",
			Handler:    _SLRoutev6Oper_SLRoutev6GlobalStatsGet_Handler,
		},
		{
			MethodName: "SLRoutev6VrfRegOp",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfRegOp_Handler,
		},
		{
			MethodName: "SLRoutev6VrfRegGet",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfRegGet_Handler,
		},
		{
			MethodName: "SLRoutev6VrfGetStats",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfGetStats_Handler,
		},
		{
			MethodName: "SLRoutev6Op",
			Handler:    _SLRoutev6Oper_SLRoutev6Op_Handler,
		},
		{
			MethodName: "SLRoutev6Get",
			Handler:    _SLRoutev6Oper_SLRoutev6Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLRoutev6OpStream",
			Handler:       _SLRoutev6Oper_SLRoutev6OpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLRoutev6GetStream",
			Handler:       _SLRoutev6Oper_SLRoutev6GetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLRoutev6GetNotifStream",
			Handler:       _SLRoutev6Oper_SLRoutev6GetNotifStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_route_ipv6.proto",
}
