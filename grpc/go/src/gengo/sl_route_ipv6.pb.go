// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_route_ipv6.proto

package service_layer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// IPv6 route
type SLRoutev6 struct {
	// IPv6 Prefix
	// 0:: - ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
	Prefix []byte `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length [0-128]
	PrefixLen uint32 `protobuf:"varint,2,opt,name=PrefixLen" json:"PrefixLen,omitempty"`
	// Common route attributes
	RouteCommon *SLRouteCommon `protobuf:"bytes,3,opt,name=RouteCommon" json:"RouteCommon,omitempty"`
	// List of route paths for a particular route.
	// Specifying more than one path is allowed for ECMP/UCMP cases
	PathList []*SLRoutePath `protobuf:"bytes,4,rep,name=PathList" json:"PathList,omitempty"`
}

func (m *SLRoutev6) Reset()                    { *m = SLRoutev6{} }
func (m *SLRoutev6) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6) ProtoMessage()               {}
func (*SLRoutev6) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{0} }

func (m *SLRoutev6) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SLRoutev6) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *SLRoutev6) GetRouteCommon() *SLRouteCommon {
	if m != nil {
		return m.RouteCommon
	}
	return nil
}

func (m *SLRoutev6) GetPathList() []*SLRoutePath {
	if m != nil {
		return m.PathList
	}
	return nil
}

// List of routes for bulk download
type SLRoutev6Msg struct {
	// Route Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator" json:"Correlator,omitempty"`
	// VRF name.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName" json:"VrfName,omitempty"`
	// List of routes for the VRF specified above
	Routes []*SLRoutev6 `protobuf:"bytes,4,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *SLRoutev6Msg) Reset()                    { *m = SLRoutev6Msg{} }
func (m *SLRoutev6Msg) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6Msg) ProtoMessage()               {}
func (*SLRoutev6Msg) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{1} }

func (m *SLRoutev6Msg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLRoutev6Msg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRoutev6Msg) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutev6Msg) GetRoutes() []*SLRoutev6 {
	if m != nil {
		return m.Routes
	}
	return nil
}

// IPv6 route result, uniquely identified by the Prefix/PrefixLen pair
type SLRoutev6Res struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// IPv6 Prefix
	Prefix []byte `protobuf:"bytes,2,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length, [0-32]
	PrefixLen uint32 `protobuf:"varint,3,opt,name=PrefixLen" json:"PrefixLen,omitempty"`
}

func (m *SLRoutev6Res) Reset()                    { *m = SLRoutev6Res{} }
func (m *SLRoutev6Res) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6Res) ProtoMessage()               {}
func (*SLRoutev6Res) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{2} }

func (m *SLRoutev6Res) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLRoutev6Res) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SLRoutev6Res) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// IPv6 bulk route result status
type SLRoutev6MsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// VRF name (matches the VRF name of the original operation)
	VrfName string `protobuf:"bytes,2,opt,name=VrfName" json:"VrfName,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,3,opt,name=StatusSummary" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLRoutev6Res `protobuf:"bytes,4,rep,name=Results" json:"Results,omitempty"`
}

func (m *SLRoutev6MsgRsp) Reset()                    { *m = SLRoutev6MsgRsp{} }
func (m *SLRoutev6MsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6MsgRsp) ProtoMessage()               {}
func (*SLRoutev6MsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{3} }

func (m *SLRoutev6MsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRoutev6MsgRsp) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutev6MsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLRoutev6MsgRsp) GetResults() []*SLRoutev6Res {
	if m != nil {
		return m.Results
	}
	return nil
}

// Used to retrieve route attributes
type SLRoutev6GetMsg struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// VRF name.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	VrfName string `protobuf:"bytes,2,opt,name=VrfName" json:"VrfName,omitempty"`
	// IPv6 Prefix
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// IPv6 prefix length, [0-32]
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen" json:"PrefixLen,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,5,opt,name=EntriesCount" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,6,opt,name=GetNext" json:"GetNext,omitempty"`
}

func (m *SLRoutev6GetMsg) Reset()                    { *m = SLRoutev6GetMsg{} }
func (m *SLRoutev6GetMsg) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6GetMsg) ProtoMessage()               {}
func (*SLRoutev6GetMsg) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{4} }

func (m *SLRoutev6GetMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRoutev6GetMsg) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutev6GetMsg) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SLRoutev6GetMsg) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *SLRoutev6GetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLRoutev6GetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// Gt Route message response
type SLRoutev6GetMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator" json:"Correlator,omitempty"`
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,2,opt,name=Eof" json:"Eof,omitempty"`
	// VRF name.
	VrfName string `protobuf:"bytes,3,opt,name=VrfName" json:"VrfName,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,4,opt,name=ErrStatus" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLRoutev6 `protobuf:"bytes,5,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLRoutev6GetMsgRsp) Reset()                    { *m = SLRoutev6GetMsgRsp{} }
func (m *SLRoutev6GetMsgRsp) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6GetMsgRsp) ProtoMessage()               {}
func (*SLRoutev6GetMsgRsp) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{5} }

func (m *SLRoutev6GetMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLRoutev6GetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLRoutev6GetMsgRsp) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutev6GetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLRoutev6GetMsgRsp) GetEntries() []*SLRoutev6 {
	if m != nil {
		return m.Entries
	}
	return nil
}

// IPv6 Route notification
type SLRoutev6NotifRoute struct {
	// VRF name.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName" json:"VrfName,omitempty"`
	// IPv6 routes
	Entries []*SLRoutev6 `protobuf:"bytes,2,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *SLRoutev6NotifRoute) Reset()                    { *m = SLRoutev6NotifRoute{} }
func (m *SLRoutev6NotifRoute) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6NotifRoute) ProtoMessage()               {}
func (*SLRoutev6NotifRoute) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{6} }

func (m *SLRoutev6NotifRoute) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLRoutev6NotifRoute) GetEntries() []*SLRoutev6 {
	if m != nil {
		return m.Entries
	}
	return nil
}

// IPv6 notification message
type SLRoutev6Notif struct {
	// Event Type
	EventType SLNotifType `protobuf:"varint,1,opt,name=EventType,enum=service_layer.SLNotifType" json:"EventType,omitempty"`
	// Further info based on EventType
	//
	// Types that are valid to be assigned to Event:
	//	*SLRoutev6Notif_ErrStatus
	//	*SLRoutev6Notif_NotifStatus
	//	*SLRoutev6Notif_Route
	//	*SLRoutev6Notif_Marker
	//	*SLRoutev6Notif_Vrf
	Event isSLRoutev6Notif_Event `protobuf_oneof:"Event"`
}

func (m *SLRoutev6Notif) Reset()                    { *m = SLRoutev6Notif{} }
func (m *SLRoutev6Notif) String() string            { return proto.CompactTextString(m) }
func (*SLRoutev6Notif) ProtoMessage()               {}
func (*SLRoutev6Notif) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{7} }

type isSLRoutev6Notif_Event interface {
	isSLRoutev6Notif_Event()
}

type SLRoutev6Notif_ErrStatus struct {
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,oneof"`
}
type SLRoutev6Notif_NotifStatus struct {
	NotifStatus *SLRouteNotifStatus `protobuf:"bytes,3,opt,name=NotifStatus,oneof"`
}
type SLRoutev6Notif_Route struct {
	Route *SLRoutev6NotifRoute `protobuf:"bytes,4,opt,name=Route,oneof"`
}
type SLRoutev6Notif_Marker struct {
	Marker *SLRouteNotifMarker `protobuf:"bytes,5,opt,name=Marker,oneof"`
}
type SLRoutev6Notif_Vrf struct {
	Vrf *SLVrfNotif `protobuf:"bytes,6,opt,name=Vrf,oneof"`
}

func (*SLRoutev6Notif_ErrStatus) isSLRoutev6Notif_Event()   {}
func (*SLRoutev6Notif_NotifStatus) isSLRoutev6Notif_Event() {}
func (*SLRoutev6Notif_Route) isSLRoutev6Notif_Event()       {}
func (*SLRoutev6Notif_Marker) isSLRoutev6Notif_Event()      {}
func (*SLRoutev6Notif_Vrf) isSLRoutev6Notif_Event()         {}

func (m *SLRoutev6Notif) GetEvent() isSLRoutev6Notif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLRoutev6Notif) GetEventType() SLNotifType {
	if m != nil {
		return m.EventType
	}
	return SLNotifType_SL_EVENT_TYPE_RESERVED
}

func (m *SLRoutev6Notif) GetErrStatus() *SLErrorStatus {
	if x, ok := m.GetEvent().(*SLRoutev6Notif_ErrStatus); ok {
		return x.ErrStatus
	}
	return nil
}

func (m *SLRoutev6Notif) GetNotifStatus() *SLRouteNotifStatus {
	if x, ok := m.GetEvent().(*SLRoutev6Notif_NotifStatus); ok {
		return x.NotifStatus
	}
	return nil
}

func (m *SLRoutev6Notif) GetRoute() *SLRoutev6NotifRoute {
	if x, ok := m.GetEvent().(*SLRoutev6Notif_Route); ok {
		return x.Route
	}
	return nil
}

func (m *SLRoutev6Notif) GetMarker() *SLRouteNotifMarker {
	if x, ok := m.GetEvent().(*SLRoutev6Notif_Marker); ok {
		return x.Marker
	}
	return nil
}

func (m *SLRoutev6Notif) GetVrf() *SLVrfNotif {
	if x, ok := m.GetEvent().(*SLRoutev6Notif_Vrf); ok {
		return x.Vrf
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLRoutev6Notif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLRoutev6Notif_OneofMarshaler, _SLRoutev6Notif_OneofUnmarshaler, _SLRoutev6Notif_OneofSizer, []interface{}{
		(*SLRoutev6Notif_ErrStatus)(nil),
		(*SLRoutev6Notif_NotifStatus)(nil),
		(*SLRoutev6Notif_Route)(nil),
		(*SLRoutev6Notif_Marker)(nil),
		(*SLRoutev6Notif_Vrf)(nil),
	}
}

func _SLRoutev6Notif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLRoutev6Notif)
	// Event
	switch x := m.Event.(type) {
	case *SLRoutev6Notif_ErrStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrStatus); err != nil {
			return err
		}
	case *SLRoutev6Notif_NotifStatus:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotifStatus); err != nil {
			return err
		}
	case *SLRoutev6Notif_Route:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case *SLRoutev6Notif_Marker:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Marker); err != nil {
			return err
		}
	case *SLRoutev6Notif_Vrf:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vrf); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLRoutev6Notif.Event has unexpected type %T", x)
	}
	return nil
}

func _SLRoutev6Notif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLRoutev6Notif)
	switch tag {
	case 2: // Event.ErrStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLErrorStatus)
		err := b.DecodeMessage(msg)
		m.Event = &SLRoutev6Notif_ErrStatus{msg}
		return true, err
	case 3: // Event.NotifStatus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLRouteNotifStatus)
		err := b.DecodeMessage(msg)
		m.Event = &SLRoutev6Notif_NotifStatus{msg}
		return true, err
	case 4: // Event.Route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLRoutev6NotifRoute)
		err := b.DecodeMessage(msg)
		m.Event = &SLRoutev6Notif_Route{msg}
		return true, err
	case 5: // Event.Marker
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLRouteNotifMarker)
		err := b.DecodeMessage(msg)
		m.Event = &SLRoutev6Notif_Marker{msg}
		return true, err
	case 6: // Event.Vrf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLVrfNotif)
		err := b.DecodeMessage(msg)
		m.Event = &SLRoutev6Notif_Vrf{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLRoutev6Notif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLRoutev6Notif)
	// Event
	switch x := m.Event.(type) {
	case *SLRoutev6Notif_ErrStatus:
		s := proto.Size(x.ErrStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLRoutev6Notif_NotifStatus:
		s := proto.Size(x.NotifStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLRoutev6Notif_Route:
		s := proto.Size(x.Route)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLRoutev6Notif_Marker:
		s := proto.Size(x.Marker)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SLRoutev6Notif_Vrf:
		s := proto.Size(x.Vrf)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SLRoutev6)(nil), "service_layer.SLRoutev6")
	proto.RegisterType((*SLRoutev6Msg)(nil), "service_layer.SLRoutev6Msg")
	proto.RegisterType((*SLRoutev6Res)(nil), "service_layer.SLRoutev6Res")
	proto.RegisterType((*SLRoutev6MsgRsp)(nil), "service_layer.SLRoutev6MsgRsp")
	proto.RegisterType((*SLRoutev6GetMsg)(nil), "service_layer.SLRoutev6GetMsg")
	proto.RegisterType((*SLRoutev6GetMsgRsp)(nil), "service_layer.SLRoutev6GetMsgRsp")
	proto.RegisterType((*SLRoutev6NotifRoute)(nil), "service_layer.SLRoutev6NotifRoute")
	proto.RegisterType((*SLRoutev6Notif)(nil), "service_layer.SLRoutev6Notif")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SLRoutev6Oper service

type SLRoutev6OperClient interface {
	// Used to retrieve Global Route information
	SLRoutev6GlobalsGet(ctx context.Context, in *SLRouteGlobalsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalsGetMsgRsp, error)
	// Used to retrieve Global Route Stats
	SLRoutev6GlobalStatsGet(ctx context.Context, in *SLRouteGlobalStatsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalStatsGetMsgRsp, error)
	// SLVrfRegMsg.Oper = SL_REGOP_REGISTER:
	//     VRF registration: Sends a list of VRF registration messages
	//     and expects a list of registration responses.
	//     A client Must Register a VRF BEFORE routes can be added/modified in
	//    the associated VRF.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     VRF Un-registeration: Sends a list of VRF un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer interested
	//     in this VRF. All previously installed routes would be lost.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_EOF:
	//     VRF End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their Routes.
	SLRoutev6VrfRegOp(ctx context.Context, in *SLVrfRegMsg, opts ...grpc.CallOption) (*SLVrfRegMsgRsp, error)
	// VRF get. Used to retrieve VRF attributes from the server.
	SLRoutev6VrfRegGet(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVrfRegGetMsgRsp, error)
	// Used to retrieve VRF Stats from the server.
	SLRoutev6VrfGetStats(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVRFGetStatsMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6Op(ctx context.Context, in *SLRoutev6Msg, opts ...grpc.CallOption) (*SLRoutev6MsgRsp, error)
	// Retrieves route attributes.
	SLRoutev6Get(ctx context.Context, in *SLRoutev6GetMsg, opts ...grpc.CallOption) (*SLRoutev6GetMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6OpStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6OpStreamClient, error)
	// Retrieves route attributes.
	SLRoutev6GetStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetStreamClient, error)
	// This call is used to get a stream of route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes a stream of per-VRF notification requests.
	// The success/failure of the notification request is relayed in the
	// SLRouteNotifStatus followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	SLRoutev6GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetNotifStreamClient, error)
}

type sLRoutev6OperClient struct {
	cc *grpc.ClientConn
}

func NewSLRoutev6OperClient(cc *grpc.ClientConn) SLRoutev6OperClient {
	return &sLRoutev6OperClient{cc}
}

func (c *sLRoutev6OperClient) SLRoutev6GlobalsGet(ctx context.Context, in *SLRouteGlobalsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalsGetMsgRsp, error) {
	out := new(SLRouteGlobalsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6GlobalsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GlobalStatsGet(ctx context.Context, in *SLRouteGlobalStatsGetMsg, opts ...grpc.CallOption) (*SLRouteGlobalStatsGetMsgRsp, error) {
	out := new(SLRouteGlobalStatsGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6GlobalStatsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfRegOp(ctx context.Context, in *SLVrfRegMsg, opts ...grpc.CallOption) (*SLVrfRegMsgRsp, error) {
	out := new(SLVrfRegMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfRegGet(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVrfRegGetMsgRsp, error) {
	out := new(SLVrfRegGetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6VrfGetStats(ctx context.Context, in *SLVrfRegGetMsg, opts ...grpc.CallOption) (*SLVRFGetStatsMsgRsp, error) {
	out := new(SLVRFGetStatsMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6VrfGetStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6Op(ctx context.Context, in *SLRoutev6Msg, opts ...grpc.CallOption) (*SLRoutev6MsgRsp, error) {
	out := new(SLRoutev6MsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6Op", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6Get(ctx context.Context, in *SLRoutev6GetMsg, opts ...grpc.CallOption) (*SLRoutev6GetMsgRsp, error) {
	out := new(SLRoutev6GetMsgRsp)
	err := grpc.Invoke(ctx, "/service_layer.SLRoutev6Oper/SLRoutev6Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLRoutev6OperClient) SLRoutev6OpStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6OpStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[0], c.cc, "/service_layer.SLRoutev6Oper/SLRoutev6OpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6OpStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6OpStreamClient interface {
	Send(*SLRoutev6Msg) error
	Recv() (*SLRoutev6MsgRsp, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6OpStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6OpStreamClient) Send(m *SLRoutev6Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6OpStreamClient) Recv() (*SLRoutev6MsgRsp, error) {
	m := new(SLRoutev6MsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GetStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[1], c.cc, "/service_layer.SLRoutev6Oper/SLRoutev6GetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6GetStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6GetStreamClient interface {
	Send(*SLRoutev6GetMsg) error
	Recv() (*SLRoutev6GetMsgRsp, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6GetStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6GetStreamClient) Send(m *SLRoutev6GetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetStreamClient) Recv() (*SLRoutev6GetMsgRsp, error) {
	m := new(SLRoutev6GetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLRoutev6OperClient) SLRoutev6GetNotifStream(ctx context.Context, opts ...grpc.CallOption) (SLRoutev6Oper_SLRoutev6GetNotifStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SLRoutev6Oper_serviceDesc.Streams[2], c.cc, "/service_layer.SLRoutev6Oper/SLRoutev6GetNotifStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLRoutev6OperSLRoutev6GetNotifStreamClient{stream}
	return x, nil
}

type SLRoutev6Oper_SLRoutev6GetNotifStreamClient interface {
	Send(*SLRouteGetNotifMsg) error
	Recv() (*SLRoutev6Notif, error)
	grpc.ClientStream
}

type sLRoutev6OperSLRoutev6GetNotifStreamClient struct {
	grpc.ClientStream
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamClient) Send(m *SLRouteGetNotifMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamClient) Recv() (*SLRoutev6Notif, error) {
	m := new(SLRoutev6Notif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SLRoutev6Oper service

type SLRoutev6OperServer interface {
	// Used to retrieve Global Route information
	SLRoutev6GlobalsGet(context.Context, *SLRouteGlobalsGetMsg) (*SLRouteGlobalsGetMsgRsp, error)
	// Used to retrieve Global Route Stats
	SLRoutev6GlobalStatsGet(context.Context, *SLRouteGlobalStatsGetMsg) (*SLRouteGlobalStatsGetMsgRsp, error)
	// SLVrfRegMsg.Oper = SL_REGOP_REGISTER:
	//     VRF registration: Sends a list of VRF registration messages
	//     and expects a list of registration responses.
	//     A client Must Register a VRF BEFORE routes can be added/modified in
	//    the associated VRF.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_UNREGISTER:
	//     VRF Un-registeration: Sends a list of VRF un-registration messages
	//     and expects a list of un-registration responses.
	//     This can be used to convey that the client is no longer interested
	//     in this VRF. All previously installed routes would be lost.
	//
	// SLVrfRegMsg.Oper = SL_REGOP_EOF:
	//     VRF End Of File message.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their Routes.
	SLRoutev6VrfRegOp(context.Context, *SLVrfRegMsg) (*SLVrfRegMsgRsp, error)
	// VRF get. Used to retrieve VRF attributes from the server.
	SLRoutev6VrfRegGet(context.Context, *SLVrfRegGetMsg) (*SLVrfRegGetMsgRsp, error)
	// Used to retrieve VRF Stats from the server.
	SLRoutev6VrfGetStats(context.Context, *SLVrfRegGetMsg) (*SLVRFGetStatsMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6Op(context.Context, *SLRoutev6Msg) (*SLRoutev6MsgRsp, error)
	// Retrieves route attributes.
	SLRoutev6Get(context.Context, *SLRoutev6GetMsg) (*SLRoutev6GetMsgRsp, error)
	// SLRoutev6Msg.Oper = SL_OBJOP_ADD:
	//     Route add. Fails if the route already exists.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_UPDATE:
	//     Route update. Creates or updates the route.
	//
	// SLRoutev6Msg.Oper = SL_OBJOP_DELETE:
	//     Route delete. The route path is not necessary to delete the route.
	SLRoutev6OpStream(SLRoutev6Oper_SLRoutev6OpStreamServer) error
	// Retrieves route attributes.
	SLRoutev6GetStream(SLRoutev6Oper_SLRoutev6GetStreamServer) error
	// This call is used to get a stream of route notifications.
	// It can be used to get "push" notifications for route
	// adds/updates/deletes.
	// The caller must maintain the GRPC channel as long as there is
	// interest in route notifications.
	//
	// The call takes a stream of per-VRF notification requests.
	// The success/failure of the notification request is relayed in the
	// SLRouteNotifStatus followed by a Start marker, any routes if present,
	// and an End Marker.
	//
	SLRoutev6GetNotifStream(SLRoutev6Oper_SLRoutev6GetNotifStreamServer) error
}

func RegisterSLRoutev6OperServer(s *grpc.Server, srv SLRoutev6OperServer) {
	s.RegisterService(&_SLRoutev6Oper_serviceDesc, srv)
}

func _SLRoutev6Oper_SLRoutev6GlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRouteGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6GlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalsGet(ctx, req.(*SLRouteGlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6GlobalStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRouteGlobalStatsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6GlobalStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6GlobalStatsGet(ctx, req.(*SLRouteGlobalStatsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegOp(ctx, req.(*SLVrfRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfRegGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfRegGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfRegGet(ctx, req.(*SLVrfRegGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6VrfGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLVrfRegGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6VrfGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6VrfGetStats(ctx, req.(*SLVrfRegGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6Op_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRoutev6Msg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6Op(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6Op",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6Op(ctx, req.(*SLRoutev6Msg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLRoutev6GetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLRoutev6OperServer).SLRoutev6Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLRoutev6Oper/SLRoutev6Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLRoutev6OperServer).SLRoutev6Get(ctx, req.(*SLRoutev6GetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLRoutev6Oper_SLRoutev6OpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6OpStream(&sLRoutev6OperSLRoutev6OpStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6OpStreamServer interface {
	Send(*SLRoutev6MsgRsp) error
	Recv() (*SLRoutev6Msg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6OpStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6OpStreamServer) Send(m *SLRoutev6MsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6OpStreamServer) Recv() (*SLRoutev6Msg, error) {
	m := new(SLRoutev6Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLRoutev6Oper_SLRoutev6GetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6GetStream(&sLRoutev6OperSLRoutev6GetStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6GetStreamServer interface {
	Send(*SLRoutev6GetMsgRsp) error
	Recv() (*SLRoutev6GetMsg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6GetStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6GetStreamServer) Send(m *SLRoutev6GetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetStreamServer) Recv() (*SLRoutev6GetMsg, error) {
	m := new(SLRoutev6GetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLRoutev6Oper_SLRoutev6GetNotifStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLRoutev6OperServer).SLRoutev6GetNotifStream(&sLRoutev6OperSLRoutev6GetNotifStreamServer{stream})
}

type SLRoutev6Oper_SLRoutev6GetNotifStreamServer interface {
	Send(*SLRoutev6Notif) error
	Recv() (*SLRouteGetNotifMsg, error)
	grpc.ServerStream
}

type sLRoutev6OperSLRoutev6GetNotifStreamServer struct {
	grpc.ServerStream
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamServer) Send(m *SLRoutev6Notif) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLRoutev6OperSLRoutev6GetNotifStreamServer) Recv() (*SLRouteGetNotifMsg, error) {
	m := new(SLRouteGetNotifMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLRoutev6Oper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLRoutev6Oper",
	HandlerType: (*SLRoutev6OperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLRoutev6GlobalsGet",
			Handler:    _SLRoutev6Oper_SLRoutev6GlobalsGet_Handler,
		},
		{
			MethodName: "SLRoutev6GlobalStatsGet",
			Handler:    _SLRoutev6Oper_SLRoutev6GlobalStatsGet_Handler,
		},
		{
			MethodName: "SLRoutev6VrfRegOp",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfRegOp_Handler,
		},
		{
			MethodName: "SLRoutev6VrfRegGet",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfRegGet_Handler,
		},
		{
			MethodName: "SLRoutev6VrfGetStats",
			Handler:    _SLRoutev6Oper_SLRoutev6VrfGetStats_Handler,
		},
		{
			MethodName: "SLRoutev6Op",
			Handler:    _SLRoutev6Oper_SLRoutev6Op_Handler,
		},
		{
			MethodName: "SLRoutev6Get",
			Handler:    _SLRoutev6Oper_SLRoutev6Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLRoutev6OpStream",
			Handler:       _SLRoutev6Oper_SLRoutev6OpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLRoutev6GetStream",
			Handler:       _SLRoutev6Oper_SLRoutev6GetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLRoutev6GetNotifStream",
			Handler:       _SLRoutev6Oper_SLRoutev6GetNotifStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_route_ipv6.proto",
}

func init() { proto.RegisterFile("sl_route_ipv6.proto", fileDescriptor10) }

var fileDescriptor10 = []byte{
	// 807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xda, 0x48,
	0x14, 0xc6, 0xfc, 0x86, 0x43, 0xc8, 0xee, 0x4e, 0xf6, 0xc7, 0xcb, 0x66, 0x23, 0xe2, 0x95, 0xb6,
	0xa8, 0x52, 0xa2, 0x88, 0xaa, 0xa8, 0x4a, 0xab, 0x5e, 0x24, 0xa2, 0xa0, 0x2a, 0x81, 0x74, 0x48,
	0x91, 0xaa, 0x5e, 0x20, 0x83, 0x06, 0x4a, 0x0b, 0xd8, 0x9a, 0x19, 0x50, 0xb8, 0xcb, 0x63, 0xf4,
	0x15, 0xfa, 0x08, 0xbd, 0xea, 0x5d, 0xaf, 0xfb, 0x48, 0xd5, 0x8c, 0xc7, 0x30, 0x26, 0x36, 0xa1,
	0xcd, 0x9d, 0x3d, 0xf3, 0x9d, 0xef, 0x7c, 0xe7, 0x3b, 0xc7, 0x07, 0x60, 0x97, 0x8d, 0x3a, 0xd4,
	0x99, 0x72, 0xd2, 0x19, 0xba, 0xb3, 0xca, 0x91, 0x4b, 0x1d, 0xee, 0xa0, 0x3c, 0x23, 0x74, 0x36,
	0xec, 0x91, 0xce, 0xc8, 0x9e, 0x13, 0x5a, 0xf8, 0x83, 0x8d, 0x3a, 0x3d, 0x67, 0x3c, 0x76, 0x26,
	0x1d, 0x3e, 0x77, 0x09, 0xf3, 0x50, 0xf2, 0xd8, 0x0b, 0xf5, 0x2e, 0xbd, 0x63, 0xeb, 0xb3, 0x01,
	0xd9, 0xd6, 0x39, 0x16, 0x17, 0xb3, 0x0a, 0xfa, 0x13, 0xd2, 0x97, 0x94, 0xf4, 0x87, 0xd7, 0xa6,
	0x51, 0x34, 0x4a, 0xdb, 0x58, 0xbd, 0xa1, 0x3d, 0xc8, 0x7a, 0x4f, 0xe7, 0x64, 0x62, 0xc6, 0x8b,
	0x46, 0x29, 0x8f, 0x97, 0x07, 0xe8, 0x39, 0xe4, 0x24, 0xc1, 0x99, 0x24, 0x36, 0x13, 0x45, 0xa3,
	0x94, 0x2b, 0xef, 0x1d, 0x05, 0x64, 0x1d, 0xa9, 0x24, 0x1e, 0x06, 0xeb, 0x01, 0xa8, 0x02, 0x5b,
	0x97, 0x36, 0x7f, 0x77, 0x3e, 0x64, 0xdc, 0x4c, 0x16, 0x13, 0xa5, 0x5c, 0xb9, 0x10, 0x1e, 0x2c,
	0x50, 0x78, 0x81, 0xb5, 0x3e, 0x19, 0xb0, 0xbd, 0xd0, 0x7e, 0xc1, 0x06, 0xe8, 0x10, 0x92, 0x4d,
	0x97, 0x50, 0x29, 0x7e, 0xa7, 0xfc, 0xf7, 0x2d, 0x92, 0x66, 0xf7, 0x3d, 0xe9, 0xf1, 0xa6, 0x8b,
	0x25, 0x0c, 0xed, 0x03, 0x9c, 0x39, 0x94, 0x92, 0x91, 0xcd, 0x1d, 0x2a, 0xcb, 0x4a, 0x62, 0xed,
	0x04, 0x99, 0x90, 0x69, 0xd3, 0x7e, 0xc3, 0x1e, 0x13, 0x59, 0x53, 0x16, 0xfb, 0xaf, 0xe8, 0x18,
	0xd2, 0x32, 0x2d, 0x53, 0x7a, 0xcd, 0x70, 0xbd, 0xb3, 0x0a, 0x56, 0x38, 0xeb, 0x46, 0xd7, 0x8a,
	0x09, 0x43, 0x27, 0x90, 0xad, 0x52, 0xda, 0xe2, 0x36, 0x9f, 0x32, 0x29, 0x38, 0xcc, 0xb2, 0x2a,
	0xa5, 0x8e, 0xc2, 0xe0, 0x25, 0x5c, 0x6b, 0x53, 0x3c, 0xba, 0x4d, 0x89, 0x95, 0x36, 0x59, 0x5f,
	0x0d, 0xf8, 0x45, 0xb7, 0x0b, 0x33, 0x77, 0xc5, 0x02, 0x63, 0x9d, 0x05, 0xf1, 0xa0, 0x05, 0xa7,
	0x90, 0xf7, 0xd4, 0xb4, 0xa6, 0xe3, 0xb1, 0x4d, 0xe7, 0x91, 0x6d, 0xd7, 0x6b, 0x08, 0x86, 0xa0,
	0xc7, 0x90, 0xc1, 0x84, 0x4d, 0x47, 0xdc, 0xf7, 0xf1, 0x9f, 0x48, 0x1f, 0x09, 0xc3, 0x3e, 0xd6,
	0xfa, 0xa2, 0x17, 0x52, 0x23, 0x5c, 0xb4, 0xfe, 0xe7, 0x0b, 0x59, 0x9a, 0x99, 0x88, 0x36, 0x33,
	0xb9, 0x3a, 0xf3, 0x16, 0x6c, 0x57, 0x27, 0x9c, 0x0e, 0x09, 0x3b, 0x73, 0xa6, 0x13, 0x6e, 0xa6,
	0x24, 0x20, 0x70, 0x26, 0x72, 0xd6, 0x08, 0x6f, 0x90, 0x6b, 0x6e, 0xa6, 0x8b, 0x46, 0x69, 0x0b,
	0xfb, 0xaf, 0xd6, 0x37, 0x03, 0xd0, 0x4a, 0x05, 0x9b, 0x74, 0xe3, 0x57, 0x48, 0x54, 0x9d, 0xbe,
	0x2c, 0x60, 0x0b, 0x8b, 0xc7, 0x35, 0x23, 0x1a, 0x98, 0xaf, 0xe4, 0x8f, 0xcd, 0x57, 0x19, 0x32,
	0xaa, 0x10, 0x33, 0x75, 0xc7, 0x7c, 0xfb, 0x40, 0xab, 0x07, 0xbb, 0x8b, 0xd3, 0x86, 0xc3, 0x87,
	0x7d, 0xf9, 0xac, 0x0b, 0x34, 0x82, 0x02, 0xb5, 0x24, 0xf1, 0x4d, 0x93, 0xdc, 0x24, 0x60, 0x27,
	0x98, 0x05, 0x3d, 0x81, 0x6c, 0x75, 0x46, 0x26, 0xfc, 0x6a, 0xee, 0x12, 0xf5, 0xe1, 0xdf, 0xde,
	0x1e, 0x12, 0x2a, 0x10, 0x78, 0x09, 0x46, 0xcf, 0x74, 0x87, 0xe2, 0x77, 0x3b, 0x54, 0x8f, 0xe9,
	0x1e, 0x55, 0x21, 0x27, 0x59, 0x55, 0xbc, 0x37, 0xfd, 0x07, 0xe1, 0x25, 0x68, 0xc0, 0x7a, 0x0c,
	0xeb, 0x71, 0xe8, 0x04, 0x52, 0x12, 0xa2, 0x5a, 0x64, 0x45, 0x79, 0xb0, 0xb4, 0xb4, 0x1e, 0xc3,
	0x5e, 0x08, 0x7a, 0x0a, 0xe9, 0x0b, 0x9b, 0x7e, 0x20, 0x54, 0x4e, 0xdf, 0xfa, 0xec, 0x1e, 0xb0,
	0x1e, 0xc3, 0x2a, 0x04, 0x1d, 0x42, 0xa2, 0x4d, 0xfb, 0x72, 0x30, 0x73, 0x21, 0xab, 0x52, 0x74,
	0x49, 0xc4, 0xd5, 0x63, 0x58, 0xe0, 0x4e, 0x33, 0x90, 0x92, 0xce, 0x95, 0x3f, 0x66, 0x20, 0xbf,
	0x50, 0x25, 0xd7, 0x68, 0x57, 0xeb, 0x7c, 0x6d, 0xe4, 0x74, 0xed, 0x11, 0xab, 0x11, 0x8e, 0xfe,
	0x0b, 0x57, 0xb3, 0x44, 0x5c, 0xb0, 0x41, 0xe1, 0xff, 0x0d, 0x40, 0xe2, 0xcb, 0x98, 0xc0, 0x5f,
	0x2b, 0x39, 0x84, 0x7f, 0x32, 0xcf, 0x83, 0x75, 0x14, 0x3e, 0x4a, 0xe4, 0x7a, 0xb8, 0x21, 0x50,
	0xe4, 0x6b, 0xc0, 0x6f, 0x8b, 0x7c, 0x6d, 0xda, 0xc7, 0x64, 0xd0, 0x74, 0x51, 0x21, 0xcc, 0x25,
	0x4c, 0x06, 0x82, 0xfc, 0xdf, 0xe8, 0x3b, 0xc1, 0xf7, 0x5a, 0xfb, 0xde, 0xbd, 0x0b, 0x21, 0x3d,
	0x2a, 0x48, 0x09, 0x2e, 0xae, 0xbd, 0x16, 0xb4, 0x6f, 0xe0, 0x77, 0x9d, 0xb6, 0x46, 0xb8, 0xac,
	0xe3, 0x2e, 0xe2, 0xdb, 0x53, 0xd6, 0xc6, 0x2f, 0xfc, 0x60, 0x45, 0xfd, 0x12, 0x72, 0x5a, 0x9b,
	0x51, 0xe4, 0x66, 0x16, 0x7c, 0xfb, 0x6b, 0x2e, 0x05, 0xd7, 0x2b, 0xed, 0xb7, 0x4f, 0xd4, 0x1d,
	0x89, 0x57, 0xfa, 0x0e, 0xd6, 0xdf, 0x0b, 0xca, 0x2b, 0xad, 0x41, 0x4d, 0xb7, 0xc5, 0x29, 0xb1,
	0xc7, 0xf7, 0x12, 0x59, 0x32, 0x8e, 0x0d, 0xf4, 0x36, 0xb8, 0x96, 0x15, 0xed, 0xfd, 0xe5, 0x4a,
	0xf2, 0x8e, 0x3e, 0xc3, 0x84, 0xab, 0x2d, 0x20, 0x33, 0x44, 0x30, 0xf8, 0xa8, 0xf0, 0x01, 0xd3,
	0x37, 0x83, 0x48, 0xd0, 0x4d, 0xcb, 0xbf, 0x74, 0x8f, 0xbe, 0x07, 0x00, 0x00, 0xff, 0xff, 0x0d,
	0x80, 0x49, 0xd2, 0x26, 0x0a, 0x00, 0x00,
}
