// @file
// @brief Proto file for Segment-routing traffic-eng (SR-TE) Policy RPCs.
// Declares calls for adding, deleting, updating the SR-TE policies.
// The GPB data model should reflect the model from the SR-TE policy
// RFC https://datatracker.ietf.org/doc/rfc9256/.
//
// ----------------------------------------------------------------
//  Copyright (c) 2025 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v3.18.3
// source: sl_srte_policy.proto

package service_layer

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SLSrPolicyOpen_SLSrPersistenceMode int32

const (
	// When the controller disconnects, the router will either start the cleanup
	// timer or delete the policies (or its candidate paths) created by the
	// controller immediately.
	SLSrPolicyOpen_DELETE SLSrPolicyOpen_SLSrPersistenceMode = 0
	// When the client disconnects, the server preserves all policies/CPs
	// instantiated by this client.
	// It is client responsibility to delete the policies when they are no
	// longer needed, Server does not do auto-cleanup of policies created
	// with this mode.
	SLSrPolicyOpen_PRESERVE SLSrPolicyOpen_SLSrPersistenceMode = 1
)

// Enum value maps for SLSrPolicyOpen_SLSrPersistenceMode.
var (
	SLSrPolicyOpen_SLSrPersistenceMode_name = map[int32]string{
		0: "DELETE",
		1: "PRESERVE",
	}
	SLSrPolicyOpen_SLSrPersistenceMode_value = map[string]int32{
		"DELETE":   0,
		"PRESERVE": 1,
	}
)

func (x SLSrPolicyOpen_SLSrPersistenceMode) Enum() *SLSrPolicyOpen_SLSrPersistenceMode {
	p := new(SLSrPolicyOpen_SLSrPersistenceMode)
	*p = x
	return p
}

func (x SLSrPolicyOpen_SLSrPersistenceMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLSrPolicyOpen_SLSrPersistenceMode) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_srte_policy_proto_enumTypes[0].Descriptor()
}

func (SLSrPolicyOpen_SLSrPersistenceMode) Type() protoreflect.EnumType {
	return &file_sl_srte_policy_proto_enumTypes[0]
}

func (x SLSrPolicyOpen_SLSrPersistenceMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLSrPolicyOpen_SLSrPersistenceMode.Descriptor instead.
func (SLSrPolicyOpen_SLSrPersistenceMode) EnumDescriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{2, 0}
}

type SLSrPolicyReq_SLSrOp int32

const (
	// Create operation for specified policies. Policies that already exist
	// will be updated.
	SLSrPolicyReq_CREATE_UPDATE SLSrPolicyReq_SLSrOp = 0
	// Delete operation for specified policies. Deletion of non-existent policy
	// will be responded with specific error code.
	SLSrPolicyReq_DELETE SLSrPolicyReq_SLSrOp = 1
)

// Enum value maps for SLSrPolicyReq_SLSrOp.
var (
	SLSrPolicyReq_SLSrOp_name = map[int32]string{
		0: "CREATE_UPDATE",
		1: "DELETE",
	}
	SLSrPolicyReq_SLSrOp_value = map[string]int32{
		"CREATE_UPDATE": 0,
		"DELETE":        1,
	}
)

func (x SLSrPolicyReq_SLSrOp) Enum() *SLSrPolicyReq_SLSrOp {
	p := new(SLSrPolicyReq_SLSrOp)
	*p = x
	return p
}

func (x SLSrPolicyReq_SLSrOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SLSrPolicyReq_SLSrOp) Descriptor() protoreflect.EnumDescriptor {
	return file_sl_srte_policy_proto_enumTypes[1].Descriptor()
}

func (SLSrPolicyReq_SLSrOp) Type() protoreflect.EnumType {
	return &file_sl_srte_policy_proto_enumTypes[1]
}

func (x SLSrPolicyReq_SLSrOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SLSrPolicyReq_SLSrOp.Descriptor instead.
func (SLSrPolicyReq_SLSrOp) EnumDescriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{4, 0}
}

// SLSrPolicyMsg is message used by client to manage policies on target device
type SLSrPolicyMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to MsgType:
	//
	//	*SLSrPolicyMsg_Open
	//	*SLSrPolicyMsg_Requests
	//	*SLSrPolicyMsg_ReplayStart
	//	*SLSrPolicyMsg_ReplayEnd
	MsgType isSLSrPolicyMsg_MsgType `protobuf_oneof:"msg_type"`
}

func (x *SLSrPolicyMsg) Reset() {
	*x = SLSrPolicyMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyMsg) ProtoMessage() {}

func (x *SLSrPolicyMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyMsg.ProtoReflect.Descriptor instead.
func (*SLSrPolicyMsg) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{0}
}

func (m *SLSrPolicyMsg) GetMsgType() isSLSrPolicyMsg_MsgType {
	if m != nil {
		return m.MsgType
	}
	return nil
}

func (x *SLSrPolicyMsg) GetOpen() *SLSrPolicyOpen {
	if x, ok := x.GetMsgType().(*SLSrPolicyMsg_Open); ok {
		return x.Open
	}
	return nil
}

func (x *SLSrPolicyMsg) GetRequests() *SLSrPolicyRequests {
	if x, ok := x.GetMsgType().(*SLSrPolicyMsg_Requests); ok {
		return x.Requests
	}
	return nil
}

func (x *SLSrPolicyMsg) GetReplayStart() *SLSrStartOfReplay {
	if x, ok := x.GetMsgType().(*SLSrPolicyMsg_ReplayStart); ok {
		return x.ReplayStart
	}
	return nil
}

func (x *SLSrPolicyMsg) GetReplayEnd() *SLSrEndOfReplay {
	if x, ok := x.GetMsgType().(*SLSrPolicyMsg_ReplayEnd); ok {
		return x.ReplayEnd
	}
	return nil
}

type isSLSrPolicyMsg_MsgType interface {
	isSLSrPolicyMsg_MsgType()
}

type SLSrPolicyMsg_Open struct {
	Open *SLSrPolicyOpen `protobuf:"bytes,1,opt,name=open,proto3,oneof"`
}

type SLSrPolicyMsg_Requests struct {
	Requests *SLSrPolicyRequests `protobuf:"bytes,2,opt,name=requests,proto3,oneof"`
}

type SLSrPolicyMsg_ReplayStart struct {
	ReplayStart *SLSrStartOfReplay `protobuf:"bytes,3,opt,name=replay_start,json=replayStart,proto3,oneof"`
}

type SLSrPolicyMsg_ReplayEnd struct {
	ReplayEnd *SLSrEndOfReplay `protobuf:"bytes,4,opt,name=replay_end,json=replayEnd,proto3,oneof"`
}

func (*SLSrPolicyMsg_Open) isSLSrPolicyMsg_MsgType() {}

func (*SLSrPolicyMsg_Requests) isSLSrPolicyMsg_MsgType() {}

func (*SLSrPolicyMsg_ReplayStart) isSLSrPolicyMsg_MsgType() {}

func (*SLSrPolicyMsg_ReplayEnd) isSLSrPolicyMsg_MsgType() {}

// RPC response
// Response to policy operation. Indicates result of the operation and not
// operational state of policy.  In case of multiple requests received for
// policy identified by specific SLSrPolicyKey, always at least single response
// will be sent to confirm processing of the last request.
type SLSrPolicyRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Set of responses corresponding to the policies in the request
	Responses []*SLSrPolicyRsp_PolicyRsp `protobuf:"bytes,1,rep,name=responses,proto3" json:"responses,omitempty"`
	// Generic error, Only set if error is not specific to policies
	Status *SLSrStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SLSrPolicyRsp) Reset() {
	*x = SLSrPolicyRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyRsp) ProtoMessage() {}

func (x *SLSrPolicyRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyRsp.ProtoReflect.Descriptor instead.
func (*SLSrPolicyRsp) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{1}
}

func (x *SLSrPolicyRsp) GetResponses() []*SLSrPolicyRsp_PolicyRsp {
	if x != nil {
		return x.Responses
	}
	return nil
}

func (x *SLSrPolicyRsp) GetStatus() *SLSrStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// Used to set session parameters by the client.
// The Open Message must be the first message sent by the controller. Any other message
// prior to the Open is considered an error. It is not allowed to send the Open Message
// multiple times for the same gRPC session.
// To update attributes (client-ID, persistence mode and cleanup timer value) included in
// the Open Message, the connection must be closed and re-opened.
// For DELETE persistence mode, Open Message is implicit start of replay.
//
// The server is not required to send an explicit response message to indicate the
// receipt of the Open Message. Server will respond in case of any error.
type SLSrPolicyOpen struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Used to set ownership of any policies instantiated during this session
	// This is expected to be unique value, which means multiple clients with
	// same client_id are not allowed to connect to the same Server.
	// On a disconnect, controller with same client_id can reclaim the ownership
	// of policies on the Server by connecting back.
	// Length of the client_id is expected to be in the range of 1 to 64.
	// An empty client_id or client_id outside of this range length is considered
	// an error. Usage of characters used in client_id is limited to alphanumerical
	// characters.
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// Only applicable to DELETE persistence mode.
	// Timer for deleting the policies after the disconnect. If not specified,
	// a default value is used. 0 value is not allowed. Value is in seconds.
	PolicyCleanupTimer *uint32 `protobuf:"varint,2,opt,name=policy_cleanup_timer,json=policyCleanupTimer,proto3,oneof" json:"policy_cleanup_timer,omitempty"`
	// Persistence mode for policies instantiated by this client
	// Persistence mode is an attribute of the gRPC client. If the gRPC client
	// reconnects with a different persistence mode, the rules associated with
	// the mode specified in the most recent Open Message will be applied to all
	// policies created with the same Client-ID, including those provisioned in
	// previous gRPC sessions.
	Mode SLSrPolicyOpen_SLSrPersistenceMode `protobuf:"varint,3,opt,name=mode,proto3,enum=service_layer.SLSrPolicyOpen_SLSrPersistenceMode" json:"mode,omitempty"`
}

func (x *SLSrPolicyOpen) Reset() {
	*x = SLSrPolicyOpen{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyOpen) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyOpen) ProtoMessage() {}

func (x *SLSrPolicyOpen) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyOpen.ProtoReflect.Descriptor instead.
func (*SLSrPolicyOpen) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{2}
}

func (x *SLSrPolicyOpen) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *SLSrPolicyOpen) GetPolicyCleanupTimer() uint32 {
	if x != nil && x.PolicyCleanupTimer != nil {
		return *x.PolicyCleanupTimer
	}
	return 0
}

func (x *SLSrPolicyOpen) GetMode() SLSrPolicyOpen_SLSrPersistenceMode {
	if x != nil {
		return x.Mode
	}
	return SLSrPolicyOpen_DELETE
}

// Set of policies to be acted on
type SLSrPolicyRequests struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Requests []*SLSrPolicyReq `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
}

func (x *SLSrPolicyRequests) Reset() {
	*x = SLSrPolicyRequests{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyRequests) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyRequests) ProtoMessage() {}

func (x *SLSrPolicyRequests) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyRequests.ProtoReflect.Descriptor instead.
func (*SLSrPolicyRequests) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{3}
}

func (x *SLSrPolicyRequests) GetRequests() []*SLSrPolicyReq {
	if x != nil {
		return x.Requests
	}
	return nil
}

// Policy operation
type SLSrPolicyReq struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Operation SLSrPolicyReq_SLSrOp `protobuf:"varint,1,opt,name=operation,proto3,enum=service_layer.SLSrPolicyReq_SLSrOp" json:"operation,omitempty"`
	// Each policy request is uniquely identified by a sequence ID and a policy key,
	// both of which are reflected by the router in the response.
	// Each policy request encompasses all candidate-paths and policy attributes.
	// Candidate-paths not included in the update request will be removed.
	//
	// Policy attributes (e.g., profile ID, Binding SID, etc.), that are not specified
	// for each candidate-path are applied to all candidate-paths. In the event of
	// a conflict with similar attribute set from other interfaces (e.g., configuration,
	// PCEP, etc.), then policy will be down. The only exception is the Binding SID
	// attribute set for a specific candidate-path, which will take precedence over
	// the Binding SID specified for the entire policy.
	Policy *SLSrPolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (x *SLSrPolicyReq) Reset() {
	*x = SLSrPolicyReq{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyReq) ProtoMessage() {}

func (x *SLSrPolicyReq) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyReq.ProtoReflect.Descriptor instead.
func (*SLSrPolicyReq) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{4}
}

func (x *SLSrPolicyReq) GetOperation() SLSrPolicyReq_SLSrOp {
	if x != nil {
		return x.Operation
	}
	return SLSrPolicyReq_CREATE_UPDATE
}

func (x *SLSrPolicyReq) GetPolicy() *SLSrPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

// The controller is expected to send an EndOfReplay message after replaying policies
// after the re-connect in case of “DELETE” persistence mode. For “PRESERVE” mode,
// replay of all policies is not required, but it can be still explicitly initiated
// by sending StartOfReplay message.
// It indicates that the controller has finished replaying all policies, which will
// then trigger cleanup of any policies not reclaimed by the controller (identified
// by Client-ID).
// The server will start replay timer, when replay is initiated with value of 600
// seconds. If the // EndOfReplay message is not received in specified time, not
// replayed policies will be deleted.
// Server will not send response to this message unless there is an error.
type SLSrEndOfReplay struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLSrEndOfReplay) Reset() {
	*x = SLSrEndOfReplay{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrEndOfReplay) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrEndOfReplay) ProtoMessage() {}

func (x *SLSrEndOfReplay) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrEndOfReplay.ProtoReflect.Descriptor instead.
func (*SLSrEndOfReplay) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{5}
}

// Client can use StartOfReplay to start a resync with the Server. This is the way for
// the controller to explicitly request start of replay on an already established
// connection.
// This message marks all the policies from this client as stale on the Server and
// starts replay timer. Note that if synchronization takes longer than specified
// replay timer value, then policies can be deleted before receiving EndOfReplay message.
//
// Replay of policies followed by EndOfReplay is expected from the client after
// this message. Replayed policies will have stale flag removed, EndOfSync will trigger
// deletion of any policies still left stale (policies that have not been replayed).
// If server receives StartOfReplay when it is already in replay state, it is considered
// an error.
// Server will not send response to this message unless there is an error.
type SLSrStartOfReplay struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLSrStartOfReplay) Reset() {
	*x = SLSrStartOfReplay{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrStartOfReplay) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrStartOfReplay) ProtoMessage() {}

func (x *SLSrStartOfReplay) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrStartOfReplay.ProtoReflect.Descriptor instead.
func (*SLSrStartOfReplay) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{6}
}

// (https://www.rfc-editor.org/rfc/rfc9256.html#section-2).
type SLSrPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The sequence number is incremented by the controller and should be scoped per
	// policy, meaning there is an independent sequence number for each policy. Server
	// includes the sequence number of the request it is responding to in its reply. The
	// server is not enforcing/validating or re-ordering requests based on sequence
	// number specified.
	SeqNum uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	// Globally unique SR policy identifier.
	Key *SLSrPolicyKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Policy attributes
	Attrs *SLSrPolicyAttributes `protobuf:"bytes,3,opt,name=attrs,proto3" json:"attrs,omitempty"`
	CPs   []*SLSrCandidatePath  `protobuf:"bytes,4,rep,name=CPs,proto3" json:"CPs,omitempty"`
}

func (x *SLSrPolicy) Reset() {
	*x = SLSrPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicy) ProtoMessage() {}

func (x *SLSrPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicy.ProtoReflect.Descriptor instead.
func (*SLSrPolicy) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{7}
}

func (x *SLSrPolicy) GetSeqNum() uint64 {
	if x != nil {
		return x.SeqNum
	}
	return 0
}

func (x *SLSrPolicy) GetKey() *SLSrPolicyKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLSrPolicy) GetAttrs() *SLSrPolicyAttributes {
	if x != nil {
		return x.Attrs
	}
	return nil
}

func (x *SLSrPolicy) GetCPs() []*SLSrCandidatePath {
	if x != nil {
		return x.CPs
	}
	return nil
}

// Policy attributes
type SLSrPolicyAttributes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TransitEligible bool `protobuf:"varint,2,opt,name=transit_eligible,json=transitEligible,proto3" json:"transit_eligible,omitempty"`
	// The segment routing dataplane.
	// This is mandatory field. Unspecified dataplane is invalid and will be rejected
	// by the server.
	Dataplane SLSrDataplane `protobuf:"varint,3,opt,name=dataplane,proto3,enum=service_layer.SLSrDataplane" json:"dataplane,omitempty"`
	// (https://www.rfc-editor.org/rfc/rfc9256.html#section-6.1).
	// If neither mpls_bsid nor srv6_bsid are specified, then dynamic BSID based on
	// dataplane will be allocated.
	MplsBsid  *SLSrMPLSBindingSID   `protobuf:"bytes,4,opt,name=mpls_bsid,json=mplsBsid,proto3" json:"mpls_bsid,omitempty"`
	Srv6Bsids []*SLSrSrv6BindingSID `protobuf:"bytes,5,rep,name=srv6_bsids,json=srv6Bsids,proto3" json:"srv6_bsids,omitempty"`
	// ID of the profile with which policy can be associated with a non-zero value. The
	// Profile ID concept is described as “Policy Association Group” in RFC 9005.
	// 0 value means unset. Maximum accepted value is 65534.
	//
	// A profile represents a set of configuration knobs specifying policy or policy
	// candidate-path (CP) attributes. The profile-ID feature allows usage of
	// vendor/implementation specific functionality per policy without requiring
	// explicit support by controller.
	ProfileId uint32 `protobuf:"varint,6,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
}

func (x *SLSrPolicyAttributes) Reset() {
	*x = SLSrPolicyAttributes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyAttributes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyAttributes) ProtoMessage() {}

func (x *SLSrPolicyAttributes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyAttributes.ProtoReflect.Descriptor instead.
func (*SLSrPolicyAttributes) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{8}
}

func (x *SLSrPolicyAttributes) GetTransitEligible() bool {
	if x != nil {
		return x.TransitEligible
	}
	return false
}

func (x *SLSrPolicyAttributes) GetDataplane() SLSrDataplane {
	if x != nil {
		return x.Dataplane
	}
	return SLSrDataplane_SL_SR_DATAPLANE_UNSPECIFIED
}

func (x *SLSrPolicyAttributes) GetMplsBsid() *SLSrMPLSBindingSID {
	if x != nil {
		return x.MplsBsid
	}
	return nil
}

func (x *SLSrPolicyAttributes) GetSrv6Bsids() []*SLSrSrv6BindingSID {
	if x != nil {
		return x.Srv6Bsids
	}
	return nil
}

func (x *SLSrPolicyAttributes) GetProfileId() uint32 {
	if x != nil {
		return x.ProfileId
	}
	return 0
}

// SR Candidate Path in the context of an SR Policy, as defined in
// [section 2.2 of RFC 9256]
// (https://www.rfc-editor.org/rfc/rfc9256.html#section-2.2).
type SLSrCandidatePath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique candidate path identifier in the context of an SR policy.
	// The tuple (`policy_key`, `candidate_path_key`) is a globally unique
	// identifier of the candidate path. Protocol origin field will be set to
	// SL_SR_POLICY_PROTOCOL_ORIGIN_CONFIG_VIA_GRPC
	Key *SLSrCandidatePathKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Candidate path name
	// String of printable ASCII with max length of 256 characters.
	// If unset, candidate-path name will be generated. Name with invalid
	// length or unacceptable characters will be rejected.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The Preference of the candidate path is used to select the
	// best candidate path for an SR Policy.
	// If not specified, 100 is used as a default.
	Preference *uint32 `protobuf:"varint,4,opt,name=preference,proto3,oneof" json:"preference,omitempty"`
	// Types that are assignable to CP:
	//
	//	*SLSrCandidatePath_Dynamic
	//	*SLSrCandidatePath_Explicit
	CP isSLSrCandidatePath_CP `protobuf_oneof:"CP"`
}

func (x *SLSrCandidatePath) Reset() {
	*x = SLSrCandidatePath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrCandidatePath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrCandidatePath) ProtoMessage() {}

func (x *SLSrCandidatePath) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrCandidatePath.ProtoReflect.Descriptor instead.
func (*SLSrCandidatePath) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{9}
}

func (x *SLSrCandidatePath) GetKey() *SLSrCandidatePathKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLSrCandidatePath) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SLSrCandidatePath) GetPreference() uint32 {
	if x != nil && x.Preference != nil {
		return *x.Preference
	}
	return 0
}

func (m *SLSrCandidatePath) GetCP() isSLSrCandidatePath_CP {
	if m != nil {
		return m.CP
	}
	return nil
}

func (x *SLSrCandidatePath) GetDynamic() *SLSrDynamicCP {
	if x, ok := x.GetCP().(*SLSrCandidatePath_Dynamic); ok {
		return x.Dynamic
	}
	return nil
}

func (x *SLSrCandidatePath) GetExplicit() *SLSrExplicitCP {
	if x, ok := x.GetCP().(*SLSrCandidatePath_Explicit); ok {
		return x.Explicit
	}
	return nil
}

type isSLSrCandidatePath_CP interface {
	isSLSrCandidatePath_CP()
}

type SLSrCandidatePath_Dynamic struct {
	// (https://www.rfc-editor.org/rfc/rfc9256.html#section-5.2).
	Dynamic *SLSrDynamicCP `protobuf:"bytes,5,opt,name=dynamic,proto3,oneof"`
}

type SLSrCandidatePath_Explicit struct {
	// (https://www.rfc-editor.org/rfc/rfc9256.html#section-5.1).
	Explicit *SLSrExplicitCP `protobuf:"bytes,6,opt,name=explicit,proto3,oneof"`
}

func (*SLSrCandidatePath_Dynamic) isSLSrCandidatePath_CP() {}

func (*SLSrCandidatePath_Explicit) isSLSrCandidatePath_CP() {}

// Candidate path with explicitly defined set/s of segment-lists
type SLSrExplicitCP struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The set of weighted segment lists in the explicit candidate path.
	SegmentList []*SLSrSegmentList `protobuf:"bytes,1,rep,name=segment_list,json=segmentList,proto3" json:"segment_list,omitempty"` //repeated SLSrSegmentList reverse_segment_list = 2;
	// Optimization metric type used for accumulating metric value (specified for each
	// segment-list).
	// Values are defined in “BGP-LS SR Policy Metric Type” registry under
	// "Border Gateway Protocol - Link State (BGP-LS) Parameters"
	MetricType uint32 `protobuf:"varint,3,opt,name=metric_type,json=metricType,proto3" json:"metric_type,omitempty"`
}

func (x *SLSrExplicitCP) Reset() {
	*x = SLSrExplicitCP{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrExplicitCP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrExplicitCP) ProtoMessage() {}

func (x *SLSrExplicitCP) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrExplicitCP.ProtoReflect.Descriptor instead.
func (*SLSrExplicitCP) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{10}
}

func (x *SLSrExplicitCP) GetSegmentList() []*SLSrSegmentList {
	if x != nil {
		return x.SegmentList
	}
	return nil
}

func (x *SLSrExplicitCP) GetMetricType() uint32 {
	if x != nil {
		return x.MetricType
	}
	return 0
}

// The specific attributes for instantiating a dynamic path request.
type SLSrDynamicCP struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The optimization metric of the dynamic candidate path.
	//
	// The objective function of the optimization problem is to minimize the
	// accumulated value of this additive link metric along the path.
	// Values are defined in “BGP-LS SR Policy Metric Type” registry under
	// "Border Gateway Protocol - Link State (BGP-LS) Parameters"
	MetricType uint32 `protobuf:"varint,1,opt,name=metric_type,json=metricType,proto3" json:"metric_type,omitempty"`
	// The set of constraints that the candidate path must satisfy.
	Constraints *SLSrConstraints `protobuf:"bytes,2,opt,name=constraints,proto3" json:"constraints,omitempty"`
}

func (x *SLSrDynamicCP) Reset() {
	*x = SLSrDynamicCP{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrDynamicCP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrDynamicCP) ProtoMessage() {}

func (x *SLSrDynamicCP) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrDynamicCP.ProtoReflect.Descriptor instead.
func (*SLSrDynamicCP) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{11}
}

func (x *SLSrDynamicCP) GetMetricType() uint32 {
	if x != nil {
		return x.MetricType
	}
	return 0
}

func (x *SLSrDynamicCP) GetConstraints() *SLSrConstraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

// A set of constraints for an SR path.
type SLSrConstraints struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Extended Administrative Groups.
	Affinities *SLSrAffinities      `protobuf:"bytes,1,opt,name=affinities,proto3" json:"affinities,omitempty"`
	Protection SLSrteProtectionType `protobuf:"varint,2,opt,name=protection,proto3,enum=service_layer.SLSrteProtectionType" json:"protection,omitempty"`
	SidAlgo    *uint32              `protobuf:"varint,3,opt,name=sid_algo,json=sidAlgo,proto3,oneof" json:"sid_algo,omitempty"`
	// Maximum number of segments in any of the candidate path segment lists.
	//
	// When set to a non-zero value, this attribute replaces the headend MSD
	// obtained from the link-state topology. When set to the default value (0),
	// this attribute is ignored.
	//
	// Note: If the first segment in the segment list can be enforced by setting
	// the outgoing interface on the headend node, it does not count towards this
	// limit.
	// Supported value is platform dependent. Server can choose to respond with an error
	// if the value is not in the supported range.
	MaximumSidDepth uint32 `protobuf:"varint,4,opt,name=maximum_sid_depth,json=maximumSidDepth,proto3" json:"maximum_sid_depth,omitempty"`
}

func (x *SLSrConstraints) Reset() {
	*x = SLSrConstraints{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrConstraints) ProtoMessage() {}

func (x *SLSrConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrConstraints.ProtoReflect.Descriptor instead.
func (*SLSrConstraints) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{12}
}

func (x *SLSrConstraints) GetAffinities() *SLSrAffinities {
	if x != nil {
		return x.Affinities
	}
	return nil
}

func (x *SLSrConstraints) GetProtection() SLSrteProtectionType {
	if x != nil {
		return x.Protection
	}
	return SLSrteProtectionType_SL_SR_PROTECTED_PREFERRED
}

func (x *SLSrConstraints) GetSidAlgo() uint32 {
	if x != nil && x.SidAlgo != nil {
		return *x.SidAlgo
	}
	return 0
}

func (x *SLSrConstraints) GetMaximumSidDepth() uint32 {
	if x != nil {
		return x.MaximumSidDepth
	}
	return 0
}

type SLSrSrv6BindingSID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Type:
	//
	//	*SLSrSrv6BindingSID_Explicit
	//	*SLSrSrv6BindingSID_Dynamic
	Type isSLSrSrv6BindingSID_Type `protobuf_oneof:"type"`
}

func (x *SLSrSrv6BindingSID) Reset() {
	*x = SLSrSrv6BindingSID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrSrv6BindingSID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrSrv6BindingSID) ProtoMessage() {}

func (x *SLSrSrv6BindingSID) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrSrv6BindingSID.ProtoReflect.Descriptor instead.
func (*SLSrSrv6BindingSID) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{13}
}

func (m *SLSrSrv6BindingSID) GetType() isSLSrSrv6BindingSID_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (x *SLSrSrv6BindingSID) GetExplicit() *SLSRv6SIDInfo {
	if x, ok := x.GetType().(*SLSrSrv6BindingSID_Explicit); ok {
		return x.Explicit
	}
	return nil
}

func (x *SLSrSrv6BindingSID) GetDynamic() *SLSrSrv6DynamicBindingSID {
	if x, ok := x.GetType().(*SLSrSrv6BindingSID_Dynamic); ok {
		return x.Dynamic
	}
	return nil
}

type isSLSrSrv6BindingSID_Type interface {
	isSLSrSrv6BindingSID_Type()
}

type SLSrSrv6BindingSID_Explicit struct {
	Explicit *SLSRv6SIDInfo `protobuf:"bytes,1,opt,name=explicit,proto3,oneof"`
}

type SLSrSrv6BindingSID_Dynamic struct {
	Dynamic *SLSrSrv6DynamicBindingSID `protobuf:"bytes,2,opt,name=dynamic,proto3,oneof"`
}

func (*SLSrSrv6BindingSID_Explicit) isSLSrSrv6BindingSID_Type() {}

func (*SLSrSrv6BindingSID_Dynamic) isSLSrSrv6BindingSID_Type() {}

type SLSrMPLSBindingSID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If not set, dynamic MPLS BSID will be allocated
	MplsBsid *uint32 `protobuf:"varint,1,opt,name=mpls_bsid,json=mplsBsid,proto3,oneof" json:"mpls_bsid,omitempty"`
}

func (x *SLSrMPLSBindingSID) Reset() {
	*x = SLSrMPLSBindingSID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrMPLSBindingSID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrMPLSBindingSID) ProtoMessage() {}

func (x *SLSrMPLSBindingSID) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrMPLSBindingSID.ProtoReflect.Descriptor instead.
func (*SLSrMPLSBindingSID) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{14}
}

func (x *SLSrMPLSBindingSID) GetMplsBsid() uint32 {
	if x != nil && x.MplsBsid != nil {
		return *x.MplsBsid
	}
	return 0
}

type SLSrSrv6DynamicBindingSID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If not set, server will use default behavior
	Behavior uint32 `protobuf:"varint,1,opt,name=behavior,proto3" json:"behavior,omitempty"`
}

func (x *SLSrSrv6DynamicBindingSID) Reset() {
	*x = SLSrSrv6DynamicBindingSID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrSrv6DynamicBindingSID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrSrv6DynamicBindingSID) ProtoMessage() {}

func (x *SLSrSrv6DynamicBindingSID) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrSrv6DynamicBindingSID.ProtoReflect.Descriptor instead.
func (*SLSrSrv6DynamicBindingSID) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{15}
}

func (x *SLSrSrv6DynamicBindingSID) GetBehavior() uint32 {
	if x != nil {
		return x.Behavior
	}
	return 0
}

type SLSrPolicyRsp_PolicyRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SeqNum uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	// SR policy identifier from the request.
	Key *SLSrPolicyKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// return code for the request.
	Status *SLSrStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SLSrPolicyRsp_PolicyRsp) Reset() {
	*x = SLSrPolicyRsp_PolicyRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_srte_policy_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLSrPolicyRsp_PolicyRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLSrPolicyRsp_PolicyRsp) ProtoMessage() {}

func (x *SLSrPolicyRsp_PolicyRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_srte_policy_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLSrPolicyRsp_PolicyRsp.ProtoReflect.Descriptor instead.
func (*SLSrPolicyRsp_PolicyRsp) Descriptor() ([]byte, []int) {
	return file_sl_srte_policy_proto_rawDescGZIP(), []int{1, 0}
}

func (x *SLSrPolicyRsp_PolicyRsp) GetSeqNum() uint64 {
	if x != nil {
		return x.SeqNum
	}
	return 0
}

func (x *SLSrPolicyRsp_PolicyRsp) GetKey() *SLSrPolicyKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SLSrPolicyRsp_PolicyRsp) GetStatus() *SLSrStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

var File_sl_srte_policy_proto protoreflect.FileDescriptor

var file_sl_srte_policy_proto_rawDesc = []byte{
	0x0a, 0x14, 0x73, 0x6c, 0x5f, 0x73, 0x72, 0x74, 0x65, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x1a, 0x12, 0x73, 0x6c, 0x5f, 0x73, 0x72, 0x5f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x99, 0x02, 0x0a, 0x0d, 0x53, 0x4c,
	0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4d, 0x73, 0x67, 0x12, 0x33, 0x0a, 0x04, 0x6f,
	0x70, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x65, 0x6e, 0x48, 0x00, 0x52, 0x04, 0x6f, 0x70, 0x65, 0x6e,
	0x12, 0x3f, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x73, 0x48, 0x00, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x73, 0x12, 0x45, 0x0a, 0x0c, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x74, 0x61, 0x72,
	0x74, 0x4f, 0x66, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x48, 0x00, 0x52, 0x0b, 0x72, 0x65, 0x70,
	0x6c, 0x61, 0x79, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x3f, 0x0a, 0x0a, 0x72, 0x65, 0x70, 0x6c,
	0x61, 0x79, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53,
	0x72, 0x45, 0x6e, 0x64, 0x4f, 0x66, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x48, 0x00, 0x52, 0x09,
	0x72, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x45, 0x6e, 0x64, 0x42, 0x0a, 0x0a, 0x08, 0x6d, 0x73, 0x67,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x92, 0x02, 0x0a, 0x0d, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x52, 0x73, 0x70, 0x12, 0x44, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x73, 0x70, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
	0x73, 0x70, 0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x31, 0x0a,
	0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x53, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x1a, 0x87, 0x01, 0x0a, 0x09, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x73, 0x70, 0x12, 0x17,
	0x0a, 0x07, 0x73, 0x65, 0x71, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x06, 0x73, 0x65, 0x71, 0x4e, 0x75, 0x6d, 0x12, 0x2e, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4b,
	0x65, 0x79, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x31, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xf5, 0x01, 0x0a, 0x0e, 0x53,
	0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x65, 0x6e, 0x12, 0x1b, 0x0a,
	0x09, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x35, 0x0a, 0x14, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x12, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x88, 0x01,
	0x01, 0x12, 0x45, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x31, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e,
	0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70, 0x65, 0x6e, 0x2e, 0x53,
	0x4c, 0x53, 0x72, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x4d, 0x6f,
	0x64, 0x65, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x2f, 0x0a, 0x13, 0x53, 0x4c, 0x53, 0x72,
	0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x12,
	0x0a, 0x0a, 0x06, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x50,
	0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x10, 0x01, 0x42, 0x17, 0x0a, 0x15, 0x5f, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x72, 0x22, 0x4e, 0x0a, 0x12, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x12, 0x38, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x73, 0x22, 0xae, 0x01, 0x0a, 0x0d, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x52, 0x65, 0x71, 0x12, 0x41, 0x0a, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x65, 0x71, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x4f, 0x70, 0x52, 0x09, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x31, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x27, 0x0a, 0x06, 0x53, 0x4c,
	0x53, 0x72, 0x4f, 0x70, 0x12, 0x11, 0x0a, 0x0d, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x5f, 0x55,
	0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x45, 0x4c, 0x45, 0x54,
	0x45, 0x10, 0x01, 0x22, 0x11, 0x0a, 0x0f, 0x53, 0x4c, 0x53, 0x72, 0x45, 0x6e, 0x64, 0x4f, 0x66,
	0x52, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x22, 0x13, 0x0a, 0x11, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x74,
	0x61, 0x72, 0x74, 0x4f, 0x66, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x79, 0x22, 0xc4, 0x01, 0x0a, 0x0a,
	0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x17, 0x0a, 0x07, 0x73, 0x65,
	0x71, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x73, 0x65, 0x71,
	0x4e, 0x75, 0x6d, 0x12, 0x2e, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4b, 0x65, 0x79, 0x52, 0x03,
	0x6b, 0x65, 0x79, 0x12, 0x39, 0x0a, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x41, 0x74, 0x74,
	0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x52, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x12, 0x32,
	0x0a, 0x03, 0x43, 0x50, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72,
	0x43, 0x61, 0x6e, 0x64, 0x69, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x74, 0x68, 0x52, 0x03, 0x43,
	0x50, 0x73, 0x22, 0x9e, 0x02, 0x0a, 0x14, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x5f, 0x65, 0x6c, 0x69, 0x67, 0x69, 0x62, 0x6c, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x45, 0x6c,
	0x69, 0x67, 0x69, 0x62, 0x6c, 0x65, 0x12, 0x3a, 0x0a, 0x09, 0x64, 0x61, 0x74, 0x61, 0x70, 0x6c,
	0x61, 0x6e, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x44, 0x61,
	0x74, 0x61, 0x70, 0x6c, 0x61, 0x6e, 0x65, 0x52, 0x09, 0x64, 0x61, 0x74, 0x61, 0x70, 0x6c, 0x61,
	0x6e, 0x65, 0x12, 0x3e, 0x0a, 0x09, 0x6d, 0x70, 0x6c, 0x73, 0x5f, 0x62, 0x73, 0x69, 0x64, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x4d, 0x50, 0x4c, 0x53, 0x42, 0x69,
	0x6e, 0x64, 0x69, 0x6e, 0x67, 0x53, 0x49, 0x44, 0x52, 0x08, 0x6d, 0x70, 0x6c, 0x73, 0x42, 0x73,
	0x69, 0x64, 0x12, 0x40, 0x0a, 0x0a, 0x73, 0x72, 0x76, 0x36, 0x5f, 0x62, 0x73, 0x69, 0x64, 0x73,
	0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x72, 0x76, 0x36, 0x42,
	0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x53, 0x49, 0x44, 0x52, 0x09, 0x73, 0x72, 0x76, 0x36, 0x42,
	0x73, 0x69, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,
	0x65, 0x49, 0x64, 0x22, 0x8f, 0x02, 0x0a, 0x11, 0x53, 0x4c, 0x53, 0x72, 0x43, 0x61, 0x6e, 0x64,
	0x69, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x74, 0x68, 0x12, 0x35, 0x0a, 0x03, 0x6b, 0x65, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x43, 0x61, 0x6e, 0x64, 0x69,
	0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0a, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e,
	0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x01, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x88, 0x01, 0x01, 0x12, 0x38, 0x0a, 0x07, 0x64, 0x79, 0x6e,
	0x61, 0x6d, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x44,
	0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x50, 0x48, 0x00, 0x52, 0x07, 0x64, 0x79, 0x6e, 0x61,
	0x6d, 0x69, 0x63, 0x12, 0x3b, 0x0a, 0x08, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x45, 0x78, 0x70, 0x6c, 0x69, 0x63,
	0x69, 0x74, 0x43, 0x50, 0x48, 0x00, 0x52, 0x08, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74,
	0x42, 0x04, 0x0a, 0x02, 0x43, 0x50, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x22, 0x74, 0x0a, 0x0e, 0x53, 0x4c, 0x53, 0x72, 0x45, 0x78, 0x70,
	0x6c, 0x69, 0x63, 0x69, 0x74, 0x43, 0x50, 0x12, 0x41, 0x0a, 0x0c, 0x73, 0x65, 0x67, 0x6d, 0x65,
	0x6e, 0x74, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c,
	0x53, 0x72, 0x53, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x0b, 0x73,
	0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0a, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x22, 0x72, 0x0a, 0x0d, 0x53,
	0x4c, 0x53, 0x72, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x43, 0x50, 0x12, 0x1f, 0x0a, 0x0b,
	0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x12, 0x40, 0x0a,
	0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x73, 0x52, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x22,
	0xee, 0x01, 0x0a, 0x0f, 0x53, 0x4c, 0x53, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x73, 0x12, 0x3d, 0x0a, 0x0a, 0x61, 0x66, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x41, 0x66, 0x66, 0x69,
	0x6e, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x0a, 0x61, 0x66, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
	0x65, 0x73, 0x12, 0x43, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x74, 0x65, 0x50, 0x72, 0x6f,
	0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x70, 0x72, 0x6f,
	0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x08, 0x73, 0x69, 0x64, 0x5f, 0x61,
	0x6c, 0x67, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x07, 0x73, 0x69, 0x64,
	0x41, 0x6c, 0x67, 0x6f, 0x88, 0x01, 0x01, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x69, 0x6d,
	0x75, 0x6d, 0x5f, 0x73, 0x69, 0x64, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x53, 0x69, 0x64, 0x44, 0x65,
	0x70, 0x74, 0x68, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x73, 0x69, 0x64, 0x5f, 0x61, 0x6c, 0x67, 0x6f,
	0x22, 0x9e, 0x01, 0x0a, 0x12, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x72, 0x76, 0x36, 0x42, 0x69, 0x6e,
	0x64, 0x69, 0x6e, 0x67, 0x53, 0x49, 0x44, 0x12, 0x3a, 0x0a, 0x08, 0x65, 0x78, 0x70, 0x6c, 0x69,
	0x63, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x52, 0x76, 0x36,
	0x53, 0x49, 0x44, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x65, 0x78, 0x70, 0x6c, 0x69,
	0x63, 0x69, 0x74, 0x12, 0x44, 0x0a, 0x07, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c,
	0x61, 0x79, 0x65, 0x72, 0x2e, 0x53, 0x4c, 0x53, 0x72, 0x53, 0x72, 0x76, 0x36, 0x44, 0x79, 0x6e,
	0x61, 0x6d, 0x69, 0x63, 0x42, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x53, 0x49, 0x44, 0x48, 0x00,
	0x52, 0x07, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x42, 0x06, 0x0a, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x22, 0x44, 0x0a, 0x12, 0x53, 0x4c, 0x53, 0x72, 0x4d, 0x50, 0x4c, 0x53, 0x42, 0x69, 0x6e,
	0x64, 0x69, 0x6e, 0x67, 0x53, 0x49, 0x44, 0x12, 0x20, 0x0a, 0x09, 0x6d, 0x70, 0x6c, 0x73, 0x5f,
	0x62, 0x73, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x08, 0x6d, 0x70,
	0x6c, 0x73, 0x42, 0x73, 0x69, 0x64, 0x88, 0x01, 0x01, 0x42, 0x0c, 0x0a, 0x0a, 0x5f, 0x6d, 0x70,
	0x6c, 0x73, 0x5f, 0x62, 0x73, 0x69, 0x64, 0x22, 0x37, 0x0a, 0x19, 0x53, 0x4c, 0x53, 0x72, 0x53,
	0x72, 0x76, 0x36, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x42, 0x69, 0x6e, 0x64, 0x69, 0x6e,
	0x67, 0x53, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72,
	0x32, 0x5e, 0x0a, 0x0c, 0x53, 0x4c, 0x53, 0x72, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x12, 0x4e, 0x0a, 0x0c, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4f, 0x70,
	0x12, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2e, 0x53, 0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4d, 0x73, 0x67, 0x1a, 0x1c,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x2e, 0x53,
	0x4c, 0x53, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x73, 0x70, 0x28, 0x01, 0x30, 0x01,
	0x42, 0x51, 0x5a, 0x4f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43,
	0x69, 0x73, 0x63, 0x6f, 0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61, 0x79,
	0x65, 0x72, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x61, 0x79, 0x65, 0x72,
	0x2d, 0x6f, 0x62, 0x6a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x73, 0x3b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_srte_policy_proto_rawDescOnce sync.Once
	file_sl_srte_policy_proto_rawDescData = file_sl_srte_policy_proto_rawDesc
)

func file_sl_srte_policy_proto_rawDescGZIP() []byte {
	file_sl_srte_policy_proto_rawDescOnce.Do(func() {
		file_sl_srte_policy_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_srte_policy_proto_rawDescData)
	})
	return file_sl_srte_policy_proto_rawDescData
}

var file_sl_srte_policy_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_sl_srte_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_sl_srte_policy_proto_goTypes = []interface{}{
	(SLSrPolicyOpen_SLSrPersistenceMode)(0), // 0: service_layer.SLSrPolicyOpen.SLSrPersistenceMode
	(SLSrPolicyReq_SLSrOp)(0),               // 1: service_layer.SLSrPolicyReq.SLSrOp
	(*SLSrPolicyMsg)(nil),                   // 2: service_layer.SLSrPolicyMsg
	(*SLSrPolicyRsp)(nil),                   // 3: service_layer.SLSrPolicyRsp
	(*SLSrPolicyOpen)(nil),                  // 4: service_layer.SLSrPolicyOpen
	(*SLSrPolicyRequests)(nil),              // 5: service_layer.SLSrPolicyRequests
	(*SLSrPolicyReq)(nil),                   // 6: service_layer.SLSrPolicyReq
	(*SLSrEndOfReplay)(nil),                 // 7: service_layer.SLSrEndOfReplay
	(*SLSrStartOfReplay)(nil),               // 8: service_layer.SLSrStartOfReplay
	(*SLSrPolicy)(nil),                      // 9: service_layer.SLSrPolicy
	(*SLSrPolicyAttributes)(nil),            // 10: service_layer.SLSrPolicyAttributes
	(*SLSrCandidatePath)(nil),               // 11: service_layer.SLSrCandidatePath
	(*SLSrExplicitCP)(nil),                  // 12: service_layer.SLSrExplicitCP
	(*SLSrDynamicCP)(nil),                   // 13: service_layer.SLSrDynamicCP
	(*SLSrConstraints)(nil),                 // 14: service_layer.SLSrConstraints
	(*SLSrSrv6BindingSID)(nil),              // 15: service_layer.SLSrSrv6BindingSID
	(*SLSrMPLSBindingSID)(nil),              // 16: service_layer.SLSrMPLSBindingSID
	(*SLSrSrv6DynamicBindingSID)(nil),       // 17: service_layer.SLSrSrv6DynamicBindingSID
	(*SLSrPolicyRsp_PolicyRsp)(nil),         // 18: service_layer.SLSrPolicyRsp.PolicyRsp
	(*SLSrStatus)(nil),                      // 19: service_layer.SLSrStatus
	(*SLSrPolicyKey)(nil),                   // 20: service_layer.SLSrPolicyKey
	(SLSrDataplane)(0),                      // 21: service_layer.SLSrDataplane
	(*SLSrCandidatePathKey)(nil),            // 22: service_layer.SLSrCandidatePathKey
	(*SLSrSegmentList)(nil),                 // 23: service_layer.SLSrSegmentList
	(*SLSrAffinities)(nil),                  // 24: service_layer.SLSrAffinities
	(SLSrteProtectionType)(0),               // 25: service_layer.SLSrteProtectionType
	(*SLSRv6SIDInfo)(nil),                   // 26: service_layer.SLSRv6SIDInfo
}
var file_sl_srte_policy_proto_depIdxs = []int32{
	4,  // 0: service_layer.SLSrPolicyMsg.open:type_name -> service_layer.SLSrPolicyOpen
	5,  // 1: service_layer.SLSrPolicyMsg.requests:type_name -> service_layer.SLSrPolicyRequests
	8,  // 2: service_layer.SLSrPolicyMsg.replay_start:type_name -> service_layer.SLSrStartOfReplay
	7,  // 3: service_layer.SLSrPolicyMsg.replay_end:type_name -> service_layer.SLSrEndOfReplay
	18, // 4: service_layer.SLSrPolicyRsp.responses:type_name -> service_layer.SLSrPolicyRsp.PolicyRsp
	19, // 5: service_layer.SLSrPolicyRsp.status:type_name -> service_layer.SLSrStatus
	0,  // 6: service_layer.SLSrPolicyOpen.mode:type_name -> service_layer.SLSrPolicyOpen.SLSrPersistenceMode
	6,  // 7: service_layer.SLSrPolicyRequests.requests:type_name -> service_layer.SLSrPolicyReq
	1,  // 8: service_layer.SLSrPolicyReq.operation:type_name -> service_layer.SLSrPolicyReq.SLSrOp
	9,  // 9: service_layer.SLSrPolicyReq.policy:type_name -> service_layer.SLSrPolicy
	20, // 10: service_layer.SLSrPolicy.key:type_name -> service_layer.SLSrPolicyKey
	10, // 11: service_layer.SLSrPolicy.attrs:type_name -> service_layer.SLSrPolicyAttributes
	11, // 12: service_layer.SLSrPolicy.CPs:type_name -> service_layer.SLSrCandidatePath
	21, // 13: service_layer.SLSrPolicyAttributes.dataplane:type_name -> service_layer.SLSrDataplane
	16, // 14: service_layer.SLSrPolicyAttributes.mpls_bsid:type_name -> service_layer.SLSrMPLSBindingSID
	15, // 15: service_layer.SLSrPolicyAttributes.srv6_bsids:type_name -> service_layer.SLSrSrv6BindingSID
	22, // 16: service_layer.SLSrCandidatePath.key:type_name -> service_layer.SLSrCandidatePathKey
	13, // 17: service_layer.SLSrCandidatePath.dynamic:type_name -> service_layer.SLSrDynamicCP
	12, // 18: service_layer.SLSrCandidatePath.explicit:type_name -> service_layer.SLSrExplicitCP
	23, // 19: service_layer.SLSrExplicitCP.segment_list:type_name -> service_layer.SLSrSegmentList
	14, // 20: service_layer.SLSrDynamicCP.constraints:type_name -> service_layer.SLSrConstraints
	24, // 21: service_layer.SLSrConstraints.affinities:type_name -> service_layer.SLSrAffinities
	25, // 22: service_layer.SLSrConstraints.protection:type_name -> service_layer.SLSrteProtectionType
	26, // 23: service_layer.SLSrSrv6BindingSID.explicit:type_name -> service_layer.SLSRv6SIDInfo
	17, // 24: service_layer.SLSrSrv6BindingSID.dynamic:type_name -> service_layer.SLSrSrv6DynamicBindingSID
	20, // 25: service_layer.SLSrPolicyRsp.PolicyRsp.key:type_name -> service_layer.SLSrPolicyKey
	19, // 26: service_layer.SLSrPolicyRsp.PolicyRsp.status:type_name -> service_layer.SLSrStatus
	2,  // 27: service_layer.SLSrtePolicy.SLSrPolicyOp:input_type -> service_layer.SLSrPolicyMsg
	3,  // 28: service_layer.SLSrtePolicy.SLSrPolicyOp:output_type -> service_layer.SLSrPolicyRsp
	28, // [28:29] is the sub-list for method output_type
	27, // [27:28] is the sub-list for method input_type
	27, // [27:27] is the sub-list for extension type_name
	27, // [27:27] is the sub-list for extension extendee
	0,  // [0:27] is the sub-list for field type_name
}

func init() { file_sl_srte_policy_proto_init() }
func file_sl_srte_policy_proto_init() {
	if File_sl_srte_policy_proto != nil {
		return
	}
	file_sl_sr_common_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_srte_policy_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyOpen); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyRequests); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyReq); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrEndOfReplay); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrStartOfReplay); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyAttributes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrCandidatePath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrExplicitCP); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrDynamicCP); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrConstraints); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrSrv6BindingSID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrMPLSBindingSID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrSrv6DynamicBindingSID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_srte_policy_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLSrPolicyRsp_PolicyRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_sl_srte_policy_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*SLSrPolicyMsg_Open)(nil),
		(*SLSrPolicyMsg_Requests)(nil),
		(*SLSrPolicyMsg_ReplayStart)(nil),
		(*SLSrPolicyMsg_ReplayEnd)(nil),
	}
	file_sl_srte_policy_proto_msgTypes[2].OneofWrappers = []interface{}{}
	file_sl_srte_policy_proto_msgTypes[9].OneofWrappers = []interface{}{
		(*SLSrCandidatePath_Dynamic)(nil),
		(*SLSrCandidatePath_Explicit)(nil),
	}
	file_sl_srte_policy_proto_msgTypes[12].OneofWrappers = []interface{}{}
	file_sl_srte_policy_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*SLSrSrv6BindingSID_Explicit)(nil),
		(*SLSrSrv6BindingSID_Dynamic)(nil),
	}
	file_sl_srte_policy_proto_msgTypes[14].OneofWrappers = []interface{}{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_srte_policy_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_sl_srte_policy_proto_goTypes,
		DependencyIndexes: file_sl_srte_policy_proto_depIdxs,
		EnumInfos:         file_sl_srte_policy_proto_enumTypes,
		MessageInfos:      file_sl_srte_policy_proto_msgTypes,
	}.Build()
	File_sl_srte_policy_proto = out.File
	file_sl_srte_policy_proto_rawDesc = nil
	file_sl_srte_policy_proto_goTypes = nil
	file_sl_srte_policy_proto_depIdxs = nil
}
