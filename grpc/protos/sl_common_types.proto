// @file
// @brief Common definitions for all of the service layer proto files. 
//
//---------------------------------------------------------------------
// Copyright (c) 2019, 2024-2025 by Cisco Systems, Inc.
// All rights reserved.
//---------------------------------------------------------------------
//
//

//@defgroup Common
//@brief Common service definitions and Global initializations.

syntax = "proto3";
package service_layer;
option go_package="github.com/Cisco-service-layer/service-layer-objmodel/grpc/protos;service_layer";

// @defgroup SLCommonTypes
// @ingroup Common
// Service Layer common types.
// The following messages are used as common Service Layer types.
// @{

// Status codes, including errors and success codes.
// All service layer errors are defined below.
message SLErrorStatus {
    enum SLErrno {

        // !!! Common error codes for all RPCs and objects

        // Success, no errors detected. 0x0.
        SL_SUCCESS = 0x0;
        // Client not connected. 0x1
        SL_NOT_CONNECTED = 0x1;
        // Operation must be retried. 0x2
        SL_EAGAIN = 0x2;
        // One or more components does not have sufficient memory. 0x3
        SL_ENOMEM = 0x3;
        // Too many outstanding requests. 0x4
        SL_EBUSY = 0x4;
        // One or more arguments are invalid. 0x5
        SL_EINVAL = 0x5;
        // Unsupported version. 0x6
        SL_UNSUPPORTED_VER = 0x6;
        // Not Available. 0x7
        SL_NOT_AVAILABLE = 0x7;
        // Stream mode not supported. 0x8
        SL_STREAM_NOT_SUPPORTED = 0x8;
        // Operation not supported. 0x9
        SL_ENOTSUP = 0x9;
        // One or more objects is errored:
        // Each object must be individually examined. 0xa
        SL_SOME_ERR = 0xa;
        // Operation Timed out.
        // The result of the operation is undeterministic (success or fail). 0xb
        SL_TIMEOUT = 0xb;
        // Due to some event, the client will no longer receive notification
        // events on this channel. 0xc
        // Such events include:
        // - Notification Session was hijacked by another client.
        SL_NOTIF_TERM = 0xc;

        // Authentication failure.
        // Incorrect credentials passed in by RPC. 0xd
        SL_AUTH_FAIL = 0xd;
        // Ack type not supported error. 0xe
        SL_ACK_TYPE_NOT_SUPPORTED = 0xe;

        // !!! Error codes for Client INIT operations.

        // Offset for INIT errors. 0x500
        SL_INIT_START_OFFSET = 0x500;
        // Success, no errors detected - clear state.
        // This error is returned on the first-ever initialization, or,
        // when a fatal event has occured and all previous state was lost. 0x501
        SL_INIT_STATE_CLEAR = 0x501;
        // Success, no errors detected - previous state is recovered.
        // This error is returned on a client re-initialization with
        // successful recovery of state. Note that any unacknowledged
        // data previously sent should be considered lost. 0x502
        SL_INIT_STATE_READY = 0x502;
        // Server software incompatible with client software version. 0x503
        SL_INIT_UNSUPPORTED_VER = 0x503;
        // Initialization request received while server is not ready. 0x504
        SL_INIT_SERVER_NOT_INITIALIZED = 0x504;
        // Server operational mode change from stream to non-stream
        // or vice-versa failed. 0x505
        SL_INIT_SERVER_MODE_CHANGE_FAILED = 0x505;

        // !!! Error codes for VRF operations.

        // Offset for VRF errors. 0x1000
        SL_RPC_VRF_START_OFFSET = 0x1000;
        // Operation rejected for ALL VRFs due to too many VRF registration
        // messages in the request. 0x1001
        SL_RPC_VRF_TOO_MANY_VRF_REG_MSGS = 0x1001;
        // Operation rejected for all VRFs as server is not initialized. 0x1002
        SL_RPC_VRF_SERVER_NOT_INITIALIZED = 0x1002;
        // Operation not supported in auto-register mode. 0x1003
        SL_RPC_VRF_OP_NOTSUP_WITH_AUTOREG = 0x1003;
        
        // !!! Error codes for VRF objects.

        // Offset for VRF errors. 0x2000
        SL_VRF_START_OFFSET = 0x2000;
        // VRF name in the VRF registration message is too long. 0x2001
        SL_VRF_NAME_TOOLONG = 0x2001;
        // VRF not found during a unregister or EOF. 0x2002
        SL_VRF_NOT_FOUND = 0x2002;
        // On a VRF registration, Table ID for the VRF is not found. 0x2003
        SL_VRF_NO_TABLE_ID = 0x2003;
        // VRF add registration message with invalid administrative distance. 0x2004
        SL_VRF_REG_INVALID_ADMIN_DISTANCE = 0x2004;
        // On a VRF registration, Table cannot be added to persistent memory. 0x2005
        SL_VRF_TABLE_ADD_ERR = 0x2005;
        // VRF table cannot be registered with RIB. 0x2006
        SL_VRF_TABLE_REGISTRATION_ERR = 0x2006;
        // VRF table cannot be unregistered with RIB. 0x2007
        SL_VRF_TABLE_UNREGISTRATION_ERR = 0x2007;
        // VRF table RIB EOF operation error. 0x2008
        SL_VRF_TABLE_EOF_ERR = 0x2008;
        // VRF registration message does not have a VRF name. 0x2009
        SL_VRF_REG_VRF_NAME_MISSING = 0x2009;
        // IPv4 routes in VRF cannot be played to Routing Information Base
        // on a process restart or connection re-establishment.
        // The Forwarding Information Base can
        // can be inconsistent. Agent/Controller should initiate a
        // recovery action by reloading the device. 0x2010
        SL_VRF_V4_ROUTE_REPLAY_FATAL_ERROR = 0x2010;
        // IPv6 routes in VRF cannot be played to Routing Information Base
        // on a process restart or connection re-establishment.
        // The Forwarding Information Base can
        // can be inconsistent. Agent/Controller should initiate a
        // recovery action by reloading the device. 0x2011
        SL_VRF_V6_ROUTE_REPLAY_FATAL_ERROR = 0x2011;
        // IPv4 routes in VRF were played to Routing Information Base
        // on a process restart or connection re-establishment. 0x2012
        SL_VRF_V4_ROUTE_REPLAY_OK = 0x2012;
        // IPv6 routes in VRF were played to Routing Information Base
        // on a process restart or connection re-establishment. 0x2013
        SL_VRF_V6_ROUTE_REPLAY_OK = 0x2013;

        // !!! Error codes for Route operations.
        
        // Offset for Route operation errors. 0x3000
        SL_RPC_ROUTE_START_OFFSET = 0x3000;
        // Operation rejected for ALL routes due to too many routes in the
        // request. 0x3001
        SL_RPC_ROUTE_TOO_MANY_ROUTES = 0x3001;
        // Operation rejected for ALL routes as the request's VRF name
        // is too long. 0x3002
        SL_RPC_ROUTE_VRF_NAME_TOOLONG = 0x3002;
        // Operation rejected for ALL routes as VRF for the given name
        // is not found. 0x3003
        SL_RPC_ROUTE_VRF_NOT_FOUND = 0x3003;
        // Operation rejected for ALL routes as VRF's Table ID is not found.
        // 0x3004
        SL_RPC_ROUTE_VRF_NO_TABLE = 0x3004;
        // Operation rejected for ALL routes as VRF is not registered with RIB.
        // 0x3005
        SL_RPC_ROUTE_VRF_TABLE_NOT_REGISTERED = 0x3005;
        // Route Operation rejected for ALL objects as VRF name is missing.
        // 0x3006
        SL_RPC_ROUTE_VRF_NAME_MISSING = 0x3006;
        // Operation rejected for all routes as the RPC request is
        // not supported for the library's initialization mode. 0x3007
        SL_RPC_ROUTE_INIT_MODE_INCOMPATIBLE = 0x3007;
        // Operation rejected for all routes as server is not initialized.
        // 0x3008
        SL_RPC_ROUTE_SERVER_NOT_INITIALIZED = 0x3008;
        // Operation rejected as the request's SrcProto is too long. 0x3009
        SL_RPC_ROUTE_NOTIF_SRC_PROTO_TOOLONG = 0x3009;
        // Operation rejected as the request's SrcProtoTag is too long. 0x300a
        SL_RPC_ROUTE_NOTIF_SRC_PROTO_TAG_TOOLONG = 0x300a;
        // Operation rejected as the requested match value/values/criteria is invalid. 0x300b
        SL_RPC_ROUTE_GET_MATCH_INVALID = 0x300b;
        // Operation rejected as the requested match value/values/criteria is not supported. 0x300c
        SL_RPC_ROUTE_GET_MATCH_NOTSUP = 0x300c;

        // !!! Error codes for Route objects.

        // Offset for route errors. 0x4000
        SL_ROUTE_START_OFFSET = 0x4000;
        // Route add operation requested but no paths were provided. 0x4001
        SL_ROUTE_ADD_NO_PATHS = 0x4001;
        // Route update operation requested but no paths were provided. 0x4002
        SL_ROUTE_UPDATE_NO_PATHS = 0x4002;
        // Route's prefix length is invalid. 0x4003
        SL_ROUTE_INVALID_PREFIX_LEN = 0x4003;
        // Route's admininstrative distance is invalid. 0x4004
        SL_ROUTE_INVALID_ADMIN_DISTANCE = 0x4004;
        // Route's number of paths exceeds system capabilities. 0x4005
        SL_ROUTE_INVALID_NUM_PATHS = 0x4005;
        // Size of IPv6 prefix is invalid. 0x4006
        SL_ROUTE_INVALID_PREFIX_SZ = 0x4006;
        // Route's prefix is invalid. 0x4007
        SL_ROUTE_INVALID_PREFIX = 0x4007;
        // Route programming failed in RIB as VRF table limit reached. 0x4008
        SL_ROUTE_ERR_RIB_TABLE_LIMIT_REACHED = 0x4008;
        // RIB route programming failed in RIB due to invalid arguments. 0x4009
        SL_ROUTE_ERR_RIB_INVALID_ARGS = 0x4009;
        // One or more paths could not be programmed in RIB as VRF
        // table limit reached. 0x400a
        SL_ROUTE_ERR_RIB_PATH_TABLE_LIMIT = 0x400a;
        // One or more paths could not be programmed in RIB as number of paths
        // reached system limit. 0x400b
        SL_ROUTE_ERR_RIB_TOOMANYPATHS = 0x400b;
        // This route already exists in the database. 0x400c  
        SL_ROUTE_EEXIST = 0x400c;
        // Route prefix has host bits set. 0x400d
        SL_ROUTE_HOST_BITS_SET = 0x400d;
        // IPv4 Route prefix is a multicast address. 0x400e
        SL_ROUTE_INVALID_PREFIX_MCAST = 0x400e;
        // Route and Path AFI does not match. 0x400f
        SL_ROUTE_PATH_AFI_MISMATCH = 0x400f;
        // Number of primary paths exceeds system capabilities. 0x4010
        SL_ROUTE_TOOMANY_PRIMARY_PATHS = 0x4010;
        // Number of backup paths exceeds system capabilities. 0x4011
        SL_ROUTE_TOOMANY_BACKUP_PATHS = 0x4011;
        // The route database is out of memory. 0x4012
        SL_ROUTE_DB_NOMEM = 0x4012;
        // The route has an invalid local label. 0x4013
        SL_ROUTE_INVALID_LOCAL_LABEL = 0x4013;
        // Invalid route flags. 0x4014
        SL_ROUTE_INVALID_FLAGS = 0x4014;

        // !!! Error codes for route path objects.

        // Offset for route path errors. 0x5000
        SL_PATH_START_OFFSET = 0x5000;
        // VRF table for the path could not be determined. 0x5001
        SL_PATH_NH_NO_TABLE = 0x5001;
        // Path next hop interface not found. 0x5002
        SL_PATH_NH_INTF_NOT_FOUND = 0x5002;
        // Number of labels in the path exceeds system capabilities. 0x5003
        SL_PATH_INVALID_LABEL_COUNT = 0x5003;
        // Path ID assigned to the path falls outside the supported range. 0x5004
        SL_PATH_INVALID_ID = 0x5004;
        // Path VRF name exceeds supported length. 0x5005
        SL_PATH_VRF_NAME_TOOLONG = 0x5005;
        // Path next hop interface name exceeds supported length. 0x5006
        SL_PATH_NH_INTF_NAME_TOOLONG = 0x5006;
        // Size of next hop IPv6 address is invalid. 0x5007
        SL_PATH_NH_INVALID_ADDR_SZ = 0x5007;
        // Next hop interface name is missing from path. 0x5008
        SL_PATH_NH_INF_NAME_MISSING = 0x5008;
        // Path has an invalid next hop address. 0x5009
        SL_PATH_INVALID_NEXT_HOP_ADDR = 0x5009;
        // Number of remote backup addresses in the path exceeds
        // system capabilities. 0x500a
        SL_PATH_INVALID_REMOTE_ADDR_COUNT = 0x500a;
        // Size of IPv6 remote backup address is invalid. 0x500b
        SL_PATH_REMOTE_ADDR_INVALID_SZ = 0x500b;
        // Route and Path remote backup address AFI does not match. 0x500c
        SL_PATH_REMOTE_ADDR_AFI_MISMATCH = 0x500c;
        // Path has an invalid protection bitmap. 0x500d
        SL_PATH_INVALID_PROTECTED_BITMAP = 0x500d;
        // Protection bitmap of a backup path refers to a missing path. 0x500e
        SL_PATH_BACKUP_MISSING_PRIMARY_PATH = 0x500e;
        // Too many primary paths with same Path ID. 0x500f
        SL_PATH_PRIMARY_ID_REPEATED = 0x500f;
        // Too many pure backup paths with same Path ID. 0x5010
        SL_PATH_BACKUP_ID_REPEATED = 0x5010;
        // A primary path has too many backup paths. 0x5011
        SL_PATH_PRIMARY_TOOMANY_BACKUP_PATHS = 0x5011;
        // A primary path has too many labels. 0x5012
        SL_PATH_PRIMARY_TOOMANY_LABELS = 0x5012;
        // A primary path has too many remote addresses. 0x5013
        SL_PATH_PRIMARY_TOOMANY_REMOTE_ADDR = 0x5013;
        // A pure backup remote address is invalid. 0x5014
        SL_PATH_REMOTE_ADDR_INVALID = 0x5014;
        // Path has an invalid label. 0x5015
        SL_PATH_INVALID_LABEL = 0x5015;
        // Size of router mac address is invalid. 0x5016
        SL_PATH_ROUTER_MAC_ADDR_INVALID_SZ = 0x5016;
        // A backup path has too many labels. 0x5017
        SL_PATH_BACKUP_TOOMANY_LABELS = 0x5017;
        // Invalid VNI for VxLAN encap. 0x5018
        SL_PATH_INVALID_VNI = 0x5018;
        // Path has an invalid  encap address. 0x5019
        SL_PATH_INVALID_ENCAP_ADDR = 0x5019;
        // Path encapsulation source and destination AFI mismatch. 0x501a
        SL_PATH_ENCAP_SRC_DST_AFI_MISMATCH = 0x501a;
        // PATH router mac is not supported with VxLAN path attributes. 0x501b
        SL_PATH_RTR_MAC_NOSUP = 0x501b;
        // Path Encap type attribute does not match specified encapsulation. 0x501c
        SL_PATH_ENCAP_TYPE_MISMATCH = 0x501c;

        // !!! Error codes for BFD opertations.

        // Offset for BFD operation errors. 0x6000
        SL_RPC_BFD_START_OFFSET = 0x6000;
        // BFD Operation rejected for ALL Sessions as the BFD Session count
        // is beyond supported limit. 0x6001
        SL_RPC_BFD_TOO_MANY_BFD_SESSIONS = 0x6001;
        // BFD Operation rejected due to one or many invalid parameters. 0x6002
        SL_RPC_BFD_API_BAD_PARAMETER = 0x6002;
        // BFD Operation failed as server is not registered with BFD. 0x6003
        SL_RPC_BFD_API_CLIENT_NOT_REGISTERED = 0x6003;
        // BFD Operation failed with internal error. 0x6004
        SL_RPC_BFD_API_INTERNAL_ERROR = 0x6004;
        // BFD Operation rejected as server is not initialized. 0x6005
        SL_RPC_BFD_SERVER_NOT_INITIALIZED = 0x6005;
        // BFD IPv4 not registered. 0x6006
        SL_RPC_BFD_V4_NOT_REGISTERED = 0x6006;
        // BFD IPv6 not registered. 0x6007
        SL_RPC_BFD_V6_NOT_REGISTERED = 0x6007;

        // !!! Error codes for BFD Session objects.

        // Offset for BFD errors. 0x7000
        SL_BFD_START_OFFSET = 0x7000;
        // BFD Session's interface name exceeds supported length. 0x7001
        SL_BFD_INTF_NAME_TOOLONG = 0x7001;
        // BFD Session's interface not found. 0x7002
        SL_BFD_INTF_NOT_FOUND = 0x7002;
        // BFD Session's tx interval or multiplier are beyond the 
        // supported range. 0x7003
        SL_BFD_INVALID_ATTRIBUTE = 0x7003;
        // BFD Session's interface name is missing. 0x7004
        SL_BFD_INTF_NAME_MISSING = 0x7004;
        // BFD Session's neighbor is mcast address. 0x7005
        SL_BFD_INVALID_NBR_MCAST = 0x7005;
        // BFD Session's neighbor address is invalid. 0x7006
        SL_BFD_INVALID_NBR = 0x7006;
        // BFD Session's VRF Name is too long. 0x7007
        SL_BFD_VRF_NAME_TOOLONG = 0x7007;
        // BFD Session's one or more parameters are invalid. 
        // For example, Multihop BFD can not have the interface name set. 0x7008
        SL_BFD_BAD_PARAMETER = 0x7008;
        // BFD Session failed with internal error. 0x7009
        SL_BFD_API_INTERNAL_ERROR = 0x7009;
        // BFD Session's VRF not found. 0x700a
        SL_BFD_VRF_NOT_FOUND = 0x700a;
        // BFD Session's neighbor IPv6 prefix size is invalid. 0x700b
        SL_BFD_INVALID_PREFIX_SIZE = 0x700b;
        // BFD Session type invalid. 0x700c
        SL_BFD_INVALID_SESSION_TYPE = 0x700c;
        // BFD Session's VRF is Invalid. 0x700d
        SL_BFD_INVALID_VRF = 0x700d;
        // BFD Session not found. 0x700e
        SL_BFD_SESSION_NOT_FOUND = 0x700e;
        // BFD Session exists. 0x700f
        SL_BFD_SESSION_EXISTS = 0x700f;
        // BFD Internal database error. 0x7010
        SL_BFD_INTERNAL_DB_ERROR = 0x7010;
        // BFD Recovery error. 0x7011
        SL_BFD_RECOVERY_ERROR = 0x7011;

        // !!! Error codes for MPLS opertations.

        // Offset for MPLS operation errors. 0x8000
        SL_RPC_MPLS_START_OFFSET = 0x8000;
        // Operation rejected for ALL ILMS due to too many ILMS in the
        // request. 0x8001
        SL_RPC_MPLS_ILM_TOO_MANY_ILMS = 0x8001;
        // Operation rejected for all ILMs as server is not initialized.
        // 0x0x8002
        SL_RPC_MPLS_SERVER_NOT_INITIALIZED = 0x8002;
        // Operation rejected for all ILMs as the RPC request is
        // not supported for the library's initialization mode. 0x8003
        SL_RPC_MPLS_INIT_MODE_INCOMPATIBLE = 0x8003;
        // Operation rejected for ALL label blocks due to too many
        // label blocks in the request. 0x8004
        SL_RPC_MPLS_LABEL_BLK_TOO_MANY_LABEL_BLKS = 0x8004;
        // Operation rejected for ALL ILMs as MPLS layer is not registered.
        // 0x8005
        SL_RPC_MPLS_NOT_REGISTERED = 0x8005;

        // !!!  MPLS ILM Error codes

        // Offset for MPLS ILM errors. 0x9000
        SL_ILM_ERR_OFFSET = 0x9000;
        // MPLS ILM add to service layer failed. 0x9001
        SL_ILM_ADD_FAILED = 0x9001;
        // MPLS ILM add to Label Switching Database failed. 0x9002
        SL_ILM_LSD_ADD_FAILED = 0x9002;
        // MPLS ILM NHLFE count exceeded max supported number. 0x9003
        SL_ILM_INVALID_NUM_NHLFE = 0x9003;
        // MPLS ILM label value out of range. 0x9004
        SL_ILM_INVALID_LABEL = 0x9004;
        // MPLS ILM delete from service layer failed. 0x9005
        SL_ILM_DELETE_FAILED = 0x9005;
        // MPLS ILM delete from Label Switching Database failed. 0x9006
        SL_ILM_LSD_DELETE_FAILED = 0x9006;
        // Number of primary NHLFEs exceeds system capabilities. 0x9007
        SL_ILM_TOOMANY_PRIMARY_NHLFES = 0x9007;
        // Number of backup NHLFEs exceeds system capabilities. 0x9008
        SL_ILM_TOOMANY_BACKUP_NHLFES = 0x9008;
        // MPLS ILM label alloc failed in Label switching database. 0x9009
        SL_ILM_LSD_ADD_LABEL_ALLOC_FAILED = 0x9009;
        // MPLS ILM NHLFE attribute invalid. 0x900a
        SL_ILM_LSD_NHLFE_INVALID_ATTRIB = 0x900a;
        // MPLS ILM already exists in the database. 0x900b
        SL_ILM_EEXIST = 0x900b;
        // The ILM database is out of memory. 0x900c
        SL_ILM_DB_NOMEM = 0x900c;
        // EXP value is outside of the valid range of <0-7>. 0x900d
        SL_ILM_INVALID_ELSP_EXP = 0x900d;
        // EXP value or Default already set. 0x900e
        SL_ILM_ELSP_EXP_OR_DFLT_ALREADY_SET = 0x900e;
        // MPLS ILM add operation requested but no paths were provided. 0x900f
        SL_ILM_ADD_NO_PATHS = 0x900f;
        // MPLS ILM update operation requested but no paths were provided. 0x9010
        SL_ILM_UPDATE_NO_PATHS = 0x9010;
        // LSP and ELSP on the same label not supported. 0x9011
        SL_ILM_UNSUPPORTED_ELSP = 0x9011;
        // Number of EXP classes on the label exceed system capabilities. 0x9012
        SL_ILM_LABEL_TOOMANY_EXP_CLASSES = 0x9012;
        // MPLS ILMs cannot be played to Label Switching Database
        // on a process restart or connection re-establishment.
        // The Forwarding Information Base can
        // can be inconsistent. Agent/Controller should initiate a
        // recovery action by reloading the device. 0x9013
        SL_ILM_REPLAY_FATAL_ERROR = 0x9013;
        // MPLS ILMs were played to Label Switching Database
        // on a process restart or connection re-establishment. 0x9014
        SL_ILM_REPLAY_OK = 0x9014;
        // ILM's prefix length is invalid. 0x9015
        SL_ILM_INVALID_PREFIX_LEN = 0x9015;
        // ILM prefix has host bits set. 0x9016
        SL_ILM_HOST_BITS_SET = 0x9016;
        // Size of IPv6 prefix is invalid. 0x9017
        SL_ILM_INVALID_PREFIX_SZ = 0x9017;
        // ILM's prefix is invalid. 0x9018
        SL_ILM_INVALID_PREFIX = 0x9018;
        // ILM's IPv4 Route prefix is a multicast address. 0x9019
        SL_ILM_INVALID_PREFIX_MCAST = 0x9019;
        // VRF name is too long. 0x9020
        SL_ILM_VRF_NAME_TOOLONG = 0x9020;
        // VRF's table ID not found. 0x9021
        SL_ILM_VRF_NO_TABLE_ID = 0x9021;
        // VRF name of the ILM route not specified. 0x9022
        SL_ILM_VRF_NAME_MISSING = 0x9022;

        // !!!  MPLS NHLFE Error codes

        // Offset for MPLS NHLFE errors. 0xa000
        SL_NHLFE_ERR_OFFSET = 0xa000;
        // MPLS NHLFE vrf table could not be determined. 0xa001
        SL_NHLFE_NH_NO_TABLE = 0xa001;
        // Size of next hop IPv6 address is invalid. 0xa002
        SL_NHLFE_NH_INVALID_ADDR_SZ = 0xa002;
        // NHLFE has an invalid next hop address. 0xa003
        SL_NHLFE_INVALID_NEXT_HOP_ADDR = 0xa003;
        // Path VRF name exceeds supported length. 0xa004
        SL_NHLFE_VRF_NAME_TOOLONG = 0xa004;
        // Next hop interface name is missing from path. 0xa005
        SL_NHLFE_NH_INF_NAME_MISSING = 0xa005;
        // Interface name exceeds supported length. 0xa006
        SL_NHLFE_NH_INTF_NAME_TOOLONG = 0xa006;
        // Number of labels in the path incompatible with system capabilities 
        // for the given label action. 0xa007
        SL_NHLFE_INVALID_LABEL_COUNT = 0xa007;
        // Path id is invalid in NHLFE. 0xa008
        SL_NHLFE_INVALID_PATH_ID = 0xa008;
        // MPLS NHLFE label value out of range. 0xa009
        SL_NHLFE_INVALID_LABEL = 0xa009;
        // NHLFE has an invalid protection bitmap. 0xa00a
        SL_NHLFE_INVALID_PROTECTED_BITMAP = 0xa00a;
        // Number of remote backup addresses in the NHLFE exceeds
        // system capabilities. 0xa00b
        SL_NHLFE_INVALID_REMOTE_ADDR_COUNT = 0xa00b;
        // Size of IPv6 remote backup address is invalid. 0xa00c
        SL_NHLFE_REMOTE_ADDR_INVALID_SZ = 0xa00c;
        // A primary NHLFE has too many labels. 0xa00d
        SL_NHLFE_PRIMARY_TOOMANY_LABELS = 0xa00d;
        // A primary NHLFE has too many remote addresses. 0xa00e
        SL_NHLFE_PRIMARY_TOOMANY_REMOTE_ADDR = 0xa00e;
        // Too many pure backup NHLFE with same Path ID. 0xa00f
        SL_NHLFE_BACKUP_ID_REPEATED = 0xa00f;
        // Too many primary NHLFE with same Path ID. 0xa010
        SL_NHLFE_PRIMARY_ID_REPEATED = 0xa010;
        // Pure backup NHLFE has a empty protected bitmap. 0xa011
        SL_NHLFE_BACKUP_PROTECTED_BITMAP_EMPTY = 0xa011;
        // A primary NHLFE has too many backup paths. 0xa012
        SL_NHLFE_PRIMARY_TOOMANY_BACKUP_PATHS = 0xa012;
        // A pure backup remote address is invalid. 0xa013
        SL_NHLFE_REMOTE_ADDR_INVALID = 0xa013;
        // Protection bitmap of a backup NHLFE refers to a missing path. 0xa014
        SL_NHLFE_BACKUP_MISSING_PRIMARY_PATH = 0xa014;
        // NHLFE next-hop missing. 0xa015
        SL_NHLFE_NEXT_HOP_MISSING = 0xa015;
        // Label action specified is invalid. 0xa016
        SL_NHLFE_LABEL_ACTION_INVALID = 0xa016;
        // NHLFE next hop interface not found. 0xa017
        SL_NHLFE_NH_INTF_NOT_FOUND = 0xa017;
        // MPLS NHLFE operation failed. 0xa018
        SL_NHLFE_OPER_FAILED = 0xa018;
        // MPLS NHLFE label action missing. 0xa019
        SL_NHLFE_LABEL_ACTION_MISSING = 0xa019;
        // Setting EXP value failed. 0xa01a
        SL_NHLFE_EXP_SET_FAILED = 0xa01a;
        // ELSP protection is unsupported. 0xa01b
        SL_NHLFE_ELSP_PROTECTION_UNSUPPORTED = 0xa01b;
        // EXP value is outside of the valid range of <0-7>. 0xa01c
        SL_NHLFE_INVALID_ELSP_EXP = 0xa01c;
        // Path Priority is invalid (valid: 0 or 1). 0xa01d
        SL_NHLFE_INVALID_PATH_PRIORITY = 0xa01d;
        // Load metric is not zero for a down path. 0xa01e
        SL_NHLFE_INVALID_LOAD_METRIC = 0xa01e;
        // Set ID value is outside of the valid range of <0-7>. 0xa01f
        SL_NHLFE_INVALID_SETID = 0xa01f;
        // Two paths with the same Set ID have different path priorities. 0xa020
        SL_NHLFE_INVALID_SETID_PRIORITY = 0xa020;
        // Multiple Set IDs are set as the primary. 0xa021
        SL_NHLFE_INVALID_MULTIPLE_PRIMARY_SETIDS = 0xa021;
        // Paths with the same SET ID are not contiguous. 0xa022
        SL_NHLFE_NON_CONTIGUOUS_SETIDS = 0xa022;
        // Paths with same EXP classification are not contiguous. 0xa023
        SL_NHLFE_NON_CONTIGUOUS_EXP = 0xa023;
        // On a ILM, mix of NHLFE with EXP class and others without any EXP class are not allowed. 0xa024
        SL_NHLFE_INCONSISTENT_EXP_ON_PATH = 0xa024;

        // !!!  MPLS Label block Error codes

        // Offset for label block errors. 0xb000
        SL_LABEL_BLK_ERR_OFFSET = 0xb000;
        // MPLS label block add from Label Switching Database failed. 0xb001
        SL_LABEL_BLK_LSD_ADD_FAILED = 0xb001;
        // MPLS label block delete from Label Switching Database failed. 0xb002
        SL_LABEL_BLK_LSD_DELETE_FAILED = 0xb002;
        // MPLS label block not found. 0xb003
        SL_LABEL_BLK_LSD_LABEL_BLK_NOT_FOUND = 0xb003;
        // MPLS label block in use. 0xb004
        SL_LABEL_BLK_LSD_LABEL_BLK_IN_USE = 0xb004;
        // MPLS label block attribute invalid. 0xb005
        SL_LABEL_BLK_LSD_INVALID_ATTRIB = 0xb005;
        // MPLS label block size > max size per block. 0xb006
        SL_LABEL_BLK_INVALID_BLOCK_SIZE = 0xb006;
        // MPLS label start_label < min label for platform . 0xb007
        SL_LABEL_BLK_INVALID_START_LABEL = 0xb007;
        // MPLS label block already exists in the database. 0xb008
        SL_LABEL_BLK_EEXIST = 0xb008;
        // MPLS label database is out of memory. 0xb009
        SL_LABEL_BLK_DB_NOMEM = 0xb009;
        // MPLS label block type invalid. 0xb00a
        SL_LABEL_BLK_TYPE_INVALID = 0xb00a;
        // MPLS label block client name exceeds max length. 0xb00b
        SL_LABEL_BLK_CLIENT_NAME_TOOLONG = 0xb00b;

        // !!!  MPLS Reg error codes

        // Offset for MPLS registration errors. 0xc000
        SL_MPLS_REG_ERR_OFFSET = 0xc000;
        // MPLS registration error. 0xc001
        SL_MPLS_REG_ERR = 0xc001;
        // MPLS unregistration error. 0xc002
        SL_MPLS_UNREG_ERR = 0xc002;
        // MPLS EOF error. 0xc003
        SL_MPLS_EOF_ERR = 0xc003;

        // !!! Error codes for Interface operations.

        // Offset for Interface operation errors. 0xd000
        SL_RPC_INTF_START_OFFSET = 0xd000;
        // Interface Operation rejected for ALL Sessions as the Interface
        // Session count is beyond supported limit. 0xd001
        SL_RPC_INTF_TOO_MANY_INTERFACES = 0xd001;
        // Interface Operation rejected as server is not initialized. 0xd002
        SL_RPC_INTF_SERVER_NOT_INITIALIZED = 0xd002;
        // Interface Operation failed as server is not registered with 
        // interface manager. 0xd003
        SL_RPC_INTF_API_CLIENT_NOT_REGISTERED = 0xd003;

        // !!! Error codes for Interface objects.

        // Offset for Interface object errors. 0xe000
        SL_INTF_START_OFFSET = 0xe000;
        // Interface object's interface name missing. 0xe001
        SL_INTF_INTERFACE_NAME_MISSING = 0xe001;
        // Interface object's interface name exceeds supported length. 0xe002
        SL_INTF_INTERFACE_NAME_TOOLONG = 0xe002;
        // Interface internal registration error. 0xe003 
        SL_INTF_INTERFACE_REG_ERR = 0xe003;
        // Internal database error. 0xe004
        SL_INTF_INTERNAL_DB_ERROR = 0xe004;
        // Interface Recovery error. 0xe005
        SL_INTF_RECOVERY_ERROR = 0xe005;
        // Interface exists. 0xe006
        SL_INTF_INTERFACE_EXISTS = 0xe006;
        // Interface not found. 0xe007
        SL_INTF_INTERFACE_NOT_FOUND = 0xe007;
        // Interface State not supported. 0xe008
        SL_INTF_INTERFACE_STATE_NOT_SUPPORTED = 0xe008;

        // !!! Error codes for Global L2 operations.

        // Offset for Global L2 operation errors. 0xf000
        SL_L2_REG_START_OFFSET = 0xf000;
        // Client cannot be registered with Layer-2 RIB. 0xf001
        SL_L2_REGISTRATION_ERR = 0xf001;
        // Client cannot be unregistered with Layer-2 RIB. 0xf002
        SL_L2_UNREGISTRATION_ERR = 0xf002;
        // EOF Operation error. 0xf003
        SL_L2_EOF_ERR = 0xf003;
        // L2 registration message with invalid admin distance. 0xf004
        SL_L2_REG_INVALID_ADMIN_DISTANCE = 0xf004;
        // Duplicate L2 registration message. 0xf005
        SL_L2_REG_IS_DUPLICATE = 0xf005;
        // L2 registration rejected as server is not initialized. 0xf006
        SL_L2_REG_SERVER_NOT_INITIALIZED = 0xf006;

        // !!! Error codes for L2 Bridge-Domain (BD) Operations.

        // Offset for L2 BD operation errors. 0x10000
        SL_RPC_L2_BD_REG_START_OFFSET = 0x10000;
        // Operation is rejected for all BDs as name is missing. 0x10001
        SL_RPC_L2_BD_REG_NAME_MISSING = 0x10001;
        // Operation rejected for all BDs due to too many BD registration
        // messages in the request. 0x10002
        SL_RPC_L2_BD_REG_TOO_MANY_MSGS = 0x10002;
        // Operation rejected for all BDs as server is not initialized.
        // 0x10003
        SL_RPC_L2_BD_REG_SERVER_NOT_INITIALIZED = 0x10003;
        // Operation rejected for all BDs as client is not registered.
        // 0x10004
        SL_RPC_L2_BD_REG_CLIENT_NOT_REGISTERED = 0x10004;

        // !!! Error codes for L2 Bridge-Domain (BD) Objects.

        // Offset for L2 BD object errors. 0x11000
        SL_L2_BD_REG_START_OFFSET = 0x11000;
        // BD cannot be registered with Layer-2 RIB. 0x11001
        SL_L2_BD_REGISTRATION_ERR = 0x11001;
        // BD cannot be unregistered with Layer-2 RIB. 0x11002
        SL_L2_BD_UNREGISTRATION_ERR = 0x11002;
        // BD EOF Operation error. 0x11003
        SL_L2_BD_EOF_ERR = 0x11003;
        // Name is too long in BD registration message. 0x11004
        SL_L2_BD_REG_NAME_TOO_LONG = 0x11004;
        // BD not found in BD registration message. 0x11005
        SL_L2_BD_REG_BD_NOT_FOUND = 0x11005;

        // !!! Error codes for L2 Route operations.

        // Offset for L2 Route Operation errors. 0x12000
        SL_RPC_L2_ROUTE_START_OFFSET = 0x12000;
        // Operation rejected for all L2 routes due to too many messages
        // in the request. 0x12001
        SL_RPC_L2_ROUTE_TOO_MANY_MSGS = 0x12001;
        // Operation rejected for all L2 routes as server is not
        // initialized. 0x12002
        SL_RPC_L2_ROUTE_SERVER_NOT_INITIALIZED = 0x12002;
        // Operation rejected for all L2 routes as client is not
        // registered. 0x12003
        SL_RPC_L2_ROUTE_CLIENT_NOT_REGISTERED = 0x12003;

        // !!! Error codes for L2 Objects.

        // Offset for L2 object errors. 0x13000
        SL_L2_ROUTE_START_OFFSET = 0x13000;
        // L2 route operation rejected as BD name is missing. 0x13001
        SL_L2_ROUTE_BD_NAME_MISSING = 0x13001;
        // L2 route operation rejected as BD name is too long. 0x13002
        SL_L2_ROUTE_BD_NAME_TOOLONG = 0x13002;
        // L2 route operation rejected as BD not found. 0x13003
        SL_L2_ROUTE_BD_NOT_FOUND = 0x13003;
        // L2 route operation rejected as BD is not registered. 0x13004
        SL_L2_ROUTE_BD_NOT_REGISTERED = 0x13004;
        // L2 route operation rejected due to one or more invalid
        // arguments. 0x13005
        SL_L2_ROUTE_INVALID_ARGS = 0x13005;

        // !!! Error codes for L2 Get Notification operations.

        // Offset for L2 Get Notification Operation errors. 0x14000
        SL_RPC_L2_NOTIF_START_OFFSET = 0x14001;
        // L2 notification request rejected as server is not initialized.
        // 0x14002
        SL_RPC_L2_NOTIF_SERVER_NOT_INITIALIZED = 0x14002;
        // L2 notification request rejected as client is not registered.
        // 0x14003
        SL_RPC_L2_NOTIF_CLIENT_NOT_REGISTERED = 0x14003;
        // L2 notification enable error. 0x14004
        SL_RPC_L2_NOTIF_ENABLE_ERR = 0x14004;
        // L2 notification disable error. 0x14005
        SL_RPC_L2_NOTIF_DISABLE_ERR = 0x14005;
        // L2 notification EOF error. 0x14006
        SL_RPC_L2_NOTIF_EOF_ERR = 0x14006;
        // L2 notification request rejected as BD name is missing. 0x14007
        SL_RPC_L2_NOTIF_BD_NAME_MISSING = 0x14007;
        // L2 notification request rejected as BD name is too long.
        // 0x14008
        SL_RPC_L2_NOTIF_BD_NAME_TOOLONG = 0x14008;
        // L2 notification request rejected as BD not found. 0x14009
        SL_RPC_L2_NOTIF_BD_NOT_FOUND = 0x14009;

        // !!! Error codes for path group objects.

        // Container VRF for PathGroup could not be added. 0x15001
        SL_PG_VRF_ADD_ERR = 0x15001;
        // PathGroup's VRF ID could not be determined. 0x15002
        SL_PG_VRF_NO_VRFID = 0x15002;
        // PathGroup's string key is too long. 0x15003
        SL_PG_STR_KEY_TOOLONG = 0x15003;
        // ID of a next hop VRF in a path in the PathGroup cannot be determined. 0x15004
        SL_PG_TARGET_VRF_NO_VRFID = 0x15004;
        // PathGroup's string key contains invalid characters. 0x15005
        SL_PG_STR_KEY_INVALID = 0x15005;

        // !!! Error codes for Nexthop request objects.

        // Offset for Nexthop request errors. 0x16000
        SL_NEXT_HOP_START_OFFSET = 0x16000;
        // Nexthop prefix length is invalid. 0x16001
        SL_NEXT_HOP_INVALID_PREFIX_LEN = 0x16001;
        // Nexthop prefix has host bits set. 0x16002
        SL_NEXT_HOP_HOST_BITS_SET = 0x16002;
        // IPv4 Route prefix is a multicast address. 0x16003
        SL_NEXT_HOP_INVALID_PREFIX_MCAST = 0x16003;
        // Nexthop prefix is invalid. 0x16004
        SL_NEXT_HOP_INVALID_PREFIX = 0x16004;
        // Invalid next hop address. 0x16005
        SL_NEXT_HOP_INVALID_NEXT_HOP_ADDR = 0x16005;
        // Size of IPv6 prefix is invalid. 0x16006
        SL_NEXT_HOP_INVALID_PREFIX_SZ = 0x16006;
        // Unable to program NH tracking registration to RIB. 0x16007
        SL_NEXT_HOP_RIB_ADD_FAILED = 0x16007;
        // Unable to program route redist registration to RIB. 0x16008
        SL_ROUTE_REDIST_RIB_ADD_FAILED = 0x16008;

        // Offset for Hardware Ack errors. 0x17000
        SL_FIB_START_OFFSET = 0x17000;
        // The operation is successfully programmed in hardware. 0x17001
        SL_FIB_SUCCESS = 0x17001;
        // FIB programming failure. 0x17002
        SL_FIB_FAILED = 0x17002;
        // The operation is not viable to be programmed in hardware at this time. 0x17003
        SL_FIB_INELIGIBLE = 0x17003;
        // Ack permit is not supported when ack type is not RIB_AND_FIB_ACK. 0x17004
        SL_ACK_PERMIT_NOT_SUPPORTED = 0x17004;
        // Ack cadence is not supported when ack permits are not set. 0x17005
        SL_ACK_CADENCE_NOT_SUPPORTED = 0x17005;

        // !!! Error codes for operations on policy objects.

        // Offset for policy object operations. 0x18000
        SL_POLICY_START_OFFSET = 0x18000;
        // Policy object could not be created. 0x18001  
        SL_POLICY_ADD_ERR = 0x18001;
        // Policy object already exists. 0x18002
        SL_POLICY_EXISTS_ERR = 0x18002;
        // Policy object delete failed. 0x18003
        SL_POLICY_DELETE_ERR = 0x18003;
        // Rule could not be created. 0x18004
        SL_POLICY_RULE_ADD_ERR = 0x18004;
        // Rule already exists. 0x18005
        SL_POLICY_RULE_EXISTS_ERR = 0x18005;
        // Rule delete error. 0x18006
        SL_POLICY_RULE_DELETE_ERR = 0x18006;
        // Policy object apply error. 0x18007
        SL_POLICY_APPLY_ERR = 0x18007;
        // Policy object unapply error. 0x18008
        SL_POLICY_UNAPPLY_ERR = 0x18008;
        // Operation rejected due to too many policies in the request. 0x18009
        SL_POLICY_TOO_MANY_POLICIES = 0x18009;
        // Policy name is too long. 0x1800a
        SL_POLICY_NAME_TOO_LONG = 0x1800a;
        // Rule name is too long. 0x1800b
        SL_POLICY_RULE_NAME_TOO_LONG = 0x1800b;
        // Duplicate priority for the rule in the same policy. 0x1800c
        SL_POLICY_DUPLICATE_PRIORITY_IN_RULE = 0x1800c;
        // Rule modification not allowed. 0x1800d
        SL_POLICY_RULE_MOD_NOT_ALLOWED = 0x1800d;
        // Rule belongs to a different policy. 0x1800e
        SL_POLICY_INVALID_RULE = 0x1800e;
        // Rule add operation requested but no rules were provided. 0x1800f
        SL_POLICY_RULE_ADD_NO_RULES = 0x1800f; 
        // Rule add operation requested but no matches were provided. 0x18010
        SL_POLICY_INVALID_MATCH_COUNT_IN_RULE = 0x18010;
        // Rule add operation requested but no actions were provided. 0x18011
        SL_POLICY_INVALID_ACTION_COUNT_IN_RULE = 0x18011;
        // Policy not found.0x18012
        SL_POLICY_NOT_FOUND = 0x18012;
        // Policy invalid. 0x18013
        SL_POLICY_INVALID = 0x18013;
        // Policy name missing. 0x18014
        SL_POLICY_NAME_MISSING = 0x18014;
        // Rule name missing. 0x18015 
        SL_POLICY_RULE_NAME_MISSING = 0x18015;
        // Priority missing in rule. 0x18016
        SL_POLICY_PRIORITY_MISSING_IN_RULE = 0x18016;
        // Invalid policy type. 0x18017 
        SL_POLICY_TYPE_INVALID = 0x18017;
        // Invalid policy direction. 0x18018
        SL_POLICY_INVALID_DIRECTION = 0x18018;
        // Policy object's interface name exceeds supported length. 0x18019
        SL_POLICY_INTF_NAME_TOOLONG = 0x18019;
        // Policy object's interface name is missing. 0x1801a 
        SL_POLICY_INTF_NAME_MISSING = 0x1801a;
        // Max rule limit within a policy is reached. 0x1801b
        SL_POLICY_MAX_RULE_LIMIT_REACHED = 0x1801b;
        // Vrf name in policy object is too long. 0x1801c
        SL_POLICY_VRF_NAME_TOO_LONG = 0x1801c;
        // Vrf name missing in policy object. 0x1801d
        SL_POLICY_VRF_NAME_MISSING = 0x1801d;
        // Path Group name in policy object too long. 0x1801e
        SL_POLICY_PATH_GRP_NAME_TOO_LONG = 0x1801e;
        // Path Group name missing in policy object. 0x1801f
        SL_POLICY_PATH_GRP_NAME_MISSING = 0x1801f;
        // Invalid Dscp Value. 0x18020
        SL_POLICY_INVALID_DSCP_VALUE = 0x18020;
        // Priority string too long. 0x18021 
        SL_POLICY_PRIORITY_STR_TOO_LONG = 0x18021;
        // Max interfaces limit in policy reached. 0x18022
        SL_POLICY_MAX_INTF_LIMIT_REACHED = 0x18022;
        // Rule delete operation requested but no rules were provided. 0x18023
        SL_POLICY_RULE_DELETE_NO_RULES = 0x18023;
        // Policy apply requested but no interfaces were provided. 0x18024
        SL_POLICY_APPLY_NO_INTFS = 0x18024;
        // Policy unapply requested but no interfaces were provided. 0x18025
        SL_POLICY_UNAPPLY_NO_INTFS = 0x18025;

        // !!! Error codes for Bgpls Topology objects.

        // Offset for Bgpls Topology errors. 0x19000
        SL_BGPLS_TOPO_START_OFFSET = 0x19000;        

        // LSLIB Server which is required for BGPLS Topology Service
        // is not available. 0x19001
        SL_BGPLS_SERVER_NOT_AVAILABLE = 0x19001;

        // Maximum match filters in SLBgplsTopoNotifReqMsg exceeded. 0x19002
        SL_BGPLS_MAX_MATCH_FILTER_EXCEEDED = 0x19002;

        // Maximum SLBgplsTopoNotifStream exceeded. 0x19003
        SL_BGPLS_MAX_STREAMS_EXCEEDED = 0x19003;

        // !!! Error codes for operations on BGP objects.

        // Offset for bgp object operations. 0x1a000
        SL_BGP_START_OFFSET = 0x1a000;
        // BGP instance name too long. 0x1a001
        SL_BGP_INST_NAME_TOOLONG = 0x1a001;
        // BGP instance name empty. 0x1a002
        SL_BGP_INST_NAME_EMPTY = 0x1a002;
        // BGP instance not initialized. 0x1a003
        SL_BGP_INST_NOT_INITIALIZED = 0x1a003;
        // BGP invalid object type. 0x1a004
        SL_BGP_INVALID_OBJ_TYPE = 0x1a004;
        // BGP vrf name too long for v4 neighbor. 0x1a005
        SL_BGP_VRF_NAME_TOOLONG_V4 = 0x1a005;
        // BGP vrf name too long for v6 neighbor. 0x1a006
        SL_BGP_VRF_NAME_TOOLONG_V6 = 0x1a006;
        // BGP unsupported vrf name. 0x1a007
        SL_BGP_UNSUPPORTED_VRF_NAME = 0x1a007;
        // BGP invalid neighbor address multicast. 0x1a008
        SL_BGP_INVALID_NBR_ADDR_MCAST = 0x1a008;
        // BGP invalid neighbor address experimental. 0x1a009
        SL_BGP_INVALID_NBR_ADDR_EXP = 0x1a009;
        // BGP invalid neighbor address. 0x1a00a
        SL_BGP_INVALID_NBR_ADDR = 0x1a00a;
        // BGP invalid neighbor v6 address size. 0x1a00b
        SL_BGP_INVALID_NBR_V6_SZ = 0x1a00b;
        // BGP invalid neighbor key. 0x1a00c
        SL_BGP_INVALID_NBR_KEY = 0x1a00c;
        // BGP invalid mpath address multicast. 0x1a00d
        SL_BGP_INVALID_MPATH_ADDR_MCAST = 0x1a00d;
        // BGP invalid mpath address experimental. 0x1a00e
        SL_BGP_INVALID_MPATH_ADDR_EXP = 0x1a00e;
        // BGP invalid mpath address. 0x1a00f
        SL_BGP_INVALID_MPATH_ADDR = 0x1a00f;
        // BGP invalid mpath v6 address size. 0x1a010
        SL_BGP_INVALID_MPATH_V6_SZ = 0x1a010;
        // BGP invalid neighbor afi/safi list. 0x1a011
        SL_BGP_INVALID_NBRSAFI_LIST = 0x1a011;
        // BGP unsupported BGP afi/safi. 0x1a012
        SL_BGP_UNSUPPORTED_BGP_AFI_SAFI = 0x1a012;
        // BGP unsupported afi. 0x1a013
        SL_BGP_UNSUPPORTED_AFI = 0x1a013;
        // BGP unsupported safi. 0x1a014
        SL_BGP_UNSUPPORTED_SAFI = 0x1a014;
        // BGP empty object. 0x1a015
        SL_BGP_EMPTY_OBJECTS = 0x1a015;
        // BGP empty object list. 0x1a016
        SL_BGP_EMPTY_OBJECT_LIST = 0x1a016;
        // BGP updating bandwidth-group database failed. 0x1a017
        SL_BGP_UPDATE_BW_GRP_FAILED = 0x1a017;
        // BGP updating mpath database failed. 0x1a018
        SL_BGP_UPDATE_MPATH_ADDR_FAILED = 0x1a018;
        // BGP deleting from bandwidth-group database failed. 0x1a019
        SL_BGP_DELETE_BW_GRP_FAILED = 0x1a019;
        // BGP deleting neighbor from database failed. 0x1a01a
        SL_BGP_DELETE_NBR_FAILED = 0x1a01a;
        // BGP deleting afi/safi from database failed. 0x1a01b
        SL_BGP_DELETE_AFI_FAILED = 0x1a01b;
        // BGP deleting from mpath database failed. 0x1a01c
        SL_BGP_DELETE_MPATH_ADDR_FAILED = 0x1a01c;
        // BGP deleting from database failed. 0x1a01d
        SL_BGP_DELETE_FAILED = 0x1a01d;
        // BGP bandwidth-group number out of range. 0x1a01e
        SL_BGP_BW_GRP_NUM_OUT_OF_RANGE = 0x1a01e;
        // BGP inbound bandwidth-group count exceeds limit. 0x1a01f
        SL_BGP_IN_BW_GRP_COUNT_EXCEEDED = 0x1a01f;
        // BGP outbound bandwidth-group count exceeds limit. 0x1a020
        SL_BGP_OUT_BW_GRP_COUNT_EXCEEDED = 0x1a020;
        // BGP invalid inbound bandwidth-group list. 0x1a021
        SL_BGP_INVALID_IN_BWGRP_LIST = 0x1a021;
        // BGP invalid outbound bandwidth-group count list. 0x1a022
        SL_BGP_INVALID_OUT_BWGRP_LIST = 0x1a022;
        // BGP link bandwidth out of range. 0x1a023
        SL_BGP_LINK_BW_OUT_OF_RANGE = 0x1a023;
        // BGP neighbor index out of range. 0x1a024
        SL_BGP_NBR_IDX_OUT_OF_RANGE = 0x1a024;
        // BGP invalid bandwidth-group type. 0x1a025
        SL_BGP_INVALID_BW_TYPE = 0x1a025;
        // BGP neighbor bandwidth-group list is NULL. 0x1a026
        SL_BGP_BW_GRP_LIST_NULL = 0x1a026;
        // BGP neighbor afi/safi list is NULL. 0x1a027
        SL_BGP_NBRSAFI_LIST_NULL = 0x1a027;
        // BGP instance does not exist in SL-API. 0x1a028
        SL_BGP_INST_NOT_CONFIG_IN_SLAPI = 0x1a028;
        // BGP object list index out of range. 0x1a029
        SL_BGP_OBJ_LIST_IDX_OUT_OF_RANGE = 0x1a029;
        // BGP AS number out of range. 0x1a02a
        SL_BGP_ASN_OUT_OF_RANGE = 0x1a02a;
        // BGP invalid bandwidth-unit. 0x1a02b
        SL_BGP_INVALID_BW_UNIT = 0x1a02b;
        // BGP Object Type required when get_next is FALSE. 0x1a02c
        SL_BGP_OBJECT_TYPE_REQUIRED = 0x1a02c;
        // BGP Object Key required when get_next is FALSE. 0x1a02d
        SL_BGP_OBJECT_KEY_REQUIRED = 0x1a02d;
        // BGP invalid object type. 0x1a02e
        SL_BGP_INVALID_OBJECT_TYPE = 0x1a02e;
        // BGP exact match for get request is not found. 0x1a02f
        SL_BGP_GET_EXACT_MATCH_NOT_FOUND = 0x1a02f;
        // BGP Internal Error 1. 0x1a101
        SL_BGP_INTERNAL_ERR_1 = 0x1a101;
        // BGP Internal Error 2. 0x1a102
        SL_BGP_INTERNAL_ERR_2 = 0x1a102;
        // BGP Internal Error 3. 0x1a103
        SL_BGP_INTERNAL_ERR_3 = 0x1a103;

        // !!! Error codes Reserved for internal errors.

        // Offset for Internal errors. 0x100000
        SL_INTERNAL_START_OFFSET = 0x100000;
    }
    SLErrno Status = 1;
}

// Registration Operations.
enum SLRegOp {
    // Reserved. 0x0
    SL_REGOP_RESERVED    = 0x0;
    // Register. 0x1
    SL_REGOP_REGISTER    = 0x1;
    // Un-Register. 0x2
    SL_REGOP_UNREGISTER  = 0x2;
    // End Of File. 0x3
    SL_REGOP_EOF         = 0x3;
}

// Object Operations.
enum SLObjectOp {
    // Reserved. 0x0
    SL_OBJOP_RESERVED   = 0x0;
    // Add. 0x1
    SL_OBJOP_ADD        = 0x1;
    // Update. 0x2
    SL_OBJOP_UPDATE     = 0x2;
    // Delete. 0x3
    SL_OBJOP_DELETE     = 0x3;
}

// Notification Operations.
enum SLNotifOp {
    // Reserved. 0x0
    SL_NOTIFOP_RESERVED   = 0x0;
    // Enable. 0x1
    SL_NOTIFOP_ENABLE     = 0x1;
    // Disable. 0x2
    SL_NOTIFOP_DISABLE    = 0x2;
}

// Update Priority
enum SLUpdatePriority {
    // Reserved. 0x0
    SL_PRIORITY_RESERVED = 0x0;
    SL_PRIORITY_CRITICAL = 0x4;
    SL_PRIORITY_HIGH = 0x8;
    SL_PRIORITY_MEDIUM = 0xc;
    SL_PRIORITY_LOW = 0x10;
}

// Interface info.
message SLInterface {
     // One of Interface name or handle
     oneof Interface {
        // Interface name.
        string Name = 1;

        // Interface handle. Can be retrieved from Interface API.
        uint32 Handle = 2;
    }
}

// One of IPv4 or IPv6 addresses.
message SLIpAddress {
    // One of IPv4 or IPv6 address. V4Address must be in host byte order.
    oneof Address {
        uint32  V4Address = 1;
        bytes  V6Address = 2;
    }
}

// Encapsulation Types.
// Specify tunnel encapsulation types.
enum SLEncapType {
    // Reserved. 0x0
    SL_ENCAP_RESERVED = 0x0;
    // Vxlan encap. 0x1
    SL_ENCAP_VXLAN =    0x1;
    // Mpls encap. 0x2
    SL_ENCAP_MPLS =     0x2;
}

// Table types in a VRF.
enum SLTableType {
    // Reserved Table type. 0x0
    SL_TABLE_TYPE_RESERVED = 0x0;

    // IPv4 Route table. 0x1
    SL_IPv4_ROUTE_TABLE = 0x1;

    // IPv6 Route table. 0x2
    SL_IPv6_ROUTE_TABLE = 0x2;

    // MPLS label table. 0x3
    SL_MPLS_LABEL_TABLE = 0x3;

    // Path Group Table. 0x4
    SL_PATH_GROUP_TABLE =    0x4;
}

// The type of response that the client expects from the
// network element for any object programming operation.
//
// For the object in operation, the network element can operate
// in two modes - whether the response from is required from 
// device's RIB or both from RIB and FIB.
//
// Unary RPC does not support RIB_AND_FIB_ACK.
//
// On a hardware programming failure, client is expected to retry or
// delete the object. The device does not perform any retries or
// take any other recovery action.
// Client is expected to handle out of order responses using the OperationID.
//
// Operation results for different keys can be out of order
// when compared to the programming sequence.

enum SLRspACKType {
  // When the operating mode is RIB_ACK,
  // once the object in the operation is successfully applied to
  // the network element's RIB, SL_SUCCESS is returned for that operation.
  // On an error, the object is not updated in the network element's RIB
  // and error is returned to the client.
  //
  // The operation is considered complete once result of RIB programming
  // is sent back to the client.
  //
  // By default, ACK type is assumed to be RIB_ACK.
  RIB_ACK = 0;

  // When the operating mode is RIB_AND_FIB_ACK,
  // the first result returned for the operation is RIB's result.
  // If the object in the operation is successfully applied to RIB,
  // SL_SUCCESS is returned.
  //
  // If the object in the operation is not active and cannot be programmed to FIB,
  // SL_FIB_INELIGIBLE is returned as a second response and the operation is
  // considered complete.
  //
  // As a result of an operation on an object, if another previously
  // programmed object becomes ineligible, previously programmed object will be
  // removed from FIB and SL_FIB_INELIGIBLE will be sent asynchronously with
  // the last known OperationID for that object. However, the object will
  // continue to remain in RIB.
  //
  // Eventually, when the object becomes active, the object is sent to FIB
  // and result of the hardware programming is returned asynchronously with the last
  // known OperationID for that object.
  //
  // It must be noted that while the object is waiting for FIB programming,
  // client can send another update on the object and the object remains in-active.
  // The network element may coalesce such back to back operations.
  // In this scenario, only the last operation on the object is responded to
  // with corresponding hardware programming result
  RIB_AND_FIB_ACK = 1;
}


// SLRspACKPermit defines bit-field that control the types of hardware programming
// responses that the client is interested in.
// A set bit in the mask indicates PERMIT/ALLOW the corresponding response type.
// If the SL-API client is interested in only a subset of possible responses
// for hardware programming, then the corresponding bits are turned ON in the
// bit-field.
// Control of response type is supported ONLY when ACK type is
// RIB_AND_FIB_ACK and is NOT supported when ACK type is RIB_ACK.
// Errorcodes not listed in SLRspACKPermit such as parsing errors are
// always permitted and will be relayed to the client even when SLRspACKPermit
// is set to values other than SL_PERMIT_ALL.
// When AckPermit is not set by the SL-API client, the SL-API server
// will default to SL_PERMIT_ALL
enum SLRspACKPermit {
    // An undefined or 0 value Permits all SLErrorStatus to be relayed to client
    SL_PERMIT_ALL = 0x0;

    // Permits SL_SUCCESS to be relayed to client
    // Note: SL_SUCCESS cannot be suppressed if ACK type is RIB_ACK
    SL_PERMIT_SL_SUCCESS = 0x1;

    // Permits SL_FIB_SUCCESS to be relayed to client
    SL_PERMIT_SL_FIB_SUCCESS = 0x2;

    // Permits SL_FIB_FAILED to be relayed to client
    SL_PERMIT_SL_FIB_FAILED = 0x4;

    // Permits SL_FIB_INELIGIBLE to be relayed to client
    SL_PERMIT_SL_FIB_INELIGIBLE = 0x8;

}

// SLRspAckCadence controls the cadence of hardware programming responses.
// When SLRspAckCadence is NOT set by the SL-API client, the SL-API server
// will default to SL_RSP_CONTINOUS and send responses defined by SLRspACKPermit,
// for all hardware programming events including events that are internal
// to the router such as insertion or removal of line cards.
// Control of cadence is supported only when ACK type is RIB_AND_FIB_ACK and
// SLRspACKPermit MUST be set with value other than SL_PERMIT_ALL.
enum SLRspAckCadence {
  // Continuous relay of hardware programming/re-programming responses
  SL_RSP_CONTINUOUS = 0;

  // SL_RSP_JUST_ONCE cadence will allow only the first response for hardware
  // programming among the response types defined by SLRspACKPermit
  //
  // For Example:
  // In the case where client sends
  // Permit == SL_PERMIT_SL_FIB_INELIGIBLE | SL_PERMIT_SL_FIB_SUCCESS | SL_PERMIT_SL_FIB_FAILED
  // Cadence == SL_RSP_JUST_ONCE and at the time of programming if the object was not viable
  // to be programmed in hardware, then the first response would be SL_FIB_INELIGIBLE.
  // There will no further notification when the object becomes viable and programmed in FIB.
  SL_RSP_JUST_ONCE = 1;

  // SL_RSP_ONCE_EACH cadence will allow only the first response for hardware
  // programming per response type defined by SLRspACKPermit
  //
  // For Example:
  // In the case where client sends
  // Permit == SL_PERMIT_SL_FIB_INELIGIBLE | SL_PERMIT_SL_FIB_SUCCESS | SL_PERMIT_SL_FIB_FAILED
  // and Cadence == SL_RSP_ONCE_EACH and at the time of programming if the object was not viable
  // to be programmed in hardware, then the first response would be SL_FIB_INELIGIBLE.
  // Later, whenever the route becomes viable and gets programmed in the FIB the 
  // corresponding result SL_FIB_SUCCESS/SL_FIB_FAILED will be also be notified.
  // This  will be particularly useful in the case of out of order programming
  // where the prefix is ineligible until referenced PathGroup is programmed.
  SL_RSP_ONCE_EACH = 2;
}

// The following table illustrates the behavior for combination of
// SLRspACKPermit and SLRspAckCadence being set or not set
// A field not set or not defined  will take the value of 0, So
// SLRspACKPermit will default to SL_PERMIT_ALL
// SLRspAckCadence will default to SL_RSP_CONTINUOUS
// +-------------+-------------+--------------------------------------------------------+
// |    Permit   | Cadence     | Behavior                                               |
// |-------------+-------------+--------------------------------------------------------+
// | Not Set     | Not Set     | Stream all responses (default)                         |
// | Set         | Not Set     | Stream only the permitted response types continuously. |
// | Not Set     | Set         | Not supported.                                         |
// | Set         | Set         | Permitted responses will be sent according to cadence  |
// +-------------+-------------+--------------------------------------------------------+

// Common Object Identifier.
message SLObjectId {
    // One of Object name or handle
    oneof entry {
      // Name of object.
      // The string can contain only non white space printable ASCII characters.
      string Name = 1;

    }
}

// Path group reference key. This can be used by route, label
// or policy objects to refer a path group object.
message SLPathGroupRefKey {
    // VRF name
    string VrfName = 1;

    // Path Group ID
    SLObjectId PathGroupId = 2;
}

// @}
