// @file
// @brief SR Common definitions for all of the service layer proto files.
//
//---------------------------------------------------------------------
// Copyright (c) 2019, 2024 by Cisco Systems, Inc.
// All rights reserved.
//---------------------------------------------------------------------
//
//

//@defgroup SrCommon
//@brief SR Common service definitions and Global initializations.

syntax = "proto3";
package service_layer;

import "sl_common_types.proto";

option go_package="github.com/Cisco-service-layer/service-layer-objmodel/grpc/protos;service_layer";

// @defgroup SLSrCommonTypes
// @ingroup SrCommon
// Service Layer SR common types.
// The following messages are used as SR Common Service Layer types.
// @{

// IPv6 addresses.
message SLIpv6Address {
    // IPv6 address.
    bytes  V6Address = 1;
}

// Protocol Originating SR Policy
// Section 8.4 of [draft-ietf-idr-bgp-ls-sr-policy]
enum SLSrPolicyProtocolOrigin {
    SL_SR_POLICY_PROTOCOL_ORIGIN_RESERVED = 0;
    SL_SR_POLICY_PROTOCOL_ORIGIN_PCEP = 1;
    SL_SR_POLICY_PROTOCOL_ORIGIN_BGP_SR_POLICY = 2;
    SL_SR_POLICY_PROTOCOL_ORIGIN_CONFIG = 3;
    SL_SR_POLICY_PROTOCOL_ORIGIN_PCEP_VIA_PCE = 10;
    SL_SR_POLICY_PROTOCOL_ORIGIN_BGP_SR_POLICY_VIA_PCE = 20;
    SL_SR_POLICY_PROTOCOL_ORIGIN_CONFIG_VIA_PCE = 30;
    SL_SR_POLICY_PROTOCOL_ORIGIN_CONFIG_VIA_GRPC = 251;
}

enum SLSrPolicyFlagsDef {
    // Flags associated with the SR policy
    // Section 4 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field. Supported values are:

    // Reserved.
    SL_SR_POLICY_FLAG_RESERVED = 0x0;

    // Bit-0: E-Flag: Indicates the encoding of endpoint as IPv6 address when
    // set and IPv4 address when clear
    SL_SR_POLICY_FLAG_ENDPOINT_V6 = 0x80;

    // Bit-1: O-Flag: Indicates the encoding of originator address as IPv6
    // address when set and IPv4 address when clear
    SL_SR_POLICY_FLAG_ORIGINATOR_V6 = 0x40;

    // All others are reserved.
}

// SR Policy flags
message SLSrPolicyFlags {
    // SL Policy Flags
    // Flags associated with the SR policy
    // Section 4 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field.
    // See SLSrPolicyFlagsDef for flag enumerations.
    // Supported values are:
    //
    // SL_SR_POLICY_FLAG_ENDPOINT_V6
    // E-Flag: Indicates the encoding of endpoint as IPv6 address when
    // set and IPv4 address when clear
    //
    // SL_SR_POLICY_FLAG_ORIGINATOR_V6
    // O-Flag: Indicates the encoding of originator address as IPv6
    // address when set and IPv4 address when clear
    //
    // All others are reserved.
    uint32 Flags = 1;
}

// SR Binding SID. TLV 1201
// Section 5.1 of [draft-ietf-idr-bgp-ls-sr-policy]
message SLSrBsid {
    oneof BindingSid {
        // This field carries info about an MPLS binding SID.
        uint32 MplsBsid = 1;

        // This field carries info about an SRv6 binding SID.
        // SRv6 binding SID takes an IPv6 Address and must be
        // enforced for 16 bytes.
        bytes Srv6Bsid = 2;
    }
}

// SR Candidate Path Name. TLV 1203
// Section 5.5 of [draft-ietf-idr-bgp-ls-sr-policy]
message SLSrCpName {
    // Symbolic name for the SR Policy candidate path without a NULL
    // terminator. It must be enforced that the size of the symbolic name
    // be limited to 255 characters.
    string Name = 1;
}

// SR Segment Type
// Section 8.5 of [draft-ietf-idr-bgp-ls-sr-policy]
enum SLSrSegmentType {
    // Reserved. 0
    SL_SR_SEG_TYPE_RESERVED = 0;

    // (Type A) SR-MPLS Label. 1
    SL_SR_SEG_TYPE_MPLS_LABEL = 1;

    // (Type B) SRv6 SID as IPv6 address. 2
    SL_SR_SEG_TYPE_SRV6_SID_V6 = 2;

    // (Type C) SR-MPLS Prefix SID as IPv4 Node Address. 3
    SL_SR_SEG_TYPE_MPLS_PFX_SID_V4 = 3;

    // (Type D) SR-MPLS Prefix SID as IPv6 Node Global Address. 4
    SL_SR_SEG_TYPE_MPLS_PFX_SID_V6 = 4;

    // (Type E) SR-MPLS Adjacency SID as IPv4 Node Address
    // & Local Interface ID. 5
    SL_SR_SEG_TYPE_MPLS_ADJ_SID_V4_NODE_ADDR_LOC_ID = 5;

    // (Type F) SR-MPLS Adjacency SID as IPv4 Local
    // & Remote Interface Addresses. 6
    SL_SR_SEG_TYPE_MPLS_ADJ_SID_V4_LOC_REM_ADDR = 6;

    // (Type G) SR-MPLS Adjacency SID as pair of IPv6 Global Address
    // & Interface ID for Local & Remote nodes. 7
    SL_SR_SEG_TYPE_MPLS_ADJ_SID_V6_LOC_REM_ADDR_AND_ID = 7;

    // (Type H) SR-MPLS Adjacency SID as pair of IPv6 Global Addresses
    // for the Local & Remote Interface. 8
    SL_SR_SEG_TYPE_MPLS_ADJ_SID_V6_LOC_REM_ADDR = 8;

    // (Type I) SRv6 END SID as IPv6 Node Global Address. 9
    SL_SR_SEG_TYPE_SRV6_END_SID_V6_NODE_ADDR = 9;

    // (Type J) SRv6 END.X SID as pair of IPv6 Global Address
    // & Interface ID for Local & Remote nodes. 10
    SL_SR_SEG_TYPE_SRV6_END_SID_V6_LOC_REM_ADDR_AND_ID = 10;

    // (Type K) SRv6 END.X SID as pair of IPv6 Global Addresses for
    // the Local & Remote Interface. 11
    SL_SR_SEG_TYPE_SRV6_END_SID_V6_LOC_REM_ADDR = 11;
}

// SR Segment Descriptors
message SLSrSegmentDesc {
    uint32 Algorithm = 1;

    // Carries info about local node address.
    oneof LocalNode {
        // This field carries info about an IPv4 local node address.
        bytes Ipv4LocalAddr = 2;

        // This field carries info about an IPv6 local node address.
        bytes Ipv6LocalAddr = 3;
    }

    // Carries info about remote node address.
    oneof RemoteNode {
        // This field carries info about an IPv4 remote node address.
        bytes Ipv4RemoteAddr = 4;

        // This field carries info about an IPv6 remote node address.
        bytes Ipv6RemoteAddr = 5;
    }

    // Carries the interface ID of the local node identified by the
    // local node address.
    // Section 5.8.1 of [draft-ietf-idr-bgp-ls-sr-policy]
    uint32 LocalNodeIntfId = 6;

    // Carries the interface ID of the remote node identified by
    // the remote node address.
    // Section 5.8.1 of [draft-ietf-idr-bgp-ls-sr-policy]
    uint32 RemoteNodeIntfId = 7;
}

enum SLSrSegmentFlags {
    // Flags associated with the SR Segment
    // Section 5.8 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field. Supported values are:

    // Reserved.
    SL_SR_SEGMENT_FLAG_RESERVED = 0x0;

    // Bit-0: S-Flag: Indicates the presence of SID value in the SID field
    // when set and that no value is indicated when clear.
    SL_SR_SEGMENT_FLAG_SID_PRESENT = 0x8000;

    // Bit-1: E-Flag: Indicates the SID value is explicitly provisioned value
    // (locally on headend or via controller/PCE) when set and is a
    // dynamically resolved value by headend when clear.
    SL_SR_SEGMENT_FLAG_SID_EXPLICIT_PROVISIONED = 0x4000;

    // Bit-2: V-Flag: Indicates the SID has passed verification or did not
    // require verification when set and failed verification when
    // clear.
    SL_SR_SEGMENT_FLAG_SID_VERIFIED = 0x2000;

    // Bit-3: R-Flag: Indicates the SID has been resolved or did not require
    // resolution (e.g. because it is not the first SID) when set and
    // failed resolution when clear.
    SL_SR_SEGMENT_FLAG_SID_RESOLVED = 0x1000;

    // Bit-4: A-Flag: Indicates that the Algorithm indicated in the Segment
    // descriptor is valid when set.  When clear, it indicates that
    // the headend is unable to determine the algorithm of the SID.
    SL_SR_SEGMENT_FLAG_SID_ALGO_VALID = 0x0800;

    // All others are reserved.
}

// SR Segment. TLV 1206
// Section 5.8 of [draft-ietf-idr-bgp-ls-sr-policy]
message SLSrSegment {
    SLSrSegmentType Type = 1;

    // SR Segment Flags
    // Flags associated with the SR Segment
    // Section 5.8 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field. Supported values are:
    //
    // SL_SR_SEGMENT_FLAG_SID_PRESENT
    // Bit-0: S-Flag: Indicates the presence of SID value in the SID field
    // when set and that no value is indicated when clear.
    //
    // SL_SR_SEGMENT_FLAG_SID_EXPLICIT_PROVISIONED
    // Bit-1: E-Flag: Indicates the SID value is explicitly provisioned value
    // (locally on headend or via controller/PCE) when set and is a
    // dynamically resolved value by headend when clear.
    //
    // SL_SR_SEGMENT_FLAG_SID_VERIFIED
    // Bit-2: V-Flag: Indicates the SID has passed verification or did not
    // require verification when set and failed verification when
    // clear.
    //
    // SL_SR_SEGMENT_FLAG_SID_RESOLVED
    // Bit-3: R-Flag: Indicates the SID has been resolved or did not require
    // resolution (e.g. because it is not the first SID) when set and
    // failed resolution when clear.
    //
    // SL_SR_SEGMENT_FLAG_SID_ALGO_VALID
    // Bit-4: A-Flag: Indicates that the Algorithm indicated in the Segment
    // descriptor is valid when set.  When clear, it indicates that
    // the headend is unable to determine the algorithm of the SID.
    //
    // All others are reserved.
    uint32 Flags = 2;

    oneof Sid {
        // This field carries info about an MPLS SID.
        uint32 MplsLabel = 3;

        // This field carries info about an SRv6 SID.
        // SRv6 SID takes an IPv6 Address and must be
        // enforced for 16 bytes.
        bytes Srv6Sid = 4;
    }

    // Variable size Segment descriptor based on the type of segment
    SLSrSegmentDesc SegmentDesc = 5;

    // SRv6 End Point Behavior. TLV 1250
    // Section 7.1 of [RFC9514]
    SLSrv6EndPointBehavior EndPointBehavior = 6;

    // SRv6 SID Structure Attribute. TLV 1252
    // Section 8 of [RFC9514]
    SLSrv6SidStruct SidStruct = 7;
}

enum SLSrv6BindingSidFlags {
    // Flags associated with the SRv6 Binding SID
    // Section 5.2 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field. Supported values are:

    // Reserved.
    SL_SRV6_BSID_FLAG_RESERVED = 0x0;

    // Bit-0: B-Flag: Indicates the allocation of the value in the BSID field
    // when set and indicates that BSID is not allocated when clear.
    SL_SRV6_BSID_FLAG_ALLOCATED = 0x8000;

    // Bit-1: U-Flag: Indicates the specified BSID value is unavailable when set.
    SL_SRV6_BSID_FLAG_UNAVAIL = 0x4000;

    // Bit-2: F-Flag: Indicates the BSID value is one allocated from dynamic
    // label pool due to fallback (e.g. when specified BSID is
    // unavailable) when set.
    SL_SRV6_BSID_FLAG_DYNAMIC = 0x2000;

    // All others are reserved.
}

// SRv6 Binding SID. TLV 1212
// Section 5.2 of [draft-ietf-idr-bgp-ls-sr-policy]
message SLSrv6BindingSid {
    // SRv6 Binding SID Flags
    // Flags associated with the SRv6 Binding SID
    // Section 5.2 of [draft-ietf-idr-bgp-ls-sr-policy]
    // Each flag is indicated as a bit field. Supported values are:
    //
    // SL_SRV6_BSID_FLAG_ALLOCATED
    // Bit-0: B-Flag: Indicates the allocation of the value in the BSID field
    // when set and indicates that BSID is not allocated when clear.
    //
    // SL_SRV6_BSID_FLAG_UNAVAIL
    // Bit-1: U-Flag: Indicates the specified BSID value is unavailable when set.
    //
    // SL_SRV6_BSID_FLAG_DYNAMIC
    // Bit-2: F-Flag: Indicates the BSID value is one allocated from dynamic
    // label pool due to fallback (e.g. when specified BSID is
    // unavailable) when set.
    //
    // All others are reserved.
    uint32 Flags = 1;

    // The operational or allocated BSID value based on the status flags.
    // SRv6 binding SID takes an IPv6 Address and must be
    // enforced for 16 bytes.
    bytes Bsid = 2;

    // The explicitly specified BSID whether it is allocated or not.
    // SRv6 binding SID takes an IPv6 Address and must be
    // enforced for 16 bytes.
    bytes SpecifiedBsid = 3;

    // SRv6 End Point Behavior. TLV 1250
    // Section 7.1 of [RFC9514]
    SLSrv6EndPointBehavior EndPointBehavior = 4;

    // SRv6 SID Structure Attribute. TLV 1252
    // Section 8 of [RFC9514]
    SLSrv6SidStruct SidStruct = 5;
}

// SRv6 End Point Behavior. TLV 1250
// Section 7.1 of [RFC9514]
message SLSrv6EndPointBehavior {
    // Endpoint behavior of the SID
    uint32 EndPointBehavior = 1;

    // Flags associated with the SID. Section 8 of [RFC9513]
    // for OSPFv3, and Section 7.2 of [RFC9352] for IS-IS.
    uint32 Flags = 2;

    // Algorithm associated with the SID
    uint32 Algorithm = 3;
}

// SRv6 SID Structure Attribute. TLV 1252
// Section 8 of [RFC9514]
message SLSrv6SidStruct {
    // Locator block length in bits
    uint32 LocatorBlockLen = 1;

    // Locator node length in bits
    uint32 LocatorNodeLen = 2;

    // Function length in bits
    uint32 FunctionLen = 3;

    // Argument length in bits
    uint32 ArgLen = 4;
}

// SR dataplane.
enum SLSrDataplane {
    // Unspecified dataplane (invalid).
    SR_DATAPLANE_UNSPECIFIED = 0;

    // MPLS dataplane.
    SR_DATAPLANE_MPLS = 1;

    // SRv6 dataplane.
    SR_DATAPLANE_SRV6 = 2;
}

// Metric type.
//
// Mapped from the [IANA IGP Metric-Type registry](
// https://www.iana.org/assignments/igp-parameters/igp-parameters.xhtml#igp-metric-type).
enum SLSrMetricType {
  option allow_alias = true;
  // Unspecified metric type, defaults to IGP metric.
  METRIC_TYPE_UNSPECIFIED = 0;

  // IGP metric type.
  METRIC_TYPE_IGP = 0;

  // Minimum unidirectional link delay metric type.
  METRIC_TYPE_DELAY = 1;

  // Traffic engineering default metric type.
  METRIC_TYPE_TE = 2;

  // Hop count metric type (custom type, not in the IGP Metric-Type registry).
  METRIC_TYPE_HOP = 255;
}

// Maximum metric that is allowed for given metric type
message SLSrMetricBounds {
    uint32 igp = 1;
    uint32 te = 2;
    uint32 latency = 3;
}

message SLSrMetricMargin {
    enum MarginType {
        // Indicates that the metric margin is specified as percentage of
        // minimum metric
        RELATIVE = 0;
        // Indicates that the metric margin is specified as an absolute value
        ABSOLUTE = 1;
    }
    MarginType type = 1;
    uint32 value = 2;
}

// Diversity level.
enum SLSrteDiversityLevel {
    option allow_alias = true;
    DIVERSITY_LEVEL_UNSPECIFIED = 0;
    DIVERSITY_LEVEL_NONE = 0;
    DIVERSITY_LEVEL_LINK = 1;
    DIVERSITY_LEVEL_NODE = 2;
    DIVERSITY_LEVEL_SRLG = 3;
    DIVERSITY_LEVEL_SRLG_NODE = 4;
}

// Extended Administrative Group.
// Bit mask of administrative groups assigned by the
// network administrator. Each set bit corresponds to one
// administrative group assigned to the interface. By convention, the
// least significant bit is referred to as group 0, and the
// most significant bit is referred to as group 31. Each EAG bitmask
// is represented in multiple of 4 bytes.
message SLSrAffinities {
    // Affinity include any.
    //
    // Mapped from [section 6.2 of RFC 9350]
    // (https://www.rfc-editor.org/rfc/rfc9350.html#section-6.2).
    repeated uint32 includeAny = 1;

    // Affinity include all.
    //
    // Mapped from [section 6.3 of RFC 9350]
    //(https://www.rfc-editor.org/rfc/rfc9350.html#section-6.3).
    repeated uint32 includeAll = 2;

    // Affinity exclude.
    //
    // Mapped from [section 6.1 of RFC 9350]
    // (https://www.rfc-editor.org/rfc/rfc9350.html#section-6.1).
    repeated uint32 excludeAny = 3;
}

// A segment descriptor.
//
// Segment descriptor types are defined in [section 4 of RFC
// 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-4).
message SLSrteSegment {
    // Type A: SR-MPLS Label.
    message TypeA {
        uint32 label = 1;
    }

    // Type B: SRv6 SID.
    message TypeB {
        SLIpv6Address ipv6_sid_address = 1;
        uint32 behavior = 2;
        SLSrv6SidStruct structure = 3;
    }

    oneof segment {
        TypeA type_a = 1;   // A segment descriptor of type A.
        TypeB type_b = 2;   // A segment descriptor of type B.
    }
}

// A (weighted) segment list.
message SLSrSegmentList {
  // Ordered list of segments.
  repeated SLSrteSegment segments = 1;

  // Load balancing weight factor.
  //
  // As per [RFC 9256](https://www.rfc-editor.org/rfc/rfc9256.html):
  //
  // - the default weight is 1; and
  // - a segment list with a weight of 0 is invalid.
  optional uint32 weight = 2;
}

// Identifier of an SR Policy as defined in [section 2.1 of RFC
// 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-2.1).
message SLSrPolicyKey {
    // IPv4 or IPv6 Router-ID of the headend node.
    //
    // The Router-ID of a node is advertised in BGP-LS TLV 1028 (IPv4) or 1029
    // (IPv6) (see [section 5.3.1 of
    // draft-ietf-idr-rfc7752bis]
    // (https://datatracker.ietf.org/doc/html/draft-ietf-idr-rfc7752bis-16#section-5.3.1))
    SLIpAddress headend = 1;

    // SR policy color
    uint32 color = 2;

    // IPv4 or IPv6 address of the policy endpoint.
    SLIpAddress endpoint = 3;
}

// Identifier of an SR Candidate Path in the context of an SR Policy, as
// defined in [section 2.6 of RFC
// 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-2.6).
message SLSrCandidatePathKey {
    // Originator of the candidate path, as defined in [section 2.4 of RFC
    // 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-2.4).
    message Originator {
        // Autonomous System Number (ASN)
        // If 2-byte ASNs are in use, the low-order 16 bits MUST be used,
        // and the high-order bits MUST be set to 0.
        uint32 ASN = 1;

        // Originator Node Address
        SLIpAddress nodeID = 2;
    }
    Originator originator = 1;

    // Protocol-Origin of the candidate path (really just a uint8), as defined in
    // [section 2.3 of RFC
    // 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-2.3).
    SLSrPolicyProtocolOrigin protocol_origin = 2;

    // Discriminator of the candidate path, as defined in [section 2.5 of RFC
    // 9256](https://www.rfc-editor.org/rfc/rfc9256.html#section-2.5).
    uint32 discriminator = 3;
}

// @}
