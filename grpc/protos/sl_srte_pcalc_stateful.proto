// SR-TE Stateful Path Calculation API
// @file 
// @brief Proto file for Segment-routing traffic-eng (SRTE) PathCompute RPCs.
// Declares calls for delegating path compute of SRTE policies to a compute server.
// The GPB data model should reflect the model from the SRTE policy
// RFC https://datatracker.ietf.org/doc/rfc9256/.
// 
// ----------------------------------------------------------------
//  Copyright (c) 2024 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

syntax = "proto3";
package service_layer;

import "sl_common_types.proto";
import "sl_sr_common.proto";

option go_package="github.com/Cisco-service-layer/service-layer-objmodel/grpc/protos;service_layer";

// @defgroup SLSrteCalcStateful
//
// @{ 

// This service provides online, stateful SR-TE path calculation capabilities
// in accordance with the Segment Routing Policy Architecture model defined in
// [RFC 9256](https://datatracker.ietf.org/doc/rfc9256/).
service SLSrteCalcStateful {
    // Opens a bidirectional streaming channel to initiate, manage, and serve
    // stateful path calculation requests.<br><br>
    //
    //
    // A single `PathCompute` channel can support any number of path requests and
    // it is recommended that a client maintains only one channel per server that
    // it is connected to.<br><br>
    //
    // The client uses this channel to initiate new path calculation requests,
    // update the attributes (e.g., optimization metric or constraints) of an
    // active request, and withdraw obsolete ones. The client must maintain the
    // channel open as long as it requires stateful path calculation service from
    // the server.<br><br>
    //
    // The server uses this channel to respond to the active path calculation
    // requests of the client. The server sends a path response after receiving a
    // new path calculation request from the client, an update to an existing
    // request, or after a routing event in the network required a modification
    // of the path. The server is responsible for monitoring the network topology
    // and providing updated responses to the active path requests such that the
    // response continuously meets the requirements of the path request.<br><br>
    //
    // When the channel is closed, the server marks any active path request (that
    // was managed through this channel) as *stale* and starts a timer. Another
    // client may claim ownership of a stale path request in a new or existing
    // channel. When the timer expires, any stale path request that was not
    // claimed by another client is deleted.
    rpc SLSrtePathCompute (stream SLSrtePathComputeRequests) returns (stream SLSrtePathComputeResponses);
}

// Enables client-side batching.
message SLSrtePathComputeRequests {
    repeated SLSrtePathComputeRequest requests = 1; // A batch of request messages.
}

// Enables server-side batching.
message SLSrtePathComputeResponses {
    repeated SLSrtePathComputeResponse responses = 1; // A batch of reponse messages.
}

// Initiate a new path request or manage an active one that was initiated or
// claimed in this channel.
message SLSrtePathComputeRequest {
    // Globally unique SR policy identifier.
    SLSrPolicyKey policy_key = 1;

    // Unique candidate path identifier in the context of an SR policy.
    //
    // The tuple (`policy_key`, `candidate_path_key`) is a globally unique
    // identifier of the candidate path.
    SLSrCandidatePathKey candidate_path_key = 2;

    // Sequence number.
    //
    // This sequence number is reproduced in any path response related to this
    // request and can be used by the client to verify that the server is
    // replying to the most up-to-date request for a given candidate path.
    //
    // The sequence number **must** be strictly increasing in path request
    // messages relative to a particular candidate path (i.e., same `policy_key`
    // and `candidate_path_key`).
    uint64 seq_num = 3;

    // Type of request message.
    oneof request_type {
        SLSrtePathInit init = 4;
        SLSrtePathUpdate update = 5;
        SLSrtePathWithdraw withdraw = 6;
    }

    // Initiate a new request for the server to maintain an SR candidate path.
    //
    // - For a dynamic candidate path, this means computing and updating a set of
    // SID-lists in order to continuously comply with the path specifications.
    // - For an explicit candidate path, this means continously validating the
    // set of SID-lists with respect to the path specification and reporting
    // the validity of SID-list.
    message SLSrtePathInit {
        // The segment routing dataplane.
        //
        // The dataplane of a candidate path is an **unmutable path attribute**. It
        // cannot be modified after the initial path request.
        SLSrDataplane dataplane = 1;

        oneof path_init_type {
            SLSrtePathInitDynamic dynamic = 2;
            SLSrtePathInitExplicit explicit = 3;
        }

        // The specific attributes for initializing a dynamic path request.
        message SLSrtePathInitDynamic {
            // The optimization metric of the dynamic candidate path.
            //
            // The objective function of the optimization problem is to minimize the
            // accumulated value of this additive link metric along the path.
            SLSrMetricType o_metric = 1;

            // The set of constraints that the candidate path must satisfy.
            ConstraintSet constraints = 2;
        }

        // The specific attributes for initializing an explicit path request.
        message SLSrtePathInitExplicit {
            // The set of weighted segment lists in the explicit candidate path.
            repeated SLSrSegmentList segment_lists = 1;

            // The set of constraints that the candidate path must satisfy.
            ConstraintSet constraints = 2;
        }
    }

    // Modify the specification of an existing path (e.g., change constraints).
    //
    // PathUpdate cannot alter any element of the candidate path identifier
    // (e.g., endpoint) nor any unmutable path attributes (e.g., dataplane).
    message SLSrtePathUpdate {
        oneof path_update_type {
            SLSrtePathUpdateDynamic dynamic = 1;
            SLSrtePathUpdateExplicit explicit = 2;
        }

        // The specific attributes for updating a dynamic path request.
        message SLSrtePathUpdateDynamic {
            // The new optimization metric of the dynamic candidate path.
            SLSrMetricType o_metric = 1;

            // The new set of constraints that the candidate path must satisfy.
            ConstraintSet constraints = 2;
        }

        // The specific attributes for updating an explicit path request.
        message SLSrtePathUpdateExplicit {
            // The new set of weighted segment lists in the explicit candidate path.
            repeated SLSrSegmentList segment_lists = 1;

            // The new set of constraints that the candidate path must satisfy.
            ConstraintSet constraints = 2;
        }
    }

    // Withdraw a path request.
    //
    // Upon receiving this message, the server immediately deletes the path from
    // the its path request database and frees any resource allocated for this
    // path. It the candidate path was using any transit policies, the server
    // unregisters this path from the list of parents of those transit policies,
    // which may lead to unprovisioning of some transit policies.
    message SLSrtePathWithdraw {}
}

message SLSrtePathComputeResponse {
    // Globally unique SR policy identifier.
    SLSrPolicyKey policy_key = 1;

    // Unique candidate path identifier in the context of an SR policy.
    SLSrCandidatePathKey candidate_path_key = 2;

    // Request sequence number.
    //
    // This attribute indicates to the client to which request (in the context of
    // a candidate path) the server is replying.
    uint64 req_seq_num = 3;

    // The type of response message.
    oneof response_type {
        // The result of a dynamic candidate path calculation.
        SLSrteDynamicPathResult path_result = 4;

        // The status of an explicit candidate path validation.
        //ExplicitPathStatus path_status = 5;

        // An error message.
        SLSrtePathError error = 6;
    }

    // The result of a dynamic candidate path calculation.
    message SLSrteDynamicPathResult {
        // Set of weighted segment lists.
        repeated SLSrSegmentList segment_lists = 1;

        // Total path *cost*, i.e., the accumulated o-metric values along the path.
        uint32 path_cost = 2;

        // Effective level of diversity achieved in the response paths.
        //
        // If the `min_diversity_level` field was set in the request, then the
        // effective diversity level is between the requested `min_diversity_level`
        // and `diversity_level`.
        //
        // Otherwise, the effective diversity level is equal to the requested
        // `diversity_level`.
        optional SLSrteDiversityLevel effective_diversity_level = 3;
    }

    // The status of an explicit candidate path validation.
    //message ExplicitPathStatus {
        // The validity of each segment list.
        //
        // The values in this list **must** be in the same order as the segment
        // lists in the related request message.
        //repeated bool status = 1;
    //}

    // An error message.
    message SLSrtePathError {
        SLErrorStatus type = 1; // Type of error.
        string description = 2; // Text description of the error.
    }
}

// A set of constraints for an SR path.
message ConstraintSet {
    // Topological Constraints
    // =======================
    //
    // Constraints that must be satisfied by every node or link along the path.
    // These constraints determine the input topology to the path calculation.

    // Extended Administrative Groups.
    SLSrAffinities affinities = 1;

    // SRLG exclude.
    //
    // Mapped from [section 6.5 of RFC 9350](https://www.rfc-editor.org/rfc/rfc9350.html#section-6.5).
    repeated uint32 srlg_exclude = 4;

    // IP address exclude.
    repeated SLIpAddress ip_exclude = 5;

    // ============================ Path Constraints ============================
    // Constraints that must be satisfied by the complete path and cannot be
    // verified on a node-by-node or link-by-link basis.

    // Path diversity (disjoint paths) constraint.
    optional PathDiversity path_diversity = 101;

    message PathDiversity {
        // Association group identifier.
        AssociationGroup association = 1;

        // Required level of diversity for the disjoint paths (e.g., link- or
        // node-disjoint)
        //
        // Values `DIVERSITY_LEVEL_UNSPECIFIED` and `DIVERSITY_LEVEL_NONE` are
        // **invalid** for this field.
        SLSrteDiversityLevel diversity_level = 2;

        // Minimum fallback level of diversity for the disjoint paths
        //
        // If this field set and the path calculation service is unable to find a
        // full set of disjoint paths meeting the `diversity_level`, it will
        // attempt to find a set of paths with a lower level of diversity. It will
        // continue to fallback to lower levels until a full set of disjoint paths
        // is found or the minimum fallback level is reached, whichever comes
        // first.
        //
        // The service attempts the diversity levels in the following order from
        // the `diversity_level` to the `min_diversity_level`:
        //
        // SRLG + Node > SRLG > Node > Link > None
        //
        // If this field is unset, or if it is set to an equal or higher level than
        // `diversity_level`, the diversity level is considered strict and no
        // fallback is performed.
        optional SLSrteDiversityLevel min_diversity_level = 3;

        // Pin this path to the shortest path.
        bool shortest_path = 4;
    }

    // Bidirectional corouted association.
    optional AssociationGroup corouted_association = 102;

    // Guaranteed bandwidth.
    //
    // When set to the default value (0), this attribute is ignored.
    //
    // For an explicit candidate path, should the server perform the bandwidth
    // reservation?
    uint32 guaranteed_bandwidth = 103;

    // ======================== Segment-List Constraints ========================
    // Constraints that determine the set of segments available to enforce the
    // path.

    // Segment list is made only of adjacency or binding segments to transit
    // policies made only of adjacency segments.
    bool strict_path_segments = 201;

    // Segment list is made only of unprotected (i.e., non FRR-protected)
    // segments or binding segments to transit policies made only of unprotected
    // segments.
    //
    // When `false`, protected segments are preferred over unprotected ones.
    //
    // Note: Setting this constraint to true also implicitly enables
    // `strict_path_segments`, since only adjacency segments can be unprotected.
    bool unprotected_segments = 202;

    // Segment list is made only of persistently allocated segments (i.e., whose
    // value remains the same across router restart or interface flap) or binding
    // segments to transit policies made only of persistent segments.
    //
    // When `false`, the segment list may comprise both persistent and
    // non-persistent segments. Persistent segments are preferred when available.
    bool persistent_segments = 203;

    // Maximum number of segments in any of the candidate path segment lists.
    //
    // When set to a non-zero value, this attribute replaces the headend MSD
    // obtained from the link-state topology. When set to the default value (0),
    // this attribute is ignored.
    //
    // Note: If the first segment in the segment list can be enforced by setting
    // the outgoing interface on the headend node, it does not count towards this
    // limit.
    uint32 max_segments = 204;

}

message AssociationGroup {
    uint32 association_id = 1;
}
