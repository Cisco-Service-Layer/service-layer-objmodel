# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from . import sl_af_pb2 as sl__af__pb2


class SLAFStub(object):
    """@defgroup SLAF
    @ingroup Common
    SL-API messages for a address family.
    Defines SL-API operations service.
    @{
    ;

    The client initiating a programming or get RPC should pass a customer gRPC text
    metadata to the client side RPC call to identify itself. The client application must
    set the gRPC metadata key named "iosxr-slapi-clientid" with a numeric
    string holding a number between 0 and 65535.

    Each client application must use a unique client ID identifying itself that is seperate
    from other clients programming the server. If there are multiple instances
    of the client application, then each such instance must be uniquely idenified.

    If "iosxr-slapi-clientid" gRPC metadata is missing, server assumes
    a default client id of 0 for that RPC invocation.

    If there are multiple clients (or instances thereof) intending to program the
    network element using this API, the co-ordination of the ClientId amongst these
    instances is outside the scope of this specification.

    Clients must not change their identity for their lifetime - such as
    RPC disconnects, client restarts, client upgrades.

    SL-API stores the objects programmed by clients and preserves them across
    RPC disconnects, client restarts and server gRPC process restarts. As such
    if a client application or instance is no longer needed, the client must remove
    all its programming from the server before it is disabled or removed.

    The route redistribution and notifications are scoped to the RPC
    and as such do not require a client ID.

    @addtogroup SLAF
    @{
    ;
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SLAFVrfRegOp = channel.unary_unary(
                '/service_layer.SLAF/SLAFVrfRegOp',
                request_serializer=sl__af__pb2.SLAFVrfRegMsg.SerializeToString,
                response_deserializer=sl__af__pb2.SLAFVrfRegMsgRsp.FromString,
                )


class SLAFServicer(object):
    """@defgroup SLAF
    @ingroup Common
    SL-API messages for a address family.
    Defines SL-API operations service.
    @{
    ;

    The client initiating a programming or get RPC should pass a customer gRPC text
    metadata to the client side RPC call to identify itself. The client application must
    set the gRPC metadata key named "iosxr-slapi-clientid" with a numeric
    string holding a number between 0 and 65535.

    Each client application must use a unique client ID identifying itself that is seperate
    from other clients programming the server. If there are multiple instances
    of the client application, then each such instance must be uniquely idenified.

    If "iosxr-slapi-clientid" gRPC metadata is missing, server assumes
    a default client id of 0 for that RPC invocation.

    If there are multiple clients (or instances thereof) intending to program the
    network element using this API, the co-ordination of the ClientId amongst these
    instances is outside the scope of this specification.

    Clients must not change their identity for their lifetime - such as
    RPC disconnects, client restarts, client upgrades.

    SL-API stores the objects programmed by clients and preserves them across
    RPC disconnects, client restarts and server gRPC process restarts. As such
    if a client application or instance is no longer needed, the client must remove
    all its programming from the server before it is disabled or removed.

    The route redistribution and notifications are scoped to the RPC
    and as such do not require a client ID.

    @addtogroup SLAF
    @{
    ;
    """

    def SLAFVrfRegOp(self, request, context):
        """
        Global IP Route, MPLS Label, and Paths operations

        IP route and MPLS label object are scoped to the respective producing
        client. A Path object is scoped globally and can be updated or removed by
        the first client that produced the object.

        Two or more clients cannot operate on the same object.


        VRF registration operations. The client must register with
        the corresponding VRF table before programming objects in that table.

        For Path VRF registration operations, only SLVrfReg.VrfName is used.
        Other attributes, if present are ignored.

        For MPLS VRF SL_REGOP_REGISTER operation, only PurgeInterval is used.
        Other attributes, if present are ignored. For Other MPLS VRF registration
        operations, attributes if present are ignored.

        SLAFVrfRegMsg.Oper = SL_REGOP_REGISTER:
        VRF registration: Sends a list of VRF registration messages
        and expects a list of registration responses.
        A client Must Register a VRF BEFORE objects can be added/modified in
        the associated VRF.

        SLAFVrfRegMsg.Oper = SL_REGOP_UNREGISTER:
        VRF Un-registration: Sends a list of VRF un-registration messages
        and expects a list of un-registration responses.
        This can be used to convey that the client is no longer interested
        in these VRFs. All previously installed objects would be remove.

        SLAFVrfRegMsg.Oper = SL_REGOP_EOF:
        VRF End Of File message.
        After Registration, the client is expected to send an EOF
        message to convey the end of replay of the client's known objects.
        This is especially useful under certain restart scenarios when the
        client and the server are trying to synchronize their objects.

        The VRF registration operations can be used by the client to
        synchronize objects with the device. When the client re-registers the VRF
        with the server using SL_REGOP_REGISTER, server marks objects as stale.
        Client then must reprogram objects it is interested in.
        When client sends SL_REGOP_EOF, any objects not reprogrammed
        are removed from the device.

        The client must perform all operations (VRF registration, objects)
        from a single execution context.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SLAFServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'SLAFVrfRegOp': grpc.unary_unary_rpc_method_handler(
                    servicer.SLAFVrfRegOp,
                    request_deserializer=sl__af__pb2.SLAFVrfRegMsg.FromString,
                    response_serializer=sl__af__pb2.SLAFVrfRegMsgRsp.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'service_layer.SLAF', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class SLAF(object):
    """@defgroup SLAF
    @ingroup Common
    SL-API messages for a address family.
    Defines SL-API operations service.
    @{
    ;

    The client initiating a programming or get RPC should pass a customer gRPC text
    metadata to the client side RPC call to identify itself. The client application must
    set the gRPC metadata key named "iosxr-slapi-clientid" with a numeric
    string holding a number between 0 and 65535.

    Each client application must use a unique client ID identifying itself that is seperate
    from other clients programming the server. If there are multiple instances
    of the client application, then each such instance must be uniquely idenified.

    If "iosxr-slapi-clientid" gRPC metadata is missing, server assumes
    a default client id of 0 for that RPC invocation.

    If there are multiple clients (or instances thereof) intending to program the
    network element using this API, the co-ordination of the ClientId amongst these
    instances is outside the scope of this specification.

    Clients must not change their identity for their lifetime - such as
    RPC disconnects, client restarts, client upgrades.

    SL-API stores the objects programmed by clients and preserves them across
    RPC disconnects, client restarts and server gRPC process restarts. As such
    if a client application or instance is no longer needed, the client must remove
    all its programming from the server before it is disabled or removed.

    The route redistribution and notifications are scoped to the RPC
    and as such do not require a client ID.

    @addtogroup SLAF
    @{
    ;
    """

    @staticmethod
    def SLAFVrfRegOp(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/service_layer.SLAF/SLAFVrfRegOp',
            sl__af__pb2.SLAFVrfRegMsg.SerializeToString,
            sl__af__pb2.SLAFVrfRegMsgRsp.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
