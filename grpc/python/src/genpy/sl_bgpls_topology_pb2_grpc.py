# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from . import sl_bgpls_topology_pb2 as sl__bgpls__topology__pb2


class SLBgplsTopoStub(object):
    """@defgroup SLBgplsTopo
    Defines RPC calls for BGP-LS Topology updates.
    @{
    @addtogroup SLBgplsTopo
    @{
    ;
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SLBgplsTopoNotifStream = channel.unary_stream(
                '/service_layer.SLBgplsTopo/SLBgplsTopoNotifStream',
                request_serializer=sl__bgpls__topology__pb2.SLBgplsTopoNotifReqMsg.SerializeToString,
                response_deserializer=sl__bgpls__topology__pb2.SLBgplsTopoNotifMsg.FromString,
                )


class SLBgplsTopoServicer(object):
    """@defgroup SLBgplsTopo
    Defines RPC calls for BGP-LS Topology updates.
    @{
    @addtogroup SLBgplsTopo
    @{
    ;
    """

    def SLBgplsTopoNotifStream(self, request, context):
        """
        BGP-LS Topology Subscription


        This call is used to get a stream of BGP-LS Topology updates.
        It can be used to get "push" information for BGP-LS
        adds/updates/deletes.

        The caller must close the response stream when it is no longer
        interested in BGP-LS Topology information.

        The call takes a request message with the information on Match filters
        to be applied while sending BGP-LS Topology updates in the response stream.

        The success/failure of the request is relayed in the response as error status.
        If the request was successful, then the initial set of BGP-LS Topology
        information is sent as a stream containing a Start marker, any BGP-LS
        Topology if present, and an End Marker. The response stream will then
        be maintained to send subsequent updates and terminated only when the
        response stream is terminated by the caller.

        When the backend process handling the BGP-LS Topology subscription goes
        for a restart and when it comes up and ready again, the caller would
        get a Start marker, any BGP-LS Topology if present, and an End Marker.
        Upon receiving the Start marker, the caller must perform a mark and
        sweep operation on the data it received from this subscription.


        @}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SLBgplsTopoServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'SLBgplsTopoNotifStream': grpc.unary_stream_rpc_method_handler(
                    servicer.SLBgplsTopoNotifStream,
                    request_deserializer=sl__bgpls__topology__pb2.SLBgplsTopoNotifReqMsg.FromString,
                    response_serializer=sl__bgpls__topology__pb2.SLBgplsTopoNotifMsg.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'service_layer.SLBgplsTopo', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class SLBgplsTopo(object):
    """@defgroup SLBgplsTopo
    Defines RPC calls for BGP-LS Topology updates.
    @{
    @addtogroup SLBgplsTopo
    @{
    ;
    """

    @staticmethod
    def SLBgplsTopoNotifStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/service_layer.SLBgplsTopo/SLBgplsTopoNotifStream',
            sl__bgpls__topology__pb2.SLBgplsTopoNotifReqMsg.SerializeToString,
            sl__bgpls__topology__pb2.SLBgplsTopoNotifMsg.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
